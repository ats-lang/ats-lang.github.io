<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Lazy Stream-Processing</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="Crash into ATS"
HREF="book1.html"><LINK
REL="PREVIOUS"
TITLE="Raising and Catching Exceptions"
HREF="c942.html"><LINK
REL="NEXT"
TITLE="Linear Lazy Stream-Processing"
HREF="c1094.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="./assets/ATS2FPCRASH-BOOK.css"></HEAD
><BODY
CLASS="chapter"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Crash into ATS: </TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="c942.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="c1094.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="chapter"
><H1
><A
NAME="lecture10"
></A
>Chapter 12. Lazy Stream-Processing</H1
><P
>&#13;A stream is like a list but it is lazy in the sense that the elements
in a stream are not required to be made available at the moment when
the stream is formed. Instead, each element only needs to be produced
at the point where the element is actually needed for evaluation.
Given a type T, the type <FONT
COLOR="RED"
>stream(T)</FONT
> is for a value
representing a stream of elements of the type T. Let us use the name
stream-value to refer to such a value, which is completely opaque for
it does not even reveal whether the stream it represents is empty or
not. Internally, a stream-value is represented as a thunk, that is, a
nullary closure-function. Evaluating a stream-value (that is, calling
the thunk representing it) yields a stream-con value of type
<FONT
COLOR="RED"
>stream_con(T)</FONT
> for some T, where <FONT
COLOR="RED"
>stream_con</FONT
>
is the following declared datatype:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN999"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">datatype</span>
<span class="staexp">stream_con<span class="keyword">(</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="dynexp">steam_nil <span class="keyword">of</span> <span class="keyword">(</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="dynexp">stream_cons <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">stream</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span></span></span>
</p></PRE
><P
></P
></DIV
>


With pattern matching, we can inspect whether a stream-con value
represents an empty stream or not. If the stream is non-empty, then
its first element can be extracted. Formally speaking, we have the
following type definition in ATS:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1001"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="keyword">typedef</span> <span class="staexp">stream<span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span><span class="keyword">t@ype</span></span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp">lazy</span><span class="keyword">(</span><span class="staexp">stream_con</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span></span>
</p></PRE
><P
></P
></DIV
>


where <FONT
COLOR="RED"
>lazy</FONT
> is a special type constructor. Given a type
T, the type <FONT
COLOR="RED"
>lazy(T)</FONT
> is essentially for a thunk that returns
a value of the type T. Often such a thunk is referred to as a suspended
computation of the type T, which can be resumed by simply calling the thunk.

</P
><P
>&#13;As an example, the following function <FONT
COLOR="RED"
>int_stream_from</FONT
>
takes an integer <FONT
COLOR="RED"
>n</FONT
> and returns a stream that enumerates
ascendingly all of the integers greater than or equal to
<FONT
COLOR="RED"
>n</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1009"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
int_stream_from
  <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">stream</span><span class="keyword">(</span><span class="staexp">int</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="dynexp"><span class="keyword">$delay</span><span class="keyword">(</span>stream_cons<span class="keyword">(</span>n<span class="keyword">,</span> int_stream_from<span class="keyword">(</span>n+1<span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span></span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


The keyword <FONT
COLOR="RED"
>$delay</FONT
> indicates the construction
of a thunk based on the expression appearing as its argument.

</P
><P
>&#13;Accessing elements in a given stream is shown in the following
example:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1013"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
stream_get_at
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">stream</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">a</span> <span class="keyword">=</span>
<span class="keyword">(</span>
<span class="keyword">case+</span> <span class="keyword">!</span>xs <span class="keyword">of</span>
<span class="keyword">|</span> stream_nil<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span>
  <span class="keyword">(</span>
    <span class="dynexp"><span class="keyword">$raise</span> StreamSubscriptExn<span class="keyword">(</span><span class="keyword">)</span></span>
  <span class="keyword">)</span>
<span class="keyword">|</span> stream_cons<span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span>
  <span class="keyword">(</span>
    <span class="keyword">if</span> n &lt;= <span class="dynexp">0</span> <span class="keyword">then</span> x <span class="keyword">else</span> stream_get_at&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>xs<span class="keyword">,</span> n-<span class="dynexp">1</span><span class="keyword">)</span>
  <span class="keyword">)</span>
<span class="keyword">)</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


The function <FONT
COLOR="RED"
>stream_get_at</FONT
> is the stream-version of
<FONT
COLOR="RED"
>list_get_at</FONT
>: Given a stream and a position (denoted by an
integer), <FONT
COLOR="RED"
>stream_get_at</FONT
> returns the element in the stream
at the given position. Note that the symbol <FONT
COLOR="RED"
>!</FONT
> refers to
the function <FONT
COLOR="RED"
>lazy_force</FONT
>, which evaluates a given stream
value into a stream-con value in this case. Like
<FONT
COLOR="RED"
>list_get_at</FONT
>, it is almost always a poor style of
programming to make use of <FONT
COLOR="RED"
>stream_get_at</FONT
> excessively (for
instance, inside the body of a loop).

</P
><P
>&#13;Let us see what is involved in the evaluation of the following two
lines of code:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1023"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> xs <span class="keyword">=</span> int_stream_from<span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> x0 <span class="keyword">=</span> stream_get_at&lt;<span class="staexp">int</span><span class="keyword">&gt;</span><span class="keyword">(</span>xs<span class="keyword">,</span> <span class="dynexp">1000000</span><span class="keyword">)</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


The call to <FONT
COLOR="RED"
>int_stream_from</FONT
> returns immediately as all
that is essentially done is creating a thunk (that is, a nullary
closure-function). The call to <FONT
COLOR="RED"
>stream_get_at</FONT
> returns
1000000 after creating 1000001 nodes to store the first 1000001
elements in the stream bound to the name <FONT
COLOR="RED"
>xs</FONT
>. While it
takes only a tiny amount of memory to store the initial stream bound
to the name <FONT
COLOR="RED"
>xs</FONT
>, it requires a large amount of memory to
store the expanded stream created during the evaluation of the call to
<FONT
COLOR="RED"
>stream_get_at</FONT
>. In general, a call to
<FONT
COLOR="RED"
>lazy_force</FONT
> evaluates its argument (of type
<FONT
COLOR="RED"
>lazy(T)</FONT
>) to a value (of type T) and then caches the value
internally so that the value can be returned immediately when another
call to <FONT
COLOR="RED"
>lazy_force</FONT
> on the same argument evaluates later.
In other words, some form of memoization happens when the evaluation
of a suspended computation is performed.  Memoization can be expensive
memory-wise and unpredicatable time-wise. There is another kind of
stream (to be presented later) that is referred to as
<SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>linear stream</I
></SPAN
>, which involves no memoization when
evaluated. As a matter of fact, the internal representation of a
linear stream only needs memory for storing one node (that contains
the head element of the stream), resulting in great memory-efficiency.

</P
><P
>&#13;Basically, for each a list-processing function, there is a
corresponding version of stream-processing function. Let us see some
concrete examples.  For instance, the following function
<FONT
COLOR="RED"
>stream_append</FONT
> (corresponding to <FONT
COLOR="RED"
>list0_append</FONT
>)
concatenates two given streams:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1037"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
stream_append
<span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">stream</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">stream</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">stream</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
stream_append
<span class="keyword">(</span>xs<span class="keyword">,</span> ys<span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp"><span class="keyword">$delay</span>
<span class="keyword">(</span>
<span class="keyword">case+</span> <span class="keyword">!</span>xs <span class="keyword">of</span>
<span class="keyword">|</span> stream_nil<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">!</span>ys
<span class="keyword">|</span> stream_cons<span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span>
  stream_cons<span class="keyword">(</span>x<span class="keyword">,</span> stream_append&lt;a<span class="keyword">&gt;</span><span class="keyword">(</span>xs<span class="keyword">,</span> ys<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">)</span></span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


Please note the symbol <FONT
COLOR="RED"
>!</FONT
> in front of <FONT
COLOR="RED"
>!ys</FONT
>:
The expression following <FONT
COLOR="RED"
>$delay</FONT
> should evaluate to
a stream-con value (instead of a stream value).

</P
><P
>&#13;With streams, we can facilitate the use of (general) recursion in
problem-solving by eliminating the risk of stack overflow caused by
deeply nested recursive calls. In the case of
<FONT
COLOR="RED"
>stream_append</FONT
>, the evaluation of a call to
<FONT
COLOR="RED"
>stream_append</FONT
> returns immediately as all it does
essentially is to form a thunk (for representing the resulting
stream). On the other hand, the implementation of
<FONT
COLOR="RED"
>list0_append</FONT
> presented previously can potentially cause
stack overflow if its argument is a long list (e.g., one consisting of
1000000 elements). By the way, the actual implementation of
<FONT
COLOR="RED"
>list0_append</FONT
> in <TT
CLASS="filename"
>ATSLIB/prelude</TT
> (the prelude
library of ATS) cannot cause stack overflow due to its being
tail-recursive. However, there is no free lunch here as this library
implementation is written in an advanced style that is somewhat
difficult to adopt in practice.

</P
><P
>&#13;The following function <FONT
COLOR="RED"
>stream_map</FONT
> is the stream-version of
<FONT
COLOR="RED"
>list0_map</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1051"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
<span class="staexp"><span class="keyword">{</span>b<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
stream_map
<span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">stream</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> fopr<span class="keyword">:</span> <span class="staexp">cfun</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">b</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">stream</span><span class="keyword">(</span><span class="staexp">b</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="keyword">{</span><span class="staexp">b</span><span class="keyword">}</span>
stream_map
  <span class="keyword">(</span>xs<span class="keyword">,</span> fopr<span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp"><span class="keyword">$delay</span>
<span class="keyword">(</span>
<span class="keyword">case+</span> <span class="keyword">!</span>xs <span class="keyword">of</span>
<span class="keyword">|</span> stream_nil<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span>
  stream_nil<span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">|</span> stream_cons<span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span>
  stream_cons<span class="keyword">(</span>fopr<span class="keyword">(</span>x<span class="keyword">)</span><span class="keyword">,</span> stream_map&lt;a<span class="keyword">&gt;&lt;</span>b<span class="keyword">&gt;</span><span class="keyword">(</span>xs<span class="keyword">,</span> fopr<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">)</span></span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;The following function <FONT
COLOR="RED"
>stream_filter</FONT
> is the stream-version of
<FONT
COLOR="RED"
>list0_filter</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1056"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
stream_filter
<span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">stream</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> test<span class="keyword">:</span> <span class="staexp">cfun</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">bool</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">stream</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
stream_filter
  <span class="keyword">(</span>xs<span class="keyword">,</span> test<span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp"><span class="keyword">$delay</span>
<span class="keyword">(</span>
<span class="keyword">case+</span> <span class="keyword">!</span>xs <span class="keyword">of</span>
<span class="keyword">|</span> stream_nil<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span>
  stream_nil<span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">|</span> stream_cons<span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span>
  <span class="keyword">if</span> test<span class="keyword">(</span>x<span class="keyword">)</span>
    <span class="keyword">then</span>
    stream_cons
      <span class="keyword">(</span>x<span class="keyword">,</span> stream_filter&lt;a<span class="keyword">&gt;</span><span class="keyword">(</span>xs<span class="keyword">,</span> test<span class="keyword">)</span><span class="keyword">)</span>
    <span class="comment">// end of [then]</span>
    <span class="keyword">else</span> <span class="keyword">!</span><span class="keyword">(</span>stream_filter&lt;a<span class="keyword">&gt;</span><span class="keyword">(</span>xs<span class="keyword">,</span> test<span class="keyword">)</span><span class="keyword">)</span>
  <span class="comment">// end of [if]</span>
<span class="keyword">)</span></span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


</P
><P
>&#13;A function like <FONT
COLOR="RED"
>stream_map</FONT
> and <FONT
COLOR="RED"
>stream_filter</FONT
>
is often referred to as being fully lazy as its evaluation does nothing
except for creating a thunk (to represent a suspended computation).

</P
><P
>&#13;The following function <FONT
COLOR="RED"
>sieve</FONT
> implements the sieve of
Eratosthenes for enumerating prime numbers:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1063"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
sieve<span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">stream</span><span class="keyword">(</span><span class="staexp">int</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
auxmain
<span class="keyword">(</span>
xs<span class="keyword">:</span> <span class="staexp">stream</span><span class="keyword">(</span><span class="staexp">int</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">stream</span><span class="keyword">(</span><span class="staexp">int</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp"><span class="keyword">$delay</span>
<span class="keyword">(</span>
<span class="keyword">case-</span> <span class="keyword">!</span>xs <span class="keyword">of</span>
<span class="keyword">|</span> stream_cons<span class="keyword">(</span>x0<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span>
  stream_cons<span class="keyword">(</span>x0<span class="keyword">,</span> auxmain<span class="keyword">(</span>stream_filter<span class="keyword">(</span>xs<span class="keyword">,</span> <span class="keyword">lam</span><span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">=&gt;</span> x % x0 <span class="keyword">&gt;</span> 0<span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">)</span></span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  auxmain<span class="keyword">(</span>int_stream_from<span class="keyword">(</span><span class="dynexp">2</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [sieve]</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


A call to <FONT
COLOR="RED"
>sieve</FONT
> returns a stream consisting of all the
primes enumerated in the ascending order: 2, 3, 5, 7, 11, etc. Note
that <FONT
COLOR="RED"
>case-</FONT
> is used in place of <FONT
COLOR="RED"
>case</FONT
> for the
purpose of suppressing a warning message that would otherwise be
issued due to pattern matching being non-exhaustive (as the case
<FONT
COLOR="RED"
>stream_nil()</FONT
> is not covered).

</P
><P
>&#13;As a simple experiment, please try to evaluate the following code:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1070"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span>
thePrimes <span class="keyword">=</span> sieve<span class="keyword">(</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp">println!</span> <span class="keyword">(</span><span class="dynstr">"stream_get_at(thePrimes, 5000):"</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp">println!</span> <span class="keyword">(</span>stream_get_at&lt;<span class="staexp">int</span><span class="keyword">&gt;</span><span class="keyword">(</span>thePrimes<span class="keyword">,</span> <span class="dynexp">5000</span><span class="keyword">)</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp">println!</span> <span class="keyword">(</span><span class="dynstr">"stream_get_at(thePrimes, 5000):"</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp">println!</span> <span class="keyword">(</span>stream_get_at&lt;<span class="staexp">int</span><span class="keyword">&gt;</span><span class="keyword">(</span>thePrimes<span class="keyword">,</span> <span class="dynexp">5000</span><span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


Note that the number <SPAN
CLASS="emphasis"
><I
CLASS="emphasis"
>48619</I
></SPAN
> is to be printed out
twice. There is a clear pause before it is done for the first time,
but there is virtually no delay between the first time and the second
time, showing clearly the effect of memoization performed during the
first call to <FONT
COLOR="RED"
>stream_get_at</FONT
> on <FONT
COLOR="RED"
>thePrimes</FONT
>.

</P
><P
>&#13;Lastly, let us see a simple but telling example that demonstrates a
stream-based approach to addressing the potential risk of stack
overflow due to deeply nested non-tail-recursive calls. The following
implementation of <FONT
COLOR="RED"
>list0_map</FONT
> is standard:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1077"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="keyword">{</span><span class="staexp">b</span><span class="keyword">}</span>
list0_map
<span class="keyword">(</span>xs<span class="keyword">,</span> fopr<span class="keyword">)</span> <span class="keyword">=</span>
auxmain<span class="keyword">(</span>xs<span class="keyword">)</span> <span class="keyword">where</span>
<span class="keyword">{</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
auxmain
<span class="keyword">(</span>
xs<span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">b</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">(</span>
<span class="keyword">case+</span> xs <span class="keyword">of</span>
<span class="keyword">|</span> list0_nil<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> list0_nil<span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">|</span> list0_cons<span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span> list0_cons<span class="keyword">(</span>fopr<span class="keyword">(</span>x<span class="keyword">)</span><span class="keyword">,</span> auxmain<span class="keyword">(</span>xs<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">}</span></span> <span class="comment">(* end of [list0_map] *)</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


Clearly, this implementation is not tail-recursive. When applied to a
long list (e.g., one consisting of 1000000 elements),
<FONT
COLOR="RED"
>list0_map</FONT
> runs a high risk of causing stack overflow. This
can become a very serious issue in practice if we ever want to apply
functional programming to a domain like machine learning where
processing large data is a norm rather than an exception. One
possibility is to insist on using only tail-recursion in the
implementation of a function like <FONT
COLOR="RED"
>list0_map</FONT
> that may need
to be applied to large data, but such a requirement or restriction can
clearly exert negative impact on the use of recursion in
problem-solving. After all, there are numerous algorithms that are
natrually expressed in terms of (general) recursion. And non-trivial
effort is often needed in order to implement such an algorithm based
on tail-recursion only, likely diminishing programming productivity.

</P
><P
>&#13;Another implementation of <FONT
COLOR="RED"
>list0_map</FONT
> is given as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN1083"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="keyword">{</span><span class="staexp">b</span><span class="keyword">}</span>
list0_map<span class="keyword">(</span>xs<span class="keyword">,</span> fopr<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
auxmain
<span class="keyword">(</span>
xs<span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">stream</span><span class="keyword">(</span><span class="staexp">b</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp"><span class="keyword">$delay</span>
<span class="keyword">(</span>
<span class="keyword">case+</span> xs <span class="keyword">of</span>
<span class="keyword">|</span> list0_nil<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> stream_nil<span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">|</span> list0_cons<span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span> stream_cons<span class="keyword">(</span>fopr<span class="keyword">(</span>x<span class="keyword">)</span><span class="keyword">,</span> auxmain<span class="keyword">(</span>xs<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">)</span></span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  g0ofg1<span class="keyword">(</span>stream2list<span class="keyword">(</span>auxmain<span class="keyword">(</span>xs<span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [list0_map]</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


What is special about this implementation of <FONT
COLOR="RED"
>list0_map</FONT
>
lies in the implementation of of the inner function
<FONT
COLOR="RED"
>auxmain</FONT
>, which turns a list into a stream. Calling
<FONT
COLOR="RED"
>auxmain</FONT
> runs no risk of stack overflow as it simply
creates a thunk (without issuing any recursive calls).  The library
function <FONT
COLOR="RED"
>stream2list</FONT
> turns a stream into a (linear) list,
which can be cast into a list0-value in O(1)-time by a call to
<FONT
COLOR="RED"
>g0ofg1</FONT
>. As <FONT
COLOR="RED"
>stream2list</FONT
> is implemented
tail-recursively, it can be safely called to generate a long list.
Consequently, this stream-based implementation of
<FONT
COLOR="RED"
>list0_map</FONT
> can be applied to a long list with no concern of
causing stack overflow. After linear lazy streams are introduced, we
are to see a significantly improved version of this stream-based
approach to resolving a common type of risk of stack overflow caused
by calling recursively defined functions for generating long lists.

</P
><P
>&#13;Please find <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/ATS2FPCRASH/LECTURE/10/CODE"
TARGET="_top"
>on-line</A
> the entirety of
the code used in this chapter. 
</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="c942.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="c1094.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Raising and Catching Exceptions</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Linear Lazy Stream-Processing</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>