<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title></title>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
  <style type="text/css">
    .patsyntax {color:#808080;background-color:#E0E0E0;}
    .patsyntax span.keyword {color:#000000;font-weight:bold;}
    .patsyntax span.comment {color:#787878;font-style:italic;}
    .patsyntax span.extcode {color:#A52A2A;}
    .patsyntax span.neuexp  {color:#800080;}
    .patsyntax span.staexp  {color:#0000F0;}
    .patsyntax span.prfexp  {color:#603030;}
    .patsyntax span.dynexp  {color:#F00000;}
    .patsyntax span.stalab  {color:#0000F0;font-style:italic}
    .patsyntax span.dynlab  {color:#F00000;font-style:italic}
    .patsyntax span.dynstr  {color:#008000;font-style:normal}
    .patsyntax span.stacstdec  {text-decoration:none;}
    .patsyntax span.stacstuse  {color:#0000CF;text-decoration:underline;}
    .patsyntax span.dyncstdec  {text-decoration:none;}
    .patsyntax span.dyncstuse  {color:#B80000;text-decoration:underline;}
    .patsyntax span.dyncst_implement  {color:#B80000;text-decoration:underline;}
  </style>
</head>
<body class="patsyntax">

<pre class="patsyntax">
<span class="comment">(***********************************************************************)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(*                         Applied Type System                         *)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(***********************************************************************)</span>

<span class="comment">(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="comment">// Author: Hongwei Xi</span>
<span class="comment">// Authoremail: gmhwxiATgmailDOTcom</span>
<span class="comment">// Start Time: April, 2011</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="extcode"><span class="extcode">%{#
#include \
"libats/libc/CATS/stdio.cats"
%}</span></span> <span class="comment">// end of [%{#]</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">#define</span>
ATS_PACKNAME "ATSLIB.libats.libc"</span>
<span class="comment">//</span>
<span class="comment">// HX: prefix for external names</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">#define</span>
ATS_EXTERN_PREFIX "atslib_libats_libc_"</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="neuexp"><span class="keyword">#define</span> RD<span class="keyword">(</span>x<span class="keyword">)</span> x</span> <span class="comment">// for commenting: read-only</span>
<span class="keyword">typedef</span> <span class="staexp">SHR<span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>type</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp">a</span></span> <span class="comment">// for commenting purpose</span>
<span class="keyword">typedef</span> <span class="staexp">NSH<span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>type</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp">a</span></span> <span class="comment">// for commenting purpose</span>

<span class="comment">(* ****** ****** *)</span>

<span class="staexp"><span class="keyword">sortdef</span> fm <span class="keyword">=</span> file_mode</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">stadef</span> <span class="staexp">r<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp">file_mode_r</span><span class="keyword">(</span><span class="keyword">)</span></span>
<span class="keyword">stadef</span> <span class="staexp">w<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp">file_mode_w</span><span class="keyword">(</span><span class="keyword">)</span></span>
<span class="keyword">stadef</span> <span class="staexp">rw<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp">file_mode_rw</span><span class="keyword">(</span><span class="keyword">)</span></span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="keyword">staload</span>
TYPES <span class="keyword">=</span>
"libats/libc/SATS/sys/types.sats"
<span class="comment">//</span>
<span class="keyword">stadef</span> <span class="staexp">fildes <span class="keyword">=</span> <span class="staexp">$TYPES<span class="keyword">.</span>fildes</span></span>
<span class="keyword">stadef</span> <span class="staexp">fildes_v <span class="keyword">=</span> <span class="staexp">$TYPES<span class="keyword">.</span>fildes_v</span></span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">(*
abstype FILEref = ptr // declared in [prelude/basic_dyn.sats]
*)</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="comment">// HX-2011-04-02:</span>
<span class="comment">//</span>
<span class="staexp"><span class="keyword">absview</span>
FILE_view<span class="keyword">(</span>l<span class="keyword">:</span>addr<span class="keyword">,</span> m<span class="keyword">:</span>fm<span class="keyword">)</span></span>
<span class="staexp"><span class="keyword">absvtype</span>
FILEptr_vtype<span class="keyword">(</span>addr<span class="keyword">,</span> fm<span class="keyword">)</span> <span class="keyword">=</span> ptr</span>
<span class="comment">//</span>
<span class="keyword">viewdef</span>
<span class="staexp">FILE_v<span class="keyword">(</span><span class="staexp">l<span class="keyword">:</span>addr</span><span class="keyword">,</span> <span class="staexp">m<span class="keyword">:</span>fm</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp">FILE_view</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span></span>
<span class="keyword">vtypedef</span>
<span class="staexp">FILEptr<span class="keyword">(</span><span class="staexp">l<span class="keyword">:</span>addr</span><span class="keyword">,</span> <span class="staexp">m<span class="keyword">:</span> fm</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp">FILEptr_vtype</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="keyword">vtypedef</span>
<span class="staexp">FILEptr0<span class="keyword">(</span><span class="staexp">m<span class="keyword">:</span>fm</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="staexp"><span class="keyword">[</span>l<span class="keyword">:</span>addr <span class="keyword">|</span> l &gt;= null<span class="keyword">]</span></span> <span class="staexp">FILEptr</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">vtypedef</span>
<span class="staexp">FILEptr1<span class="keyword">(</span><span class="staexp">m<span class="keyword">:</span>fm</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>l<span class="keyword">:</span>agz<span class="keyword">]</span></span> <span class="staexp">FILEptr</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span></span>
<span class="keyword">vtypedef</span>
<span class="staexp">FILEptr1<span class="comment">(*none*)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>l<span class="keyword">:</span>agz<span class="keyword">;</span>m<span class="keyword">:</span>fm<span class="keyword">]</span></span> <span class="staexp">FILEptr</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">stadef</span> <span class="staexp">fmlte <span class="keyword">=</span> <span class="staexp">file_mode_lte</span></span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">castfn</span>
FILEptr2ptr
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>fm<span class="keyword">}</span></span><span class="keyword">(</span>filp<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">FILEptr</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">ptr</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">overload</span> ptrcast <span class="keyword">with</span> FILEptr2ptr</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">castfn</span>
FILEptr_encode
<span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>fm<span class="keyword">}</span></span>
<span class="keyword">(</span>
<span class="prfexp">pf<span class="keyword">:</span> <span class="staexp">FILE_v</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span></span> <span class="keyword">|</span> p<span class="keyword">:</span> <span class="staexp">ptr</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">FILEptr</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">overload</span> encode <span class="keyword">with</span> FILEptr_encode</span>

<span class="dynexp"><span class="keyword">castfn</span>
FILEptr_decode
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>agz<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>fm<span class="keyword">}</span></span>
<span class="keyword">(</span>
p0<span class="keyword">:</span> <span class="staexp">FILEptr</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">FILE_v</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="staexp">ptr</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">overload</span> decode <span class="keyword">with</span> FILEptr_decode</span>

<span class="comment">(* ****** ****** *)</span>

<span class="prfexp"><span class="keyword">praxi</span>
FILEptr_free_null
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>alez<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>fm<span class="keyword">}</span></span><span class="keyword">(</span>p0<span class="keyword">:</span> <span class="staexp">FILEptr</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">prf</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span>
<span class="comment">// end of [FILEptr_free_null]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">castfn</span>
FILEptr_refize<span class="keyword">(</span>filp<span class="keyword">:</span> <span class="staexp">FILEptr1</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">FILEref</span></span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="comment">// HX:</span>
<span class="comment">// A lock is associated with each FILEref-value</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">castfn</span>
FILEref_vttakeout
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>fm<span class="keyword">}</span></span>
  <span class="keyword">(</span>filr<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">[</span>l<span class="keyword">:</span>agz<span class="keyword">]</span></span> <span class="staexp">vttakeout0</span><span class="keyword">(</span><span class="staexp">FILEptr</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">// end of [FILEref_vttakeout]</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="staexp"><span class="keyword">abst@ype</span> whence_type <span class="keyword">=</span> int</span>
<span class="comment">//</span>
<span class="keyword">typedef</span> <span class="staexp">whence <span class="keyword">=</span> <span class="staexp">whence_type</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">macdef</span> SEEK_SET <span class="keyword">=</span> <span class="dynexp"><span class="keyword">$extval</span><span class="keyword">(</span>whence<span class="keyword">,</span> "SEEK_SET"<span class="keyword">)</span></span></span>
<span class="dynexp"><span class="keyword">macdef</span> SEEK_CUR <span class="keyword">=</span> <span class="dynexp"><span class="keyword">$extval</span><span class="keyword">(</span>whence<span class="keyword">,</span> "SEEK_CUR"<span class="keyword">)</span></span></span>
<span class="dynexp"><span class="keyword">macdef</span> SEEK_END <span class="keyword">=</span> <span class="dynexp"><span class="keyword">$extval</span><span class="keyword">(</span>whence<span class="keyword">,</span> "SEEK_END"<span class="keyword">)</span></span></span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">(*
//
// FILE *fopen (const char *path, const char *mode);
//
The fopen function opens the file whose name is the string pointed to by
path and associates a stream with it.

The argument mode points to a string beginning with one of the follow
ing sequences (Additional characters may follow these sequences.):

  r      Open  text  file  for  reading.  The stream is positioned at the
         beginning of the file.

  r+     Open for reading and writing.  The stream is positioned  at  the
         beginning of the file.

  w      Truncate  file  to  zero length or create text file for writing.
         The stream is positioned at the beginning of the file.

  w+     Open for reading and writing.  The file is created  if  it  does
         not  exist, otherwise it is truncated.  The stream is positioned
         at the beginning of the file.

  a      Open for appending (writing at end of file).  The file is created
         if it does not exist.  The stream is positioned at the end of the
         file.

  a+     Open for reading and appending (writing at end  of  file).   The
         file  is created if it does not exist.  The stream is positioned
         at the end of the file.

*)</span>

<span class="dynexp"><span class="keyword">fun</span>
fopen<span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>fm<span class="keyword">}</span></span>
<span class="keyword">(</span>
  path<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">fmode</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">FILEptr0</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>

<span class="dynexp"><span class="keyword">fun</span>
fopen_exn<span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>fm<span class="keyword">}</span></span>
<span class="keyword">(</span>
  path<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">fmode</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exnwrt</span><span class="keyword">&gt;</span> <span class="staexp">FILEptr1</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">)</span> <span class="keyword">=</span> "ext#%"</span>

<span class="dynexp"><span class="keyword">fun</span>
fopen_ref_exn<span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>fm<span class="keyword">}</span></span>
<span class="keyword">(</span>
  path<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">fmode</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exnwrt</span><span class="keyword">&gt;</span> <span class="staexp">FILEref</span><span class="comment">(*none*)</span> <span class="keyword">=</span> "ext#%"</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">symintr</span> fclose</span>
<span class="neuexp"><span class="keyword">symintr</span> fclose_exn</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
fclose0
<span class="keyword">(</span>
  filr<span class="keyword">:</span> <span class="staexp">FILEref</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span>
fclose1
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>fm<span class="keyword">}</span></span>
<span class="keyword">(</span>
  filp<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">FILEptr</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">ptr</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span>
  <span class="staexp"><span class="keyword">[</span>i<span class="keyword">:</span>int <span class="keyword">|</span> i &lt;= 0<span class="keyword">]</span></span>
<span class="keyword">(</span>
  <span class="staexp">option_v</span> <span class="keyword">(</span><span class="staexp">FILE_v</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">i</span> <span class="staexp"><span class="keyword">&lt;</span></span> <span class="staexp">0</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="staexp">int</span> <span class="staexp">i</span>
<span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span> <span class="comment">// endfun</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">overload</span> fclose <span class="keyword">with</span> fclose0</span>
<span class="dynexp"><span class="keyword">overload</span> fclose <span class="keyword">with</span> fclose1</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
fclose0_exn
  <span class="keyword">(</span>filr<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exnwrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> "ext#%"</span>
<span class="dynexp"><span class="keyword">fun</span>
fclose1_exn
  <span class="keyword">(</span>filp<span class="keyword">:</span> <span class="staexp">FILEptr1</span><span class="comment">(*none*)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exnwrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> "ext#%"</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">overload</span> fclose_exn <span class="keyword">with</span> fclose0_exn</span>
<span class="dynexp"><span class="keyword">overload</span> fclose_exn <span class="keyword">with</span> fclose1_exn</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">(*
fun fclose_stdin ():&lt;!exnwrt&gt; void = "ext#%"
fun fclose_stdout ():&lt;!exnwrt&gt; void = "ext#%"
fun fclose_stderr ():&lt;!exnwrt&gt; void = "ext#%"
*)</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">(*
//
// FILE *freopen (const char *path, const char *mode, FILE *stream);
//
The [freopen] function opens the file whose name is the string pointed to
by path and associates the stream pointed to by stream with it.  The original
stream (if it exists) is closed.  The mode argument is used just as in the
fopen function.  The primary use of the freopen function is to change the file
associated with a standard text stream (stderr, stdin, or stdout).
//
*)</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">symintr</span> freopen</span>
<span class="neuexp"><span class="keyword">symintr</span> freopen_exn</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
freopen0<span class="staexp"><span class="keyword">{</span>m2<span class="keyword">:</span>fm<span class="keyword">}</span></span>
<span class="keyword">(</span>
  path<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span>
<span class="keyword">,</span> mode<span class="keyword">:</span> <span class="staexp">fmode</span><span class="keyword">(</span><span class="staexp">m2</span><span class="keyword">)</span><span class="keyword">,</span> filr<span class="keyword">:</span> <span class="staexp">FILEref</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">Ptr0</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="comment">// HX-2012-07:</span>
<span class="comment">// the original stream is closed even if [freopen] fails.</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
freopen1
<span class="staexp"><span class="keyword">{</span>m1<span class="keyword">,</span>m2<span class="keyword">:</span>fm<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>l0<span class="keyword">:</span>addr<span class="keyword">}</span></span>
<span class="keyword">(</span>
  path<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span>
<span class="keyword">,</span> mode<span class="keyword">:</span> <span class="staexp">fmode</span><span class="keyword">(</span><span class="staexp">m2</span><span class="keyword">)</span><span class="keyword">,</span> filp<span class="keyword">:</span> <span class="staexp">FILEptr</span><span class="keyword">(</span><span class="staexp">l0</span><span class="keyword">,</span> <span class="staexp">m1</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span>
<span class="staexp"><span class="keyword">[</span>
  l<span class="keyword">:</span>addr <span class="keyword">|</span> l==null || l==l0
<span class="keyword">]</span></span> <span class="keyword">(</span>
  <span class="staexp">option_v</span><span class="keyword">(</span><span class="staexp">FILE_v</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">m2</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">l</span> <span class="staexp"><span class="keyword">&gt;</span></span> <span class="staexp">null</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="staexp">ptr</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span> <span class="comment">// end of [freopen1]</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
freopen0_exn<span class="staexp"><span class="keyword">{</span>m2<span class="keyword">:</span>fm<span class="keyword">}</span></span>
<span class="keyword">(</span>
  path<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">,</span> mode<span class="keyword">:</span> <span class="staexp">fmode</span><span class="keyword">(</span><span class="staexp">m2</span><span class="keyword">)</span><span class="keyword">,</span> filr<span class="keyword">:</span> <span class="staexp">FILEref</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exnwrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> "ext#%"</span> <span class="comment">// end of [freopen0_exn]</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">overload</span> freopen <span class="keyword">with</span> freopen0</span>
<span class="dynexp"><span class="keyword">overload</span> freopen <span class="keyword">with</span> freopen1</span>
<span class="dynexp"><span class="keyword">overload</span> freopen_exn <span class="keyword">with</span> freopen0_exn</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">(*
fun
freopen_stdin
  (path: NSH(string)):&lt;!exnwrt&gt; void = "ext#%"
// end of [freopen_stdin]
fun
freopen_stdout
  (path: NSH(string)):&lt;!exnwrt&gt; void = "ext#%"
// end of [freopen_stdout]
fun
freopen_stderr
  (path: NSH(string)):&lt;!exnwrt&gt; void = "ext#%"
// end of [freopen_stderr]
*)</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">(*
//
// int fileno (FILE* filp) ;
// 
The function fileno examines the argument stream and returns its integer
descriptor. In case fileno detects that its argument is not a valid stream,
it must return -1 and set errno to EBADF.
*)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
fileno0<span class="keyword">(</span>filr<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span>
fileno1<span class="keyword">(</span>filp<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">FILEptr1</span><span class="comment">(*none*)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">symintr</span> fileno</span>
<span class="dynexp"><span class="keyword">overload</span> fileno <span class="keyword">with</span> fileno0</span>
<span class="dynexp"><span class="keyword">overload</span> fileno <span class="keyword">with</span> fileno1</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="comment">(*
//
// HX-2011-08
//
*)</span>
<span class="keyword">dataview</span>
<span class="staexp">fdopen_v
<span class="keyword">(</span>
  fd<span class="keyword">:</span>int<span class="keyword">,</span> addr<span class="keyword">,</span> m<span class="keyword">:</span> fmode
<span class="keyword">)</span> <span class="keyword">=</span> <span class="comment">(* fdopen_v *)</span>
  <span class="keyword">|</span> <span class="prfexp"><span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>agz<span class="keyword">}</span></span>
    fdopen_v_succ<span class="keyword">(</span><span class="staexp">fd</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="staexp">FILE_v</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="prfexp">fdopen_v_fail<span class="keyword">(</span><span class="staexp">fd</span><span class="keyword">,</span> <span class="staexp">null</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="staexp">fildes_v</span><span class="keyword">(</span><span class="staexp">fd</span><span class="keyword">)</span></span></span>
<span class="comment">// end of [fdopen_v]</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
fdopen
<span class="staexp"><span class="keyword">{</span>fd<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>fm<span class="keyword">}</span></span>
<span class="keyword">(</span>
  fd<span class="keyword">:</span> <span class="staexp">fildes</span><span class="keyword">(</span><span class="staexp">fd</span><span class="keyword">)</span><span class="keyword">,</span> m<span class="keyword">:</span> <span class="staexp">fmode</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>l<span class="keyword">:</span>agez<span class="keyword">]</span></span> 
<span class="keyword">(</span>
  <span class="staexp">fdopen_v</span><span class="keyword">(</span><span class="staexp">fd</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="staexp">ptr</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span> <span class="comment">// end of [fdopen]</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
fdopen_exn
<span class="staexp"><span class="keyword">{</span>fd<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>fm<span class="keyword">}</span></span>
<span class="keyword">(</span>fd<span class="keyword">:</span> <span class="staexp">fildes</span><span class="keyword">(</span><span class="staexp">fd</span><span class="keyword">)</span><span class="keyword">,</span> m<span class="keyword">:</span> <span class="staexp">fmode</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">FILEptr1</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">)</span> <span class="keyword">=</span> "ext#%"</span>
<span class="comment">// end of [fdopen_exn]</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">(*  
//
// int feof (FILE *stream);
//
The function feof() returns a nonzero value if the end of the given file
stream has been reached.
//
*)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
feof0 <span class="keyword">(</span>filr<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span>
feof1 <span class="keyword">(</span>filp<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">FILEptr1</span><span class="comment">(*none*)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">symintr</span> feof</span>
<span class="dynexp"><span class="keyword">overload</span> feof <span class="keyword">with</span> feof0</span>
<span class="dynexp"><span class="keyword">overload</span> feof <span class="keyword">with</span> feof1</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">(*
//
// int ferror (FILE *stream);
//
The function [ferror] tests the error indicator for the stream pointed to by
stream, returning non-zero if it is set.  The error indicator can only be
reset by the [clearerr] function.
*)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
ferror0 <span class="keyword">(</span>filr<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span>
ferror1 <span class="keyword">(</span>filp<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">FILEptr1</span><span class="comment">(*none*)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">symintr</span> ferror</span>
<span class="dynexp"><span class="keyword">overload</span> ferror <span class="keyword">with</span> ferror0</span>
<span class="dynexp"><span class="keyword">overload</span> ferror <span class="keyword">with</span> ferror1</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">(*
//
// void clearerr (FILE *stream);
//
The function [clearerr] clears the end-of-file and error indicators for
the stream pointed to by stream.
//
*)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
clearerr0
  <span class="keyword">(</span>filr<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span>
clearerr1
  <span class="keyword">(</span>filp<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">FILEptr1</span><span class="comment">(*none*)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">symintr</span> clearerr</span>
<span class="dynexp"><span class="keyword">overload</span> clearerr <span class="keyword">with</span> clearerr0</span>
<span class="dynexp"><span class="keyword">overload</span> clearerr <span class="keyword">with</span> clearerr1</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">(*
//
// int fflush (FILE *stream);
//
The function fflush forces a write of all user-space buffered data for the
given output or update stream via the streams underlying write function.
The open status of the stream is unaffected.
//
Upon successful completion 0 is returned.  Otherwise, EOF is returned and
the global variable errno is set to indicate the error.
*)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
fflush0
  <span class="keyword">(</span>out<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span>
fflush1<span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>fm<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp">pf<span class="keyword">:</span> <span class="staexp">fmlte</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">w</span><span class="keyword">)</span></span> <span class="keyword">|</span> out<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">FILEptr1</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">[</span>i<span class="keyword">:</span>int <span class="keyword">|</span> i &lt;= 0<span class="keyword">]</span></span> <span class="staexp">int</span><span class="keyword">(</span><span class="staexp">i</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
fflush0_exn
  <span class="keyword">(</span>out<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exnwrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> "ext#%"</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">symintr</span> fflush</span>
<span class="neuexp"><span class="keyword">symintr</span> fflush_exn</span>
<span class="dynexp"><span class="keyword">overload</span> fflush <span class="keyword">with</span> fflush0</span>
<span class="dynexp"><span class="keyword">overload</span> fflush <span class="keyword">with</span> fflush1</span>
<span class="dynexp"><span class="keyword">overload</span> fflush_exn <span class="keyword">with</span> fflush0_exn</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> fflush_all <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exnwrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> "ext#%"</span>
<span class="dynexp"><span class="keyword">fun</span> fflush_stdout <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exnwrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> "ext#%"</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">(*
//
// int fgetc (FILE *stream)
//
[fgetc] reads the next character from stream and returns it as an
unsigned char cast to an int, or EOF on end of file or error. Note
that EOF must be a negative number!
//
*)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
fgetc0
  <span class="keyword">(</span>inp<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span>
fgetc1 <span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>fm<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp">pf<span class="keyword">:</span> <span class="staexp">fmlte</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">r</span><span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span></span> <span class="keyword">|</span> inp<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">FILEptr1</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">intLte</span> <span class="keyword">(</span><span class="staexp">UCHAR_MAX</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">symintr</span> fgetc</span>
<span class="dynexp"><span class="keyword">overload</span> fgetc <span class="keyword">with</span> fgetc0</span>
<span class="dynexp"><span class="keyword">overload</span> fgetc <span class="keyword">with</span> fgetc1</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">macdef</span> getc <span class="keyword">=</span> fgetc</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span>
getchar0<span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span>
getchar1<span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">[</span>i<span class="keyword">:</span>int<span class="keyword">|</span>i &lt;= UCHAR_MAX<span class="keyword">]</span></span> <span class="staexp">int</span><span class="keyword">(</span><span class="staexp">i</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
fgets0
<span class="staexp"><span class="keyword">{</span>sz<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n0<span class="keyword">:</span>pos <span class="keyword">|</span> n0 &lt;= sz<span class="keyword">}</span></span>
<span class="keyword">(</span>
  buf<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">b0ytes</span><span class="keyword">(</span><span class="staexp">sz</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">bytes</span><span class="keyword">(</span><span class="staexp">sz</span><span class="keyword">)</span><span class="keyword">,</span> n0<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">n0</span><span class="keyword">,</span> inp<span class="keyword">:</span> <span class="staexp">FILEref</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">Ptr0</span> <span class="keyword">=</span> "mac#%"</span> <span class="comment">// = addr@(buf) or NULL</span>
<span class="dynexp"><span class="keyword">fun</span>
fgets1
<span class="staexp"><span class="keyword">{</span>sz<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n0<span class="keyword">:</span>pos <span class="keyword">|</span> n0 &lt;= sz<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>fm<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp">pfm<span class="keyword">:</span> <span class="staexp">fmlte</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">r</span><span class="keyword">)</span></span>
<span class="keyword">|</span> buf<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">b0ytes</span><span class="keyword">(</span><span class="staexp">sz</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">bytes</span><span class="keyword">(</span><span class="staexp">sz</span><span class="keyword">)</span><span class="keyword">,</span> n0<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">n0</span><span class="keyword">,</span> inp<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">FILEptr1</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">Ptr0</span> <span class="keyword">=</span> "mac#%"</span> <span class="comment">// = addr@(buf) or NULL</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">symintr</span> fgets</span>
<span class="dynexp"><span class="keyword">overload</span> fgets <span class="keyword">with</span> fgets0</span>
<span class="dynexp"><span class="keyword">overload</span> fgets <span class="keyword">with</span> fgets1</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="keyword">dataview</span>
<span class="staexp">fgets_v
<span class="keyword">(</span>
  sz<span class="keyword">:</span>int<span class="keyword">,</span> n0<span class="keyword">:</span> int<span class="keyword">,</span> addr<span class="keyword">,</span> addr
<span class="keyword">)</span> <span class="keyword">=</span> <span class="comment">(* fgets_v *)</span>
  <span class="keyword">|</span> <span class="prfexp"><span class="staexp"><span class="keyword">{</span>l0<span class="keyword">:</span>addr<span class="keyword">}</span></span>
    fgets_v_fail <span class="keyword">(</span><span class="staexp">sz</span><span class="keyword">,</span> <span class="staexp">n0</span><span class="keyword">,</span> <span class="staexp">l0</span><span class="keyword">,</span> <span class="staexp">null</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="staexp">b0ytes</span><span class="keyword">(</span><span class="staexp">sz</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l0</span></span>
  <span class="keyword">|</span> <span class="prfexp"><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat <span class="keyword">|</span> n <span class="keyword">&lt;</span> n0<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>l0<span class="keyword">:</span>agz<span class="keyword">}</span></span>
    fgets_v_succ <span class="keyword">(</span><span class="staexp">sz</span><span class="keyword">,</span> <span class="staexp">n0</span><span class="keyword">,</span> <span class="staexp">l0</span><span class="keyword">,</span> <span class="staexp">l0</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="staexp">strbuf</span><span class="keyword">(</span><span class="staexp">sz</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l0</span></span></span>
<span class="comment">// end of [fgets_v]</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
fgets1_err
<span class="staexp"><span class="keyword">{</span>sz<span class="keyword">,</span>n0<span class="keyword">:</span>int
<span class="keyword">|</span> 0 <span class="keyword">&lt;</span> n0
<span class="keyword">;</span> n0 &lt;= sz<span class="keyword">}</span></span>
<span class="staexp"><span class="keyword">{</span>l0<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>fm<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp">pf_mod<span class="keyword">:</span> <span class="staexp">fmlte</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">r</span><span class="keyword">)</span></span>
<span class="keyword">,</span> <span class="prfexp">pf_buf<span class="keyword">:</span> <span class="staexp">b0ytes</span><span class="keyword">(</span><span class="staexp">sz</span><span class="keyword">)</span><span class="staexp"><span class="keyword">@</span></span><span class="staexp">l0</span></span>
<span class="keyword">|</span> p0<span class="keyword">:</span> <span class="staexp">ptr</span><span class="keyword">(</span><span class="staexp">l0</span><span class="keyword">)</span><span class="keyword">,</span> n0<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">(</span><span class="staexp">n0</span><span class="keyword">)</span><span class="keyword">,</span> inp<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">FILEptr1</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">[</span>l1<span class="keyword">:</span>addr<span class="keyword">]</span></span> <span class="keyword">(</span><span class="staexp">fgets_v</span><span class="keyword">(</span><span class="staexp">sz</span><span class="keyword">,</span> <span class="staexp">n0</span><span class="keyword">,</span> <span class="staexp">l0</span><span class="keyword">,</span> <span class="staexp">l1</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="staexp">ptr</span><span class="keyword">(</span><span class="staexp">l1</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">// end of [fgets_err]</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">overload</span> fgets <span class="keyword">with</span> fgets1_err</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="comment">// HX-2013-05:</span>
<span class="comment">// A complete line is read each time // [nullp] for error</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
fgets0_gc
  <span class="keyword">(</span>bsz<span class="keyword">:</span> <span class="staexp">intGte</span><span class="keyword">(</span><span class="staexp">1</span><span class="keyword">)</span><span class="keyword">,</span> inp<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">Strptr0</span> <span class="keyword">=</span> "ext#%"</span>
<span class="dynexp"><span class="keyword">fun</span>
fgets1_gc<span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>fm<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp">pf_mod<span class="keyword">:</span> <span class="staexp">fmlte</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">r</span><span class="keyword">)</span></span> <span class="keyword">|</span> bsz<span class="keyword">:</span> <span class="staexp">intGte</span><span class="keyword">(</span><span class="staexp">1</span><span class="keyword">)</span><span class="keyword">,</span> inp<span class="keyword">:</span> <span class="staexp">FILEptr1</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">Strptr0</span> <span class="keyword">=</span> "ext#%"</span> <span class="comment">// end of [fget1_gc]</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">(*
//
// int fgetpos(FILE *stream, fpos_t *pos);
//
The [fgetpos] function stores the file position indicator of the given file
stream in the given position variable. The position variable is of type
fpos_t (which is defined in stdio.h) and is an object that can hold every
possible position in a FILE. [fgetpos] returns zero upon success, and a
non-zero value upon failure.
//
*)</span>
<span class="comment">//</span>
<span class="staexp"><span class="keyword">abst@ype</span> fpos_t <span class="keyword">=</span> <span class="keyword">$extype</span>"ats_fpos_type"</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
fgetpos0
<span class="keyword">(</span>
  filp<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">,</span> pos<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">fpos_t</span><span class="staexp">?</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">opt</span> <span class="keyword">(</span><span class="staexp">fpos_t</span><span class="keyword">,</span> <span class="staexp">i</span><span class="staexp">==</span><span class="staexp">0</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">#[</span>i<span class="keyword">:</span>int <span class="keyword">|</span> i &lt;= 0<span class="keyword">]</span></span> <span class="staexp">int</span> <span class="keyword">(</span><span class="staexp">i</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span> fgetpos1
<span class="keyword">(</span>
  filp<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">FILEptr1</span><span class="keyword">,</span> pos<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">fpos_t</span><span class="staexp">?</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">opt</span> <span class="keyword">(</span><span class="staexp">fpos_t</span><span class="keyword">,</span> <span class="staexp">i</span><span class="staexp">==</span><span class="staexp">0</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">#[</span>i<span class="keyword">:</span>int <span class="keyword">|</span> i &lt;= 0<span class="keyword">]</span></span> <span class="staexp">int</span> <span class="keyword">(</span><span class="staexp">i</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
fgetpos0_exn 
  <span class="keyword">(</span>filp<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">,</span> pos<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">fpos_t</span><span class="staexp">?</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exnwrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> "ext#%"</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">symintr</span> fgetpos</span>
<span class="neuexp"><span class="keyword">symintr</span> fgetpos_exn</span>
<span class="dynexp"><span class="keyword">overload</span> fgetpos <span class="keyword">with</span> fgetpos0</span>
<span class="dynexp"><span class="keyword">overload</span> fgetpos <span class="keyword">with</span> fgetpos1</span>
<span class="dynexp"><span class="keyword">overload</span> fgetpos_exn <span class="keyword">with</span> fgetpos0_exn</span> 
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">(*
//
// int fputc (int c, FILE *stream)
//
The function [fputc] writes the given character [c] to the given output
stream. The return value is the character, unless there is an error, in
which case the return value is EOF.
//
*)</span>
<span class="comment">//</span>
<span class="keyword">typedef</span>
<span class="staexp">fputc0_type
  <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>t0p</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">FILEref</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">0</span><span class="keyword">,</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">int</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
fputc0_int <span class="keyword">:</span> <span class="staexp">fputc0_type</span> <span class="keyword">(</span><span class="staexp">int</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span> 
<span class="dynexp"><span class="keyword">fun</span>
fputc0_char <span class="keyword">:</span> <span class="staexp">fputc0_type</span> <span class="keyword">(</span><span class="staexp">char</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span> 
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">symintr</span> fputc</span>
<span class="dynexp"><span class="keyword">overload</span> fputc <span class="keyword">with</span> fputc0_int <span class="keyword">of</span> 0</span>
<span class="dynexp"><span class="keyword">overload</span> fputc <span class="keyword">with</span> fputc0_char <span class="keyword">of</span> 0</span>
<span class="comment">//</span>
<span class="keyword">typedef</span>
<span class="staexp">fputc1_type
  <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>t0p</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>fm<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="staexp">fmlte</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">w</span><span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="staexp">a</span><span class="keyword">,</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">FILEptr1</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">0</span><span class="keyword">,</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">intLte</span> <span class="keyword">(</span><span class="staexp">UCHAR_MAX</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">fun</span> fputc1_int <span class="keyword">:</span> <span class="staexp">fputc1_type</span> <span class="keyword">(</span><span class="staexp">int</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span> fputc1_char <span class="keyword">:</span> <span class="staexp">fputc1_type</span> <span class="keyword">(</span><span class="staexp">char</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">overload</span> fputc <span class="keyword">with</span> fputc1_int <span class="keyword">of</span> 10</span>
<span class="dynexp"><span class="keyword">overload</span> fputc <span class="keyword">with</span> fputc1_char <span class="keyword">of</span> 10</span>
<span class="comment">//</span>
<span class="keyword">typedef</span>
<span class="staexp">fputc0_exn_type
  <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>t0p</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">FILEref</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">0</span><span class="keyword">,</span><span class="keyword">!</span><span class="staexp">exnwrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
fputc0_exn_int <span class="keyword">:</span> <span class="staexp">fputc0_exn_type</span> <span class="keyword">(</span><span class="staexp">int</span><span class="keyword">)</span> <span class="keyword">=</span> "ext#%"</span>
<span class="dynexp"><span class="keyword">fun</span>
fputc0_exn_char <span class="keyword">:</span> <span class="staexp">fputc0_exn_type</span> <span class="keyword">(</span><span class="staexp">char</span><span class="keyword">)</span> <span class="keyword">=</span> "ext#%"</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">symintr</span> fputc_exn</span>
<span class="dynexp"><span class="keyword">overload</span> fputc_exn <span class="keyword">with</span> fputc0_exn_int <span class="keyword">of</span> 0</span>
<span class="dynexp"><span class="keyword">overload</span> fputc_exn <span class="keyword">with</span> fputc0_exn_char <span class="keyword">of</span> 0</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">macdef</span> putc <span class="keyword">=</span> fputc</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
putchar0 <span class="keyword">(</span>c<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span>
putchar1
  <span class="keyword">(</span>c<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">[</span>i<span class="keyword">:</span>int<span class="keyword">|</span>i &lt;= UCHAR_MAX<span class="keyword">]</span></span> <span class="staexp">int</span><span class="keyword">(</span><span class="staexp">i</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">// end of [putchar1]</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">(*
//
// int fputs (const char* s, FILE *stream)
//
The function [fputs] writes a string to a file. it returns
a non-negative number on success, or EOF on error.
*)</span>
<span class="comment">//</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
fputs0
<span class="keyword">(</span>
  str<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">,</span> fil<span class="keyword">:</span> <span class="staexp">FILEref</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span>
fputs1<span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>fm<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp">pf<span class="keyword">:</span> <span class="staexp">fmlte</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">w</span><span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span></span> <span class="keyword">|</span> str<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">,</span> out<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">FILEptr1</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
fputs0_exn
  <span class="keyword">(</span>str<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">,</span> fil<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exnwrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> "ext#%"</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">symintr</span> fputs</span>
<span class="neuexp"><span class="keyword">symintr</span> fputs_exn</span>
<span class="dynexp"><span class="keyword">overload</span> fputs <span class="keyword">with</span> fputs0</span>
<span class="dynexp"><span class="keyword">overload</span> fputs <span class="keyword">with</span> fputs1</span>
<span class="dynexp"><span class="keyword">overload</span> fputs_exn <span class="keyword">with</span> fputs0_exn</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="comment">// [puts] puts a newline at the end</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
puts<span class="keyword">(</span>inp<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
puts_exn<span class="keyword">(</span>inp<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exnwrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> "ext#%"</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">(*
//
// size_t fread (void *ptr, size_t size, size_t nmemb, FILE *stream);
//
The function [fread] reads [nmemb] elements of data, each [size] bytes
long, from the stream pointed to by stream, storing them at the location
given by ptr. The return value is the number of items that are actually
read.
//
[fread] does not distinguish between end-of-file and error, and callers
must use [feof] and [ferror] to determine which occurred.
//
*)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
fread0 <span class="comment">// [isz]: the size of each item</span>
  <span class="staexp"><span class="keyword">{</span>isz<span class="keyword">:</span>pos<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>nbf<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n*isz &lt;= nbf<span class="keyword">}</span></span>
<span class="keyword">(</span>
  buf<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">bytes</span><span class="keyword">(</span><span class="staexp">nbf</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span>
<span class="keyword">,</span> isz<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">isz</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">n</span>
<span class="keyword">,</span> inp<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="comment">(*none*)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">sizeLte</span> <span class="staexp">n</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span>
fread1 <span class="comment">// [isz]: the size of each item</span>
  <span class="staexp"><span class="keyword">{</span>isz<span class="keyword">:</span>pos<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>nbf<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n*isz &lt;= nbf<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>fm<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp">pfm<span class="keyword">:</span> <span class="staexp">fmlte</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">r</span><span class="keyword">)</span></span>
<span class="keyword">|</span> buf<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">bytes</span><span class="keyword">(</span><span class="staexp">nbf</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span>
<span class="keyword">,</span> isz<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">isz</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">n</span>
<span class="keyword">,</span> inp<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">FILEptr1</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">sizeLte</span> <span class="staexp">n</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
fread0_exn <span class="comment">// [isz]: the size of each item</span>
<span class="staexp"><span class="keyword">{</span>isz<span class="keyword">:</span>pos<span class="keyword">}</span></span>
<span class="staexp"><span class="keyword">{</span>nbf<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n*isz &lt;= nbf<span class="keyword">}</span></span>
<span class="keyword">(</span>
  buf<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">bytes</span><span class="keyword">(</span><span class="staexp">nbf</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">,</span> isz<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">isz</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">n</span><span class="keyword">,</span> inp<span class="keyword">:</span> <span class="staexp">FILEref</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exnwrt</span><span class="keyword">&gt;</span> <span class="staexp">sizeLte</span> <span class="staexp">n</span> <span class="keyword">=</span> "ext#%"</span> <span class="comment">// endfun</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">symintr</span> fread</span>
<span class="neuexp"><span class="keyword">symintr</span> fread_exn</span>
<span class="dynexp"><span class="keyword">overload</span> fread <span class="keyword">with</span> fread0</span>
<span class="dynexp"><span class="keyword">overload</span> fread <span class="keyword">with</span> fread1</span>
<span class="dynexp"><span class="keyword">overload</span> fread_exn <span class="keyword">with</span> fread0_exn</span>
<span class="comment">//</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">(*
//
// size_t fwrite (
//   const void *ptr,  size_t size,  size_t nmemb, FILE *stream
// ) ;
//
The function [fwrite] writes [nmemb] elements of data, each [size] bytes
long, to the stream pointed to by stream, obtaining them from the location
given by [ptr]. The return value is the number of items that are actually
written.
//
*)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
fwrite0 <span class="comment">// [isz]: the size of each item</span>
  <span class="staexp"><span class="keyword">{</span>isz<span class="keyword">:</span>pos<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>nbf<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n*isz &lt;= nbf<span class="keyword">}</span></span>
<span class="keyword">(</span>
  buf<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">RD</span><span class="keyword">(</span><span class="staexp">bytes</span><span class="keyword">(</span><span class="staexp">nbf</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">,</span> isz<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">isz</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">n</span>
<span class="keyword">,</span> out<span class="keyword">:</span> <span class="staexp">FILEref</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">sizeLte</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span>
fwrite1 <span class="comment">// [isz]: the size of each item</span>
  <span class="staexp"><span class="keyword">{</span>isz<span class="keyword">:</span>pos<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>nbf<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n*isz &lt;= nbf<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>fm<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp">pfm<span class="keyword">:</span> <span class="staexp">fmlte</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">w</span><span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span></span>
<span class="keyword">|</span> buf<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">RD</span><span class="keyword">(</span><span class="staexp">bytes</span><span class="keyword">(</span><span class="staexp">nbf</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">,</span> isz<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">isz</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">n</span>
<span class="keyword">,</span> out<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">FILEptr1</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">sizeLte</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
fwrite0_exn <span class="comment">// [isz]: the size of each item</span>
  <span class="staexp"><span class="keyword">{</span>isz<span class="keyword">:</span>pos<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>nbf<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n*isz &lt;= nbf<span class="keyword">}</span></span>
<span class="keyword">(</span>
  buf<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">RD</span><span class="keyword">(</span><span class="staexp">bytes</span><span class="keyword">(</span><span class="staexp">nbf</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">,</span> isz<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">isz</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">n</span>
<span class="keyword">,</span> out<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="comment">(*none*)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exnwrt</span><span class="keyword">&gt;</span> <span class="staexp">sizeLte</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span> "ext#%"</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">symintr</span> fwrite</span>
<span class="neuexp"><span class="keyword">symintr</span> fwrite_exn</span>
<span class="dynexp"><span class="keyword">overload</span> fwrite <span class="keyword">with</span> fwrite0</span>
<span class="dynexp"><span class="keyword">overload</span> fwrite <span class="keyword">with</span> fwrite1</span>
<span class="dynexp"><span class="keyword">overload</span> fwrite_exn <span class="keyword">with</span> fwrite0_exn</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">(*
//
// int fseek (FILE *stream, long offset, int whence)
//
The [fseek] function sets the file position indicator for the stream
pointed to by stream.  The new position, measured in bytes, is obtained by
adding offset bytes to the position specified by whence.  If whence is set
to [SEEK_SET], [SEEK_CUR], or [SEEK_END], the offset is relative to the
start of the file, the current position indicator, or end-of-file,
respectively.  A successful call to the [fseek] function clears the end-
of-file indicator for the stream and undoes any effects of the [ungetc]
function on the same stream. Upon success, [fseek] returns 0. Otherwise,
it returns -1.
//
*)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
fseek0
<span class="keyword">(</span>
  filr<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">,</span> offset<span class="keyword">:</span> <span class="staexp">lint</span><span class="keyword">,</span> whence<span class="keyword">:</span> <span class="staexp">whence</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span>
fseek1
<span class="keyword">(</span>
  filp<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">FILEptr1</span><span class="keyword">,</span> offset<span class="keyword">:</span> <span class="staexp">lint</span><span class="keyword">,</span> whence<span class="keyword">:</span> <span class="staexp">whence</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
fseek0_exn
<span class="keyword">(</span>
  filr<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">,</span> offset<span class="keyword">:</span> <span class="staexp">lint</span><span class="keyword">,</span> whence<span class="keyword">:</span> <span class="staexp">whence</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exnwrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> "ext#%"</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">symintr</span> fseek</span>
<span class="neuexp"><span class="keyword">symintr</span> fseek_exn</span>
<span class="dynexp"><span class="keyword">overload</span> fseek <span class="keyword">with</span> fseek0</span>
<span class="dynexp"><span class="keyword">overload</span> fseek <span class="keyword">with</span> fseek1</span>
<span class="dynexp"><span class="keyword">overload</span> fseek_exn <span class="keyword">with</span> fseek0_exn</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">(*
//
// void fsetpos(FILE *stream, const fpos_t *pos);
//
The [fsetpos] function moves the file position indicator for the given
stream to a location specified by the position object. The type fpos_t is
defined in stdio.h.  The return value for fsetpos() is zero upon success,
non-zero on failure.
//
*)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
fsetpos0
<span class="keyword">(</span>filp<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="comment">(*none*)</span><span class="keyword">,</span> pos<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">RD</span><span class="keyword">(</span><span class="staexp">fpos_t</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span>
fsetpos1
<span class="keyword">(</span>filp<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">FILEptr1</span><span class="comment">(*none*)</span><span class="keyword">,</span> pos<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">RD</span><span class="keyword">(</span><span class="staexp">fpos_t</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
fsetpos0_exn
<span class="keyword">(</span>filp<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="comment">(*none*)</span><span class="keyword">,</span> pos<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">RD</span><span class="keyword">(</span><span class="staexp">fpos_t</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exnwrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> "ext#%"</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">symintr</span> fsetpos</span>
<span class="neuexp"><span class="keyword">symintr</span> fsetpos_exn</span>
<span class="dynexp"><span class="keyword">overload</span> fsetpos <span class="keyword">with</span> fsetpos0</span>
<span class="dynexp"><span class="keyword">overload</span> fsetpos <span class="keyword">with</span> fsetpos1</span>
<span class="dynexp"><span class="keyword">overload</span> fsetpos_exn <span class="keyword">with</span> fsetpos0_exn</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">(*
//
// long ftell (FILE *stream)
//
[ftell] returns the current offset of the given file stream upon on
success. Otherwise, -1 is returned and the global variable errno is set to
indicate the error.
//
*)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
ftell0
  <span class="keyword">(</span>filr<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">lint</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span>
ftell1
  <span class="keyword">(</span>filp<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">FILEptr1</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">lint</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
ftell0_exn
  <span class="keyword">(</span>filr<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exnwrt</span><span class="keyword">&gt;</span> <span class="staexp">lint</span> <span class="keyword">=</span> "ext#%"</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">symintr</span> ftell</span>
<span class="neuexp"><span class="keyword">symintr</span> ftell_exn</span>
<span class="dynexp"><span class="keyword">overload</span> ftell <span class="keyword">with</span> ftell0</span>
<span class="dynexp"><span class="keyword">overload</span> ftell <span class="keyword">with</span> ftell1</span>
<span class="dynexp"><span class="keyword">overload</span> ftell_exn <span class="keyword">with</span> ftell0_exn</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">(*
//
// perror - print a system error message
//
The routine [perror(s)] produces a message on the standard error output,
describing the last error encountered during a call to a system or library
function.  First (if s is not NULL and *s is not NULL) the argument string
s is printed, followed by a colon and a blank.  Then the message and a
newline.
//
*)</span>
<span class="dynexp"><span class="keyword">fun</span>
perror
  <span class="keyword">(</span>msg<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">// end of [perror]</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="staexp"><span class="keyword">abstype</span>
pmode_type<span class="keyword">(</span>m<span class="keyword">:</span>fm<span class="keyword">)</span> <span class="keyword">=</span> string</span>
<span class="keyword">typedef</span>
<span class="staexp">pmode<span class="keyword">(</span><span class="staexp">m<span class="keyword">:</span>fm</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp">pmode_type</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="staexp"><span class="keyword">absview</span>
popen_view<span class="keyword">(</span>l<span class="keyword">:</span>addr<span class="keyword">)</span></span>
<span class="keyword">viewdef</span>
<span class="staexp">popen_v<span class="keyword">(</span><span class="staexp">l<span class="keyword">:</span>addr</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp">popen_view</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">praxi</span>
popen_v_free_null <span class="keyword">(</span>pf<span class="keyword">:</span> <span class="staexp">popen_v</span> <span class="keyword">(</span><span class="staexp">null</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
popen<span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>fm<span class="keyword">}</span></span>
<span class="keyword">(</span>
  cmd<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">,</span> mode<span class="keyword">:</span> <span class="staexp">pmode</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>l<span class="keyword">:</span>addr<span class="keyword">]</span></span> <span class="keyword">(</span><span class="staexp">popen_v</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="staexp">FILEptr</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
popen_exn<span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>fm<span class="keyword">}</span></span>
<span class="keyword">(</span>
  cmd<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">,</span> mode<span class="keyword">:</span> <span class="staexp">pmode</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">FILEref</span> <span class="keyword">=</span> "ext#%"</span> <span class="comment">// endfun</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
pclose0_exn <span class="keyword">(</span>filr<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> "ext#%"</span>
<span class="dynexp"><span class="keyword">fun</span>
pclose1_exn
<span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>agz<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>fm<span class="keyword">}</span></span>
<span class="keyword">(</span><span class="prfexp">pf<span class="keyword">:</span> <span class="staexp">popen_v</span> <span class="staexp">l</span></span> <span class="keyword">|</span> filr<span class="keyword">:</span> <span class="staexp">FILEptr</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">=</span> "ext#%"</span>
<span class="comment">// end of [pclose1_exn]</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
remove
  <span class="keyword">(</span>inp<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span>
remove_exn
  <span class="keyword">(</span>inp<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exnwrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> "ext#%"</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span> rename
<span class="keyword">(</span>
  oldpath<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">,</span> newpath<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span> <span class="comment">// end of [fun]</span>

<span class="dynexp"><span class="keyword">fun</span> rename_exn
<span class="keyword">(</span>
  oldpath<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">,</span> newpath<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exnwrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> "ext#%"</span> <span class="comment">// end of [fun]</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">(*
// HX: [rewind] generates no error
*)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
rewind0
  <span class="keyword">(</span>fil<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
rewind1
  <span class="keyword">(</span>fil<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">FILEptr1</span><span class="comment">(*none*)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">symintr</span> rewind</span>
<span class="dynexp"><span class="keyword">overload</span> rewind <span class="keyword">with</span> rewind0</span>
<span class="dynexp"><span class="keyword">overload</span> rewind <span class="keyword">with</span> rewind1</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
tmpfile<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">FILEptr0</span> <span class="keyword">(</span><span class="staexp">rw</span><span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
tmpfile_exn<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exnwrt</span><span class="keyword">&gt;</span> <span class="staexp">FILEptr1</span> <span class="keyword">(</span><span class="staexp">rw</span><span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=</span> "ext#%"</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
tmpfile_ref_exn<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exnwrt</span><span class="keyword">&gt;</span> <span class="staexp">FILEref</span><span class="comment">(*none*)</span> <span class="keyword">=</span> "ext#%"</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">(*
//
// int ungetc(int c, FILE *stream);
//
[ungetc] pushes [c] back to stream, cast to unsigned char, where it is
available for subsequent read operations.  Pushed-back characters will be
returned in reverse order; only one pushback is guaranteed.
//
*)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
ungetc0
  <span class="keyword">(</span>c<span class="keyword">:</span> <span class="staexp">char</span><span class="keyword">,</span> f<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span>
ungetc1
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>agz<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>fm<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp">pfm<span class="keyword">:</span> <span class="staexp">fmlte</span> <span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">rw</span><span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span></span> <span class="keyword">|</span> c<span class="keyword">:</span> <span class="staexp">char</span><span class="keyword">,</span> f<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">FILEptr</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">[</span>i<span class="keyword">:</span>int <span class="keyword">|</span> i &lt;= UCHAR_MAX<span class="keyword">]</span></span> <span class="staexp">int</span> <span class="keyword">(</span><span class="staexp">i</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
ungetc0_exn
  <span class="keyword">(</span>c<span class="keyword">:</span> <span class="staexp">char</span><span class="keyword">,</span> f<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exnwrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> "ext#%"</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">symintr</span> ungetc</span>
<span class="neuexp"><span class="keyword">symintr</span> ungetc_exn</span>
<span class="dynexp"><span class="keyword">overload</span> ungetc <span class="keyword">with</span> ungetc0</span>
<span class="dynexp"><span class="keyword">overload</span> ungetc <span class="keyword">with</span> ungetc1</span>
<span class="dynexp"><span class="keyword">overload</span> ungetc_exn <span class="keyword">with</span> ungetc0_exn</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="staexp"><span class="keyword">stacst</span>
BUFSIZ <span class="keyword">:</span> int</span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">praxi</span> BUFSIZ_gtez <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>BUFSIZ &gt;= 0<span class="keyword">]</span></span> <span class="staexp">void</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">macdef</span> BUFSIZ <span class="keyword">=</span> <span class="dynexp"><span class="keyword">$extval</span><span class="keyword">(</span>int<span class="keyword">(</span>BUFSIZ<span class="keyword">)</span><span class="keyword">,</span> "BUFSIZ"<span class="keyword">)</span></span></span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="staexp"><span class="keyword">abst@ype</span> bufmode_t <span class="keyword">=</span> int</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">macdef</span> _IOFBF <span class="keyword">=</span> <span class="dynexp"><span class="keyword">$extval</span><span class="keyword">(</span>bufmode_t<span class="keyword">,</span> "_IOFBF"<span class="keyword">)</span></span></span> <span class="comment">// fully buffered</span>
<span class="dynexp"><span class="keyword">macdef</span> _IOLBF <span class="keyword">=</span> <span class="dynexp"><span class="keyword">$extval</span><span class="keyword">(</span>bufmode_t<span class="keyword">,</span> "_IOLBF"<span class="keyword">)</span></span></span> <span class="comment">// buffered by line</span>
<span class="dynexp"><span class="keyword">macdef</span> _IONBF <span class="keyword">=</span> <span class="dynexp"><span class="keyword">$extval</span><span class="keyword">(</span>bufmode_t<span class="keyword">,</span> "_IONBF"<span class="keyword">)</span></span></span> <span class="comment">// there is no buffering</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
setbuf0_null
  <span class="keyword">(</span>f<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span>
setbuf1_null
  <span class="keyword">(</span>f<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">FILEptr1</span><span class="comment">(*none*)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">symintr</span> setbuf_null</span>
<span class="dynexp"><span class="keyword">overload</span> setbuf_null <span class="keyword">with</span> setbuf0_null</span>
<span class="dynexp"><span class="keyword">overload</span> setbuf_null <span class="keyword">with</span> setbuf1_null</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">(*
//
// HX-2010-10-03:
// the buffer can be freed only after it is no longer used by
// the stream to which it is attached!!!
*)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
setbuffer0
<span class="staexp"><span class="keyword">{</span>n1<span class="keyword">,</span>n2<span class="keyword">:</span>nat <span class="keyword">|</span> n2 &lt;= n1<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp">pf_buf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">b0ytes</span><span class="keyword">(</span><span class="staexp">n1</span><span class="keyword">)</span><span class="staexp"><span class="keyword">@</span></span><span class="staexp">l</span></span>
<span class="keyword">|</span> filr<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">,</span> p_buf<span class="keyword">:</span> <span class="staexp">ptr</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span><span class="keyword">,</span> n2<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">n2</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
setbuffer1
<span class="staexp"><span class="keyword">{</span> n1
<span class="keyword">,</span> n2<span class="keyword">:</span> nat
<span class="keyword">|</span> n2 &lt;= n1
<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>lbf<span class="keyword">:</span>addr<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp">pf_buf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">b0ytes</span><span class="keyword">(</span><span class="staexp">n1</span><span class="keyword">)</span><span class="staexp"><span class="keyword">@</span></span><span class="staexp">lbf</span></span>
<span class="keyword">|</span> filp<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">FILEptr1</span><span class="comment">(*none*)</span><span class="keyword">,</span> p_buf<span class="keyword">:</span> <span class="staexp">ptr</span><span class="keyword">(</span><span class="staexp">lbf</span><span class="keyword">)</span><span class="keyword">,</span> n2<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">n2</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">symintr</span> setbuffer</span>
<span class="dynexp"><span class="keyword">overload</span> setbuffer <span class="keyword">with</span> setbuffer0</span>
<span class="dynexp"><span class="keyword">overload</span> setbuffer <span class="keyword">with</span> setbuffer1</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
setlinebuf0
  <span class="keyword">(</span>f<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span>
setlinebuf1
  <span class="keyword">(</span>f<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">FILEptr1</span><span class="comment">(*none*)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">symintr</span> setlinebuf</span>
<span class="dynexp"><span class="keyword">overload</span> setlinebuf <span class="keyword">with</span> setlinebuf0</span>
<span class="dynexp"><span class="keyword">overload</span> setlinebuf <span class="keyword">with</span> setlinebuf1</span>
<span class="comment">//</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
setvbuf0_null
  <span class="keyword">(</span>f<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">,</span> mode<span class="keyword">:</span> <span class="staexp">bufmode_t</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span>
setvbuf1_null
  <span class="keyword">(</span>f<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">FILEptr1</span><span class="comment">(*none*)</span><span class="keyword">,</span> mode<span class="keyword">:</span> <span class="staexp">bufmode_t</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">symintr</span> setvbuf_null</span>
<span class="dynexp"><span class="keyword">overload</span> setvbuf_null <span class="keyword">with</span> setvbuf0_null</span>
<span class="dynexp"><span class="keyword">overload</span> setvbuf_null <span class="keyword">with</span> setvbuf1_null</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
setvbuf0
<span class="staexp"><span class="keyword">{</span> n1
<span class="keyword">,</span> n2<span class="keyword">:</span>nat
<span class="keyword">|</span> n2 &lt;= n1
<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>lbf<span class="keyword">:</span>addr<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp">pf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">b0ytes</span><span class="keyword">(</span><span class="staexp">n1</span><span class="keyword">)</span><span class="staexp"><span class="keyword">@</span></span><span class="staexp">lbf</span></span>
<span class="keyword">|</span> filr<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">,</span> mode<span class="keyword">:</span> <span class="staexp">bufmode_t</span><span class="keyword">,</span> n2<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">n2</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span>
setvbuf1
<span class="staexp"><span class="keyword">{</span> n1
<span class="keyword">,</span> n2 <span class="keyword">:</span> nat
<span class="keyword">|</span> n2 &lt;= n1
<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>lbf<span class="keyword">:</span>addr<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp">pf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">b0ytes</span><span class="keyword">(</span><span class="staexp">n1</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">lbf</span></span>
<span class="keyword">|</span> filp<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">FILEptr1</span><span class="comment">(*none*)</span><span class="keyword">,</span> mode<span class="keyword">:</span> <span class="staexp">bufmode_t</span><span class="keyword">,</span> n2<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">n2</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">symintr</span> setvbuf</span>
<span class="dynexp"><span class="keyword">overload</span> setvbuf <span class="keyword">with</span> setvbuf0</span>
<span class="dynexp"><span class="keyword">overload</span> setvbuf <span class="keyword">with</span> setvbuf1</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">(* end of [stdio.sats] *)</span>
</pre>
<pre class="patsyntax">
<span class="comment">(***********************************************************************)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(*                         Applied Type System                         *)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(***********************************************************************)</span>

<span class="comment">(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="comment">// Author: Hongwei Xi</span>
<span class="comment">// Authoremail: gmhwxiATgmailDOTcom</span>
<span class="comment">// Start Time: June, 2012</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="extcode"><span class="extcode">%{#
//
#include \
"libats/libc/CATS/stdlib.cats"
//
%}</span></span> <span class="comment">// end of [%{#]</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">#define</span>
ATS_PACKNAME "ATSLIB.libats.libc"</span>
<span class="comment">//</span>
<span class="comment">// HX: prefix for external names</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">#define</span>
ATS_EXTERN_PREFIX "atslib_libats_libc_"</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">vtypedef</span>
<span class="staexp">RD<span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>vt0p</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp">a</span></span> <span class="comment">// for commenting: read-only</span>
<span class="neuexp"><span class="keyword">#define</span> NSH<span class="keyword">(</span>x<span class="keyword">)</span> x</span> <span class="comment">// for commenting: no sharing</span>
<span class="neuexp"><span class="keyword">#define</span> SHR<span class="keyword">(</span>x<span class="keyword">)</span> x</span> <span class="comment">// for commenting: it is shared</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="keyword">staload</span>
STDDEF <span class="keyword">=</span>
"libats/libc/SATS/stddef.sats"
<span class="comment">//</span>
<span class="keyword">typedef</span> <span class="staexp">wchar_t <span class="keyword">=</span> <span class="staexp">$STDDEF<span class="keyword">.</span>wchar_t</span></span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">macdef</span> EXIT_FAILURE <span class="keyword">=</span> <span class="dynexp"><span class="keyword">$extval</span><span class="keyword">(</span>int<span class="keyword">,</span> "EXIT_FAILURE"<span class="keyword">)</span></span></span>
<span class="dynexp"><span class="keyword">macdef</span> EXIT_SUCCESS <span class="keyword">=</span> <span class="dynexp"><span class="keyword">$extval</span><span class="keyword">(</span>int<span class="keyword">,</span> "EXIT_SUCCESS"<span class="keyword">)</span></span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="staexp"><span class="keyword">abst@ype</span> div_t <span class="keyword">=</span> <span class="keyword">$extype</span>"div_t"</span>
<span class="staexp"><span class="keyword">abst@ype</span> ldiv_t <span class="keyword">=</span> <span class="keyword">$extype</span>"ldiv_t"</span>
<span class="staexp"><span class="keyword">abst@ype</span> lldiv_t <span class="keyword">=</span> <span class="keyword">$extype</span>"lldiv_t"</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">/*
void _Exit(int);
*/</span>
<span class="dynexp"><span class="keyword">fun</span> _Exit <span class="keyword">(</span><span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> "mac#%"</span>

<span class="comment">/*
int atexit(void (*)(void));
*/</span>
<span class="dynexp"><span class="keyword">fun</span> atexit
  <span class="keyword">(</span>f<span class="keyword">:</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">-&gt;</span></span> <span class="staexp">void</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span><span class="comment">(*err*)</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">// end of [atexit]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">/*
void abort(void);
*/</span>
<span class="dynexp"><span class="keyword">fun</span> abort<span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> "mac#%"</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">/*
int abs(int)
*/</span>
<span class="dynexp"><span class="keyword">fun</span> abs<span class="keyword">(</span><span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">/*
long int labs(long int j);
*/</span>
<span class="dynexp"><span class="keyword">fun</span> labs<span class="keyword">(</span><span class="staexp">lint</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">lint</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">/*
long long int llabs(long long int j);
*/</span>
<span class="dynexp"><span class="keyword">fun</span> llabs<span class="keyword">(</span><span class="staexp">lint</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">llint</span> <span class="keyword">=</span> "mac#%"</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">/*
div_t div(int, int);
*/</span>
<span class="dynexp"><span class="keyword">fun</span> div<span class="keyword">(</span><span class="staexp">int</span><span class="keyword">,</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">div_t</span></span>
<span class="comment">/*
ldiv_t ldiv(long, long);
*/</span>
<span class="dynexp"><span class="keyword">fun</span> ldiv<span class="keyword">(</span><span class="staexp">lint</span><span class="keyword">,</span> <span class="staexp">lint</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">ldiv_t</span></span>
<span class="comment">/*
lldiv_t lldiv(long long, long long);                              
*/</span>
<span class="dynexp"><span class="keyword">fun</span> lldiv<span class="keyword">(</span><span class="staexp">llint</span><span class="keyword">,</span> <span class="staexp">llint</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">lldiv_t</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">/*
long a64l(const char *);
*/</span>
<span class="dynexp"><span class="keyword">fun</span> a64l<span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">lint</span> <span class="keyword">=</span> "mac#%"</span>

<span class="comment">/*
char *l64a(long value); // not defined for a negative value
*/</span>
<span class="dynexp"><span class="keyword">fun</span> l64a
  <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat<span class="keyword">}</span></span>
<span class="keyword">(</span>
  x<span class="keyword">:</span> <span class="staexp">lint</span> <span class="staexp">i</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">refwrt</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">[</span>l<span class="keyword">:</span>agz<span class="keyword">]</span></span> <span class="staexp">vttakeout0</span><span class="keyword">(</span><span class="staexp">strptr</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">// end of [l64a]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">/*
int atoi(const char *);
*/</span>
<span class="dynexp"><span class="keyword">fun</span> atoi<span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>

<span class="comment">/*
long atol(const char *);
*/</span>
<span class="dynexp"><span class="keyword">fun</span> atol<span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">lint</span> <span class="keyword">=</span> "mac#%"</span>

<span class="comment">/*
long long atoll(const char *);
*/</span>
<span class="dynexp"><span class="keyword">fun</span> atoll<span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">llint</span> <span class="keyword">=</span> "mac#%"</span>
                                          
<span class="comment">(* ****** ****** *)</span>

<span class="comment">/*
double atof(const char *);
*/</span>
<span class="dynexp"><span class="keyword">fun</span> atof<span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">double</span> <span class="keyword">=</span> "mac#%"</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="comment">/*
long int
strtol(const char *nptr, char **endptr, int base);
*/</span>
<span class="dynexp"><span class="keyword">fun</span> strtol0
  <span class="keyword">(</span>nptr<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">,</span> base<span class="keyword">:</span> <span class="staexp">intBtwe</span><span class="keyword">(</span><span class="staexp">2</span><span class="keyword">,</span> <span class="staexp">36</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">lint</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span> strtol1
  <span class="keyword">(</span>nptr<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">,</span> endptr<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">ptr</span><span class="staexp">?</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">,</span> base<span class="keyword">:</span> <span class="staexp">intBtwe</span><span class="keyword">(</span><span class="staexp">2</span><span class="keyword">,</span> <span class="staexp">36</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">lint</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span> strtol_unsafe
  <span class="keyword">(</span>nptr<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">,</span> endptr<span class="keyword">:</span> <span class="staexp">ptr</span><span class="keyword">,</span> base<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">lint</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">// end of [strtol_unsafe]</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">symintr</span> strtol</span>
<span class="dynexp"><span class="keyword">overload</span> strtol <span class="keyword">with</span> strtol0</span>
<span class="dynexp"><span class="keyword">overload</span> strtol <span class="keyword">with</span> strtol1</span>
<span class="comment">//</span>
<span class="comment">/*
long long int
strtoll(const char *nptr, char **endptr, int base);
*/</span>
<span class="dynexp"><span class="keyword">fun</span> strtoll0
  <span class="keyword">(</span>nptr<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">,</span> base<span class="keyword">:</span> <span class="staexp">intBtwe</span><span class="keyword">(</span><span class="staexp">2</span><span class="keyword">,</span> <span class="staexp">36</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">llint</span></span>
<span class="dynexp"><span class="keyword">fun</span> strtoll1
  <span class="keyword">(</span>nptr<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">,</span> endptr<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">ptr</span><span class="staexp">?</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">,</span> base<span class="keyword">:</span> <span class="staexp">intBtwe</span><span class="keyword">(</span><span class="staexp">2</span><span class="keyword">,</span> <span class="staexp">36</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">llint</span></span>
<span class="dynexp"><span class="keyword">fun</span> strtoll_unsafe
  <span class="keyword">(</span>nptr<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">,</span> endptr<span class="keyword">:</span> <span class="staexp">ptr</span><span class="keyword">,</span> base<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">llint</span></span>
<span class="comment">// end of [strtoll_unsafe]</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">symintr</span> strtoll</span>
<span class="dynexp"><span class="keyword">overload</span> strtoll <span class="keyword">with</span> strtoll0</span>
<span class="dynexp"><span class="keyword">overload</span> strtoll <span class="keyword">with</span> strtoll1</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="comment">/*
unsigned long
strtoul(const char *nptr, char **endptr, int base);
*/</span>
<span class="dynexp"><span class="keyword">fun</span> strtoul0
  <span class="keyword">(</span>nptr<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">,</span> base<span class="keyword">:</span> <span class="staexp">intBtwe</span><span class="keyword">(</span><span class="staexp">2</span><span class="keyword">,</span> <span class="staexp">36</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">ulint</span></span>
<span class="dynexp"><span class="keyword">fun</span> strtoul1
  <span class="keyword">(</span>nptr<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">,</span> endptr<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">ptr</span><span class="staexp">?</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">,</span> base<span class="keyword">:</span> <span class="staexp">intBtwe</span><span class="keyword">(</span><span class="staexp">2</span><span class="keyword">,</span> <span class="staexp">36</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">ulint</span></span>
<span class="dynexp"><span class="keyword">fun</span> strtoul_unsafe
  <span class="keyword">(</span>nptr<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">,</span> endptr<span class="keyword">:</span> <span class="staexp">ptr</span><span class="keyword">,</span> base<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">ulint</span></span>
<span class="comment">// end of [strtoul_unsafe]</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">symintr</span> strtoul</span>
<span class="dynexp"><span class="keyword">overload</span> strtoul <span class="keyword">with</span> strtoul0</span>
<span class="dynexp"><span class="keyword">overload</span> strtoul <span class="keyword">with</span> strtoul1</span>
<span class="comment">//</span>
<span class="comment">/*
unsigned long long
strtoull(const char *nptr, char **endptr, int base);
*/</span>
<span class="dynexp"><span class="keyword">fun</span> strtoull0
  <span class="keyword">(</span>nptr<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">,</span> base<span class="keyword">:</span> <span class="staexp">intBtwe</span><span class="keyword">(</span><span class="staexp">2</span><span class="keyword">,</span> <span class="staexp">36</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">ullint</span></span>
<span class="dynexp"><span class="keyword">fun</span> strtoull1
  <span class="keyword">(</span>nptr<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">,</span> endptr<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">ptr</span><span class="staexp">?</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">,</span> base<span class="keyword">:</span> <span class="staexp">intBtwe</span><span class="keyword">(</span><span class="staexp">2</span><span class="keyword">,</span> <span class="staexp">36</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">ullint</span></span>
<span class="dynexp"><span class="keyword">fun</span> strtoull_unsafe
  <span class="keyword">(</span>nptr<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">,</span> endptr<span class="keyword">:</span> <span class="staexp">ptr</span><span class="keyword">,</span> base<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">ullint</span></span>
<span class="comment">// end of [strtoull_unsafe]</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">symintr</span> strtoull</span>
<span class="dynexp"><span class="keyword">overload</span> strtoull <span class="keyword">with</span> strtoull0</span>
<span class="dynexp"><span class="keyword">overload</span> strtoull <span class="keyword">with</span> strtoull1</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">/*
float
strtof(const char *nptr, char **endptr);
*/</span>
<span class="dynexp"><span class="keyword">fun</span>
strtof0
  <span class="keyword">(</span>nptr<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">float</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span>
strtof1
  <span class="keyword">(</span>nptr<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">,</span> endptr<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">ptr</span><span class="staexp">?</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">float</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span> strtof_unsafe
  <span class="keyword">(</span>nptr<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">,</span> endptr<span class="keyword">:</span> <span class="staexp">ptr</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">float</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">// end of [strtof_unsafe]</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">symintr</span> strtof</span>
<span class="dynexp"><span class="keyword">overload</span> strtof <span class="keyword">with</span> strtof0</span>
<span class="dynexp"><span class="keyword">overload</span> strtof <span class="keyword">with</span> strtof1</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">/*
double
strtod(const char *nptr, char **endptr);
*/</span>
<span class="dynexp"><span class="keyword">fun</span>
strtod0
  <span class="keyword">(</span>nptr<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">double</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span>
strtod1
  <span class="keyword">(</span>nptr<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">,</span> endptr<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">ptr</span><span class="staexp">?</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">double</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span>
strtod_unsafe
  <span class="keyword">(</span>nptr<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">,</span> endptr<span class="keyword">:</span> <span class="staexp">ptr</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">double</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">// end of [strtod_unsafe]</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">symintr</span> strtod</span>
<span class="dynexp"><span class="keyword">overload</span> strtod <span class="keyword">with</span> strtod0</span>
<span class="dynexp"><span class="keyword">overload</span> strtod <span class="keyword">with</span> strtod1</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">/*
long double
strtold(const char *nptr, char **endptr);
*/</span>
<span class="dynexp"><span class="keyword">fun</span>
strtold0
  <span class="keyword">(</span>nptr<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">ldouble</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span>
strtold1
  <span class="keyword">(</span>nptr<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">,</span> endptr<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">ptr</span><span class="staexp">?</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">ldouble</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span>
strtold_unsafe
  <span class="keyword">(</span>nptr<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">,</span> endptr<span class="keyword">:</span> <span class="staexp">ptr</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">ldouble</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">// end of [strtold_unsafe]</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">symintr</span> strtold</span>
<span class="dynexp"><span class="keyword">overload</span> strtold <span class="keyword">with</span> strtold0</span>
<span class="dynexp"><span class="keyword">overload</span> strtold <span class="keyword">with</span> strtold1</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">(*
//
// HX: these env-functions may not be reentrant!
//
*)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">/*
char *getenv(char *);
*/</span>
<span class="dynexp"><span class="keyword">fun</span> getenv
<span class="keyword">(</span>
  name<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">ref</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">[</span>l<span class="keyword">:</span>addr<span class="keyword">]</span></span> <span class="staexp">vttakeout0</span><span class="keyword">(</span><span class="staexp">strptr</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>

<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span> getenv_gc<span class="keyword">(</span>name<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">refwrt</span><span class="keyword">&gt;</span> <span class="staexp">Strptr0</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">/*
int putenv(char *);
*/</span>
<span class="comment">//</span>
<span class="comment">// HX: [nameval] is shared!</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> putenv
  <span class="keyword">(</span>nameval<span class="keyword">:</span> <span class="staexp">SHR</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">refwrt</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">// end of [putenv]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">/*
int setenv
(
  const char *name, const char *value, int overwrite
) ;
*/</span>
<span class="dynexp"><span class="keyword">fun</span> setenv
<span class="keyword">(</span>
  name<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">,</span> value<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">,</span> overwrite<span class="keyword">:</span> <span class="staexp">int</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">refwrt</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>

<span class="comment">/*
int unsetenv(const char *name);
*/</span>
<span class="dynexp"><span class="keyword">fun</span> unsetenv
  <span class="keyword">(</span>name<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">refwrt</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">// end of [unsetenv]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">/*
int clearenv(void);
*/</span>
<span class="dynexp"><span class="keyword">fun</span> clearenv <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">refwrt</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="comment">// HX:</span>
<span class="comment">// these funs seem to have become obsolete</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> rand <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">refwrt</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span> srand <span class="keyword">(</span>seed<span class="keyword">:</span> <span class="staexp">uint</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">refwrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> "mac#%"</span>

<span class="dynexp"><span class="keyword">fun</span> rand_r <span class="keyword">(</span>seed<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">uint</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="comment">/*
long int random(void);
*/</span>
<span class="dynexp"><span class="keyword">fun</span> random<span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">refwrt</span><span class="keyword">&gt;</span> <span class="staexp">lint</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="comment">/*
void srandom(unsigned int seed);
*/</span>
<span class="dynexp"><span class="keyword">fun</span> srandom<span class="keyword">(</span>seed<span class="keyword">:</span> <span class="staexp">uint</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">refwrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="comment">/*
char
*initstate
(
  unsigned int seed, char *state, size_t n
) ;
*/</span>
<span class="dynexp"><span class="keyword">fun</span>
initstate_unsafe
<span class="keyword">(</span>
  seed<span class="keyword">:</span> <span class="staexp">uint</span><span class="keyword">,</span> state<span class="keyword">:</span> <span class="staexp">cPtr1</span><span class="keyword">(</span><span class="staexp">char</span><span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">sizeGte</span><span class="keyword">(</span><span class="staexp">8</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">cPtr0</span><span class="keyword">(</span><span class="staexp">char</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">// end of [initstate_unsafe]</span>
<span class="comment">//</span>
<span class="comment">/*
char *setstate(char *state);
*/</span>
<span class="dynexp"><span class="keyword">fun</span> setstate_unsafe
  <span class="keyword">(</span>state<span class="keyword">:</span> <span class="staexp">cPtr1</span><span class="keyword">(</span><span class="staexp">char</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">ref</span><span class="keyword">&gt;</span> <span class="staexp">cPtr0</span><span class="keyword">(</span><span class="staexp">char</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">// end of [setstate_unsafe]</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">/*
double drand48(void); // obsolete
*/</span>
<span class="dynexp"><span class="keyword">fun</span> drand48 <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">ref</span><span class="keyword">&gt;</span> <span class="staexp">double</span> <span class="keyword">=</span> "mac#%"</span>
     
<span class="comment">/*
double erand48(unsigned short xsubi[3]); // obsolete
*/</span>
<span class="dynexp"><span class="keyword">fun</span> erand48
  <span class="keyword">(</span>xsubi<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">usint</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">3</span><span class="keyword">]</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">ref</span><span class="keyword">&gt;</span> <span class="staexp">double</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">// end of [erand48]</span>

<span class="comment">/*
long int lrand48(void); // obsolete
*/</span>
<span class="dynexp"><span class="keyword">fun</span> lrand48 <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">ref</span><span class="keyword">&gt;</span> <span class="staexp">lint</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">/*
long int nrand48(unsigned short xsubi[3]); // obsolete
*/</span>
<span class="dynexp"><span class="keyword">fun</span> nrand48
  <span class="keyword">(</span>xsubi<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">usint</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">3</span><span class="keyword">]</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">ref</span><span class="keyword">&gt;</span> <span class="staexp">lint</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">// end of [nrand48]</span>

<span class="comment">/*
long int mrand48(void); // obsolete
*/</span>
<span class="dynexp"><span class="keyword">fun</span> mrand48 <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">ref</span><span class="keyword">&gt;</span> <span class="staexp">lint</span> <span class="keyword">=</span> "mac#%"</span>

<span class="comment">/*
long int jrand48(unsigned short xsubi[3]); // obsolete
*/</span>
<span class="dynexp"><span class="keyword">fun</span> jrand48
  <span class="keyword">(</span>xsubi<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">usint</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">3</span><span class="keyword">]</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">ref</span><span class="keyword">&gt;</span> <span class="staexp">lint</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">// end of [jrand48]</span>

<span class="comment">/*
void srand48(long int seedval); // obsolete
*/</span>
<span class="dynexp"><span class="keyword">fun</span> srand48 <span class="keyword">(</span>seedval<span class="keyword">:</span> <span class="staexp">lint</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">ref</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> "mac#%"</span>

<span class="comment">/*
unsigned short *seed48(unsigned short seed16v[3]); // obsolete
*/</span>
<span class="comment">// HX: returning pointer to some internal buffer</span>
<span class="dynexp"><span class="keyword">fun</span> seed48 <span class="keyword">(</span>seed16v<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">usint</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">3</span><span class="keyword">]</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">Ptr1</span> <span class="keyword">=</span> "mac#%"</span>

<span class="comment">/*
void lcong48(unsigned short param[7]); // obsolete
*/</span>
<span class="dynexp"><span class="keyword">fun</span> lcong48 <span class="keyword">(</span>param<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">usint</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">7</span><span class="keyword">]</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">ref</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> "mac#%"</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">/*
void
*bsearch
(
  const void *key
, const void *base
, size_t nmemb, size_t size
, int (*compar)(const void *, const void *)
) ; // end of [bsearch]
*/</span>
<span class="dynexp"><span class="keyword">fun</span> bsearch
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  key<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">RD</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">,</span> arr<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">RD</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span>
<span class="keyword">,</span> asz<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> tsz<span class="keyword">:</span> <span class="staexp">sizeof_t</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmpref</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">Ptr0</span> <span class="keyword">=</span> "mac#%"</span> <span class="comment">// end of [bsearch]</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">/*
void qsort
(
  void *base, size_t nmemb, size_t size
, int(*compar)(const void *, const void *)
) ; // end of [qsort]
*/</span>
<span class="dynexp"><span class="keyword">fun</span> qsort
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  A<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span><span class="keyword">,</span> asz<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> tsz<span class="keyword">:</span> <span class="staexp">sizeof_t</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cmpref</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> "mac#%"</span> <span class="comment">// end of [qsort]</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">/*
int mblen(const char *s, size_t);
*/</span>
<span class="dynexp"><span class="keyword">fun</span>
mblen_unsafe
  <span class="keyword">(</span>s<span class="keyword">:</span> <span class="staexp">cPtr0</span><span class="keyword">(</span><span class="staexp">char</span><span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">refwrt</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">// end of [mblen_unsafe]</span>

<span class="comment">/*
int wctomb(char *s, wchar_t wc);
*/</span>
<span class="dynexp"><span class="keyword">fun</span>
wctomb_unsafe
  <span class="keyword">(</span>s<span class="keyword">:</span> <span class="staexp">cPtr0</span><span class="keyword">(</span><span class="staexp">char</span><span class="keyword">)</span><span class="keyword">,</span> wc<span class="keyword">:</span> <span class="staexp">wchar_t</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">refwrt</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">// end of [wctomb_unsafe]</span>

<span class="comment">/*
size_t
wcstombs(char *dest, const wchar_t *src, size_t);
*/</span>
<span class="dynexp"><span class="keyword">fun</span>
wcstombs_unsafe
<span class="keyword">(</span>
  dest<span class="keyword">:</span> <span class="staexp">cPtr0</span><span class="keyword">(</span><span class="staexp">char</span><span class="keyword">)</span><span class="keyword">,</span> src<span class="keyword">:</span> <span class="staexp">cPtr1</span><span class="keyword">(</span><span class="staexp">wchar_t</span><span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">refwrt</span><span class="keyword">&gt;</span> <span class="staexp">ssize_t</span> <span class="keyword">=</span> "mac#%"</span> <span class="comment">// endfun</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">/*
void setkey(const char *key);
*/</span>
<span class="dynexp"><span class="keyword">fun</span> setkey_unsafe <span class="keyword">(</span>key<span class="keyword">:</span> <span class="staexp">cPtr1</span><span class="keyword">(</span><span class="staexp">char</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">ref</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> "mac#%"</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">/*
int mkstemp(char *template);
*/</span>
<span class="dynexp"><span class="keyword">fun</span>
mkstemp
<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n &gt;= 6<span class="keyword">}</span></span>
  <span class="keyword">(</span>template<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">strnptr</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">// end of [mkstemp] // endfun</span>
<span class="comment">//</span>
<span class="comment">/*
int mkostemp(char *template, int flags);
*/</span>
<span class="dynexp"><span class="keyword">fun</span>
mkostemp
<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n &gt;= 6<span class="keyword">}</span></span>
  <span class="keyword">(</span>template<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">strnptr</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> flags<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">// end of [mkostemp] // endfun</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">/*
int grantpt(int fd);
*/</span>
<span class="dynexp"><span class="keyword">fun</span> grantpt <span class="keyword">(</span>fd<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">dataview</span>
<span class="staexp">malloc_libc_v
  <span class="keyword">(</span>addr<span class="keyword">,</span> int<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="prfexp"><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
    malloc_libc_v_fail
      <span class="keyword">(</span><span class="staexp">null</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span>
    <span class="comment">// malloc_libc_v_fail</span>
  <span class="keyword">|</span> <span class="prfexp"><span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>agz<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
    malloc_libc_v_succ
      <span class="keyword">(</span><span class="staexp">l</span><span class="comment">(*addr*)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">b0ytes</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">mfree_libc_v</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span><span class="keyword">)</span></span></span>
    <span class="comment">// malloc_libc_v_succ</span>
<span class="comment">// end of [malloc_libc_v]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span>
malloc_libc
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  bsz<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">n</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span>
<span class="staexp"><span class="keyword">[</span>
  l<span class="keyword">:</span>addr
<span class="keyword">]</span></span> <span class="keyword">(</span>
  <span class="staexp">malloc_libc_v</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="staexp">ptr</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span> <span class="comment">// end of [malloc]</span>

<span class="dynexp"><span class="keyword">fun</span>
malloc_libc_exn
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  bsz<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span>
<span class="staexp"><span class="keyword">[</span>
  l<span class="keyword">:</span>addr <span class="keyword">|</span> l <span class="keyword">&gt;</span> null
<span class="keyword">]</span></span> <span class="keyword">(</span>
  <span class="staexp">b0ytes</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="staexp"><span class="keyword">@</span></span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">mfree_libc_v</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="staexp">ptr</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span> <span class="comment">// end of [malloc_exn]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span> mfree_libc
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp"><span class="staexp">b0ytes</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="staexp"><span class="keyword">@</span></span><span class="staexp">l</span></span><span class="keyword">,</span> <span class="prfexp"><span class="staexp">mfree_libc_v</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span></span> <span class="keyword">|</span> <span class="staexp">ptr</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> "mac#%"</span> <span class="comment">// end-of-fun</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="comment">/*
int system(const char *command);
*/</span>
<span class="dynexp"><span class="keyword">fun</span> system<span class="keyword">(</span>command<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">(* end of [stdlib.sats] *)</span>
</pre>
<pre class="patsyntax">
<span class="comment">(***********************************************************************)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(*                         Applied Type System                         *)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(***********************************************************************)</span>

<span class="comment">(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="comment">// Author: Hongwei Xi (gmhwxi AT gmail DOT com)</span>
<span class="comment">// Start Time: March, 2013</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="extcode"><span class="extcode">%{#
#include \
"libats/libc/CATS/string.cats"
%}</span></span> <span class="comment">// end of [%{#]</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">#define</span>
ATS_PACKNAME "ATSLIB.libats.libc"</span>
<span class="comment">//</span>
<span class="comment">// HX: prefix for external names</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">#define</span>
ATS_EXTERN_PREFIX "atslib_libats_libc_"</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">vtypedef</span>
<span class="staexp">RD<span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>vt0p</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp">a</span></span> <span class="comment">// for commenting: read-only</span>
<span class="neuexp"><span class="keyword">#define</span> NSH <span class="keyword">(</span>x<span class="keyword">)</span> x</span> <span class="comment">// for commenting: no sharing</span>
<span class="neuexp"><span class="keyword">#define</span> SHR <span class="keyword">(</span>x<span class="keyword">)</span> x</span> <span class="comment">// for commenting: it is shared</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span> strcmp <span class="keyword">(</span>x1<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">,</span> x2<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span> strncmp <span class="keyword">(</span>x1<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">,</span> x2<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span> strcoll <span class="keyword">(</span>x1<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">,</span> x2<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span> strspn <span class="keyword">(</span>x1<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">,</span> x2<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">size_t</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span> strcspn <span class="keyword">(</span>x1<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">,</span> x2<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">size_t</span> <span class="keyword">=</span> "mac#%"</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> strlen
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">string</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">size_t</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span> strnlen <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">string</span> <span class="staexp">n</span><span class="keyword">,</span> max<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="staexp">m</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">size_t</span> <span class="keyword">(</span><span class="staexp">min</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span> strcat
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n1<span class="keyword">,</span>n2<span class="keyword">:</span>int <span class="keyword">|</span> n1+n2 <span class="keyword">&lt;</span> m<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp"><span class="staexp"><span class="keyword">!</span></span><span class="staexp">strbuf_v</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">strbuf_v</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="staexp">+</span><span class="staexp">n2</span><span class="keyword">)</span></span> <span class="keyword">|</span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">string</span> <span class="keyword">(</span><span class="staexp">n2</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span> <span class="comment">// end of [strcat]</span>

<span class="dynexp"><span class="keyword">fun</span> strcat_unsafe
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span> <span class="keyword">(</span>x1<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span><span class="keyword">,</span> x2<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span> strncat_unsafe
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span> <span class="keyword">(</span>x1<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span><span class="keyword">,</span> x2<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span> strcpy
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n <span class="keyword">&lt;</span> m<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp"><span class="staexp"><span class="keyword">!</span></span><span class="staexp">b0ytes</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">strbuf_v</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span> <span class="keyword">|</span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">string</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span> <span class="comment">// endfun</span>

<span class="dynexp"><span class="keyword">fun</span> strcpy_unsafe
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span> <span class="keyword">(</span>dst<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span><span class="keyword">,</span> src<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span> strncpy_unsafe
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span> <span class="keyword">(</span>dst<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span><span class="keyword">,</span> src<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>

<span class="comment">(* ****** ****** *)</span>

<span class="staexp"><span class="keyword">absview</span> strdup_view <span class="keyword">(</span>l<span class="keyword">:</span>addr<span class="keyword">)</span></span>
<span class="keyword">viewdef</span> <span class="staexp">strdup_v <span class="keyword">(</span><span class="staexp">l<span class="keyword">:</span>addr</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp">strdup_view</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span></span>

<span class="dynexp"><span class="keyword">fun</span> strdup
<span class="keyword">(</span>
  str<span class="keyword">:</span> <span class="staexp">string</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">[</span>l<span class="keyword">:</span>addr<span class="keyword">]</span></span> <span class="keyword">(</span><span class="staexp">strdup_v</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="staexp">strptr</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span> strndup
<span class="keyword">(</span>
  str<span class="keyword">:</span> <span class="staexp">string</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">[</span>l<span class="keyword">:</span>addr<span class="keyword">]</span></span> <span class="keyword">(</span><span class="staexp">strdup_v</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="staexp">strptr</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>

<span class="dynexp"><span class="keyword">fun</span> strdup_free
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span> <span class="keyword">(</span><span class="prfexp">pf<span class="keyword">:</span> <span class="staexp">strdup_v</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span></span> <span class="keyword">|</span> x<span class="keyword">:</span> <span class="staexp">strptr</span> <span class="staexp">l</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">// end of [strdup_free]</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="comment">// HX-2013-03:</span>
<span class="comment">// strdupa-functions are gcc-functions;</span>
<span class="comment">// they use alloca for memory allocation</span>
<span class="comment">//</span>
<span class="staexp"><span class="keyword">absview</span> strdupa_view <span class="keyword">(</span>l<span class="keyword">:</span>addr<span class="keyword">)</span></span>
<span class="keyword">viewdef</span> <span class="staexp">strdupa_v <span class="keyword">(</span><span class="staexp">l<span class="keyword">:</span>addr</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp">strdupa_view</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span></span>

<span class="dynexp"><span class="keyword">fun</span> strdupa
<span class="keyword">(</span>
  str<span class="keyword">:</span> <span class="staexp">string</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">[</span>l<span class="keyword">:</span>addr<span class="keyword">]</span></span> <span class="keyword">(</span><span class="staexp">strdupa_v</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="staexp">strptr</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span> strndupa
<span class="keyword">(</span>
  str<span class="keyword">:</span> <span class="staexp">string</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">[</span>l<span class="keyword">:</span>addr<span class="keyword">]</span></span> <span class="keyword">(</span><span class="staexp">strdupa_v</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="staexp">strptr</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>

<span class="dynexp"><span class="keyword">fun</span> strdupa_free
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span> <span class="keyword">(</span><span class="prfexp">pf<span class="keyword">:</span> <span class="staexp">strdupa_v</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span></span> <span class="keyword">|</span> x<span class="keyword">:</span> <span class="staexp">strptr</span> <span class="staexp">l</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">// end of [strdupa_free]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span> strfry <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>agz<span class="keyword">}</span></span> <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">strptr</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> memcpy
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>n1<span class="keyword">,</span>n2<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n &lt;= n1<span class="keyword">;</span> n &lt;= n2<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp">pf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">b0ytes</span><span class="keyword">(</span><span class="staexp">n1</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">bytes</span><span class="keyword">(</span><span class="staexp">n1</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span></span>
<span class="keyword">|</span> dst<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span><span class="keyword">,</span> src<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">RD</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">byte</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n2</span><span class="keyword">]</span><span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span> <span class="comment">// end of [memcpy]</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> memcpy_unsafe<span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span>
  <span class="keyword">(</span>dst<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span><span class="keyword">,</span> src<span class="keyword">:</span> <span class="staexp">ptr</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">/*
void *memset(void *s, int c, size_t n);
*/</span>
<span class="dynexp"><span class="keyword">fun</span> memset_unsafe<span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span>
  <span class="keyword">(</span>dst<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span><span class="keyword">,</span> c<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">/*
void *memmove(void *dest, const void *src, size_t n);
*/</span>
<span class="dynexp"><span class="keyword">fun</span> memmove_unsafe<span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span>
  <span class="keyword">(</span>dst<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span><span class="keyword">,</span> src<span class="keyword">:</span> <span class="staexp">ptr</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">/*
void *memccpy(void *dest, const void *src, int c, size_t n);
*/</span>
<span class="dynexp"><span class="keyword">fun</span> memccpy_unsafe<span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span>
  <span class="keyword">(</span>dst<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span><span class="keyword">,</span> src<span class="keyword">:</span> <span class="staexp">ptr</span><span class="keyword">,</span> c<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">Ptr0</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> mempcpy
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>n1<span class="keyword">,</span>n2<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n &lt;= n1<span class="keyword">;</span> n &lt;= n2<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp">pf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">b0ytes</span><span class="keyword">(</span><span class="staexp">n1</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">bytes</span><span class="keyword">(</span><span class="staexp">n1</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span></span>
<span class="keyword">|</span> dst<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span><span class="keyword">,</span> src<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">RD</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">byte</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n2</span><span class="keyword">]</span><span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l</span><span class="staexp">+</span><span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span> <span class="comment">// end of [mempcpy]</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> mempcpy_unsafe<span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>dst<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span><span class="keyword">,</span> src<span class="keyword">:</span> <span class="staexp">ptr</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l</span><span class="staexp">+</span><span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="comment">// HX: This one is non-reentrant:</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> strerror
  <span class="keyword">(</span>errnum<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">ref</span><span class="keyword">&gt;</span> <span class="staexp"><span class="keyword">[</span>l<span class="keyword">:</span>agz<span class="keyword">]</span></span> <span class="staexp">vttakeout0</span> <span class="keyword">(</span><span class="staexp">strptr</span> <span class="staexp">l</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">// end of [strerror]</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">/*
int strerror_r(int errnum, char *buf, size_t buflen);
*/</span>
<span class="dynexp"><span class="keyword">fun</span> strerror_r<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>errnum<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> buf<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">bytes</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">// end of [strerror_r]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span> strerror_r_gc <span class="keyword">(</span>errnum<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">Strptr1</span> <span class="keyword">=</span> "ext#%"</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">(* end of [string.sats] *)</span>
</pre>
<pre class="patsyntax">
<span class="comment">(***********************************************************************)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(*                         Applied Type System                         *)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(***********************************************************************)</span>

<span class="comment">(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">(* Author: Hongwei Xi *)</span>
<span class="comment">(* Authoremail: gmhwxiATgmailDOTcom *)</span>
<span class="comment">(* Start time: April, 2012 *)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="extcode"><span class="extcode">%{#
#include \
"libats/libc/CATS/unistd.cats"
%}</span></span> <span class="comment">// end of [%{#]</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">#define</span>
ATS_PACKNAME "ATSLIB.libats.libc"</span>
<span class="comment">//</span>
<span class="comment">// HX: prefix for external names</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">#define</span> ATS_EXTERN_PREFIX "atslib_libats_libc_"</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="neuexp"><span class="keyword">#define</span> SHR<span class="keyword">(</span>x<span class="keyword">)</span> x</span> <span class="comment">// SHARED // HX: for commenting</span>
<span class="neuexp"><span class="keyword">#define</span> NSH<span class="keyword">(</span>x<span class="keyword">)</span> x</span> <span class="comment">// NSHARED // HX: for commenting</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">typedef</span> <span class="staexp">interr <span class="keyword">=</span> <span class="staexp">int</span></span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="keyword">staload</span>
TYPES <span class="keyword">=</span>
"libats/libc/SATS/sys/types.sats"
<span class="comment">//</span>
<span class="keyword">typedef</span> <span class="staexp">off_t <span class="keyword">=</span> <span class="staexp">$TYPES<span class="keyword">.</span>off_t</span></span>
<span class="comment">//</span>
<span class="keyword">typedef</span> <span class="staexp">pid_t <span class="keyword">=</span> <span class="staexp">$TYPES<span class="keyword">.</span>pid_t</span></span>
<span class="keyword">typedef</span> <span class="staexp">uid_t <span class="keyword">=</span> <span class="staexp">$TYPES<span class="keyword">.</span>uid_t</span></span>
<span class="keyword">typedef</span> <span class="staexp">gid_t <span class="keyword">=</span> <span class="staexp">$TYPES<span class="keyword">.</span>gid_t</span></span>
<span class="comment">//</span>
<span class="keyword">stadef</span> <span class="staexp">fildes_v <span class="keyword">=</span> <span class="staexp">$TYPES<span class="keyword">.</span>fildes_v</span></span>
<span class="comment">//</span>
<span class="keyword">vtypedef</span>
<span class="staexp">fildes <span class="keyword">(</span><span class="staexp">i<span class="keyword">:</span>int</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp">$TYPES<span class="keyword">.</span>fildes</span> <span class="keyword">(</span><span class="staexp">i</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">vtypedef</span> <span class="staexp">Fildes <span class="keyword">=</span> <span class="staexp">$TYPES<span class="keyword">.</span>Fildes</span></span>
<span class="keyword">vtypedef</span> <span class="staexp">Fildes0 <span class="keyword">=</span> <span class="staexp">$TYPES<span class="keyword">.</span>Fildes0</span></span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">macdef</span> STDIN_FILENO <span class="keyword">=</span> <span class="dynexp"><span class="keyword">$extval</span><span class="keyword">(</span>int<span class="keyword">,</span> "STDIN_FILENO"<span class="keyword">)</span></span></span>
<span class="dynexp"><span class="keyword">macdef</span> STDOUT_FILENO <span class="keyword">=</span> <span class="dynexp"><span class="keyword">$extval</span><span class="keyword">(</span>int<span class="keyword">,</span> "STDOUT_FILENO"<span class="keyword">)</span></span></span>
<span class="dynexp"><span class="keyword">macdef</span> STDERR_FILENO <span class="keyword">=</span> <span class="dynexp"><span class="keyword">$extval</span><span class="keyword">(</span>int<span class="keyword">,</span> "STDERR_FILENO"<span class="keyword">)</span></span></span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">/*
int close (int);
*/</span>
<span class="neuexp"><span class="keyword">symintr</span> close</span>
<span class="neuexp"><span class="keyword">symintr</span> close_exn</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> close0 <span class="keyword">(</span>fd<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">interr</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="comment">// HX-2013-03-25: should this be moved to unistd.sats?</span>
<span class="comment">//</span>
<span class="keyword">dataview</span>
<span class="staexp">close_v <span class="keyword">(</span>fd<span class="keyword">:</span>int<span class="keyword">,</span> int<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="prfexp">close_v_succ <span class="keyword">(</span><span class="staexp">fd</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="keyword">(</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="prfexp"><span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>int <span class="keyword">|</span> i <span class="keyword">&lt;</span> 0<span class="keyword">}</span></span> close_v_fail <span class="keyword">(</span><span class="staexp">fd</span><span class="keyword">,</span> <span class="staexp">i</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="staexp">fildes_v</span> <span class="keyword">(</span><span class="staexp">fd</span><span class="keyword">)</span></span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> close1<span class="staexp"><span class="keyword">{</span>fd<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="keyword">(</span>fd<span class="keyword">:</span> <span class="staexp">fildes</span> <span class="keyword">(</span><span class="staexp">fd</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>i<span class="keyword">:</span>int<span class="keyword">]</span></span> <span class="keyword">(</span><span class="staexp">close_v</span> <span class="keyword">(</span><span class="staexp">fd</span><span class="keyword">,</span> <span class="staexp">i</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="staexp">int</span> <span class="staexp">i</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">overload</span> close <span class="keyword">with</span> close0</span>
<span class="dynexp"><span class="keyword">overload</span> close <span class="keyword">with</span> close1</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> close0_exn <span class="keyword">(</span>fd<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> "ext#%"</span>
<span class="dynexp"><span class="keyword">fun</span> close1_exn <span class="keyword">(</span>fd<span class="keyword">:</span> <span class="staexp">Fildes0</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exn</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> "ext#%"</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">overload</span> close_exn <span class="keyword">with</span> close0_exn</span>
<span class="dynexp"><span class="keyword">overload</span> close_exn <span class="keyword">with</span> close1_exn</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span> dup <span class="keyword">(</span>fildes<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span> dup_fildes <span class="keyword">(</span>fd<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">Fildes0</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">Fildes</span> <span class="keyword">=</span> "mac#%"</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> dup2
  <span class="keyword">(</span>fildes<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> fildes2<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="comment">// HX-2013-05:</span>
<span class="comment">// this one requires that [fd2] be not in use</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> dup2_fildes<span class="staexp"><span class="keyword">{</span>fd2<span class="keyword">:</span>nat<span class="keyword">}</span></span>
  <span class="keyword">(</span>fd<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">Fildes0</span><span class="keyword">,</span> fd2<span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">(</span><span class="staexp">fd2</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">Fildes</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="comment">// HX: this one requires -D_GNU_SOURCE</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> dup3
  <span class="keyword">(</span>fildes<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> fildes2<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">,</span> flags<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
execv
<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>pos<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp">pf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">parray_v</span> <span class="keyword">(</span><span class="staexp">string</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span> <span class="keyword">|</span> path<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">,</span> argv<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="staexp">l</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">intLt</span><span class="keyword">(</span><span class="staexp">0</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#atslib_libats_libc_execv"</span>
<span class="dynexp"><span class="keyword">fun</span>
execv_unsafe <span class="comment">// HX: for failure, ~1 is returned</span>
  <span class="keyword">(</span>path<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">,</span> argv<span class="keyword">:</span> <span class="staexp">ptr</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">intLt</span><span class="keyword">(</span><span class="staexp">0</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#atslib_libats_libc_execv"</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
execvp
<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>pos<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp">pf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">parray_v</span> <span class="keyword">(</span><span class="staexp">string</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span> <span class="keyword">|</span> fname<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">,</span> argv<span class="keyword">:</span> <span class="staexp">ptr</span> <span class="staexp">l</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">intLt</span><span class="keyword">(</span><span class="staexp">0</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#atslib_libats_libc_execvp"</span>
<span class="dynexp"><span class="keyword">fun</span>
execvp_unsafe <span class="comment">// HX: for failure, ~1 is returned</span>
  <span class="keyword">(</span>fname<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">,</span> argv<span class="keyword">:</span> <span class="staexp">ptr</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">intLt</span><span class="keyword">(</span><span class="staexp">0</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#atslib_libats_libc_execvp"</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">/*
//
// HX: for failure, ~1 is returned
//
int
execve
(
  const char *filename
, char *const argv[], char *const envp[]
) ;
*/</span>
<span class="dynexp"><span class="keyword">fun</span>
execve
<span class="staexp"><span class="keyword">{</span>n1<span class="keyword">,</span>n2<span class="keyword">:</span>pos<span class="keyword">}</span></span>
<span class="staexp"><span class="keyword">{</span>l1<span class="keyword">,</span>l2<span class="keyword">:</span>addr<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp">pf1<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">parray_v</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">,</span> <span class="staexp">l1</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="keyword">)</span></span>
<span class="keyword">,</span> <span class="prfexp">pf2<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">parray_v</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">,</span> <span class="staexp">l2</span><span class="keyword">,</span> <span class="staexp">n2</span><span class="keyword">)</span></span>
<span class="keyword">|</span> fname<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">,</span> argv<span class="keyword">:</span> <span class="staexp">ptr</span><span class="keyword">(</span><span class="staexp">l1</span><span class="keyword">)</span><span class="keyword">,</span> envp<span class="keyword">:</span> <span class="staexp">ptr</span><span class="keyword">(</span><span class="staexp">l2</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">intLt</span><span class="keyword">(</span><span class="staexp">0</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#atslib_libats_libc_execve"</span>
<span class="dynexp"><span class="keyword">fun</span>
execve_unsafe
<span class="keyword">(</span>
  fname<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">,</span> argv<span class="keyword">:</span> <span class="staexp">ptr</span><span class="comment">(*parray*)</span><span class="keyword">,</span> envp<span class="keyword">:</span> <span class="staexp">ptr</span><span class="comment">(*parray*)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">intLt</span><span class="keyword">(</span><span class="staexp">0</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#atslib_libats_libc_execve"</span>
<span class="comment">// end of [execve_unsafe]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">/*
void
encrypt(char block[64], int edflag);
*/</span>
<span class="dynexp"><span class="keyword">fun</span>
encrypt
<span class="keyword">(</span>
  block<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">char</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">64</span><span class="keyword">]</span><span class="keyword">)</span><span class="keyword">,</span> edflag<span class="keyword">:</span> <span class="staexp">int</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">ref</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> "mac#%"</span> <span class="comment">// endfun</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span> fork <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">pid_t</span> <span class="keyword">=</span> "mac#%"</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="keyword">dataview</span>
<span class="staexp">getcwd_v
<span class="keyword">(</span>
  m<span class="keyword">:</span>int<span class="keyword">,</span> l<span class="keyword">:</span>addr<span class="keyword">,</span> addr
<span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">|</span> <span class="prfexp"><span class="staexp"><span class="keyword">{</span>l<span class="keyword">&gt;</span>null<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>nat<span class="keyword">}</span></span>
    getcwd_v_succ<span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="staexp">strbuf_v</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span>
  <span class="keyword">|</span> <span class="prfexp">getcwd_v_fail<span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">null</span><span class="keyword">)</span> <span class="keyword">of</span> <span class="staexp">b0ytes</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">@</span></span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span></span></span>
<span class="comment">// end of [getcwd_v]</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> getcwd
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp">pf<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">b0ytes</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">)</span><span class="staexp"><span class="keyword">@</span></span><span class="staexp">l</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">getcwd_v</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">,</span> <span class="staexp">l1</span><span class="keyword">)</span></span> <span class="keyword">|</span> p<span class="keyword">:</span> <span class="staexp">ptr</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span><span class="keyword">,</span> m<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp"><span class="keyword">#[</span>l1<span class="keyword">:</span>addr<span class="keyword">]</span></span> <span class="staexp">ptr</span> <span class="keyword">(</span><span class="staexp">l1</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span> <span class="comment">// end of [getcwd]</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> getcwd_gc <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">Strptr0</span> <span class="keyword">=</span> "ext#%"</span> <span class="comment">// HX: this is a convenient wrapper</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="comment">/*
pid_t getpid(void);
pid_t getppid(void);
*/</span>
<span class="dynexp"><span class="keyword">fun</span> getpid <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">pid_t</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span> getppid <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">pid_t</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span> getuid<span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">uid_t</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span> setuid<span class="keyword">(</span>uid<span class="keyword">:</span> <span class="staexp">uid_t</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span> geteuid<span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">uid_t</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span> seteuid<span class="keyword">(</span>uid<span class="keyword">:</span> <span class="staexp">uid_t</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span> getgid<span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">gid_t</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span> setgid<span class="keyword">(</span>gid<span class="keyword">:</span> <span class="staexp">gid_t</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span> getegid<span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">gid_t</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span> setegid<span class="keyword">(</span>gid<span class="keyword">:</span> <span class="staexp">gid_t</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
        
<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span> setreuid<span class="keyword">(</span>ruid<span class="keyword">:</span> <span class="staexp">uid_t</span><span class="keyword">,</span> euid<span class="keyword">:</span> <span class="staexp">uid_t</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span> setregid<span class="keyword">(</span>rgid<span class="keyword">:</span> <span class="staexp">gid_t</span><span class="keyword">,</span> egid<span class="keyword">:</span> <span class="staexp">gid_t</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span> setresuid<span class="keyword">(</span>ruid<span class="keyword">:</span> <span class="staexp">uid_t</span><span class="keyword">,</span> euid<span class="keyword">:</span> <span class="staexp">uid_t</span><span class="keyword">,</span> suid<span class="keyword">:</span> <span class="staexp">uid_t</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span> setresgid<span class="keyword">(</span>rgid<span class="keyword">:</span> <span class="staexp">gid_t</span><span class="keyword">,</span> egid<span class="keyword">:</span> <span class="staexp">gid_t</span><span class="keyword">,</span> sgid<span class="keyword">:</span> <span class="staexp">gid_t</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
          
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="comment">// HX: these are linux-specific!</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> setfsuid<span class="keyword">(</span>fsuid<span class="keyword">:</span> <span class="staexp">uid_t</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span> setfsgid<span class="keyword">(</span>fsgid<span class="keyword">:</span> <span class="staexp">gid_t</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> getlogin<span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">vStrptr0</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> getlogin_r
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n &gt;= 2<span class="keyword">}</span></span>
  <span class="keyword">(</span>buf<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">bytes</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> getlogin_r_gc<span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">Strptr0</span> <span class="keyword">=</span> "ext#%"</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="comment">// HX: [pause] can only returns -1</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> pause <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span> read_err
  <span class="staexp"><span class="keyword">{</span>sz<span class="keyword">,</span>n<span class="keyword">:</span>nat <span class="keyword">|</span> n &lt;= sz<span class="keyword">}</span></span>
<span class="keyword">(</span>
  fd<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">Fildes0</span>
<span class="keyword">,</span> buf<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">b0ytes</span><span class="keyword">(</span><span class="staexp">sz</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">bytes</span><span class="keyword">(</span><span class="staexp">sz</span><span class="keyword">)</span><span class="keyword">,</span> ntotal<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">ssizeBtw</span><span class="keyword">(</span><span class="staexp"><span class="keyword">~</span></span><span class="staexp">1</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span> <span class="comment">// end-of-fun</span>

<span class="dynexp"><span class="keyword">fun</span> write_err
  <span class="staexp"><span class="keyword">{</span>sz<span class="keyword">,</span>n<span class="keyword">:</span>nat <span class="keyword">|</span> n &lt;= sz<span class="keyword">}</span></span>
<span class="keyword">(</span>
  fd<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">Fildes0</span><span class="keyword">,</span> buf<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">RD</span><span class="keyword">(</span><span class="staexp">bytes</span><span class="keyword">(</span><span class="staexp">sz</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> ntotal<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">ssizeBtw</span><span class="keyword">(</span><span class="staexp"><span class="keyword">~</span></span><span class="staexp">1</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span> <span class="comment">// end-of-fun</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span> pread<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  fd<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">Fildes0</span><span class="keyword">,</span> buf<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">byte</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span><span class="staexp">&gt;&gt;</span><span class="staexp">_</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> ofs<span class="keyword">:</span> <span class="staexp">off_t</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">ssize_t</span> <span class="keyword">=</span> "mac#%"</span> <span class="comment">// end of [pread]</span>

<span class="dynexp"><span class="keyword">fun</span> pwrite<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  fd<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">Fildes0</span><span class="keyword">,</span> buf<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">RD</span><span class="keyword">(</span><span class="staexp">array</span><span class="keyword">(</span><span class="staexp">byte</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> ofs<span class="keyword">:</span> <span class="staexp">off_t</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">ssize_t</span> <span class="keyword">=</span> "mac#%"</span> <span class="comment">// end of [pwrite]</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="staexp"><span class="keyword">absview</span>
alarm_v<span class="keyword">(</span>n<span class="keyword">:</span> int<span class="keyword">)</span></span> <span class="comment">// n: remaining seconds</span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">praxi</span>
alarm_v_elim <span class="keyword">(</span>pfrem<span class="keyword">:</span> <span class="staexp">alarm_v</span><span class="keyword">(</span><span class="staexp">0</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
alarm_set<span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>t<span class="keyword">:</span> <span class="staexp">uint</span><span class="keyword">(</span><span class="staexp">i</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">alarm_v</span><span class="keyword">(</span><span class="staexp">i</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="staexp">uInt</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">// end of [alarm_set]</span>
<span class="dynexp"><span class="keyword">fun</span>
alarm_cancel<span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="prfexp">pf<span class="keyword">:</span> <span class="staexp">alarm_v</span><span class="keyword">(</span><span class="staexp">i</span><span class="keyword">)</span></span> <span class="keyword">|</span> <span class="comment">(*none*)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">uInt</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">// end of [alarm_cancel]</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="comment">// HX: [sleep] may be implemented using SIGARM</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> sleep_int
  <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat<span class="keyword">}</span></span> <span class="keyword">(</span>t<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">i</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>j<span class="keyword">:</span>nat <span class="keyword">|</span> j &lt;= i<span class="keyword">]</span></span> <span class="staexp">int</span> <span class="staexp">j</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span> sleep_uint
  <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>t<span class="keyword">:</span> <span class="staexp">uint</span> <span class="staexp">i</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>j<span class="keyword">:</span>nat <span class="keyword">|</span> j &lt;= i<span class="keyword">]</span></span> <span class="staexp">uint</span> <span class="staexp">j</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">symintr</span> sleep</span>
<span class="dynexp"><span class="keyword">overload</span> sleep <span class="keyword">with</span> sleep_int</span>
<span class="dynexp"><span class="keyword">overload</span> sleep <span class="keyword">with</span> sleep_uint</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="comment">// HX: some systems require that the argument &lt;= 1 million</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> usleep_int <span class="comment">// succ/fail: 0/~1</span>
  <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i &lt;= 1000000<span class="keyword">}</span></span> <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">int</span> <span class="staexp">i</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">intLte</span><span class="keyword">(</span><span class="staexp">0</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span> usleep_uint <span class="comment">// succ/fail: 0/~1</span>
  <span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>int <span class="keyword">|</span> i &lt;= 1000000<span class="keyword">}</span></span> <span class="keyword">(</span>n<span class="keyword">:</span> <span class="staexp">uint</span> <span class="staexp">i</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">intLte</span><span class="keyword">(</span><span class="staexp">0</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">symintr</span> usleep</span>
<span class="dynexp"><span class="keyword">overload</span> usleep <span class="keyword">with</span> usleep_int</span>
<span class="dynexp"><span class="keyword">overload</span> usleep <span class="keyword">with</span> usleep_uint</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">/*
int rmdir(const char *pathname);
*/</span>
<span class="dynexp"><span class="keyword">fun</span> rmdir <span class="keyword">(</span>path<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span> rmdir_exn <span class="keyword">(</span>path<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> "ext#%"</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">/*
int link(const char *old, const char *new)
*/</span>
<span class="dynexp"><span class="keyword">fun</span> link
<span class="keyword">(</span>
  old<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span>
<span class="keyword">,</span> new<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">ref</span><span class="keyword">&gt;</span> <span class="staexp">intLte</span><span class="keyword">(</span><span class="staexp">0</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span> link_exn
  <span class="keyword">(</span>old<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">,</span> new<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">ref</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> "ext#%"</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">/*
int symlink(const char *old, const char *new)
*/</span>
<span class="dynexp"><span class="keyword">fun</span> symlink
<span class="keyword">(</span>
  old<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span>
<span class="keyword">,</span> new<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">ref</span><span class="keyword">&gt;</span> <span class="staexp">intLte</span><span class="keyword">(</span><span class="staexp">0</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span> symlink_exn
  <span class="keyword">(</span>old<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">,</span> new<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">ref</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> "ext#%"</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">/*
int unlink(const char *pathname);
*/</span>
<span class="dynexp"><span class="keyword">fun</span> unlink <span class="keyword">(</span>path<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">ref</span><span class="keyword">&gt;</span> <span class="staexp">intLte</span><span class="keyword">(</span><span class="staexp">0</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span> unlink_exn <span class="keyword">(</span>path<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">exnref</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> "ext#%"</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span> readlink<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  path<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">,</span> buf<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="keyword">@[</span><span class="staexp">byte</span><span class="keyword">]</span><span class="keyword">[</span><span class="staexp">n</span><span class="keyword">]</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">size_t</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">ssizeLte</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span> <span class="comment">// end of [readlink]</span>

<span class="dynexp"><span class="keyword">fun</span> readlink_gc <span class="keyword">(</span>path<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">Strptr0</span> <span class="keyword">=</span> "ext#%"</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span> sync <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span> fsync <span class="keyword">(</span>fd<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">Fildes0</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span> fdatasync <span class="keyword">(</span>fd<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">Fildes0</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> truncate
  <span class="keyword">(</span>path<span class="keyword">:</span> <span class="staexp">NSH</span><span class="keyword">(</span><span class="staexp">string</span><span class="keyword">)</span><span class="keyword">,</span> ofs<span class="keyword">:</span> <span class="staexp">off_t</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> ftruncate <span class="keyword">(</span>fd<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">Fildes0</span><span class="keyword">,</span> ofs<span class="keyword">:</span> <span class="staexp">off_t</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="neuexp"><span class="keyword">#include</span> "./unistd_sysconf.sats"</span>
<span class="neuexp"><span class="keyword">#include</span> "./unistd_pathconf.sats"</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">(* end of [unistd.sats] *)</span>
</pre>
<pre class="patsyntax">
<span class="comment">(***********************************************************************)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(*                         Applied Type System                         *)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(***********************************************************************)</span>

<span class="comment">(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="comment">// Author: Hongwei Xi</span>
<span class="comment">// Start Time: May, 2012</span>
<span class="comment">// Authoremail: gmhwxiATgmailDOTcom</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">#define</span>
ATS_PACKNAME "ATSLIB.libats.libc"</span>
<span class="neuexp"><span class="keyword">#define</span>
ATS_DYNLOADFLAG 0</span> <span class="comment">// no dynloading at run-time</span>
<span class="neuexp"><span class="keyword">#define</span>
ATS_EXTERN_PREFIX
"atslib_libats_libc_"</span> <span class="comment">// prefix for external names</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="extcode"><span class="extcode">%{^
#include "share/H/pats_atslib.h"
%}</span></span> <span class="comment">// end of [%{^]</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="keyword">staload</span> "libats/libc/SATS/stdio.sats"
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="extcode"><span class="extcode">%{$
//
extern
atstype_ptr
atslib_libats_libc_fopen_exn
(
  atstype_string path
, atstype_string mode
) {
  FILE *filp ;
  filp = fopen ((char*)path, (char*)mode) ;
  if (!filp) ATSLIBfailexit("fopen") ; // HX: failure
  return filp ;
} /* end of [atslib_libats_libc_fopen_exn] */
//
%}</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="extcode"><span class="extcode">%{$
//
extern
atsvoid_t0ype
atslib_libats_libc_fclose_exn
  (atstype_ptr filp) {
  int err ;
  err = fclose ((FILE*)filp) ;
  if (0 &gt; err) ATSLIBfailexit("fclose") ;
  return ;
} /* end of [atslib_libats_libc_fclose_exn] */
//
%}</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="extcode"><span class="extcode">%{$
//
extern
atsvoid_t0ype
atslib_libats_libc_fflush_exn
(
  atstype_ptr filp
) {
  int err = fflush((FILE*)filp) ;
  if (0 &gt; err) ATSLIBfailexit("fflush") ;
  return ;
} /* end of [atslib_libats_libc_fflush_exn] */
//
%}</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="extcode"><span class="extcode">%{$
//
extern
atsvoid_t0ype
atslib_libats_libc_fputc_exn
(
  atstype_int c, atstype_ptr filp
) {
  int err ;
  err = fputc(c, (FILE*)filp) ;
  if (0 &gt; err) {
    ATSLIBfailexit("fputc") ; // abnormal exit
  } // end of [if]
  return ;  
} /* end of [atslib_libats_libc_fputc_exn] */
//
%}</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="extcode"><span class="extcode">%{$
//
extern
atsvoid_t0ype
atslib_libats_libc_fgets_exn
(
  atstype_ptr buf0
, atstype_int bsz0
, atstype_ptr filp
) {
  char *buf, *pres ;
  buf = (char*)buf0 ;
  pres = fgets(buf, (int)bsz0, (FILE*)filp) ;
  if (!pres)
  {
    if (feof((FILE*)filp))
    {
      buf[0] = '\000' ; // EOF is reached
    } else {
      ATSLIBfailexit("fgets") ; // abnormal exit
    } // end of [if]
  } // end of [if]
  return ;  
} /* end of [atslib_libats_libc_fgets_exn] */
//
%}</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="extcode"><span class="extcode">%{$
//
extern
atstype_ptr
atslib_libats_libc_fgets_gc
(
  atstype_int bsz0
, atstype_ptr filp0
)
{
  int bsz = bsz0 ;
  FILE *filp = (FILE*)filp0 ;
  int ofs = 0, ofs2 ;
  char *buf, *buf2, *pres ;
  buf = atspre_malloc_gc(bsz) ;
  while (1) {
    buf2 = buf+ofs ;
    pres = fgets(buf2, bsz-ofs, filp) ;
    if (!pres)
    {
      if (feof(filp))
      {
        *buf2 = '\000' ; return buf ;
      } else {
        atspre_mfree_gc(buf) ; return (char*)0 ;
      } // end of [if]
    }
    ofs2 = strlen(buf2) ;
    if (ofs2==0) return buf ;
    ofs += ofs2 ; // HX: ofs &gt; 0
    if (buf[ofs-1]=='\n') return buf ;
    bsz *= 2 ; buf2 = buf ;
    buf = atspre_malloc_gc(bsz) ;
    memcpy(buf, buf2, ofs) ;
    atspre_mfree_gc(buf2) ;
  } // end of [while]
  return buf ; // HX: deadcode
} /* end of [atslib_libats_libc_fgets_gc] */
//
%}</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="extcode"><span class="extcode">%{$
//
extern
atsvoid_t0ype
atslib_libats_libc_fputs_exn
(
  atstype_string str, atstype_ptr filp
) {
  int err ;
  err = fputs((char*)str, (FILE*)filp) ;
  if (0 &gt; err) {
    ATSLIBfailexit("fputs") ; // abnormal exit
  } // end of [if]
  return ;  
} /* end of [atslib_libats_libc_fputs_exn] */
//
%}</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="extcode"><span class="extcode">%{$
//
extern
atsvoid_t0ype
atslib_libats_libc_puts_exn
(
  atstype_string str
) {
  int err ;
  err = puts((char*)str) ;
  if (0 &gt; err) {
    ATSLIBfailexit("puts") ; // abnormal exit
  } // end of [if]
  return ;  
} /* end of [atslib_libats_libc_puts_exn] */
//
%}</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="extcode"><span class="extcode">%{$
//
extern
atstype_ptr
atslib_libats_libc_popen_exn
(
  atstype_string cmd
, atstype_string type
) {
  FILE *filp ;
  filp = popen((char*)cmd, (char*)type) ;
  if (!filp) {
    ATSLIBfailexit("popen") ; // abnormal exit
  } // end of [if]
  return filp ;
} /* end of [atslib_libats_libc_popen_exn] */
//
%}</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="extcode"><span class="extcode">%{$
//
extern
atstype_int
atslib_libats_libc_pclose_exn
(
  atstype_ptr filp
) {
  int res ;
  res = pclose((FILE*)filp) ;
  if (0 &gt; res) {
    ATSLIBfailexit("pclose") ; // abnormal exit
  } // end of [if]
  return res ;
} /* end of [atslib_libats_libc_pclose_exn] */
//
%}</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="extcode"><span class="extcode">%{$
//
extern
atstype_ptr
atslib_libats_libc_tmpfile_exn
(
// argumentless
) {
  FILE *filp = tmpfile() ;
  if (!filp) ATSLIBfailexit("tmpfile") ;
  return (filp) ;
} /* end of [atslib_libats_libc_tmpfile_exn] */
//
%}</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">(* end of [stdio.dats] *)</span>
</pre>
<pre class="patsyntax">
<span class="comment">(***********************************************************************)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(*                         Applied Type System                         *)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(***********************************************************************)</span>

<span class="comment">(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="comment">// Author: Hongwei Xi</span>
<span class="comment">// Start Time: May, 2012</span>
<span class="comment">// Authoremail: gmhwxiATgmailDOTcom</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">#define</span>
ATS_PACKNAME "ATSLIB.libats.libc"</span>
<span class="neuexp"><span class="keyword">#define</span>
ATS_DYNLOADFLAG 0</span> <span class="comment">// no dynloading at run-time</span>
<span class="neuexp"><span class="keyword">#define</span>
ATS_EXTERN_PREFIX
"atslib_libats_libc_"</span> <span class="comment">// prefix for external names</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="extcode"><span class="extcode">%{^
//
#include "share/H/pats_atslib.h"
//
%}</span></span> <span class="comment">// end of [%{^]</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="keyword">staload</span> "libats/libc/SATS/stdlib.sats"
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp"><span class="keyword">}</span></span><span class="comment">(*tmp*)</span>
getenv_gc
  <span class="keyword">(</span>name<span class="keyword">)</span> <span class="keyword">=</span> str2 <span class="keyword">where</span>
<span class="keyword">{</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span>
fpfstr <span class="keyword">=</span> getenv<span class="keyword">(</span>name<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> str2 <span class="keyword">=</span> strptr0_copy<span class="keyword">(</span>fpfstr<span class="dynexp"><span class="keyword">.1</span></span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> fpfstr<span class="dynexp"><span class="keyword">.0</span></span><span class="keyword">(</span>fpfstr<span class="dynexp"><span class="keyword">.1</span></span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">}</span></span> <span class="comment">(* end of [getenv_gc] *)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="extcode"><span class="extcode">%{$
//
extern
atstype_ptr
atslib_libats_libc_malloc_libc_exn
  (atstype_size bsz)
{
  void *p0 ;
  p0 = atslib_libats_libc_malloc_libc(bsz) ;
  if (!p0) {
    fprintf(stderr, "exit(ATSLIB): [malloc] failed\n") ; exit(1) ;
  } // end of [if]
  return p0 ;
} /* end of [atslib_libats_libc_malloc_libc_exn] */
//
%}</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">(* end of [stdlib.dats] *)</span>
</pre>
<pre class="patsyntax">
<span class="comment">(***********************************************************************)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(*                         Applied Type System                         *)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(***********************************************************************)</span>

<span class="comment">(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="comment">// Author: Hongwei Xi (gmhwxi AT gmail DOT com)</span>
<span class="comment">// Start Time: March, 2013</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">#define</span>
ATS_PACKNAME "ATSLIB.libats.libc"</span>
<span class="neuexp"><span class="keyword">#define</span>
ATS_DYNLOADFLAG 0</span> <span class="comment">// no dynloading at run-time</span>
<span class="neuexp"><span class="keyword">#define</span>
ATS_EXTERN_PREFIX
"atslib_libats_libc_"</span> <span class="comment">// prefix for external names</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="keyword">staload</span>
"libats/libc/SATS/string.sats"
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="extcode"><span class="extcode">%{$
extern
atstype_ptr
atslib_libats_libc_strerror_r_gc
(
  atstype_int errnum
) {
  char *p_err ;
  int bsz ;
  int myerr, myeno ;
//
// HX: [64] is chosen nearly randomly
//
  bsz = 64 ;
  p_err = (char*)0 ;
//
  while (1)
  {
    p_err = atspre_malloc_gc(bsz) ;
    myerr = atslib_libats_libc_strerror_r(errnum, p_err, bsz) ; myeno = errno ;
    if (!myerr) return p_err ;
    if (myeno != ERANGE) break ;
    atspre_mfree_gc(p_err) ; bsz = 2 * bsz ;
  }
//
  return p_err ;
//
} /* end of [atslib_libats_libc_strerror_r_gc] */
%}</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">(* end of [string.dats] *)</span>
</pre>
<pre class="patsyntax">
<span class="comment">(***********************************************************************)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(*                         Applied Type System                         *)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(***********************************************************************)</span>

<span class="comment">(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="comment">// Author: Hongwei Xi (gmhwxi AT gmail DOT com)</span>
<span class="comment">// Start Time: March, 2013</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">#define</span>
ATS_PACKNAME "ATSLIB.libats.libc"</span>
<span class="neuexp"><span class="keyword">#define</span>
ATS_DYNLOADFLAG 0</span> <span class="comment">// no need for dynloading at run-time</span>
<span class="neuexp"><span class="keyword">#define</span>
ATS_EXTERN_PREFIX "atslib_libats_libc_"</span> <span class="comment">// prefix for external names</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="extcode"><span class="extcode">%{^
#include"share/H/pats_atslib.h"
%}</span></span> <span class="comment">// end of [%{^]</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="keyword">staload</span> "libats/libc/SATS/errno.sats"
<span class="keyword">staload</span> "libats/libc/SATS/fcntl.sats"
<span class="keyword">staload</span> "libats/libc/SATS/unistd.sats"
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="extcode"><span class="extcode">%{$
extern
atsvoid_t0ype
atslib_libats_libc_close_exn
(
  atstype_int fd
) {
  int err ;
  err = atslib_libats_libc_close(fd) ;
  if (0 &gt; err) ATSLIBfailexit("close") ;
  return ;
} /* end of [atslib_libats_libc_close_exn] */
%}</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="extcode"><span class="extcode">%{$
extern
atstype_int
atslib_libats_libc_dup2_fildes
(
  atstype_int fd, atstype_int fd2
) {
  int flags ;
//
  flags = fcntl(fd, F_GETFD) ;
//
  if (flags &gt;= 0) {
    errno = EINVAL ; return -1 ; // [fd2] in use
  } /* end of [if] */
//
  return atslib_libats_libc_dup2(fd, fd2) ;
//
} /* end of [atslib_libats_libc_dup2_fildes] */
%}</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="extcode"><span class="extcode">%{$
extern
atstype_strptr
atslib_libats_libc_getcwd_gc (
) {
  char *p_cwd ;
  int bsz ;
  int myeno ;
  char *p2_cwd ;
//
// HX: [64] is chosen nearly randomly
//
  bsz = 64 ;
  p_cwd = (char*)0 ;
//
  while (1)
  {
    p_cwd = atspre_malloc_gc(bsz) ;
    p2_cwd = atslib_libats_libc_getcwd(p_cwd, bsz) ; myeno = errno ;
    if (p2_cwd != 0) return p_cwd ; else atspre_mfree_gc(p_cwd) ;
    if (myeno != ERANGE) break ;
    bsz = 2 * bsz ;
  }
//
  return (char*)0 ;
//
} /* end of [atslib_libats_libc_getcwd_gc] */
%}</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="extcode"><span class="extcode">%{$
extern
atstype_strptr
atslib_libats_libc_getlogin_r_gc (
) {
  char *p_uid ;
  int bsz ;
  int err, myeno ;
//
// HX: [16] is chosen nearly randomly
//
  bsz = 16 ;
  p_uid = (char*)0 ;
//
  while (1)
  {
    p_uid = atspre_malloc_gc(bsz) ;
    err = atslib_libats_libc_getlogin_r(p_uid, bsz) ; myeno = errno ;
    if (err==0) return p_uid ; else atspre_mfree_gc(p_uid) ;
    if (myeno != ERANGE) break ;
    bsz = 2 * bsz ;
  }
//
  return (char*)0 ;
//
} /* end of [atslib_libats_libc_getlogin_r_gc] */
%}</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="extcode"><span class="extcode">%{$
extern
atsvoid_t0ype
atslib_libats_libc_rmdir_exn
(
  atstype_string path
) {
  int err ;
  err = atslib_libats_libc_rmdir(path) ;
  if (0 &gt; err) ATSLIBfailexit("rmdir") ;
  return ;
} /* end of [atslib_libats_libc_rmdir_exn] */
%}</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="extcode"><span class="extcode">%{$
extern
atsvoid_t0ype
atslib_libats_libc_link_exn
(
  atstype_string old, atstype_string new
) {
  int err ;
  err = atslib_libats_libc_link(old, new) ;
  if (0 &gt; err) ATSLIBfailexit("link") ;
  return ;
} /* end of [atslib_libats_libc_link_exn] */
%}</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="extcode"><span class="extcode">%{$
extern
atsvoid_t0ype
atslib_libats_libc_unlink_exn
(
  atstype_string path
) {
  int err ;
  err = atslib_libats_libc_unlink(path) ;
  if (0 &gt; err) ATSLIBfailexit("unlink") ;
  return ;
} /* end of [atslib_libats_libc_unlink_exn] */
%}</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="extcode"><span class="extcode">%{$
extern
atsvoid_t0ype
atslib_libats_libc_symlink_exn
(
  atstype_string old, atstype_string new
) {
  int err ;
  err = atslib_libats_libc_symlink(old, new) ;
  if (0 &gt; err) ATSLIBfailexit("symlink") ;
  return ;
} /* end of [atslib_libats_libc_symlink_exn] */
%}</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="extcode"><span class="extcode">%{$
extern
atstype_strptr
atslib_libats_libc_readlink_gc
(
  atstype_string path
) {
  char *bfp ;
//
// HX: [64] is chosen nearly randomly
//
  int bsz = 64 ;
  ssize_t bsz2 ;
  bfp = (char*)0 ;
//
  while (1)
  {
    bfp = atspre_malloc_gc(bsz) ;
    bsz2 = atslib_libats_libc_readlink(path, bfp, bsz) ;
/*
    fprintf(stderr, "atslib_libats_libc_readlink_gc: bsz2 = %li\n", bsz2) ;
*/
    if (bsz2 &lt; 0) {
      atspre_mfree_gc(bfp) ; break ;
    }
    if (bsz2 &lt; bsz) {
      bfp[bsz2] = '\000' ; return bfp ;
    }
    atspre_mfree_gc(bfp) ; bsz *= 2 ;
  }
//
  return (char*)0 ; // HX: deadcode
//
} /* end of [atslib_libats_libc_readlink_gc] */
%}</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">(* end of [unistd.dats] *)</span>
</pre>
<!--php-->

</body>
</html>
