(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: May, 2012
//
(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

staload "libc/SATS/stdlib.sats"

(* ****** ****** *)

implement{
} getenv_gc
  (name) = let
  val fpfstr = getenv (name)
  val str2 = strptr0_copy (fpfstr.1)
  prval () = fpfstr.0 (fpfstr.1)
in
  str2
end // end of [getenv_gc]

(* ****** ****** *)

%{
extern
atstype_ptr
atslib_malloc_libc_exn
  (atstype_size bsz)
{
  void *p ;
  p = atslib_malloc_libc(bsz) ;
  if (!p) {
    fprintf(stderr, "exit(ATSLIB): [malloc] failed\n") ; exit(1) ;
  } // end of [if]
  return p ;
} /* end of [atslib_malloc_libc_exn] */
%}

(* ****** ****** *)

(* end of [stdlib.dats] *)(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: May, 2012
//
(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

staload "libc/SATS/stdio.sats"

(* ****** ****** *)

%{
extern
atstype_ptr
atslib_fopen_exn
(
  atstype_string path
, atstype_string mode
) {
  FILE *filp ;
  filp = fopen ((char*)path, (char*)mode) ;
  if (!filp) ATSLIBfailexit("fopen") ; // HX: failure
  return filp ;
} /* end of [atslib_fopen_exn] */
%}

(* ****** ****** *)

%{
extern
atsvoid_t0ype
atslib_fclose_exn
  (atstype_ptr filp) {
  int err ;
  err = fclose ((FILE*)filp) ;
  if (0 > err) ATSLIBfailexit("fclose") ;
  return ;
} /* end of [atslib_fclose_exn] */
%}

(* ****** ****** *)

%{
extern
atsvoid_t0ype
atslib_fflush_exn
(
  atstype_ptr filp
) {
  int err = fflush((FILE*)filp) ;
  if (0 > err) ATSLIBfailexit("fflush") ;
  return ;
} /* end of [atslib_fflush_exn] */
%}

(* ****** ****** *)

%{
extern
atsvoid_t0ype
atslib_fputc_exn
(
  atstype_int c, atstype_ptr filp
) {
  int err ;
  err = fputc(c, (FILE*)filp) ;
  if (0 > err) {
    ATSLIBfailexit("fputc") ; // abnormal exit
  } // end of [if]
  return ;  
} /* end of [atslib_fputc_exn] */
%}

(* ****** ****** *)

%{
extern
atsvoid_t0ype
atslib_fgets_exn
(
  atstype_ptr buf0
, atstype_int bsz0
, atstype_ptr filp
) {
  char *buf, *pres ;
  buf = (char*)buf0 ;
  pres = fgets(buf, (int)bsz0, (FILE*)filp) ;
  if (!pres)
  {
    if (feof((FILE*)filp))
    {
      buf[0] = '\000' ; // EOF is reached
    } else {
      ATSLIBfailexit("fgets") ; // abnormal exit
    } // end of [if]
  } // end of [if]
  return ;  
} /* end of [atslib_fgets_exn] */
%}

(* ****** ****** *)

%{
extern
atstype_ptr
atslib_fgets_gc
(
  atstype_int bsz0
, atstype_ptr filp0
)
{
  int bsz = bsz0 ;
  FILE *filp = (FILE*)filp0 ;
  int ofs = 0, ofs2 ;
  char *buf, *buf2, *pres ;
  buf = atspre_malloc_gc(bsz) ;
  while (1) {
    buf2 = buf+ofs ;
    pres = fgets(buf2, bsz-ofs, filp) ;
    if (!pres)
    {
      if (feof(filp))
      {
        *buf2 = '\000' ; return buf ;
      } else {
        atspre_mfree_gc(buf) ; return (char*)0 ;
      } // end of [if]
    }
    ofs2 = strlen(buf2) ;
    if (ofs2==0) return buf ;
    ofs += ofs2 ; // HX: ofs > 0
    if (buf[ofs-1]=='\n') return buf ;
    bsz *= 2 ; buf2 = buf ;
    buf = atspre_malloc_gc(bsz) ;
    memcpy(buf, buf2, ofs) ;
    atspre_mfree_gc(buf2) ;
  } // end of [while]
  return buf ; // HX: deadcode
} /* end of [atslib_fgets_gc] */
%}

(* ****** ****** *)

%{
extern
atsvoid_t0ype
atslib_fputs_exn
(
  atstype_string str, atstype_ptr filp
) {
  int err ;
  err = fputs((char*)str, (FILE*)filp) ;
  if (0 > err) {
    ATSLIBfailexit("fputs") ; // abnormal exit
  } // end of [if]
  return ;  
} /* end of [atslib_fputs_exn] */
%}

(* ****** ****** *)

%{
extern
atsvoid_t0ype
atslib_puts_exn
(
  atstype_string str
) {
  int err ;
  err = puts((char*)str) ;
  if (0 > err) {
    ATSLIBfailexit("puts") ; // abnormal exit
  } // end of [if]
  return ;  
} /* end of [atslib_puts_exn] */
%}

(* ****** ****** *)

%{
extern
atstype_ptr
atslib_popen_exn
(
  atstype_string cmd
, atstype_string type
) {
  FILE *filp ;
  filp = popen((char*)cmd, (char*)type) ;
  if (!filp) {
    ATSLIBfailexit("popen") ; // abnormal exit
  } // end of [if]
  return filp ;
} /* end of [atslib_popen_exn] */
%}

(* ****** ****** *)

%{
extern
atstype_int
atslib_pclose_exn
(
  atstype_ptr filp
) {
  int res ;
  res = pclose((FILE*)filp) ;
  if (0 > res) {
    ATSLIBfailexit("pclose") ; // abnormal exit
  } // end of [if]
  return res ;
} /* end of [atslib_pclose_exn] */
%}

(* ****** ****** *)

%{
extern
atstype_ptr
atslib_tmpfile_exn(
) {
  FILE *filp = tmpfile() ;
  if (!filp) ATSLIBfailexit("tmpfile") ;
  return (filp) ;
} /* end of [atslib_tmpfile_exn] */
%}

(* ****** ****** *)

(* end of [stdio.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: March, 2013
//
(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

staload "libc/SATS/string.sats"

(* ****** ****** *)

%{
extern
atstype_ptr
atslib_strerror_r_gc
(
  atstype_int errnum
) {
  char *p_err ;
  int bsz ;
  int err, myeno ;
//
// HX: [64] is chosen nearly randomly
//
  bsz = 64 ;
  p_err = (char*)0 ;
//
  while (1)
  {
    p_err = atspre_malloc_gc(bsz) ;
    err = atslib_strerror_r(errnum, p_err, bsz) ; myeno = errno ;
    if (err==0) return p_err ;
    if (myeno != ERANGE) break ;
    atspre_mfree_gc(p_err) ; bsz = 2 * bsz ;
  }
//
  return p_err ;
//
} /* end of [atslib_strerror_r_gc] */
%}

(* ****** ****** *)

(* end of [string.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: May, 2012
//
(* ****** ****** *)

#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libc/SATS/time.sats"

(* ****** ****** *)

implement{
} ctime_r_gc (tval) = let
//
val bsz = g1i2u (CTIME_BUFSZ)
val (pf, pfgc | p) = malloc_gc (bsz)
//
val p1 = ctime_r (pf | tval, p)
//
in
//
if p1 > 0 then let
  prval ctime_v_succ (pf) = pf
in
  $UN.castvwtp0{Strptr1}((pf, pfgc | p))
end else let
  prval ctime_v_fail (pf) = pf
  val () = mfree_gc (pf, pfgc | p)
in
  strptr_null ()
end // end of [if]
//
end // end of [ctime_r_gc]

(* ****** ****** *)

(* end of [stdlib.dats] *)(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: October, 2014
//
(* ****** ****** *)

#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

staload "libc/SATS/float.sats"

(* ****** ****** *)

(* end of [float.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: March, 2013
//
(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

staload "libc/SATS/math.sats"

(* ****** ****** *)

implement isfinite<float> = isfinite_float
implement isfinite<double> = isfinite_double
implement isfinite<ldouble> = isfinite_ldouble

implement isnormal<float> = isnormal_float
implement isnormal<double> = isnormal_double
implement isnormal<ldouble> = isnormal_ldouble

implement fpclassify<float> = fpclassify_float
implement fpclassify<double> = fpclassify_double
implement fpclassify<ldouble> = fpclassify_ldouble

(* ****** ****** *)
//
implement isinf<float> = isinf_float
implement isinf<double> = isinf_double
implement isinf<ldouble> = isinf_ldouble
//
implement isnan<float> = isnan_float
implement isnan<double> = isnan_double
implement isnan<ldouble> = isnan_ldouble
//
(* ****** ****** *)

implement ceil<float> = ceil_float
implement ceil<double> = ceil_double
implement ceil<ldouble> = ceil_ldouble

(* ****** ****** *)

implement floor<float> = floor_float
implement floor<double> = floor_double
implement floor<ldouble> = floor_ldouble

(* ****** ****** *)

implement round<float> = round_float
implement round<double> = round_double
implement round<ldouble> = round_ldouble

(* ****** ****** *)

implement trunc<float> = trunc_float
implement trunc<double> = trunc_double
implement trunc<ldouble> = trunc_ldouble

(* ****** ****** *)

implement fmod<float> = fmod_float
implement fmod<double> = fmod_double
implement fmod<ldouble> = fmod_ldouble

(* ****** ****** *)
//
implement fmax<float> = fmax_float
implement fmax<double> = fmax_double
implement fmax<ldouble> = fmax_ldouble
//
implement fmin<float> = fmin_float
implement fmin<double> = fmin_double
implement fmin<ldouble> = fmax_ldouble
//
(* ****** ****** *)

implement fdim<float> = fdim_float
implement fdim<double> = fdim_double
implement fdim<ldouble> = fdim_ldouble

(* ****** ****** *)

implement fma<float> = fma_float
implement fma<double> = fma_double
implement fma<ldouble> = fma_ldouble

(* ****** ****** *)
//
implement sqrt<float> = sqrt_float
implement sqrt<double> = sqrt_double
implement sqrt<ldouble> = sqrt_ldouble
//
implement cbrt<float> = cbrt_float
implement cbrt<double> = cbrt_double
implement cbrt<ldouble> = cbrt_ldouble
//
(* ****** ****** *)

implement pow<float> = pow_float
implement pow<double> = pow_double
implement pow<ldouble> = pow_ldouble

(* ****** ****** *)

implement exp<float> = exp_float
implement exp<double> = exp_double
implement exp<ldouble> = exp_ldouble

(* ****** ****** *)

implement log<float> = log_float
implement log<double> = log_double
implement log<ldouble> = log_ldouble
implement log10<float> = log10_float
implement log10<double> = log10_double
implement log10<ldouble> = log10_ldouble

(* ****** ****** *)
//
implement sin<float> = sin_float
implement sin<double> = sin_double
implement sin<ldouble> = sin_ldouble
//
implement cos<float> = cos_float
implement cos<double> = cos_double
implement cos<ldouble> = cos_ldouble
//
implement tan<float> = tan_float
implement tan<double> = tan_double
implement tan<ldouble> = tan_ldouble
//
(* ****** ****** *)
//
implement asin<float> = asin_float
implement asin<double> = asin_double
implement asin<ldouble> = asin_ldouble
//
implement acos<float> = acos_float
implement acos<double> = acos_double
implement acos<ldouble> = acos_ldouble
//
implement atan<float> = atan_float
implement atan<double> = atan_double
implement atan<ldouble> = atan_ldouble
//
implement atan2<float> = atan2_float
implement atan2<double> = atan2_double
implement atan2<ldouble> = atan2_ldouble
//
(* ****** ****** *)
//
implement sinh<float> = sinh_float
implement sinh<double> = sinh_double
implement sinh<ldouble> = sinh_ldouble
//
implement cosh<float> = cosh_float
implement cosh<double> = cosh_double
implement cosh<ldouble> = cosh_ldouble
//
implement tanh<float> = tanh_float
implement tanh<double> = tanh_double
implement tanh<ldouble> = tanh_ldouble
//
(* ****** ****** *)
//
implement asinh<float> = asinh_float
implement asinh<double> = asinh_double
implement asinh<ldouble> = asinh_ldouble
//
implement acosh<float> = acosh_float
implement acosh<double> = acosh_double
implement acosh<ldouble> = acosh_ldouble
//
implement atanh<float> = atanh_float
implement atanh<double> = atanh_double
implement atanh<ldouble> = atanh_ldouble
//
(* ****** ****** *)

(* end of [math.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: March, 2013
//
(* ****** ****** *)

#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

staload "libc/SATS/fcntl.sats"

(* ****** ****** *)

%{
extern
atstype_int
atslib_fildes_iget_int
(
  atstype_int fd
) {
  int flags ;
  flags = fcntl (fd, F_GETFD) ;
  if (flags < 0) return -1 ; // [fd2] not in use
  return fd ;
} // end of [atslib_fildes_iget_int]
%}

(* ****** ****** *)

(* end of [fcntl.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: March, 2013
//
(* ****** ****** *)

#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libc/SATS/dirent.sats"

(* ****** ****** *)

implement{}
dirent$PC_NAME_MAX ((*void*)) = 256

(* ****** ****** *)

implement{}
dirent_get_d_name_gc
  (ent) = let
//
val (
  fpf | str
) = dirent_get_d_name (ent)
val str2 = strptr1_copy (str)
prval () = fpf (str)
//
in
  str2
end // end of [dirent_get_d_name_gc]

implement{}
direntp_get_d_name_gc
  (entp) = let
//
val (
  pf, fpf | p
) = direntp_get_viewptr (entp)
val str2 = dirent_get_d_name_gc<> (!p)
prval () = minus_addback (fpf, pf | entp)
//
in
  str2
end // end of [direntp_get_d_name_gc]

(* ****** ****** *)

implement{}
compare_dirent_string
  (ent1, str2) = let
//
val
(
  fpf1 | str1
) = dirent_get_d_name (ent1)
val sgn = compare_string_string ($UN.strptr2string(str1), str2)
prval () = fpf1 (str1)
//
in
  sgn
end // end of [compare_dirent_string]

(* ****** ****** *)

%{
extern
atstype_ptr
atslib_opendir_exn
(
  atstype_string dname
) {
  DIR *dirp ;
  dirp = opendir((char*)dname) ;
  if (!dirp) ATSLIBfailexit("opendir") ;
  return dirp ; // [opendir] succeeded
} // end of [atslib_opendir_exn]
%}

(* ****** ****** *)

%{
extern
atsvoid_t0ype
atslib_closedir_exn
(
  atstype_ptr dirp
) {
  int err = closedir((DIR*)dirp) ;
  if (err < 0) ATSLIBfailexit("closedir") ;
  return ; // [closedir] succeeded
} // end of [atslib_closedir_exn]
%}

(* ****** ****** *)

implement
{}(*tmp*)
readdir_r_gc
  (dirp) = let
//
val ofs = $extfcall
(
  Size_t
, "offsetof"
, $extval (int, "atslib_dirent_type")
, $extval (int, "d_name")
)
//
val bsz = ofs + i2sz(dirent$PC_NAME_MAX()+1)
val [l:addr] (pf, pfgc | p) = malloc_gc (bsz)
prval pf = $UN.castview0{(dirent?)@l}(pf)
var res: ptr
val err = readdir_r (dirp, !p, res)
//
in
//
if res > 0 then
  $UN.castvwtp0{Direntp1}@(pf, pfgc | p)
else let
  prval () = opt_clear{dirent}(!p)
  val () = ptr_free{dirent?}(pfgc, pf | p)
in
  $UN.castvwtp0{Direntp0}(the_null_ptr)
end (* end of [if] *)
//
end // end of [readdir_r_gc]

(* ****** ****** *)

(* end of [dirent.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: January, 2014
//
(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

staload "libc/SATS/errno.sats"

(* ****** ****** *)

(* end of [errno.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: March, 2013
//
(* ****** ****** *)

#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

staload "libc/SATS/strings.sats"

(* ****** ****** *)
//
// HX-2013-03: it is still empty
//
(* ****** ****** *)

(* end of [strings.dats] *)(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: May, 2014
//
(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

staload "libc/SATS/alloca.sats"

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

(*
implement
ptr_alloca_tsz
  {a}{dummy}
  (pf | tsz) = let
//
val [l:addr]
  (pfat, fpfat | p) = alloca (pf | tsz)
//
prval pfat =
  $UN.castview0{(a?)@l}(pfat)
prval fpfat =
  $UN.castview0{(a?)@l->void@dummy}(fpfat)
//
in
  (pfat, fpfat | p)
end // end of [ptr_alloca_tsz]
*)

(* ****** ****** *)

(*
implement
array_ptr_alloca_tsz
  {a}{dummy}{n}
  (pf | asz, tsz) = let
//
val [l:addr]
  (pfat, fpfat | p) = alloca (pf | asz*tsz)
//
prval pfat =
  $UN.castview0{array(a?,n)@l}(pfat)
prval fpfat =
  $UN.castview0{array(a?,n)@l->void@dummy}(fpfat)
//
in
  (pfat, fpfat | p)
end // end of [array_ptr_alloca_tsz]
*)

(* ****** ****** *)

(* end of [alloca.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: March, 2013
//
(* ****** ****** *)

#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

staload "libc/SATS/errno.sats"
staload "libc/SATS/fcntl.sats"
staload "libc/SATS/unistd.sats"

(* ****** ****** *)

%{
extern
atsvoid_t0ype
atslib_close_exn
(
  atstype_int fd
) {
  int err ;
  err = atslib_close(fd) ;
  if (0 > err) ATSLIBfailexit("close") ;
  return ;
} /* end of [atslib_close_exn] */
%}

(* ****** ****** *)

%{
extern
atstype_int
atslib_dup2_fildes
(
  atstype_int fd, atstype_int fd2
) {
  int flags ;
//
  flags = fcntl(fd, F_GETFD) ;
//
  if (flags >= 0) {
    errno = EINVAL ; return -1 ; // [fd2] in use
  } /* end of [if] */
//
  return atslib_dup2(fd, fd2) ;
//
} /* end of [atslib_dup2_fildes] */
%}

(* ****** ****** *)

%{
extern
atstype_strptr
atslib_getcwd_gc (
) {
  char *p_cwd ;
  int bsz ;
  int myeno ;
  char *p2_cwd ;
//
// HX: [64] is chosen nearly randomly
//
  bsz = 64 ;
  p_cwd = (char*)0 ;
//
  while (1)
  {
    p_cwd = atspre_malloc_gc(bsz) ;
    p2_cwd = atslib_getcwd(p_cwd, bsz) ; myeno = errno ;
    if (p2_cwd != 0) return p_cwd ; else atspre_mfree_gc(p_cwd) ;
    if (myeno != ERANGE) break ;
    bsz = 2 * bsz ;
  }
//
  return (char*)0 ;
//
} /* end of [atslib_getcwd_gc] */
%}

(* ****** ****** *)

%{
extern
atstype_strptr
atslib_getlogin_r_gc (
) {
  char *p_uid ;
  int bsz ;
  int err, myeno ;
//
// HX: [16] is chosen nearly randomly
//
  bsz = 16 ;
  p_uid = (char*)0 ;
//
  while (1)
  {
    p_uid = atspre_malloc_gc(bsz) ;
    err = atslib_getlogin_r(p_uid, bsz) ; myeno = errno ;
    if (err==0) return p_uid ; else atspre_mfree_gc(p_uid) ;
    if (myeno != ERANGE) break ;
    bsz = 2 * bsz ;
  }
//
  return (char*)0 ;
//
} /* end of [atslib_getlogin_r_gc] */
%}

(* ****** ****** *)

%{
extern
atsvoid_t0ype
atslib_rmdir_exn
(
  atstype_string path
) {
  int err ;
  err = atslib_rmdir(path) ;
  if (0 > err) ATSLIBfailexit("rmdir") ;
  return ;
} /* end of [atslib_rmdir_exn] */
%}

(* ****** ****** *)

%{
extern
atsvoid_t0ype
atslib_link_exn
(
  atstype_string old, atstype_string new
) {
  int err ;
  err = atslib_link(old, new) ;
  if (0 > err) ATSLIBfailexit("link") ;
  return ;
} /* end of [atslib_link_exn] */
%}

(* ****** ****** *)

%{
extern
atsvoid_t0ype
atslib_unlink_exn
(
  atstype_string path
) {
  int err ;
  err = atslib_unlink(path) ;
  if (0 > err) ATSLIBfailexit("unlink") ;
  return ;
} /* end of [atslib_unlink_exn] */
%}

(* ****** ****** *)

%{
extern
atsvoid_t0ype
atslib_symlink_exn
(
  atstype_string old, atstype_string new
) {
  int err ;
  err = atslib_symlink(old, new) ;
  if (0 > err) ATSLIBfailexit("symlink") ;
  return ;
} /* end of [atslib_symlink_exn] */
%}

(* ****** ****** *)

%{
extern
atstype_strptr
atslib_readlink_gc
(
  atstype_string path
) {
  char *bfp ;
//
// HX: [64] is chosen nearly randomly
//
  int bsz = 64 ;
  ssize_t bsz2 ;
  bfp = (char*)0 ;
//
  while (1)
  {
    bfp = atspre_malloc_gc(bsz) ;
    bsz2 = atslib_readlink(path, bfp, bsz) ;
/*
    fprintf(stderr, "atslib_readlink_gc: bsz2 = %li\n", bsz2) ;
*/
    if (bsz2 < 0) {
      atspre_mfree_gc(bfp) ; break ;
    }
    if (bsz2 < bsz) {
      bfp[bsz2] = '\000' ; return bfp ;
    }
    atspre_mfree_gc(bfp) ; bsz *= 2 ;
  }
//
  return (char*)0 ; // HX: deadcode
//
} /* end of [atslib_readlink_gc] */
%}

(* ****** ****** *)

(* end of [unistd.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: April, 2014
//
(* ****** ****** *)

%{#
#include "libc/sys/CATS/types.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_DYNLOADFLAG 0 // no need for staloading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)
//
// HX-2014-04-29: it is still empty
//
(* ****** ****** *)

(* end of [types.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: November, 2014
//
(* ****** ****** *)

%{#
#include "libc/sys/CATS/socket.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_DYNLOADFLAG 0 // no need for staloading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

staload "libc/sys/SATS/socket.sats"

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

%{
ATSextern()
atstype_int
atslib_socket_AF_type_exn
(
  sa_family_t af, atstype_int tp
) {
  int
  fildes;
  fildes = socket(af, tp, 0);
  if(0 > fildes) ATSLIBfailexit("socket") ; // HX: failure
  return fildes;
} // end of [atslib_socket_AF_type_exn]
%} // end of [%{]

(* ****** ****** *)

%{
ATSextern()
atsvoid_t0ype
atslib_bind_exn
(
  atstype_int fd
, atstype_ptr addr, socklen_t addrlen
) {
  int
  err;
  err = bind(fd, addr, addrlen);
  if(0 > err) ATSLIBfailexit("bind") ; // HX: failure
  return;
} // end of [atslib_bind_exn]
%} // end of [%{]

(* ****** ****** *)

%{
ATSextern()
atsvoid_t0ype
atslib_listen_exn
(
  atstype_int fd, atstype_int nq
) {
  int
  err;
  err = listen(fd, nq);
  if(0 > err) ATSLIBfailexit("listen") ; // HX: failure
  return;
} // end of [atslib_listen_exn]
%} // end of [%{]

(* ****** ****** *)

%{
ATSextern()
atsvoid_t0ype
atslib_connect_exn
(
  atstype_int fd
, atstype_ptr addr, socklen_t addrlen
) {
  int
  err;
  err = connect(fd, addr, addrlen);
  if(0 > err) ATSLIBfailexit("connect") ; // HX: failure
  return;
} // end of [atslib_connect_exn]
%} // end of [%{]

(* ****** ****** *)

%{
ATSextern()
atsvoid_t0ype
atslib_socket_close_exn
(
  atstype_int fd
) {
  int
  err;
  err = close(fd);
  if(0 > err) ATSLIBfailexit("socket_close") ; // HX: failure
  return;
} // end of [atslib_socket_close_exn]
%} // end of [%{]

(* ****** ****** *)

%{
ATSextern()
atsvoid_t0ype
atslib_shutdown_exn
(
  atstype_int fd, atstype_int how
) {
  int
  err;
  err = shutdown(fd, how);
  if(0 > err) ATSLIBfailexit("shutdown") ; // HX: failure
  return;
} // end of [atslib_shutdown_exn]
%} // end of [%{]

(* ****** ****** *)

(* end of [socket.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: April, 2014
//
(* ****** ****** *)

%{#
#include "libc/sys/CATS/stat.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_DYNLOADFLAG 0 // no need for staloading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

staload "libc/sys/SATS/stat.sats"

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

implement
{(*tmp*)}
mkdirp (path, mode) = let
//
#define NUL '\000'
val dirsep = dirsep_get<> ()
//
fun auxmk
(
  path: string, mode: mode_t
) : int = let
  var st: stat?
  val ret = stat (path, st)
  prval () = opt_clear{stat}(st)
in
  if ret < 0 then mkdir (path, mode) else 0(*isexi*)
end // end of [auxmk]
//
fnx loop
  (p0: ptr, p1: ptr): int = let
  val c = $UN.ptr0_get<char> (p1)
in
//
if (
c != NUL
) then (
  if c = dirsep
    then loop2 (p0, p1) else loop (p0, ptr_succ<char> (p1))
  // end of [if]
) else (
  auxmk ($UN.cast{string}(p0), mode)
) (* end of [if] *)
//
end // end of [loop]
//
and loop2
  (p0: ptr, p1: ptr): int = let
  val () = $UN.ptr0_set<char> (p1, NUL)
  val ret = auxmk ($UN.cast{string}(p0), mode)
  val () = $UN.ptr0_set<char> (p1, dirsep)
in
  if ret >= 0 then loop (p0, ptr_succ<char> (p1)) else ret
end // end of [loop2]
//
val path = string0_copy (path)
//
val p0 = $UN.castvwtp1{ptr}(path)
//
val c0 = $UN.ptr0_get<char> (p0)
val ret =
(
if (
c0 != NUL
) then (
  if c0 = dirsep
    then loop (p0, ptr_succ<char> (p0)) else loop (p0, p0)
  // end of [if]
) else (0)
) : int // end of [val]
//
val ((*freed*)) = strptr_free (path)
//
in
  ret
end // end of [mkdirp]

(* ****** ****** *)

(* end of [stat.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: November, 2014
//
(* ****** ****** *)

%{#
#include "libc/sys/CATS/socket_in.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_DYNLOADFLAG 0 // no need for staloading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

staload "libc/sys/SATS/socket_in.sats"

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

%{
ATSextern()
atsvoid_t0ype
atslib_bind_in_exn
(
  atstype_int fd, atstype_ptr addr
) {
  int
  err;
  err =
  bind(
    fd, (const struct sockaddr*)addr, sizeof(struct sockaddr_in)
  ); // end of [connent]
  if(0 > err) ATSLIBfailexit("bind");
  return;
} // end of [atslib_bind_in_exn]
%} // end of [%{]

(* ****** ****** *)

%{
ATSextern()
atsvoid_t0ype
atslib_connect_in_exn
(
  atstype_int fd, atstype_ptr addr
) {
  int
  err;
  err =
  connect(
    fd, (const struct sockaddr*)addr, sizeof(struct sockaddr_in)
  ); // end of [connent]
  if(0 > err) ATSLIBfailexit("connect");
  return;
} // end of [atslib_connect_in_exn]
%} // end of [%{]

(* ****** ****** *)

(* end of [socket_in.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: March, 2013
//
(* ****** ****** *)

%{#
#include "libc/sys/CATS/stat.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

#define NSH (x) x // for commenting: no sharing
#define SHR (x) x // for commenting: it is shared

(* ****** ****** *)

staload
TYPES = "libc/sys/SATS/types.sats"

(* ****** ****** *)
//
typedef dev_t = $TYPES.dev_t
typedef ino_t = $TYPES.ino_t
typedef mode_t = $TYPES.mode_t
typedef nlink_t = $TYPES.nlink_t
//
typedef uid_t = $TYPES.uid_t
typedef gid_t = $TYPES.gid_t
//
typedef off_t = $TYPES.off_t
//
typedef blkcnt_t = $TYPES.blkcnt_t
typedef blksize_t = $TYPES.blksize_t
//
typedef time_t = $TYPES.time_t
//
vtypedef
fildes (i:int) = $TYPES.fildes (i)
//
vtypedef Fildes = $TYPES.Fildes
vtypedef Fildes0 = $TYPES.Fildes0
//
(* ****** ****** *)
//
typedef
stat_struct =
$extype_struct"atslib_stat_struct" of
{
  st_dev= dev_t // device
, st_ino= ino_t // 32-bit file serial number
, st_mode= mode_t // file mode
, st_nlink= nlink_t // link count
, st_uid= uid_t // user ID of the file's owner
, st_gid= gid_t // group ID of the file's group
, st_rdev= dev_t // device number if device
, st_size= off_t // size of file in bytes
, st_blksize= blksize_t // optimal block size for I/O
, st_blocks= blkcnt_t // number 512-byte blocks allocated
, st_atime= time_t // time of last access
, st_mtime= time_t // time of last modification
, st_ctime= time_t // time of last status change
//
, _rest= undefined_t0ype // ...
//
} // end of [stat_struct]
typedef stat = stat_struct
//
(* ****** ****** *)

macdef S_IFMT = $extval (mode_t, "S_IFMT")
macdef S_IFBLK = $extval (mode_t, "S_IFBLK")
macdef S_IFCHR = $extval (mode_t, "S_IFCHR")
macdef S_IFDIR = $extval (mode_t, "S_IFDIR")
macdef S_IFIFO = $extval (mode_t, "S_IFIFO")
macdef S_IFLNK = $extval (mode_t, "S_IFLNK")
macdef S_IFREG = $extval (mode_t, "S_IFREG")
macdef S_IFSOCK = $extval (mode_t, "S_IFSOCK")

(* ****** ****** *)
//
macdef S_IRWXU = $extval (mode_t, "S_IRWXU")
macdef S_IRUSR = $extval (mode_t, "S_IRUSR")
macdef S_IWUSR = $extval (mode_t, "S_IWUSR")
macdef S_IXUSR = $extval (mode_t, "S_IXUSR")
//
macdef S_IRWXG = $extval (mode_t, "S_IRWXG")
macdef S_IRGRP = $extval (mode_t, "S_IRGRP")
macdef S_IWGRP = $extval (mode_t, "S_IWGRP")
macdef S_IXGRP = $extval (mode_t, "S_IXGRP")
//
macdef S_IRWXO = $extval (mode_t, "S_IRWXO")
macdef S_IROTH = $extval (mode_t, "S_IROTH")
macdef S_IWOTH = $extval (mode_t, "S_IWOTH")
macdef S_IXOTH = $extval (mode_t, "S_IXOTH")
//
macdef S_ISUID = $extval (mode_t, "S_ISUID")
macdef S_ISGID = $extval (mode_t, "S_ISGID")
macdef S_ISVTX = $extval (mode_t, "S_ISVTX")
//
(* ****** ****** *)
//
// HX: macros
//
fun S_ISBLK (m: mode_t): bool = "mac#%"
fun S_ISCHR (m: mode_t): bool = "mac#%"
fun S_ISDIR (m: mode_t): bool = "mac#%"
fun S_ISFIFO (m: mode_t): bool = "mac#%"
fun S_ISREG (m: mode_t): bool = "mac#%"
fun S_ISLNK (m: mode_t): bool = "mac#%"
fun S_ISSOCK (m: mode_t): bool = "mac#%"
//
(* ****** ****** *)
//
// HX: (0/1/-1 : false/true/error)
//
fun isfdtype (fildes: int, fdtype: mode_t): int
//
(* ****** ****** *)
//
fun chmod
  (path: NSH(string), mode: mode_t): int = "mac#%"
fun chmod_exn
  (path: NSH(string), mode: mode_t): void = "ext#%"
//
fun fchmod (fd: !Fildes0, mode: mode_t): int = "mac#%"
//
(* ****** ****** *)
//
fun mkdir
  (path: NSH(string), mode: mode_t): int = "mac#%"
fun mkdir_exn
  (path: NSH(string), mode: mode_t): void = "ext#%"
//
(* ****** ****** *)
//
// HX-2014-04: this one is like [mkdir -p]
//
fun{
} mkdirp
  (path: NSH(string), mode: mode_t): int = "mac#%"
//
(* ****** ****** *)
//
fun mkdirat
  (dirfd: int, path: NSH(string), mode: mode_t): int = "mac#%"
//
(* ****** ****** *)
//
fun mkfifo // 0/-1 : succ/fail // errno set
  (path: NSH(string), perm: mode_t): int = "mac#%"
//
(* ****** ****** *)
//
fun stat
(
  path: NSH(string), st: &stat? >> opt (stat, i==0)
) : #[i:int | i <= 0] int (i) = "mac#%"
fun stat_exn
  (path: NSH(string), st: &stat? >> stat): void = "ext#%"
//
(* ****** ****** *)
//
fun fstat
(
  fd: !Fildes0, st: &stat? >> opt (stat, i==0)
) : #[i:int | i <= 0] int (i) = "mac#%"
fun fstat_exn
  (fd: !Fildes0, st: &stat? >> stat): void = "ext#%"
//
(* ****** ****** *)
//
fun lstat
(
  path: NSH(string), st: &stat? >> opt (stat, i==0)
) : #[i:int | i <= 0] int (i) = "mac#%"
fun lstat_exn
  (path: NSH(string), st: &stat? >> stat): void = "ext#%"
//
(* ****** ****** *)

fun umask
  (mask_new: mode_t): mode_t(*old*)  = "mac#%"
// end of [umask]

(* ****** ****** *)

(* end of [stat.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: November, 2014
//
(* ****** ****** *)

%{#
#include "libc/sys/CATS/socket.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

#define NSH (x) x // for commenting: no sharing
#define SHR (x) x // for commenting: it is shared

(* ****** ****** *)

abst@ype
sa_family_t = $extype"sa_family_t"
//
// HX: these are the primary ones:
//
macdef AF_UNIX = $extval (sa_family_t, "AF_UNIX")
macdef AF_INET = $extval (sa_family_t, "AF_INET")
macdef AF_INET6 = $extval (sa_family_t, "AF_INET6")
macdef AF_UNSPEC = $extval (sa_family_t, "AF_UNSPEC")
//
macdef AF_LOCAL = $extval (sa_family_t, "AF_LOCAL")
macdef AF_FILE = $extval (sa_family_t, "AF_FILE")
macdef AF_AX25 = $extval (sa_family_t, "AF_AX25")
macdef AF_IPX = $extval (sa_family_t, "AF_IPX")
macdef AF_APPLETALK = $extval (sa_family_t, "AF_APPLETALK")
macdef AF_NETROM = $extval (sa_family_t, "AF_NETROM")
macdef AF_BRIDGE = $extval (sa_family_t, "AF_BRIDGE")
macdef AF_ATMPVC = $extval (sa_family_t, "AF_ATMPVC")
macdef AF_X25 = $extval (sa_family_t, "AF_X25")
macdef AF_ROSE = $extval (sa_family_t, "AF_ROSE")
macdef AF_DECnet = $extval (sa_family_t, "AF_DECnet")
macdef AF_NETBEUI = $extval (sa_family_t, "AF_NETBEUI")
macdef AF_SECURITY = $extval (sa_family_t, "AF_SECURITY")
macdef AF_KEY = $extval (sa_family_t, "AF_KEY")
macdef AF_NETLINK = $extval (sa_family_t, "AF_NETLINK")
macdef AF_ROUTE = $extval (sa_family_t, "AF_ROUTE")
macdef AF_PACKET = $extval (sa_family_t, "AF_PACKET")
macdef AF_ASH = $extval (sa_family_t, "AF_ASH")
macdef AF_ECONET = $extval (sa_family_t, "AF_ECONET")
macdef AF_ATMSVC = $extval (sa_family_t, "AF_ATMSVC")
macdef AF_RDS = $extval (sa_family_t, "AF_RDS")
macdef AF_SNA = $extval (sa_family_t, "AF_SNA")
macdef AF_IRDA = $extval (sa_family_t, "AF_IRDA")
macdef AF_PPPOX = $extval (sa_family_t, "AF_PPPOX")
macdef AF_WANPIPE = $extval (sa_family_t, "AF_WANPIPE")
macdef AF_LLC = $extval (sa_family_t, "AF_LLC")
macdef AF_CAN = $extval (sa_family_t, "AF_CAN")
macdef AF_TIPC = $extval (sa_family_t, "AF_TIPC")
macdef AF_BLUETOOTH = $extval (sa_family_t, "AF_BLUETOOTH")
macdef AF_IUCV = $extval (sa_family_t, "AF_IUCV")
macdef AF_RXRPC = $extval (sa_family_t, "AF_RXRPC")
macdef AF_ISDN = $extval (sa_family_t, "AF_ISDN")
macdef AF_PHONET = $extval (sa_family_t, "AF_PHONET")
macdef AF_IEEE802154 = $extval (sa_family_t, "AF_IEEE802154")
macdef AF_MAX = $extval (sa_family_t, "AF_MAX")
//
(* ****** ****** *)
//
abst@ype
sp_family_t = $extype"sp_family_t"
//
macdef PF_UNIX = $extval (sp_family_t, "PF_UNIX")
macdef PF_INET = $extval (sp_family_t, "PF_INET")
macdef PF_INET6 = $extval (sp_family_t, "PF_INET6")
//
(* ****** ****** *)
//
abst@ype
socktype_t = int
//
macdef SOCK_RAW = $extval (socktype_t, "SOCK_RAW")
macdef SOCK_RDM = $extval (socktype_t, "SOCK_RDM")
macdef SOCK_DCCP = $extval (socktype_t, "SOCK_DCCP")
macdef SOCK_DGRAM = $extval (socktype_t, "SOCK_DGRAM")
macdef SOCK_PACKET = $extval (socktype_t, "SOCK_PACKET")
macdef SOCK_STREAM = $extval (socktype_t, "SOCK_STREAM")
macdef SOCK_SEQPACKET = $extval (socktype_t, "SOCK_SEQPACKET")
//
(* ****** ****** *)
//
abst@ype
socklen_t(n:int) = $extype"socklen_t"
//
castfn
int2socklen
  : {n:nat} (int n) -<> socklen_t(n)
castfn
size2socklen
  : {n:int} (size_t n) -<> socklen_t(n)
//
(* ****** ****** *)

stacst socklen_max : int // HX: sockaddr length

(* ****** ****** *)
//
abst@ype
sockaddr_struct(n:int) = $extype"sockaddr_struct"
stadef SA = sockaddr_struct
//
(* ****** ****** *)
//
// HX:
// client: init -> connect
// server:
// init -> bind -> listen -> accept
//
datasort
status =
| init | conn | bind | listen
//
absview socket_v (int, status)
//
(* ****** ****** *)
  
fun
socket_AF_type
(
  af: sa_family_t, st: socktype_t
) : [fd:int]
(
  option_v (socket_v (fd, init), fd >= 0) | int fd
) = "mac#%" // end-of-function
  
fun
socket_AF_type_exn
(
  af: sa_family_t, st: socktype_t
) : [fd:nat] (socket_v(fd, init) | int fd) = "ext#%"

(* ****** ****** *)  
//
dataview
bind_v
  (fd:int, int) = 
  | bind_v_succ (fd,  0) of socket_v (fd, bind)
  | bind_v_fail (fd, ~1) of socket_v (fd, init)
// end of [bind_v]
//
fun
bind_err
  {fd:int}{n:int}
(
  pf: socket_v (fd, init)
| fd: int fd, sockaddr: &SA(n), salen: socklen_t(n)
) : [i:int] (bind_v (fd, i) | int i) = "mac#%"
//
fun
bind_exn
  {fd:int}{n:int}
(
  pf: !socket_v(fd, init) >> socket_v(fd, bind)
| fd: int fd, sockaddr: &SA(n), salen: socklen_t(n)
) : void = "exn#%" // end of [bind_exn]
//
(* ****** ****** *)
//
dataview
listen_v
  (fd:int, int) = 
  | listen_v_succ (fd,  0) of socket_v (fd, listen)
  | listen_v_fail (fd, ~1(*err*)) of socket_v (fd, bind) 
// end of [listen_v]
//
fun
listen_err
  {fd:int}
(
  pf: socket_v(fd, bind)
| fd: int fd, backlog: intGt(0)
) : [i:int] (listen_v (fd, i) | int i) = "mac#%"
//
fun
listen_exn {fd:int}
(
  pf: !socket_v(fd, bind) >> socket_v(fd, listen)
| fd: int fd, backlog: intGt(0)
) : void = "ext#%" // end of [listen_exn]
//
(* ****** ****** *)
//
dataview
connect_v
(
  fd:int, int
) =
  | connect_v_succ (fd,  0) of socket_v (fd, conn)
  | connect_v_fail (fd, ~1(*err*)) of socket_v (fd, init)
// end of [connect_v]
//
fun
connect_err
  {fd:int}{n:int}
(
  pf: socket_v (fd, init)
| fd: int fd, sockaddr: &SA(n), salen: socklen_t(n)
) : [i:int] (connect_v (fd, i) | int i) = "mac#%"
//
fun
connect_exn
  {fd:int}{n:int}
(
  pf: !socket_v(fd, init) >> socket_v(fd, conn)
| fd: int fd, sockaddr: &SA(n), salen: socklen_t(n)
) : void = "exn#%" // end of [connect_exn]
//
(* ****** ****** *)
//
dataview
accept_v
  (fd1: int, int) =
  | {fd2:nat}
    accept_v_succ (fd1, fd2) of socket_v (fd2, conn)
  | accept_v_fail (fd1, ~1(*err*)) of () // failed attempt
// end of [accept_v]

fun
accept_err
  {fd1:int}{n:int}
(
  pf: !socket_v(fd1, listen)
| fd1: int fd1
, sa: &SA(n)? >> opt(SA(n), fd2 >= 0)
, salen: &socklen_t(n) >> socklen_t(n2)
) : #[fd2:int;n2:nat] (accept_v (fd1, fd2) | int fd2) = "mac#%"

fun
accept_null_err
  {fd1:int}
(
  pf: !socket_v(fd1, listen) | fd1: int fd1
) : [fd2:int]
(
  option_v (socket_v (fd2, conn), fd2 >= 0) | int fd2
) = "mac#%" // end-of-function

(* ****** ****** *)
//
fun
socket_close
  {fd:int}{s:status}
(
  pf: socket_v (fd, s) | fd: int fd
) : [i:int | i <= 0]
(
  option_v (socket_v (fd, s), i < 0) | int i
) = "mac#%" // end of [socket_close_err]
//
fun
socket_close_exn
  {fd:int}{s:status}
  (pf: socket_v (fd, s) | fd: int fd): void = "ext#%"
// end of [socket_close_exn]
//
(* ****** ****** *)

abst@ype
shutkind_t = int
macdef SHUT_RD = $extval(shutkind_t, "SHUT_RD")
macdef SHUT_WR = $extval(shutkind_t, "SHUT_WR")
macdef SHUT_RDWR = $extval(shutkind_t, "SHUT_RDWR")

(* ****** ****** *)
//
// HX: what error can occur?
//
fun
shutdown
  {fd:int} // 0/-1 : succ/fail // errno set
(
  pf: socket_v (fd, conn) | fd: int fd, how: shutkind_t
) : [i:int | i <= 0]
(
  option_v (socket_v (fd, conn), i < 0) | int i
) = "mac#%" // end of [shutdown]
//
fun
shutdown_exn
  {fd:int} // 0/-1 : succ/fail // errno set
(
  pf: socket_v (fd, conn) | fd: int fd, how: shutkind_t
) : void = "ext#%" // end of [shutdown_exn]
//
(* ****** ****** *)
//
// HX: it is just [read] in [unistd]
//
fun
socket_read
  {fd:int}
  {n,sz:int |
   0 <= n; n <= sz}
(
  pf: !socket_v(fd, conn) | fd: int fd, buf: &bytes(sz), ntot: size_t(n)
) : ssizeBtwe(~1, n) = "mac#%" // end of [socket_read]

(* ****** ****** *)
//
// HX: it is just [write] in [unistd]
//
fun
socket_write
  {fd:int}
  {n,sz:int |
   0 <= n; n <= sz}
(
  pf: !socket_v(fd, conn) | fd: int fd, buf: &bytes(sz), ntot: size_t(n)
) : ssizeBtwe(~1, n) = "mac#%" // end of [socket_write]
//
(* ****** ****** *)

(* end of [socket.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: August, 2013
//
(* ****** ****** *)

%{#
#include "libc/sys/CATS/time.cats"
%} // end of [%{#]

(* ****** ****** *)

#define
ATS_PACKNAME "ATSLIB.libc"
#define
ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)
//
staload
TYPES = "libc/sys/SATS/types.sats"
typedef time_t = $TYPES.time_t
typedef suseconds_t = $TYPES.suseconds_t
//
(* ****** ****** *)
//
typedef
timeval_struct =
$extype_struct
"atslib_timeval_type" of
{ // = struct timeval
  tv_sec= time_t // seconds  
, tv_usec= suseconds_t // microseconds
} // end of [timeval_struct]
//
typedef timeval = timeval_struct
//
(* ****** ****** *)

(*
//
// HX: these macros seem only available in BSD
//
fun timerisset (tv: &timeval):<> bool = "mac#%"
fun timerclear (tv: &timeval >> _):<> bool = "mac#%"
*)

(* ****** ****** *)

typedef
timezone_struct =
$extype_struct"atslib_timezone_type" of
{ // = struct timezone
  tz_minuteswest= int // minutes west of GMT
, tz_dsttime= int // nonzero if DST is ever in effect
} // end of [timezone_struct]
typedef timezone = timezone_struct

(* ****** ****** *)
//
symintr gettimeofday
//
fun gettimeofday_tv
(
  tv: &timeval? >> opt (timeval, i==0)
) :<> #[i:int | i <= 0] int(i) = "mac#%"
overload gettimeofday with gettimeofday_tv
//
fun gettimeofday_tz
(
  tz: &timezone? >> opt (timezone, i==0)
) :<> #[i:int | i <= 0] int(i) = "mac#%"
overload gettimeofday with gettimeofday_tz
//
(* ****** ****** *)
//
symintr settimeofday
//
fun settimeofday_tv
  (tv: &timeval):<> [i:int | i <= 0] int(i) = "mac#%"
overload settimeofday with settimeofday_tv
//
fun settimeofday_tz
  (tz: &timezone):<> [i:int | i <= 0] int(i) = "mac#%"
overload settimeofday with settimeofday_tz
//
fun settimeofday_tvtz
  (tv: &timeval, tz: &timezone):<> [i:int | i <= 0] int(i) = "mac#%"
overload settimeofday with settimeofday_tvtz
//
(* ****** ****** *)

fun utimes
( // -1 on error // errno set
  path: string, buf: &(@[timeval][2])
) : int = "mac#%" // end of [utimes]

fun futimes {fd:nat}
( // -1 on error // errno set
  fd: int (fd), buf: &(@[timeval][2])
) : int = "mac#%" // end of [futimes]

fun futimesat
( // -1 on error // errno set
  dirfd: int, path: string, buf: &(@[timeval][2])
) : int = "mac#%" // end of [futimesat]

(* ****** ****** *)
//
abst@ype
itimerknd_t0ype = int
typedef itimerknd = itimerknd_t0ype
macdef ITIMER_REAL = $extval (itimerknd, "ITIMER_REAL")
macdef ITIMER_VIRTUAL = $extval (itimerknd, "ITIMER_VIRTUAL")
macdef ITIMER_PROF = $extval (itimerknd, "ITIMER_PROF")
//
(* ****** ****** *)
//
typedef
itimerval_struct =
$extype_struct"atslib_itimerval_type" of
{
  it_interval= timeval, it_value= timeval
} // end of [itimerval_struct] // end of [typedef]
//
typedef itimerval = itimerval_struct
//
(* ****** ****** *)
//
// HX: -1/0 : succ/fail // errno set
//
fun getitimer
(
  which: itimerknd
, itval: &itimerval? >> opt (itimerval, i==0)
) : #[i:int | i <= 0] int(i) = "mac#%" // endfun

fun setitimer
(
  which: itimerknd, itval: &itimerval
, itval_old: &itimerval? >> opt (itimerval, i==0)
) : #[i:int | i <= 0] int(i) = "mac#%" // endfun

fun setitimer_null
  (which: itimerknd, itval: &itimerval): int = "mac#%"
// end of [setitimer_null]

(* ****** ****** *)

(* end of [time.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: October, 2013
//
(* ****** ****** *)

%{#
#include "libc/sys/CATS/mman.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

#define NSH (x) x // for commenting: no sharing
#define SHR (x) x // for commenting: it is shared

(* ****** ****** *)
//
staload
FCNTL = "libc/SATS/fcntl.sats"
//
typedef mode_t = $FCNTL.mode_t
typedef fcntlflags = $FCNTL.fcntlflags
stadef fildes = $FCNTL.fildes
vtypedef Fildes = $FCNTL.Fildes
//
(* ****** ****** *)
//
abst@ype protflags = int
//
macdef PROT_NONE = $extval (protflags, "PROT_NONE")
macdef PROT_EXEC = $extval (protflags, "PROT_EXEC")
macdef PROT_READ = $extval (protflags, "PROT_READ")
macdef PROT_WRITE = $extval (protflags, "PROT_WRITE")
//                      
fun lor_protflags_protflags
  : (protflags, protflags) -<> protflags = "ext#atspre_lor_int_int"
overload lor with lor_protflags_protflags
//
(* ****** ****** *)
//
abst@ype mmapflags = int
//
macdef MAP_SHARED = $extval (mmapflags, "MAP_SHARED")
macdef MAP_PRIVATE = $extval (mmapflags, "MAP_PRIVATE")
//
macdef MAP_ANONYMOUS = $extval (mmapflags, "MAP_ANONYMOUS")
//
fun lor_mmapflags_mmapflags
  : (mmapflags, mmapflags) -<> mmapflags = "ext#atspre_lor_int_int"
overload lor with lor_mmapflags_mmapflags
//
(* ****** ****** *)

macdef MAP_FAILED = $extval (ptr, "MAP_FAILED") // = (void*)-1

(* ****** ****** *)

(*
/*
** Open shared memory segment
*/
extern
int shm_open
(
  __const char *__name, int __oflag, mode_t __mode
 ) ; // end of [shm_open]
*)
fun shm_open
(
  path: NSH(string), flags: fcntlflags, mode: mode_t
) : Fildes = "mac#%" // endfun

(* ****** ****** *)

(*
/*
** Remove shared memory segment
*/
extern int shm_unlink (__const char *__name);
*)
fun shm_unlink (path: NSH(string)):<!ref> intLte(0) = "mac#%"

(* ****** ****** *)

(* end of [mman.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: May, 2013
//
(* ****** ****** *)

%{#
#include "libc/sys/CATS/wait.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

#define NSH (x) x // for commenting: no sharing
#define SHR (x) x // for commenting: it is shared

(* ****** ****** *)

staload
TYPES =
"libc/sys/SATS/types.sats"
typedef pid_t = $TYPES.pid_t

(* ****** ****** *)

absprop
WIFEXITED_p (s:int, b:bool)

fun WEXITSTATUS{s:int}
(
  pf: WIFEXITED_p (s, true) | status: int s
) : int = "mac#%" // end of [WEXITSTATUS]

fun WIFEXITED{s:int}
  (status: int s): [b:bool] (WIFEXITED_p (s, b) | bool b) = "mac#%"
// end of [WIFEXITED]

(* ****** ****** *)

absprop
WIFSIGNALED_p (s:int, b:bool)

fun WTERMSIG{s:int}
(
  pf: WIFSIGNALED_p (s, true) | status: int s
) : int = "mac#%" // end of [WTERMSIG]

fun WIFSIGNALED{s:int}
  (status: int s): [b:bool] (WIFSIGNALED_p (s, b) | bool b) = "mac#%"
// end of [WIFSIGNALED]

(* ****** ****** *)

absprop
WIFSTOPPED_p (s:int, b:bool)

fun WSTOPSIG{s:int}
(
  pf: WIFSTOPPED_p (s, true) | status: int s
) : int = "mac#%" // end of [WSTOPSIG]

fun WIFSTOPPED {s:int}
  (status: int s): [b:bool] (WIFSTOPPED_p (s, b) | bool b) = "mac#%"
// end of [WIFSTOPPED]

(* ****** ****** *)

absprop
WIFCONTINUED_p (s:int, b:bool)

fun WIFCONTINUED {s:int}
  (status: int s): [b:bool] (WIFCONTINUED_p (s, b) | bool b) = "mac#%"
// end of [WIFCONTINUED]

(* ****** ****** *)

absprop
WCOREDUMP_p (s:int, b:bool)

fun WCOREDUMP {s:int}
  (status: int s): [b:bool] (WCOREDUMP_p (s, b) | bool b) = "mac#%"
// end of [WCOREDUMP]

(* ****** ****** *)
//
symintr wait
fun wait_void (): pid_t = "mac#%"
fun wait_status (status: &int? >> int): pid_t = "mac#%"
overload wait with wait_void
overload wait with wait_status
//
(* ****** ****** *)

abst@ype
waitopt_t0ype = $extype"ats_int_type"
typedef waitopt = waitopt_t0ype
macdef WNONE = $extval (waitopt, "0")
macdef WNOHANG = $extval (waitopt, "WNOHANG")
macdef WUNTRACED = $extval (waitopt, "WUNTRACED")
macdef WCONTINUED = $extval (waitopt, "WCONTINUED")

fun lor_waitopt_waitopt
  (opt1: waitopt, opt2: waitopt): waitopt
overload lor with lor_waitopt_waitopt

(* ****** ****** *)

fun waitpid
(
  chldpid: pid_t, status: &int? >> int, opt: waitopt
) : pid_t = "mac#%" // end of [waitpid]

(* ****** ****** *)

(* end of [wait.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: November, 2014
//
(* ****** ****** *)

%{#
#include "libc/sys/CATS/socket_in.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

staload "libc/sys/SATS/socket.sats"

(* ****** ****** *)

staload IN = "libc/netinet/SATS/in.sats"

(* ****** ****** *)
//
typedef
in_port_t = $IN.in_port_t
typedef
in_port_nbo_t = $IN.in_port_nbo_t
//
(* ****** ****** *)
//
typedef
in_addr_hbo_t = $IN.in_addr_hbo_t
typedef
in_addr_nbo_t = $IN.in_addr_nbo_t
//
(* ****** ****** *)
//
typedef
in_addr_struct = $IN.in_addr_struct
//  
(* ****** ****** *)
//
typedef
sockaddr_in_struct =
$extype_struct
"sockaddr_in_struct" of
{
  sin_family = sa_family_t
, sin_port(**) = in_port_nbo_t // uint16
, sin_addr(**) = in_addr_struct
} // end of [sockaddr_in_struct]
//
typedef SA_in = sockaddr_in_struct
typedef sockaddr_in = sockaddr_in_struct
//
stacst socklen_in : int // HX: length of [sockaddr_in]
(*
stadef socklen_in = sizeof (sockaddr_in_struct)
*)
macdef socklen_in =
  $extval (socklen_t(socklen_in), "atslib_socklen_in")
//
praxi socklen_lte_in (): [socklen_in <= socklen_max] void
praxi sockaddr_in_trans {l:addr}
  (pf: !sockaddr_in_struct @ l >> sockaddr_struct(socklen_in) @ l): void
praxi sockaddr_trans_in {l:addr}
  (pf: !sockaddr_struct(socklen_in) @ l >> sockaddr_in_struct @ l): void
//
(* ****** ****** *)
//
fun
sockaddr_in_init
(
  sa: &SA_in? >> SA_in
, af: sa_family_t, inp: in_addr_nbo_t, port: in_port_nbo_t
) :<> void = "mac#%" // end of [sockaddr_in_init]

(* ****** ****** *)

fun
bind_in_exn
  {fd:int}
(
  pf: !socket_v(fd, init) >> socket_v(fd, bind) | fd: int fd, sa: &SA_in
) :<!exnref> void = "ext#%" // end of [bind_in_exn]

(* ****** ****** *)

fun
connect_in_exn
  {fd:int}
(
  pf: !socket_v(fd, init) >> socket_v(fd, conn) | fd: int fd, sa: &SA_in
) :<!exnref> void = "ext#%" // end of [connect_in_exn]

(* ****** ****** *)

(* end of [socket_in.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: March, 2013
//
(* ****** ****** *)

%{#
#include "libc/sys/CATS/types.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

#define NSH (x) x // for commenting: no sharing
#define SHR (x) x // for commenting: it is shared

(* ****** ****** *)

abst@ype
time_t0ype = $extype"atslib_time_type"
typedef time_t = time_t0ype // = its C-counterpart

(* ****** ****** *)

fun time2lint (t: time_t):<> lint = "mac#%"
fun time2double (t: time_t):<> double = "mac#%"

(* ****** ****** *)
//
fun lt_time_time (t1: time_t, t2: time_t):<> bool = "mac#%"
fun lte_time_time (t1: time_t, t2: time_t):<> bool = "mac#%"
overload < with lt_time_time
overload <= with lte_time_time
//
fun gt_time_time (t1: time_t, t2: time_t):<> bool = "mac#%"
fun gte_time_time (t1: time_t, t2: time_t):<> bool = "mac#%"
overload > with gt_time_time
overload >= with gte_time_time
//
fun eq_time_time (t1: time_t, t2: time_t):<> bool = "mac#%"
fun neq_time_time (t1: time_t, t2: time_t):<> bool = "mac#%"
overload = with eq_time_time
overload <> with neq_time_time
overload != with neq_time_time
//
(* ****** ****** *)

abst@ype
clock_t0ype = $extype"atslib_clock_type"
typedef clock_t = clock_t0ype // = its C-counterpart

(* ****** ****** *)

fun clock2lint (t: clock_t):<> lint = "mac#%"
fun clock2double (t: clock_t):<> double = "mac#%"

(* ****** ****** *)

abst@ype
clockid_t0ype = $extype"atslib_clockid_type"
typedef clockid_t = clockid_t0ype // = its C-counterpart

(* ****** ****** *)

abst@ype
mode_t0ype = $extype"atslib_mode_type"
typedef mode_t = mode_t0ype // = its C-counterpart

(* ****** ****** *)

fun mode2int (m: mode_t):<> int = "mac#%"
fun mode2uint (m: mode_t):<> uint = "mac#%"

fun eq_mode_mode (m1: mode_t, m2: mode_t):<> bool
fun neq_mode_mode (m1: mode_t, m2: mode_t):<> bool
overload = with eq_mode_mode
overload != with neq_mode_mode
overload <> with neq_mode_mode

(* ****** ****** *)

fun lor_mode_mode
  (m1: mode_t, m2: mode_t):<> mode_t = "mac#%"
overload lor with lor_mode_mode

fun land_mode_mode
  (m1: mode_t, m2: mode_t):<> mode_t = "mac#%"
overload land with land_mode_mode

(* ****** ****** *)

abst@ype
dev_t0ype = $extype"atslib_dev_type"
typedef dev_t = dev_t0ype // = its C-counterpart

(* ****** ****** *)

abst@ype
ino_t0ype = $extype"atslib_ino_type"
typedef ino_t = ino_t0ype // = its C-counterpart

(* ****** ****** *)

abst@ype
nlink_t0ype = $extype"atslib_nlink_type"
typedef nlink_t = nlink_t0ype // = its C-counterpart

(* ****** ****** *)

abst@ype
pid_t0ype = $extype"atslib_pid_type"
typedef pid_t = pid_t0ype // = its C-counterpart
castfn pid2int (x: pid_t):<> int
castfn pid2lint (x: pid_t):<> lint

(* ****** ****** *)

abst@ype
uid_t0ype = $extype"atslib_uid_type"
typedef uid_t = uid_t0ype // = its C-counterpart
abst@ype
gid_t0ype = $extype"atslib_gid_type"
typedef gid_t = gid_t0ype // = its C-counterpart

(* ****** ****** *)

abst@ype
off_t0ype = $extype"atslib_off_type"
typedef off_t = off_t0ype // = its C-counterpart

(* ****** ****** *)

abst@ype
blkcnt_t0ype = $extype"atslib_blkcnt_type"
typedef blkcnt_t = blkcnt_t0ype // = its C-counterpart
abst@ype
blkcnt_t0ype = $extype"atslib_blkcnt_type"
typedef blkcnt_t = blkcnt_t0ype // = its C-counterpart

(* ****** ****** *)

abst@ype
blksize_t0ype = $extype"atslib_blksize_type"
typedef blksize_t = blksize_t0ype // = its C-counterpart
abst@ype
blksize_t0ype = $extype"atslib_blksize_type"
typedef blksize_t = blksize_t0ype // = its C-counterpart

(* ****** ****** *)

fun lint2off (x: lint):<> off_t = "mac#%"
fun off2lint (x: off_t):<> lint = "mac#%"
fun size2off (x: size_t):<> off_t = "mac#%"
fun off2size (x: off_t):<> size_t = "mac#%"

(* ****** ****** *)
//
absview fildes_view (fd: int)
viewdef fildes_v (i:int) = fildes_view (i)
//
absvt@ype
fildes_vtype (fd: int) = int
//
vtypedef
fildes (fd: int) = fildes_vtype (fd)
//
vtypedef Fildes = [fd:int] fildes (fd)
vtypedef Fildes0 = [fd:int | fd >= 0] fildes (fd)
//
(* ****** ****** *)

castfn
fildes_decode
  {fd:nat} (fd: fildes (fd)):<> (fildes_v (fd) | int fd)
// end of [fildes_decode]

castfn fildes_encode
  {fd:nat} (pf: fildes_v (fd) | fd: int fd):<> fildes (fd)
// end of [fildes_encode]

(* ****** ****** *)

abst@ype
useconds_t = // microseconds
$extype"atslib_useconds_type"
castfn usec2lint (x: useconds_t):<> lint

abst@ype
suseconds_t = // microseconds
$extype"atslib_suseconds_type"
castfn susec2lint (x: suseconds_t):<> lint

(* ****** ****** *)

abst@ype
pthread_t =
$extype"atslib_pthread_type"
castfn pthread2lint (x: pthread_t):<> lint

(* ****** ****** *)

(* end of [types.sats] *)
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/sys/CATS/CODEGEN/socket.atxt
** Time of generation: Tue Sep  1 22:06:05 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: November, 2014 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_SYS_CATS_SOCKET
#define ATSLIB_LIBC_SYS_CATS_SOCKET

/* ****** ****** */
//
#include <unistd.h>
#include <sys/socket.h>
//
/* ****** ****** */

#include "share/H/pats_atslib.h"

/* ****** ****** */

/*
typedef
unsigned short int sa_family_t; // socket address family
*/
typedef
unsigned short int sp_family_t; // socket protocol family

/* ****** ****** */

#define atslib_socket_AF_type socket_AF_type
#define atslib_socket_PF_type socket_PF_type

/* ****** ****** */
//
#define \
atslib_bind_err(fd, sa, len) \
  bind(fd, (const struct sockaddr*)sa, len)
//
extern
void
atslib_bind_exn
(
  int sockfd, atstype_ptr sa, socklen_t salen
); // end of [atslib_bind_exn]
//
/* ****** ****** */
//
#define \
atslib_listen_err(fd, qsz) listen(fd, qsz)
//
extern
void
atslib_listen_exn (int sockfd, int listenqsz);
//
/* ****** ****** */
//
#define \
atslib_connect_err(fd, sa, len) \
  connect(fd, (const struct sockaddr*)sa, len)
//
extern
void
atslib_connect_exn
(
  int sockfd, atstype_ptr sa, socklen_t salen
); // end of [atslib_connect_exn]
//
/* ****** ****** */
//
#define \
atslib_accept_err(fd, sa, len) \
  accept(fd, (struct sockaddr*)sa, (socklen_t*)len)
//
#define \
atslib_accept_null_err(fd) atslib_accept_err(fd, 0, 0)
//
/* ****** ****** */

#define atslib_socket_close(fd) close(fd)

/* ****** ****** */

#define atslib_shutdown(fd, how) shutdown(fd, how)

/* ****** ****** */

#define \
atslib_socket_read(fd, bufp, bsz) read(fd, (char*)bufp, bsz)
#define \
atslib_socket_write(fd, bufp, bsz) write(fd, (const char*)bufp, bsz)

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_SYS_CATS_SOCKET

/* ****** ****** */

/* end of [socket.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/sys/CATS/CODEGEN/stat.atxt
** Time of generation: Tue Sep  1 22:06:05 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_SYS_CATS_STAT
#define ATSLIB_LIBC_SYS_CATS_STAT

/* ****** ****** */

#include <sys/stat.h>

/* ****** ****** */

typedef
struct stat
atslib_stat_struct ;

/* ****** ****** */

#define atslib_umask umask

/* ****** ****** */

#define atslib_chmod chmod

/* ****** ****** */

#define atslib_mkdir mkdir
#define atslib_mkdirat mkdirat

/* ****** ****** */

#define atslib_mkfifo mkfifo

/* ****** ****** */

#define atslib_stat stat
#define atslib_fstat fstat
#define atslib_lstat lstat

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_SYS_CATS_STAT

/* ****** ****** */

/* end of [stat.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/sys/CATS/CODEGEN/time.atxt
** Time of generation: Tue Sep  1 22:06:05 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: August, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_SYS_CATS_TIME
#define ATSLIB_LIBC_SYS_CATS_TIME

/* ****** ****** */

#include <sys/time.h>

/* ****** ****** */

typedef struct timeval atslib_timeval_type ;
typedef struct timezone atslib_timezone_type ;

/* ****** ****** */

#define atslib_gettimeofday_tv(tv) gettimeofday(tv, NULL)
#define atslib_gettimeofday_tz(tz) gettimeofday(NULL, tz)

#define atslib_settimeofday_tv(tv) settimeofday(tv, NULL)
#define atslib_settimeofday_tz(tz) settimeofday(NULL, tz)
#define atslib_settimeofday_tvtz(tv, tz) settimeofday(tv, tz)

/* ****** ****** */

#define atslib_utimes utimes
#define atslib_futimes futimes
#define atslib_futimesat futimesat

/* ****** ****** */

typedef struct itimerval ats_itimerval_type ;

#define atslib_getitimer getitimer
#define atslib_setitimer setitimer
#define atslib_setitimer_null(which, itval) setitimer(which, itval, NULL)

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_SYS_CATS_TIME

/* ****** ****** */

/* end of [time.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/sys/CATS/CODEGEN/mman.atxt
** Time of generation: Tue Sep  1 22:06:05 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: October, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_SYS_CATS_MMAN
#define ATSLIB_LIBC_SYS_CATS_MMAN

/* ****** ****** */
//
#include <fcntl.h>
#include <sys/types.h>
//
#include <sys/mman.h>
//
/* ****** ****** */

#define atslib_shm_open shm_open
#define atslib_shm_unlink shm_unlink

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_SYS_CATS_MMAN

/* ****** ****** */

/* end of [mman.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/sys/CATS/CODEGEN/wait.atxt
** Time of generation: Tue Sep  1 22:06:05 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: October, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_SYS_CATS_WAIT
#define ATSLIB_LIBC_SYS_CATS_WAIT

/* ****** ****** */
//
#include <sys/wait.h>
//
/* ****** ****** */
//
// HX: it is yet empty
//
/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_SYS_CATS_WAIT

/* ****** ****** */

/* end of [wait.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/sys/CATS/CODEGEN/types.atxt
** Time of generation: Tue Sep  1 22:06:05 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_SYS_CATS_TYPES
#define ATSLIB_LIBC_SYS_CATS_TYPES

/* ****** ****** */

#include <sys/types.h>

/* ****** ****** */

typedef mode_t atslib_mode_type ;

/* ****** ****** */
//
// HX-2013-8:
// [atslib_time_type] is already
// defined in [libc/CATS/time.cats]
//
typedef time_t atslib_types_time_type ;
//
/* ****** ****** */

#if(0)
//
// HX-2013-05: where are they?
// HX-2013-06: they are declared in [time.h]
//
typedef clock_t atslib_clock_type ;
typedef clockid_t atslib_clockid_type ;
#endif

/* ****** ****** */

typedef ino_t atslib_ino_type ;
typedef off_t atslib_off_type ;

/* ****** ****** */

typedef pid_t atslib_pid_type ;
typedef uid_t atslib_uid_type ;
typedef gid_t atslib_gid_type ;

/* ****** ****** */

ATSinline()
atslib_mode_type
atslib_lor_mode_mode
(
  atslib_mode_type m1
, atslib_mode_type m2
) {
  return (m1 | m2) ;
} // end of [atslib_lor_mode_mode]

ATSinline()
atslib_mode_type
atslib_land_mode_mode
(
  atslib_mode_type m1
, atslib_mode_type m2
) {
  return (m1 & m2) ;
} // end of [atslib_land_mode_mode]

/* ****** ****** */

ATSinline()
atstype_bool
atslib_lt_time_time
(
  atslib_types_time_type t1
, atslib_types_time_type t2
)
{
  return (t1 < t2 ? atsbool_true : atsbool_false) ;
} // end of [atslib_lt_time_time]
ATSinline()
atstype_bool
atslib_lte_time_time
(
  atslib_types_time_type t1
, atslib_types_time_type t2
)
{
  return (t1 <= t2 ? atsbool_true : atsbool_false) ;
} // end of [atslib_lte_time_time]

#define atslib_gt_time_time(t1, t2) atslib_lt_time_time(t2, t1)
#define atslib_gte_time_time(t1, t2) atslib_lte_time_time(t2, t1)

ATSinline()
atstype_bool
atslib_eq_time_time
(
  atslib_types_time_type t1
, atslib_types_time_type t2
)
{
  return (t1 == t2 ? atsbool_true : atsbool_false) ;
} // end of [atslib_eq_time_time]
ATSinline()
atstype_bool
atslib_neq_time_time
(
  atslib_types_time_type t1
, atslib_types_time_type t2
)
{
  return (t1 != t2 ? atsbool_true : atsbool_false) ;
} // end of [atslib_neq_time_time]

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_SYS_CATS_TYPES

/* ****** ****** */

/* end of [types.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/sys/CATS/CODEGEN/socket_in.atxt
** Time of generation: Tue Sep  1 22:06:06 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: November, 2014 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_SYS_CATS_SOCKET_IN
#define ATSLIB_LIBC_SYS_CATS_SOCKET_IN

/* ****** ****** */
//
#include <sys/socket.h>
#include <netinet/in.h>
//
/* ****** ****** */

#ifndef memset
extern void *memset (void *p, int c, size_t n) ;
#endif // ifndef(memset)

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atslib_sockaddr_in_init
(
  atstype_ptr sa
, sa_family_t af, in_addr_t inp, in_port_t port
) {
  struct sockaddr_in *sa2 = sa ;
  (void)memset(sa2, 0, sizeof(struct sockaddr_in)) ;
  sa2->sin_family = af ;
  sa2->sin_addr.s_addr = inp ;
  sa2->sin_port = port ;
} // end of [sockaddr_in_init]

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_SYS_CATS_SOCKET_IN

/* ****** ****** */

/* end of [socket_in.cats] */
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: December, 2013
//
(* ****** ****** *)

%{#
#include "libc/CATS/dlfcn.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

#define RD(x) x // for commenting: read-only
#define NSH(x) x // for commenting: no sharing
#define SHR(x) x // for commenting: it is shared

(* ****** ****** *)
//
macdef RTLD_NOW = $extval (uint, "RTLD_NOW")
macdef RTLD_LAZY = $extval (uint, "RTLD_LAZY")
//
(* ****** ****** *)
//
macdef RTLD_LOCAL = $extval (uint, "RTLD_LOCAL")
macdef RTLD_GLOBAL = $extval (uint, "RTLD_GLOBAL")
macdef RTLD_NOLOAD = $extval (uint, "RTLD_NOLOAD") // glibc-2.2
macdef RTLD_NODELETE = $extval (uint, "RTLD_NODELETE") // glibc-2.2
macdef RTLD_DEEPBIND = $extval (uint, "RTLD_DEEPBIND") // glibc-2.3.4
//
(* ****** ****** *)

absview dlopen_v (l:addr)

(* ****** ****** *)

fun dlopen (
  filename: NSH(stropt), flag: uint
) : [l:addr] (option_v (dlopen_v(l), l > null) | ptr l) = "mac#%"

(* ****** ****** *)

fun dlclose{l:agz}
  (pf: dlopen_v (l) | p: ptr (l)): [i:int | i >= 0] int(i) = "mac#%"
// end of [dlclose]

(* ****** ****** *)
//
praxi
dlopen_v_elim_null{l:addr | l <= null} (pf: dlopen_v (l)): void
//
(* ****** ****** *)

fun dlerror ((*void*)): vStrptr0 = "mac#%"

(* ****** ****** *)
//
fun dlsym{l:agz}
  (pf: !dlopen_v l | handle: ptr l, sym: NSH(string)): Ptr0 = "mac#%"
//
(* ****** ****** *)

(* end of [dlfcn.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: June, 2012
//
(* ****** ****** *)

%{#
#include "libc/CATS/stdlib.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

vtypedef
RD(a:vt0p) = a // for commenting: read-only
#define NSH(x) x // for commenting: no sharing
#define SHR(x) x // for commenting: it is shared

(* ****** ****** *)

staload
STDDEF = "libc/SATS/stddef.sats"
typedef wchar_t = $STDDEF.wchar_t

(* ****** ****** *)

macdef EXIT_FAILURE = $extval (int, "EXIT_FAILURE")
macdef EXIT_SUCCESS = $extval (int, "EXIT_SUCCESS")

(* ****** ****** *)

abst@ype div_t = $extype"div_t"
abst@ype ldiv_t = $extype"ldiv_t"
abst@ype lldiv_t = $extype"lldiv_t"

(* ****** ****** *)
/*
void _Exit(int);
*/
fun _Exit (int): void = "mac#%"

/*
int atexit(void (*)(void));
*/
fun atexit
  (f: ((*void*)) -> void): int(*err*) = "mac#%"
// end of [atexit]

(* ****** ****** *)

/*
void abort(void);
*/
fun abort ((*void*)): void = "mac#%"

(* ****** ****** *)

/*
int abs (int)
*/
fun abs (int):<> int = "mac#%"
/*
long int labs(long int j);
*/
fun labs (lint):<> lint = "mac#%"
/*
long long int llabs(long long int j);
*/
fun llabs (lint):<> llint = "mac#%"

(* ****** ****** *)

/*
div_t div(int, int);
*/
fun div (int, int):<> div_t
/*
ldiv_t ldiv(long, long);
*/
fun ldiv (lint, lint):<> ldiv_t
/*
lldiv_t lldiv(long long, long long);                              
*/
fun lldiv (llint, llint):<> lldiv_t

(* ****** ****** *)

/*
long a64l(const char *);
*/
fun a64l (x: NSH(string)):<> lint = "mac#%"

/*
char *l64a(long value); // not defined for a negative value
*/
fun l64a
  {i:nat} (
  x: lint i
) :<!refwrt> [l:agz] vttakeout0 (strptr l) = "mac#%"
// end of [l64a]

(* ****** ****** *)

/*
int atoi(const char *);
*/
fun atoi (x: NSH(string)):<> int = "mac#%"

/*
long atol(const char *);
*/
fun atol (x: NSH(string)):<> lint = "mac#%"

/*
long long atoll(const char *);
*/
fun atoll (x: NSH(string)):<> llint = "mac#%"
                                          
/*
double atof(const char *);
*/
fun atof (x: NSH(string)):<> double = "mac#%"

(* ****** ****** *)

/*
long int strtol(const char *nptr, char **endptr, int base);
*/
symintr strtol
fun strtol0
  (nptr: string, base: intBtwe (2, 36)):<!wrt> lint = "mac#%"
overload strtol with strtol0
fun strtol1
  (nptr: string, endptr: &ptr? >> _, base: intBtwe (2, 36)):<!wrt> lint = "mac#%"
overload strtol with strtol1
fun strtol_unsafe
  (nptr: string, endptr: ptr, base: int):<!wrt> lint = "mac#%"
// end of [strtol_unsafe]
/*
long long int strtoll(const char *nptr, char **endptr, int base);
*/
symintr strtoll
fun strtoll0
  (nptr: string, base: intBtwe (2, 36)):<!wrt> llint
overload strtoll with strtoll0
fun strtoll1
  (nptr: string, endptr: &ptr? >> _, base: intBtwe (2, 36)):<!wrt> llint
overload strtoll with strtoll1
fun strtoll_unsafe
  (nptr: string, endptr: ptr, base: int):<!wrt> llint
// end of [strtoll_unsafe]

(* ****** ****** *)

/*
unsigned long strtoul(const char *nptr, char **endptr, int base);
*/
symintr strtoul
fun strtoul0
  (nptr: string, base: intBtwe (2, 36)):<!wrt> ulint
overload strtoul with strtoul0
fun strtoul1
  (nptr: string, endptr: &ptr? >> _, base: intBtwe (2, 36)):<!wrt> ulint
overload strtoul with strtoul1
fun strtoul_unsafe
  (nptr: string, endptr: ptr, base: int):<!wrt> ulint
// end of [strtoul_unsafe]
/*
unsigned long long strtoull(const char *nptr, char **endptr, int base);
*/
symintr strtoull
fun strtoull0
  (nptr: string, base: intBtwe (2, 36)):<!wrt> ullint
overload strtoull with strtoull0
fun strtoull1
  (nptr: string, endptr: &ptr? >> _, base: intBtwe (2, 36)):<!wrt> ullint
overload strtoull with strtoull1
fun strtoull_unsafe
  (nptr: string, endptr: ptr, base: int):<!wrt> ullint
// end of [strtoull_unsafe]

(* ****** ****** *)

/*
float strtof(const char *nptr, char **endptr);
*/
symintr strtof
fun strtof0 (nptr: string):<!wrt> float = "mac#%"
overload strtof with strtof0
fun strtof1
  (nptr: string, endptr: &ptr? >> _):<!wrt> float = "mac#%"
overload strtof with strtof1
fun strtof_unsafe
  (nptr: string, endptr: ptr):<!wrt> float = "mac#%"
// end of [strtof_unsafe]
/*
double strtod(const char *nptr, char **endptr);
*/
symintr strtod
fun strtod0 (nptr: string):<!wrt> double = "mac#%"
overload strtod with strtod0
fun strtod1
  (nptr: string, endptr: &ptr? >> _):<!wrt> double = "mac#%"
overload strtod with strtod1
fun strtod_unsafe
  (nptr: string, endptr: ptr):<!wrt> double = "mac#%"
// end of [strtod_unsafe]
/*
long double strtold(const char *nptr, char **endptr);
*/
symintr strtold
fun strtold0 (nptr: string):<!wrt> ldouble = "mac#%"
overload strtold with strtold0
fun strtold1
  (nptr: string, endptr: &ptr? >> _):<!wrt> ldouble = "mac#%"
overload strtold with strtold1
fun strtold_unsafe
  (nptr: string, endptr: ptr):<!wrt> ldouble = "mac#%"
// end of [strtold_unsafe]

(* ****** ****** *)

(*
//
// HX: these env-functions may not be reentrant!
//
*)

(* ****** ****** *)

/*
char *getenv(char *);
*/
fun getenv
(
  name: NSH(string)
) :<!ref> [l:addr] vttakeout0 (strptr l) = "mac#%"

fun{} getenv_gc (name: NSH(string)):<!refwrt> Strptr0

(* ****** ****** *)

/*
int putenv(char *);
*/
//
// HX: [nameval] is shared!
//
fun putenv
  (nameval: SHR(string)):<!refwrt> int = "mac#%"
// end of [putenv]

(* ****** ****** *)

/*
int setenv
(
  const char *name, const char *value, int overwrite
) ;
*/
fun setenv
(
  name: NSH(string), value: NSH(string), overwrite: int
) :<!refwrt> int = "mac#%"

/*
int unsetenv(const char *name);
*/
fun unsetenv
  (name: NSH(string)):<!refwrt> int = "mac#%"
// end of [unsetenv]

(* ****** ****** *)

/*
int clearenv(void);
*/
fun clearenv ((*void*)):<!refwrt> int = "mac#%"

(* ****** ****** *)
//
// HX:
// these funs seem to have become obsolete
//
fun rand ((*void*)):<!refwrt> int = "mac#%"
fun srand (seed: uint):<!refwrt> void = "mac#%"

fun rand_r (seed: &uint >> _):<> int = "mac#%"

(* ****** ****** *)
/*
long int random(void);
*/
fun random((*void*)):<!refwrt> lint = "mac#%"

/*
void srandom(unsigned int seed);
*/
fun srandom(seed: uint):<!refwrt> void = "mac#%"

/*
char
*initstate
(
  unsigned int seed, char *state, size_t n
) ;
*/
fun initstate_unsafe
(
  seed: uint, state: cPtr1 (char), n: sizeGte(8)
) : cPtr0 (char) = "mac#%"
// end of [initstate_unsafe]

/*
char *setstate(char *state);
*/
fun setstate_unsafe
  (state: cPtr1 (char)):<!ref> cPtr0 (char) = "mac#%"
// end of [setstate_unsafe]

(* ****** ****** *)
/*
double drand48(void); // obsolete
*/
fun drand48 ((*void*)):<!ref> double = "mac#%"
     
/*
double erand48(unsigned short xsubi[3]); // obsolete
*/
fun erand48
  (xsubi: &(@[usint][3])):<!ref> double = "mac#%"
// end of [erand48]

/*
long int lrand48(void); // obsolete
*/
fun lrand48 ((*void*)):<!ref> lint = "mac#%"
/*
long int nrand48(unsigned short xsubi[3]); // obsolete
*/
fun nrand48
  (xsubi: &(@[usint][3])):<!ref> lint = "mac#%"
// end of [nrand48]

/*
long int mrand48(void); // obsolete
*/
fun mrand48 ((*void*)):<!ref> lint = "mac#%"

/*
long int jrand48(unsigned short xsubi[3]); // obsolete
*/
fun jrand48
  (xsubi: &(@[usint][3])):<!ref> lint = "mac#%"
// end of [jrand48]

/*
void srand48(long int seedval); // obsolete
*/
fun srand48 (seedval: lint):<!ref> void = "mac#%"

/*
unsigned short *seed48(unsigned short seed16v[3]); // obsolete
*/
// HX: returning pointer to some internal buffer
fun seed48 (seed16v: &(@[usint][3])): Ptr1 = "mac#%"

/*
void lcong48(unsigned short param[7]); // obsolete
*/
fun lcong48 (param: &(@[usint][7])):<!ref> void = "mac#%"

(* ****** ****** *)
/*
void
*bsearch
(
  const void *key
, const void *base
, size_t nmemb, size_t size
, int (*compar)(const void *, const void *)
) ; // end of [bsearch]
*/
fun bsearch
  {a:vt0p}{n:int}
(
  key: &RD(a)
, arr: &RD(@[INV(a)][n])
, asz: size_t (n), tsz: sizeof_t (a)
, cmp: cmpref (a)
) :<> Ptr0 = "mac#%" // end of [bsearch]

(* ****** ****** *)
/*
void qsort
(
  void *base, size_t nmemb, size_t size
, int(*compar)(const void *, const void *)
) ; // end of [qsort]
*/
fun qsort
  {a:vt0p}{n:int}
(
  A: &(@[INV(a)][n]), asz: size_t (n), tsz: sizeof_t (a), cmp: cmpref (a)
) :<!wrt> void = "mac#%" // end of [qsort]

(* ****** ****** *)
/*
int mblen(const char *s, size_t n);
*/
fun mblen_unsafe
  (s: cPtr0 (char), n: size_t):<!refwrt> int = "mac#%"
// end of [mblen_unsafe]

/*
int wctomb(char *s, wchar_t wc);
*/
fun wctomb_unsafe
  (s: cPtr0 (char), wc: wchar_t):<!refwrt> int = "mac#%"
// end of [wctomb_unsafe]

/*
size_t wcstombs
(
  char *dest, const wchar_t *src, size_t n
) ;
*/
fun wcstombs_unsafe
(
  dest: cPtr0 (char), src: cPtr1 (wchar_t), n: size_t
) :<!refwrt> ssize_t = "mac#%" // endfun

(* ****** ****** *)
/*
void setkey(const char *key);
*/
fun setkey_unsafe (key: cPtr1 (char)):<!ref> void = "mac#%"

(* ****** ****** *)
/*
int mkstemp(char *template);
*/
fun mkstemp {n:int | n >= 6}
  (template: !strnptr (n)): int = "mac#%"
// end of [mkstemp] // endfun

/*
int mkostemp (char *template, int flags);
*/
fun mkostemp {n:int | n >= 6}
  (template: !strnptr (n), flags: int): int = "mac#%"
// end of [mkostemp] // endfun

(* ****** ****** *)
/*
int grantpt(int fd);
*/
fun grantpt (fd: int): int = "mac#%"

(* ****** ****** *)

dataview
malloc_libc_v (addr, int) =
  | {l:agz}{n:int}
    malloc_libc_v_succ (l, n) of (b0ytes (n) @ l, mfree_libc_v (l))
  | {n:int} malloc_libc_v_fail (null, n)
// end of [malloc_libc_v]

(* ****** ****** *)

fun
malloc_libc
  {n:int}
(
  bsz: size_t n
) :<!wrt>
[
  l:addr
] (
  malloc_libc_v (l, n) | ptr l
) = "mac#%" // end of [malloc]

fun
malloc_libc_exn
  {n:int}
(
  bsz: size_t n
) :<!wrt>
[
  l:addr | l > null
] (
  b0ytes(n) @ l, mfree_libc_v l | ptr l
) = "mac#%" // end of [malloc_exn]

fun mfree_libc
  {l:addr}{n:int}
(
  b0ytes(n) @ l, mfree_libc_v l | ptr l
) :<!wrt> void = "mac#%" // endfun

(* ****** ****** *)

/*
int system(const char *command);
*/
fun system (command: NSH(string)): int = "mac#%"

(* ****** ****** *)

(* end of [stdlib.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: February, 2014
//
(* ****** ****** *)

%{#
#include "libc/CATS/alloca.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

#define NSH(x) x // for commenting: no sharing
#define SHR(x) x // for commenting: it is shared

(* ****** ****** *)

fun alloca
  {dummy:addr}{n:int}
(
  pf: void@dummy | n: size_t (n)
) : [l:addr]
(
  bytes(n) @ l, bytes(n) @ l -> void@dummy | ptr(l)
) = "mac#%" // end of [alloca]

(* ****** ****** *)

(*
fun{
a:vt0p
} ptr_alloca
  {dummy:addr} (
  pf: void@dummy | (*void*)
) : [l:addr] (a? @ l, a? @ l -> void@dummy | ptr(l))
*)
fun
ptr_alloca_tsz
  {a:vt0p}{dummy:addr}
  (pf: void@dummy | tsz: sizeof_t(a))
: [l:addr] (a? @ l, a? @ l -> void@dummy | ptr(l)) = "mac#%"

(* ****** ****** *)

(*
fun{
a:vt0p
} array_ptr_alloca
  {dummy:addr}{n:int}
(
  pf: void@dummy | asz: size_t(n)
) : [l:addr] (array(a?,n)@l, array(a?,n)@l -> void@dummy | ptr(l))
*)
fun
array_ptr_alloca_tsz
  {a:vt0p}{dummy:addr}{n:int}
(
  pf: void@dummy | asz: size_t(n), tsz: sizeof_t(a)
) : [l:addr] (array(a?,n)@l, array(a?,n)@l -> void@dummy | ptr(l)) = "mac#%"

(* ****** ****** *)

(* end of [alloca.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: March, 2013
//
(* ****** ****** *)

%{#
#include "libc/CATS/string.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

vtypedef
RD(a:vt0p) = a // for commenting: read-only
#define NSH (x) x // for commenting: no sharing
#define SHR (x) x // for commenting: it is shared

(* ****** ****** *)

fun strcmp (x1: string, x2: string):<> int = "mac#%"
fun strncmp (x1: string, x2: string, n: size_t):<> int = "mac#%"

(* ****** ****** *)

fun strcoll (x1: string, x2: string):<> int = "mac#%"

(* ****** ****** *)

fun strspn (x1: string, x2: string):<> size_t = "mac#%"
fun strcspn (x1: string, x2: string):<> size_t = "mac#%"

(* ****** ****** *)
//
fun strlen
  {n:int} (x: string n):<> size_t (n) = "mac#%"
fun strnlen {m,n:int}
  (x: string n, max: size_t m):<> size_t (min(m,n)) = "mac#%"
//
(* ****** ****** *)

fun strcat
  {l:addr}{m:int}{n1,n2:int | n1+n2 < m}
(
  !strbuf_v (l, m, n1) >> strbuf_v (l, m, n1+n2) | ptr (l), string (n2)
) :<!wrt> ptr (l) = "mac#%" // end of [strcat]

fun strcat_unsafe
  {l:addr} (x1: ptr (l), x2: string):<!wrt> ptr (l) = "mac#%"
fun strncat_unsafe
  {l:addr} (x1: ptr (l), x2: string, n: size_t):<!wrt> ptr (l) = "mac#%"

(* ****** ****** *)

fun strcpy
  {l:addr}{m:int}{n:int | n < m}
(
  !b0ytes(m) @ l >> strbuf_v (l, m, n) | ptr (l), string (n)
) :<!wrt> ptr (l) = "mac#%" // endfun

fun strcpy_unsafe
  {l:addr} (dst: ptr (l), src: string):<!wrt> ptr (l) = "mac#%"
fun strncpy_unsafe
  {l:addr} (dst: ptr (l), src: string, n: size_t):<!wrt> ptr (l) = "mac#%"

(* ****** ****** *)

absview strdup_view (l:addr)
viewdef strdup_v (l:addr) = strdup_view (l)

fun strdup
(
  str: string
) :<!wrt> [l:addr] (strdup_v (l) | strptr (l)) = "mac#%"
fun strndup
(
  str: string
) :<!wrt> [l:addr] (strdup_v (l) | strptr (l)) = "mac#%"

fun strdup_free
  {l:addr} (pf: strdup_v (l) | x: strptr l):<!wrt> void = "mac#%"
// end of [strdup_free]

(* ****** ****** *)
//
// HX-2013-03:
// strdupa-functions are gcc-functions;
// they use alloca for memory allocation
//
absview strdupa_view (l:addr)
viewdef strdupa_v (l:addr) = strdupa_view (l)

fun strdupa
(
  str: string
) :<!wrt> [l:addr] (strdupa_v (l) | strptr (l)) = "mac#%"
fun strndupa
(
  str: string
) :<!wrt> [l:addr] (strdupa_v (l) | strptr (l)) = "mac#%"

fun strdupa_free
  {l:addr} (pf: strdupa_v (l) | x: strptr l):<!wrt> void = "mac#%"
// end of [strdupa_free]

(* ****** ****** *)

fun strfry {l:agz} (x: !strptr (l) >> _):<!wrt> ptr (l) = "mac#%"

(* ****** ****** *)
//
fun memcpy
  {l:addr}
  {n1,n2:int}
  {n:int | n <= n1; n <= n2}
(
  pf: !b0ytes(n1) @ l >> bytes(n1) @ l
| dst: ptr (l), src: &RD(@[byte][n2]), n: size_t (n)
) :<!wrt> ptr (l) = "mac#%" // end of [memcpy]
//
fun memcpy_unsafe{l:addr}
  (dst: ptr (l), src: ptr, n: size_t):<!wrt> ptr (l) = "mac#%"
//
(* ****** ****** *)
/*
void *memset(void *s, int c, size_t n);
*/
fun memset_unsafe{l:addr}
  (dst: ptr (l), c: int, n: size_t): ptr (l) = "mac#%"
//
(* ****** ****** *)
/*
void *memmove(void *dest, const void *src, size_t n);
*/
fun memmove_unsafe{l:addr}
  (dst: ptr (l), src: ptr, n: size_t):<!wrt> ptr (l) = "mac#%"
//
(* ****** ****** *)
/*
void *memccpy(void *dest, const void *src, int c, size_t n);
*/
fun memccpy_unsafe{l:addr}
  (dst: ptr (l), src: ptr, c: int, n: size_t):<!wrt> Ptr0 = "mac#%"
//
(* ****** ****** *)
//
fun mempcpy
  {l:addr}
  {n1,n2:int}
  {n:int | n <= n1; n <= n2}
(
  pf: !b0ytes(n1) @ l >> bytes(n1) @ l
| dst: ptr (l), src: &RD(@[byte][n2]), n: size_t (n)
) :<!wrt> ptr (l+n) = "mac#%" // end of [mempcpy]
//
fun mempcpy_unsafe{l:addr}{n:int}
  (dst: ptr (l), src: ptr, n: size_t (n)):<!wrt> ptr (l+n) = "mac#%"
//
(* ****** ****** *)
//
// HX: This one is non-reentrant:
//
fun strerror
  (errnum: int):<!ref> [l:agz] vttakeout0 (strptr l) = "mac#%"
// end of [strerror]

(* ****** ****** *)
/*
int strerror_r(int errnum, char *buf, size_t buflen);
*/
fun strerror_r{n:int}
  (errnum: int, buf: &bytes(n), n: size_t (n)):<> int = "mac#%"
// end of [strerror_r]

(* ****** ****** *)

fun strerror_r_gc (errnum: int):<> Strptr1 = "ext#%"

(* ****** ****** *)

(* end of [string.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: October, 2014
//
(* ****** ****** *)

%{#
#include "libc/CATS/float.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

macdef
FLT_EPSILON = $extval (float, "FLT_EPSILON")
macdef
DBL_EPSILON = $extval (double, "DBL_EPSILON")

(* ****** ****** *)

(* end of [float.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: March, 2013
//
(* ****** ****** *)

%{#
#include "libc/CATS/fnmatch.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

#define RD(x) x // for commenting: read-only
#define NSH(x) x // for commenting: no sharing
#define SHR(x) x // for commenting: it is shared

(* ****** ****** *)

macdef
FNM_MATCH = 0 // HX: match is found
macdef
FNM_NOMATCH = $extval (int, "FNM_NOMATCH") // HX: no match is found

(* ****** ****** *)

typedef fnmflags = int

(* ****** ****** *)

(*
FNM_NOESCAPE
If this flag is set, treat backslash as an ordinary character, instead of
an escape character.
*)
macdef
FNM_NOESCAPE = $extval (fnmflags, "FNM_NOESCAPE")

(*
FNM_PATHNAME
If this flag is set, match a slash in string only with a slash in pattern
and not by an asterisk '*' or a question mark (?) metacharacter, nor by a
bracket expression ([]) containing a slash.
*)
macdef
FNM_PATHNAME = $extval (fnmflags, "FNM_PATHNAME")
                                                  
(*
FNM_PERIOD
If this flag is set, a leading period in string has to be matched exactly
by a period in pattern.  A period is considered to be leading if it is the
first character in string, or if both FNM_PATHNAME is set and the period
immediately follows a slash.
*)
macdef
FNM_PERIOD = $extval (fnmflags, "FNM_PERIOD")

(*
FNM_FILE_NAME
This is a GNU synonym for FNM_PATHNAME.
*)
macdef
FNM_FILE_NAME = $extval (fnmflags, "FNM_FILE_NAME")

(*
FNM_LEADING_DIR
If this flag (a GNU extension) is set, the pattern is considered to be
matched if it matches an initial segment of string which is followed by a
slash.  This flag is mainly for the internal use of glibc and is only
implemented in certain cases.
*)
macdef
FNM_LEADING_DIR = $extval (fnmflags, "FNM_LEADING_DIR")
                                                                                                                                             
(*
FNM_CASEFOLD
If this flag (a GNU extension) is set, the pattern is matched
case-insensitively.
*)
macdef
FNM_CASEFOLD = $extval (fnmflags, "FNM_CASEFOLD")

(* ****** ****** *)

symintr fnmatch

fun fnmatch_null
(
  pattern: NSH(string), fname: NSH(string)
) :<> int = "mac#%" // end of [fnmatch]

fun fnmatch_flags
(
  pattern: NSH(string), fname: NSH(string), flags: fnmflags
) :<> int = "mac#%" // end of [fnmatch]

overload fnmatch with fnmatch_null
overload fnmatch with fnmatch_flags

(* ****** ****** *)

(* end of [fnmatch.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: April, 2014
//
(* ****** ****** *)

%{#
#include "libc/CATS/signal.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)
//
staload
TYPES = "libc/sys/SATS/types.sats"
typedef pid_t = $TYPES.pid_t
typedef uid_t = $TYPES.uid_t
typedef clock_t = $TYPES.clock_t
//
(*
staload
PTHREAD = "libc/SATS/pthread.sats"
typedef pthread_t = $PTHREAD.pthread_t
*)
abst@ype
pthread_t0ype =
$extype "pthread_t"
//
typedef pthread_t = pthread_t0ype
//
(* ****** ****** *)
//
// HX: defined in [libc/CATS/signal.cats]
//
abst@ype
signum_t0ype =
$extype"signum_t"
//
typedef signum_t = signum_t0ype
//
macdef SIGHUP = $extval (signum_t, "SIGHUP") // 1
macdef SIGINT = $extval (signum_t, "SIGINT") // 2
macdef SIGQUIT = $extval (signum_t, "SIGQUIT") // 3
macdef SIGILL = $extval (signum_t, "SIGILL") // 4
macdef SIGABRT = $extval (signum_t, "SIGABRT") // 6
macdef SIGFPE = $extval (signum_t, "SIGFPE") // 8
macdef SIGKILL = $extval (signum_t, "SIGKILL") // 9
macdef SIGSEGV = $extval (signum_t, "SIGSEGV") // 11
macdef SIGPIPE = $extval (signum_t, "SIGPIPE") // 13
macdef SIGALRM = $extval (signum_t, "SIGALRM") // 14
macdef SIGTERM = $extval (signum_t, "SIGTERM") // 15
macdef SIGUSR1 = $extval (signum_t, "SIGUSR1")
macdef SIGUSR2 = $extval (signum_t, "SIGUSR2")
macdef SIGCHLD = $extval (signum_t, "SIGCHLD")
macdef SIGCONT = $extval (signum_t, "SIGCONT")
macdef SIGSTOP = $extval (signum_t, "SIGSTOP")
macdef SIGTSTP = $extval (signum_t, "SIGTSTP")
macdef SIGTTIN = $extval (signum_t, "SIGTTIN")
macdef SIGTTOU = $extval (signum_t, "SIGTTOU")
//
macdef SIGBUS = $extval (signum_t, "SIGBUS")
macdef SIGTRAP = $extval (signum_t, "SIGTRAP") // 5
//
macdef SIGIO = $extval (signum_t, "SIGIO")
//
(* ****** ****** *)
//
abstype
sighandler_type = ptr
typedef
sighandler_t = sighandler_type
//
macdef SIG_DFL = $extval (sighandler_t, "SIG_DFL")
macdef SIG_IGN = $extval (sighandler_t, "SIG_IGN")
macdef SIG_HOLD = $extval (sighandler_t, "SIG_HOLD")
macdef SIG_ERR = $extval (sighandler_t, "SIG_ERR")
//
castfn sighandler (f: (signum_t) -<fun1> void): sighandler_t
//
(* ****** ****** *)
//
abst@ype
sigset_t0ype =
$extype"sigset_t"
//
typedef sigset_t = sigset_t0ype
//
// HX-2014-04-07:
// errno [EINVAL] is set in case of failure
//
fun
sigemptyset // 0/-1 : succ/fail
(
  set: &sigset_t? >> opt (sigset_t, i==0)
) : #[i:int | i <= 0] int (i) = "mac#%"
//
fun
sigfillset // 0/-1 : succ/fail
(
  set: &sigset_t? >> opt (sigset_t, i==0)
) : #[i:int | i <= 0] int (i) = "mac#%"
//
fun
sigaddset // 0/-1 : succ/fail
  (set: &sigset_t, sgn: signum_t): int = "mac#%"
//
fun
sigdelset // 0/-1 : succ/fail
  (set: &sigset_t, sgn: signum_t): int = "mac#%"
//
fun
sigismember // 0/1/-1 : false/true/error
  (set: &sigset_t, sgn: signum_t): int = "mac#%"
//
(* ****** ****** *)
//
abst@ype
sigmaskhow_t0ype = int
//
typedef sigmaskhow_t = sigmaskhow_t0ype
//
macdef SIG_BLOCK = $extval (sigmaskhow_t, "SIG_BLOCK")
macdef SIG_UNBLOCK = $extval (sigmaskhow_t, "SIG_UNBLOCK")
macdef SIG_SETMASK = $extval (sigmaskhow_t, "SIG_SETMASK")
//
(* ****** ****** *)
//
abst@ype
sigval_t0ype =
$extype"sigval_t"
typedef sigval_t = sigval_t0ype
//
abst@ype
saflag_t0ype = uint
typedef saflag_t = saflag_t0ype
//
macdef
SA_NOCLDSTOP = $extval (saflag_t, "SA_NOCLDSTOP")
macdef
SA_NOCLDWAIT = $extval (saflag_t, "SA_NOCLDWAIT")
macdef SA_NODEFER = $extval (saflag_t, "SA_NODEFER")
macdef SA_ONSTACK = $extval (saflag_t, "SA_ONSTACK")
macdef SA_RESETHAND = $extval (saflag_t, "SA_RESETHAND")
macdef SA_RESTART = $extval (saflag_t, "SA_RESTART")
macdef SA_SIGINFO = $extval (saflag_t, "SA_SIGINFO")
//
(* ****** ****** *)
//
// HX: this one is deprecated; please use [sigaction]
//
fun signal
  (sgn: signum_t, act: sighandler_t): sighandler_t = "mac#%"
// end of [signal]
//
(* ****** ****** *)
//
typedef
siginfo_struct =
$extype_struct"siginfo_t" of
{
  si_signo= int // signal number
, si_sigerror= int // error value
, si_code= int // signal code
, si_trapno= int // trap number that caused HW signal
, si_pid= pid_t // proc ID of the sending process
, si_uid= uid_t // real user ID of the sending process
, si_status= int // exit value or signal
, si_utime= clock_t // user time consumed
, si_stime= clock_t // system time consumed
, si_value= sigval_t // signal value
, si_int= int // signal (POSIX.1b)
, si_ptr= ptr // signal (POSIX.1b)
, si_overrun= int // timer overrun count (POSIX.1b)
, si_timerid= int // timer ID (POSIX.1b)
, si_addr= ptr // memory location that caused fault
, si_band= int // band event
, si_fd= int // file descriptor
} (* end of [siginfo_struct] *)
//
typedef siginfo = siginfo_struct
//
(* ****** ****** *)
//
typedef
sigaction_struct =
$extype_struct
"atslib_sigaction_struct" of
{
  sa_handler= sighandler_t
, sa_sigaction= (int, &siginfo, ptr) -<fun1> void
, sa_mask= sigset_t
, sa_flags= saflag_t
, sa_restorer= ((*void*)) -<fun1> void
} (* end of [sigaction_struct] *)
//
typedef sigaction = sigaction_struct
//
fun sigaction
(
  sgn: signum_t
, newact: &RD(sigaction)
, oldact: &sigaction? >> opt (sigaction, i==0)
) : #[i:int | i <= 0] int i = "mac#%" // 0/-1 : succ/fail
//
fun sigaction_null
  (sgn: signum_t, newact: &RD(sigaction)): int = "mac#%"
//
(* ****** ****** *)
//
fun kill // 0/-1 : succ/fail // errno set
  (proc: pid_t, sgn: signum_t): int = "mac#%"
//
// HX: killpg (pgrp, sgn) = kill (-pgrp, sgn)
//
fun killpg // 0/-1 : succ/fail // errno set
  (pgrp: pid_t, sgn: signum_t): int = "mac#%"
//
(* ****** ****** *)
//
// HX-2014-04:
// raise(sgn) =
// pthread_kill (pthread_self, sgn)
//
fun raise (signum_t): int = "mac#%"
//
fun pthread_kill // 0/errno : succ/fail
  (tid: pthread_t, sgn: signum_t): int = "mac#%"
//
(* ****** ****** *)
//
// HX-2014-04-07: 0/errno : succ/fail
//
fun sigwait
(
  set: &sigset_t
, sgn: &signum_t? >> opt (signum_t, i==0)
) : #[i:int | i >= 0] int(i) = "mac#%"
//
(* ****** ****** *)
//
// HX-2014-04-07:
// [sigpause] is deprecated
// please use [sigsuspend] instead
//
// always -1: fail // errno set
fun sigpause (sgn: signum_t): int = "mac#%"
//
// HX-2014-04-07:
// always -1: fail // errno set // EINTR is set normally
//
fun sigsuspend (mask: &sigset_t): int = "mac#%"
//
(* ****** ****** *)
//
// HX-2014-04-07:
// 0/-1 : succ/fail // errno set
//
fun sigpending
(
  set: &sigset_t? >> opt (sigset_t, i==0)
) : #[i:int | i <= 0] int (i) = "mac#%"
//
//
// HX-2014-04-07:
// 0/-1 : succ/fail // errno set
//
fun siginterrupt (sgn: signum_t, flag: int): int = "mac#%"
//
(* ****** ****** *)
//
(*
//
// HX: print onto stderr
//
*)
fun psignal
  (sgn: signum_t, msg: string): void = "mac#%"
// end of [psignal]
fun strsignal
  (sgn: signum_t) // HX: errno set?
  :<!ref> [l:addr] (strptr(l) -<lin,prf> void | strptr(l)) = "mac#%"
// end of [strsignal]
//
(* ****** ****** *)

(* end of [signal.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxi AT gmail DOT com
// Start Time: March, 2013
//
(* ****** ****** *)

%{#
#include "libc/CATS/time.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

#define RD(x) x // for commenting: read-only
#define NSH(x) x // for commenting: no sharing
#define SHR(x) x // for commenting: it is shared

(* ****** ****** *)
//
staload
TYPES = "libc/sys/SATS/types.sats"
//
typedef time_t = $TYPES.time_t
typedef clock_t = $TYPES.clock_t
typedef clockid_t = $TYPES.clockid_t
//
macdef
CLOCKS_PER_SEC = $extval (clock_t, "CLOCKS_PER_SEC")
//
macdef
CLOCK_REALTIME = $extval (clockid_t, "CLOCK_REALTIME")
macdef
CLOCK_MONOTONIC = $extval (clockid_t, "CLOCK_MONOTONIC")
//
macdef
CLOCK_THREAD_CPUTIME_ID = $extval (clockid_t, "CLOCK_THREAD_CPUTIME_ID")
macdef
CLOCK_PROCESS_CPUTIME_ID = $extval (clockid_t, "CLOCK_PROCESS_CPUTIME_ID")
//
(* ****** ****** *)

fun difftime
(
  finish: time_t, start: time_t
) :<> double = "mac#%" // endfun

(* ****** ****** *)
//
symintr time
//
fun
time_get ():<> time_t = "mac#%"
//
fun
time_getset
(
  t: &time_t? >> opt (time_t, b)
) :<> #[b:bool] bool (b) = "mac#%"
//
overload time with time_get
overload time with time_getset
//
(* ****** ****** *)

fun ctime // non-reentrant
(
  t: &RD(time_t) // read-only
) :<!ref> [l:agez] vttakeout0 (strptr l) = "mac#%" // endfun

(* ****** ****** *)
//
#define CTIME_BUFSZ 26
//
dataview
ctime_v (m:int, addr, addr) =
  | {l:addr}
    ctime_v_fail (m, l, null) of b0ytes_v (l, m)
  | {l:agz}
    ctime_v_succ (m, l, l) of strbuf_v (l, m, CTIME_BUFSZ-1)
//
fun ctime_r // reentrant-version
  {l:addr}{m:int | m >= CTIME_BUFSZ}
(
  !b0ytes_v (l, m) >> ctime_v (m, l, l1) | &RD(time_t), ptr (l)
) :<!wrt> #[l1:addr] ptr (l1) = "mac#%" // end of [ctime_r]
//
fun{
} ctime_r_gc (&RD(time_t)):<!wrt> Strptr0 // end of [ctime_r_gc]
//
(* ****** ****** *)

typedef
tm_struct =
$extype_struct"atslib_tm_struct_type" of
{
  tm_sec= int // natLt(60)
, tm_min= int // natLt(60)
, tm_hour= int // natLt(24)
, tm_mon= int (* month *) // natLt(12)
, tm_year= int (* year *) // starting from 1900
, tm_wday= int (* day of the week *) // natLt(7)
, tm_mday= int (* day of the month *)
, tm_yday= int (* day in the year *)
, tm_isdst= int (* daylight saving time *) // yes/no: 1/0
} // end of [tm_struct] // end of [typedef]

(* ****** ****** *)
//
(*
** HX (2010-01-15):
** These functions are now kept for backward compatibility
*)
fun tm_get_sec
  (tm: &READ(tm_struct)):<> int = "mac#%"
fun tm_get_min
  (tm: &READ(tm_struct)):<> int = "mac#%"
fun tm_get_hour
  (tm: &READ(tm_struct)):<> int = "mac#%"
fun tm_get_mday
  (tm: &READ(tm_struct)):<> int = "mac#%"
fun tm_get_mon
  (tm: &READ(tm_struct)):<> int = "mac#%"
fun tm_get_year
  (tm: &READ(tm_struct)):<> int = "mac#%"
fun tm_get_wday
  (tm: &READ(tm_struct)):<> int = "mac#%"
fun tm_get_yday
  (tm: &READ(tm_struct)):<> int = "mac#%"
fun tm_get_isdst
  (tm: &READ(tm_struct)):<> int = "mac#%"
//
(* ****** ****** *)

fun mktime (tm: &RD(tm_struct)):<> time_t = "mac#%"

(* ****** ****** *)

fun asctime
(
  tm: &RD(tm_struct)
) :<!ref> [l:addr] vttakeout0 (strptr l) = "mac#%"

(* ****** ****** *)

/*
size_t
strftime
(
  char *s, size_t max, const char *format, const struct tm *tm
) ; // end of [strftime]
*/
fun strftime
  {l:addr}{m:pos} (
  pf: !b0ytes(m) @ l >> strbuf(m, n) @ l
| p: ptr l, m: size_t m, fmt: string, tm: &RD(tm_struct)
) :<> #[n:nat | n < m] size_t n = "mac#%" // endfun

(* ****** ****** *)

fun
gmtime // non-reentrant
(
  tval: &RD(time_t)
) :<!ref>
[
  l:addr
] (
  option_v (vtakeout0 (tm_struct@l), l > null) | ptr l
) = "mac#%" // end of [gmtime]

fun
gmtime_r // reentrant-version
(
  tval: &RD(time_t), tm: &tm_struct? >> opt (tm_struct, l > null)
) :<> #[l:addr] ptr (l) = "mac#%" // endfun

(* ****** ****** *)

fun
localtime // non-reentrant
(
  tval: &RD(time_t) // read-only
) :<!ref>
[
  l:addr
] (
  option_v (vtakeout0 (tm_struct@l), l > null) | ptr l
) = "mac#%" // end of [localtime]

fun
localtime_r // reentrant-version
(
  tval: &RD(time_t), tm: &tm_struct? >> opt (tm_struct, l > null)
) :<> #[l:addr] ptr (l) = "mac#%" // endfun

(* ****** ****** *)

fun tzset ():<!ref> void = "mac#%"

(* ****** ****** *)

fun clock (): clock_t = "mac#%" // -1 for error

(* ****** ****** *)

typedef
timespec =
$extype_struct"atslib_timespec_type" of
{
  tv_sec= time_t (*secs*), tv_nsec= lint (*nanosecs*)
} // end of [extype_struct] // end of [timespec]

(* ****** ****** *)

fun
nanosleep
(
  tms: &RD(timespec)
, rem: &timespec? >> opt (timespec, i==0)
) : #[i:int | i <= 0] int(i) = "mac#%"

fun
nanosleep_null (tms: &RD(timespec)): int = "mac#%"

(* ****** ****** *)
//
// HX:
// librt is needed for these functions
//
fun
clock_getres
(
  id: clockid_t
, res: &timespec? >> opt (timespec, i==0)
) : #[i:int | i <= 0] int(i) = "mac#%"
//
fun
clock_gettime
(
  id: clockid_t
, tms: &timespec? >> opt (timespec, i==0)
) : #[i:int | i <= 0] int(i) = "mac#%"
//
// HX: this one requires SUPERUSER previlege
//
fun
clock_settime
  (id: clockid_t, tms: &RD(timespec)): int = "mac#%"
//
(* ****** ****** *)

(* end of [time.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: April, 2011
//
(* ****** ****** *)

%{#
#include "libc/CATS/stdio.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

#define RD(x) x // for commenting: read-only
typedef SHR(a:type) = a // for commenting purpose
typedef NSH(a:type) = a // for commenting purpose

(* ****** ****** *)

sortdef fm = file_mode

(* ****** ****** *)

stadef r() = file_mode_r()
stadef w() = file_mode_w()
stadef rw() = file_mode_rw()

(* ****** ****** *)
//
staload
TYPES =
"libc/sys/SATS/types.sats"
//
stadef fildes = $TYPES.fildes
stadef fildes_v = $TYPES.fildes_v
//
(* ****** ****** *)

(*
abstype FILEref = ptr // declared in [prelude/basic_dyn.sats]
*)

(* ****** ****** *)
//
// HX-2011-04-02:
//
absview
FILE_view (l:addr, m:fm)
absvtype
FILEptr_vtype (addr, fm) = ptr
//
viewdef
FILE_v (l:addr, m:fm) = FILE_view (l, m)
vtypedef
FILEptr (l:addr, m: fm) = FILEptr_vtype (l, m)
//
(* ****** ****** *)
//
vtypedef
FILEptr0 (m:fm) =
  [l:addr | l >= null] FILEptr (l, m)
//
vtypedef
FILEptr1 (m:fm) = [l:agz] FILEptr (l, m)
vtypedef
FILEptr1 (*none*) = [l:agz;m:fm] FILEptr (l, m)
//
(* ****** ****** *)

stadef fmlte = file_mode_lte

(* ****** ****** *)
//
castfn
FILEptr2ptr
  {l:addr}{m:fm}(filp: !FILEptr (l, m)):<> ptr(l)
//
overload ptrcast with FILEptr2ptr
//
(* ****** ****** *)

castfn
FILEptr_encode
  {l:addr}{m:fm} (
  pf: FILE_v (l, m) | p: ptr l
) : FILEptr (l, m)
overload encode with FILEptr_encode

castfn
FILEptr_decode
  {l:agz}{m:fm} (
  p: FILEptr (l, m)
) : (FILE_v (l, m) | ptr l)
overload decode with FILEptr_decode

(* ****** ****** *)

praxi
FILEptr_free_null
  {l:alez}{m:fm} (p: FILEptr (l, m)):<prf> void
// end of [FILEptr_free_null]

(* ****** ****** *)

castfn
FILEptr_refize (filp: FILEptr1):<> FILEref

(* ****** ****** *)

castfn
FILEref_vttakeout // a lock is associated with FILEref-value
  {m:fm} (filr: FILEref):<> [l:agz] vttakeout0 (FILEptr (l, m))
// end of [FILEref_vttakeout]

(* ****** ****** *)
//
abst@ype whence_type = int
//
typedef whence = whence_type
//
macdef SEEK_SET = $extval (whence, "SEEK_SET")
macdef SEEK_CUR = $extval (whence, "SEEK_CUR")
macdef SEEK_END = $extval (whence, "SEEK_END")
//
(* ****** ****** *)
(*
//
// FILE *fopen (const char *path, const char *mode);
//
The fopen function opens the file whose name is the string pointed to by
path and associates a stream with it.

The argument mode points to a string beginning with one of the follow
ing sequences (Additional characters may follow these sequences.):

  r      Open  text  file  for  reading.  The stream is positioned at the
         beginning of the file.

  r+     Open for reading and writing.  The stream is positioned  at  the
         beginning of the file.

  w      Truncate  file  to  zero length or create text file for writing.
         The stream is positioned at the beginning of the file.

  w+     Open for reading and writing.  The file is created  if  it  does
         not  exist, otherwise it is truncated.  The stream is positioned
         at the beginning of the file.

  a      Open for appending (writing at end of file).  The file is created
         if it does not exist.  The stream is positioned at the end of the
         file.

  a+     Open for reading and appending (writing at end  of  file).   The
         file  is created if it does not exist.  The stream is positioned
         at the end of the file.

*)

fun fopen{m:fm}
(
  path: NSH(string), fmode(m)
) :<!wrt> FILEptr0 (m) = "mac#%"

fun fopen_exn{m:fm}
(
  path: NSH(string), fmode(m)
) :<!exnwrt> FILEptr1 (m) = "ext#%"

fun fopen_ref_exn{m:fm}
(
  path: NSH(string), fmode(m)
) :<!exnwrt> FILEref(*none*) = "ext#%"

(* ****** ****** *)
//
symintr fclose
symintr fclose_exn
//
fun fclose0
  (filr: FILEref):<!wrt> int = "mac#%"
fun fclose1
  {l:addr}{m:fm}
(
  filp: !FILEptr (l, m) >> ptr l
) :<!wrt>
  [i:int | i <= 0]
(
  option_v (FILE_v (l, m), i < 0) | int i
) = "mac#%" // endfun
//
overload fclose with fclose0
overload fclose with fclose1
//
fun fclose0_exn
  (filr: FILEref):<!exnwrt> void = "ext#%"
fun fclose1_exn
  (filp: FILEptr1(*none*)):<!exnwrt> void = "ext#%"
//
overload fclose_exn with fclose0_exn
overload fclose_exn with fclose1_exn
//
(* ****** ****** *)

(*
fun fclose_stdin ():<!exnwrt> void = "ext#%"
fun fclose_stdout ():<!exnwrt> void = "ext#%"
fun fclose_stderr ():<!exnwrt> void = "ext#%"
*)

(* ****** ****** *)
(*
//
// FILE *freopen (const char *path, const char *mode, FILE *stream);
//
The [freopen] function opens the file whose name is the string pointed to
by path and associates the stream pointed to by stream with it.  The original
stream (if it exists) is closed.  The mode argument is used just as in the
fopen function.  The primary use of the freopen function is to change the file
associated with a standard text stream (stderr, stdin, or stdout).
//
*)
//
symintr freopen
symintr freopen_exn
//
fun freopen0 {m2:fm}
(
  path: NSH(string), m2: fmode m2, filr: FILEref
) :<!wrt> Ptr0 = "mac#%"
//
// HX-2012-07:
// the original stream is closed even if [freopen] fails.
//
fun freopen1
  {m1,m2:fm}{l0:addr}
(
  path: NSH(string), m2: fmode m2, filp: FILEptr (l0, m1)
) :<!wrt> [
  l:addr | l==null || l==l0
] (
  option_v (FILE_v (l, m2), l > null) | ptr l
) = "mac#%" // end of [freopen1]
//
overload freopen with freopen0
overload freopen with freopen1
//
fun
freopen0_exn
  {m2:fm}
(
  path: NSH(string), m2: fmode m2, filr: FILEref
) :<!exnwrt> void = "ext#%" // end of [freopen0_exn]
overload freopen_exn with freopen0_exn
//
(* ****** ****** *)

(*
fun freopen_stdin
  (path: NSH(string)):<!exnwrt> void = "ext#%"
// end of [freopen_stdin]
fun freopen_stdout
  (path: NSH(string)):<!exnwrt> void = "ext#%"
// end of [freopen_stdout]
fun freopen_stderr
  (path: NSH(string)):<!exnwrt> void = "ext#%"
// end of [freopen_stderr]
*)

(* ****** ****** *)
(*
//
// int fileno (FILE* filp) ;
// 
The function fileno examines the argument stream and returns its integer
descriptor. In case fileno detects that its argument is not a valid stream,
it must return -1 and set errno to EBADF.
*)
//
symintr fileno
//
fun fileno0 (filr: FILEref):<> int = "mac#%"
overload fileno with fileno0
fun fileno1 (filp: !FILEptr1(*none*)):<> int = "mac#%"
overload fileno with fileno1

(* ****** ****** *)

(*
//
// HX-2011-08
//
*)
dataview
fdopen_v
(
  fd:int, addr, m: fmode
) =
  | {l:agz}
    fdopen_v_succ (fd, l, m) of FILE_v (l, m)
  | fdopen_v_fail (fd, null, m) of fildes_v (fd)
// end of [fdopen_v]

fun fdopen
  {fd:int}{m:fm}
(
  fd: fildes (fd), m: fmode (m)
) : [l:agez] 
(
  fdopen_v (fd, l, m) | ptr l
) = "mac#%" // end of [fdopen]

fun fdopen_exn
  {fd:int}{m:fm}
  (fd: fildes (fd), m: fmode (m)): FILEptr1 (m) = "ext#%"
// end of [fdopen_exn]

(* ****** ****** *)
(*  
//
// int feof (FILE *stream);
//
The function feof() returns a nonzero value if the end of the given file
stream has been reached.
//
*)
//
symintr feof
//
fun feof0 (filr: FILEref):<> int = "mac#%"
overload feof with feof0
fun feof1 (filp: !FILEptr1(*none*)):<> int = "mac#%"
overload feof with feof1

(* ****** ****** *)
(*
//
// int ferror (FILE *stream);
//
The function [ferror] tests the error indicator for the stream pointed to by
stream, returning non-zero if it is set.  The error indicator can only be
reset by the [clearerr] function.
*)
//
symintr ferror
//
fun ferror0 (filr: FILEref):<> int = "mac#%"
overload ferror with ferror0
fun ferror1 (filp: !FILEptr1(*none*)):<> int = "mac#%"
overload ferror with ferror1

(* ****** ****** *)
(*
//
// void clearerr (FILE *stream);
//
The function [clearerr] clears the end-of-file and error indicators for
the stream pointed to by stream.
//
*)
//
symintr clearerr
//
fun clearerr0
  (filr: FILEref):<!wrt> void = "mac#%"
overload clearerr with clearerr0
fun clearerr1
  (filp: !FILEptr1(*none*)):<!wrt> void = "mac#%"
overload clearerr with clearerr1

(* ****** ****** *)
(*
//
// int fflush (FILE *stream);
//
The function fflush forces a write of all user-space buffered data for the
given output or update stream via the streams underlying write function.
The open status of the stream is unaffected.
//
Upon successful completion 0 is returned.  Otherwise, EOF is returned and
the global variable errno is set to indicate the error.
*)
//
symintr fflush
symintr fflush_exn
//
fun fflush0
  (out: FILEref):<!wrt> int = "mac#%"
fun fflush1 {m:fm}
(
  pf: fmlte (m, w) | out: !FILEptr1 (m)
) :<!wrt> [i:int | i <= 0] int (i) = "mac#%"
//
overload fflush with fflush0
overload fflush with fflush1
//
fun fflush0_exn
  (out: FILEref):<!exnwrt> void = "ext#%"
overload fflush_exn with fflush0_exn
//
(* ****** ****** *)
//
fun fflush_all ():<!exnwrt> void = "ext#%"
fun fflush_stdout ():<!exnwrt> void = "ext#%"
//
(* ****** ****** *)
(*
//
// int fgetc (FILE *stream)
//
[fgetc] reads the next character from stream and returns it as an
unsigned char cast to an int, or EOF on end of file or error. Note
that EOF must be a negative number!
//
*)
//
symintr fgetc
//
fun fgetc0
  (inp: FILEref):<!wrt> int = "mac#%"
fun fgetc1 {m:fm}
(
  pf: fmlte (m, r()) | inp: !FILEptr1 (m)
) :<!wrt> intLte (UCHAR_MAX) = "mac#%"
//
overload fgetc with fgetc0
overload fgetc with fgetc1
//
(* ****** ****** *)

macdef getc = fgetc

(* ****** ****** *)

fun getchar0 ():<!wrt> int = "mac#%"
fun getchar1 (
) :<!wrt> [i:int | i <= UCHAR_MAX] int i = "mac#%"

(* ****** ****** *)
//
symintr fgets
//
fun fgets0
  {sz:int}{n0:pos | n0 <= sz}
(
  buf: &b0ytes(sz) >> bytes(sz), n0: int n0, inp: FILEref
) :<!wrt> Ptr0 = "mac#%" // = addr@(buf) or NULL
fun fgets1
  {sz:int}{n0:pos | n0 <= sz}{m:fm}
(
  pfm: fmlte (m, r)
| buf: &b0ytes(sz) >> bytes(sz), n0: int n0, inp: !FILEptr1 (m)
) :<!wrt> Ptr0 = "mac#%" // = addr@(buf) or NULL
//
overload fgets with fgets0
overload fgets with fgets1
//
dataview
fgets_v (
  sz:int, n0: int, addr, addr
) =
  | {l0:addr}
    fgets_v_fail (sz, n0, l0, null) of b0ytes(sz) @ l0
  | {n:nat | n < n0} {l0:agz}
    fgets_v_succ (sz, n0, l0, l0) of strbuf(sz, n) @ l0
// end of [fgets_v]
//
fun fgets1_err
  {sz,n0:int | sz >= n0; n0 > 0}{l0:addr}{m:fm}
(
  pf_mod: fmlte (m, r), pf_buf: b0ytes (sz) @ l0
| p0: ptr (l0), n0: int (n0), inp: !FILEptr1 (m)
) :<> [l1:addr] (fgets_v (sz, n0, l0, l1) | ptr l1) = "mac#%"
// end of [fgets_err]
//
overload fgets with fgets1_err
//
(* ****** ****** *)
//
// HX-2013-05:
// A complete line is read each time // [nullp] for error
//
fun fgets0_gc
  (bsz: intGte(1), inp: FILEref): Strptr0 = "ext#%"
fun fgets1_gc {m:fm}
(
  pf_mod: fmlte (m, r) | bsz: intGte(1), inp: FILEptr1 (m)
) : Strptr0 = "ext#%" // end of [fget1_gc]

(* ****** ****** *)
(*
//
// int fgetpos(FILE *stream, fpos_t *pos);
//
The [fgetpos] function stores the file position indicator of the given file
stream in the given position variable. The position variable is of type
fpos_t (which is defined in stdio.h) and is an object that can hold every
possible position in a FILE. [fgetpos] returns zero upon success, and a
non-zero value upon failure.
//
*)
//
symintr fgetpos
//
abst@ype fpos_t = $extype"ats_fpos_type"
//
fun fgetpos0
(
  filp: FILEref, pos: &fpos_t? >> opt (fpos_t, i==0)
) :<!wrt> #[i:int | i <= 0] int (i) = "mac#%"
fun fgetpos1
(
  filp: !FILEptr1, pos: &fpos_t? >> opt (fpos_t, i==0)
) :<!wrt> #[i:int | i <= 0] int (i) = "mac#%"
//
overload fgetpos with fgetpos0
overload fgetpos with fgetpos1
//
symintr fgetpos_exn
//
fun fgetpos0_exn 
  (filp: FILEref, pos: &fpos_t? >> _) :<!exnwrt> void = "ext#%"
overload fgetpos_exn with fgetpos0_exn 
//
(* ****** ****** *)
(*
//
// int fputc (int c, FILE *stream)
//
The function [fputc] writes the given character [c] to the given output
stream. The return value is the character, unless there is an error, in
which case the return value is EOF.
//
*)
//
symintr fputc
//
typedef
fputc0_type
  (a:t0p) = (a, FILEref) -<0,!wrt> int
fun fputc0_int : fputc0_type (int) = "mac#%" 
fun fputc0_char : fputc0_type (char) = "mac#%" 
overload fputc with fputc0_int of 0
overload fputc with fputc0_char of 0
//
typedef
fputc1_type
  (a:t0p) = {m:fm}
(
  fmlte (m, w()) | a, !FILEptr1 (m)
) -<0,!wrt> intLte (UCHAR_MAX)
fun fputc1_int : fputc1_type (int) = "mac#%"
fun fputc1_char : fputc1_type (char) = "mac#%"
overload fputc with fputc1_int of 10
overload fputc with fputc1_char of 10
//
symintr fputc_exn
//
typedef
fputc0_exn_type
  (a:t0p) = (a, FILEref) -<0,!exnwrt> void
fun fputc0_exn_int : fputc0_exn_type (int) = "ext#%"
fun fputc0_exn_char : fputc0_exn_type (char) = "ext#%"
overload fputc_exn with fputc0_exn_int of 0
overload fputc_exn with fputc0_exn_char of 0
//
(* ****** ****** *)

macdef putc = fputc

(* ****** ****** *)

fun putchar0 (c: int):<!wrt> int = "mac#%"
fun putchar1
  (c: int):<!wrt> [i:int | i <= UCHAR_MAX] int i = "mac#%"
// end of [putchar1]

(* ****** ****** *)
(*
//
// int fputs (const char* s, FILE *stream)
//
The function [fputs] writes a string to a file. it returns
a non-negative number on success, or EOF on error.
*)

//
symintr fputs
symintr fputs_exn
//
fun fputs0
(
  str: NSH(string), fil: FILEref
) :<!wrt> int = "mac#%"
fun fputs1{m:fm}
(
  pf: fmlte (m, w()) | str: NSH(string), out: !FILEptr1 (m)
) :<!wrt> int = "mac#%"
//
overload fputs with fputs0
overload fputs with fputs1
//
fun fputs0_exn
(
  str: NSH(string), fil: FILEref
) :<!exnwrt> void = "ext#%"
//
overload fputs_exn with fputs0_exn
//
(* ****** ****** *)
//
// [puts] puts a newline at the end
//
fun puts
  (inp: NSH(string)):<!wrt> int = "mac#%"
// end of [puts]
fun puts_exn
  (inp: NSH(string)):<!exnwrt> void = "ext#%"
// end of [puts_exn]

(* ****** ****** *)
(*
//
// size_t fread (void *ptr, size_t size, size_t nmemb, FILE *stream);
//
The function [fread] reads [nmemb] elements of data, each [size] bytes
long, from the stream pointed to by stream, storing them at the location
given by ptr. The return value is the number of items that are actually
read.
//
[fread] does not distinguish between end-of-file and error, and callers
must use [feof] and [ferror] to determine which occurred.
//
*)
//
symintr fread
//
fun
fread0 // [isz]: the size of each item
  {isz:pos}
  {nbf:int}
  {n:int | n*isz <= nbf}
(
  buf: &bytes(nbf) >> _
, isz: size_t isz, n: size_t n
, inp: FILEref(*none*)
) :<!wrt> sizeLte n = "mac#%"
fun
fread1 // [isz]: the size of each item
  {isz:pos}
  {nbf:int}
  {n:int | n*isz <= nbf}
  {m:fm}
(
  pfm: fmlte (m, r)
| buf: &bytes(nbf) >> _
, isz: size_t isz, n: size_t n
, inp: !FILEptr1 (m)
) :<!wrt> sizeLte n = "mac#%"
//
overload fread with fread0
overload fread with fread1
//
symintr fread_exn
//
fun
fread0_exn // [isz]: the size of each item
  {isz:pos}
  {nbf:int}
  {n:int | n*isz <= nbf}
(
  buf: &bytes(nbf) >> _, isz: size_t isz, n: size_t n, inp: FILEref
) :<!exnwrt> sizeLte n = "ext#%" // endfun
overload fread_exn with fread0_exn

(* ****** ****** *)
(*
//
// size_t fwrite (
//   const void *ptr,  size_t size,  size_t nmemb, FILE *stream
// ) ;
//
The function [fwrite] writes [nmemb] elements of data, each [size] bytes
long, to the stream pointed to by stream, obtaining them from the location
given by [ptr]. The return value is the number of items that are actually
written.
//
*)
//
symintr fwrite
//
fun
fwrite0 // [isz]: the size of each item
  {isz:pos}
  {nbf:int}
  {n:int | n*isz <= nbf}
(
  buf: &RD(bytes(nbf))
, isz: size_t isz, n: size_t n
, out: FILEref
) :<!wrt> sizeLte (n) = "mac#%"
fun
fwrite1 // [isz]: the size of each item
  {isz:pos}
  {nbf:int}
  {n:int | n*isz <= nbf}
  {m:fm}
(
  pfm: fmlte(m, w())
| buf: &RD(bytes(nbf))
, isz: size_t isz, n: size_t n
, out: !FILEptr1 (m)
) :<!wrt> sizeLte (n) = "mac#%"
//
overload fwrite with fwrite0
overload fwrite with fwrite1
//
symintr fwrite_exn
//
fun
fwrite0_exn // [isz]: the size of each item
  {isz:pos}
  {nbf:int}
  {n:int | n*isz <= nbf}
(
  buf: &RD(bytes(nbf))
, isz: size_t isz, n: size_t n
, out: FILEref(*none*)
) :<!exnwrt> sizeLte (n) = "ext#%"
overload fwrite_exn with fwrite0_exn

(* ****** ****** *)
(*
//
// int fseek (FILE *stream, long offset, int whence)
//
The [fseek] function sets the file position indicator for the stream
pointed to by stream.  The new position, measured in bytes, is obtained by
adding offset bytes to the position specified by whence.  If whence is set
to [SEEK_SET], [SEEK_CUR], or [SEEK_END], the offset is relative to the
start of the file, the current position indicator, or end-of-file,
respectively.  A successful call to the [fseek] function clears the end-
of-file indicator for the stream and undoes any effects of the [ungetc]
function on the same stream. Upon success, [fseek] returns 0. Otherwise,
it returns -1.
//
*)
//
symintr fseek
symintr fseek_exn
//
fun fseek0
(
  filr: FILEref, offset: lint, whence: whence
) :<!wrt> int = "mac#%"
fun fseek1
(
  f: !FILEptr1(*none*), offset: lint, whence: whence
) :<!wrt> int = "mac#%"
//
overload fseek with fseek0
overload fseek with fseek1
//
fun fseek0_exn
(
  filr: FILEref, offset: lint, whence: whence
) :<!exnwrt> void = "ext#%"
//
overload fseek_exn with fseek0_exn
//
(* ****** ****** *)
(*
//
// void fsetpos(FILE *stream, const fpos_t *pos);
//
The [fsetpos] function moves the file position indicator for the given
stream to a location specified by the position object. The type fpos_t is
defined in stdio.h.  The return value for fsetpos() is zero upon success,
non-zero on failure.
//
*)
//
symintr fsetpos
symintr fsetpos_exn
//
fun fsetpos0
  (filp: FILEref(*none*), pos: &RD(fpos_t)):<!wrt> int = "mac#%"
fun fsetpos1
  (filp: !FILEptr1(*none*), pos: &RD(fpos_t)):<!wrt> int = "mac#%"
//
overload fsetpos with fsetpos0
overload fsetpos with fsetpos1
//
fun fsetpos0_exn
  (filp: FILEref(*none*), pos: &RD(fpos_t)):<!exnwrt> void = "ext#%"
//
overload fsetpos_exn with fsetpos0_exn
//
(* ****** ****** *)

(*
//
// long ftell (FILE *stream)
//
[ftell] returns the current offset of the given file stream upon on
success. Otherwise, -1 is returned and the global variable errno is set to
indicate the error.
//
*)
//
symintr ftell
symintr ftell_exn
//
fun ftell0
  (filr: FILEref):<!wrt> lint = "mac#%"
fun ftell1
  (filp: !FILEptr1(*none*)):<!wrt> lint = "mac#%"
overload ftell with ftell0
overload ftell with ftell1
//
fun ftell0_exn
  (filr: FILEref):<!exnwrt> lint = "ext#%"
//
overload ftell_exn with ftell0_exn
//
(* ****** ****** *)

(*
//
// perror - print a system error message
//
The routine [perror(s)] produces a message on the standard error output,
describing the last error encountered during a call to a system or library
function.  First (if s is not NULL and *s is not NULL) the argument string
s is printed, followed by a colon and a blank.  Then the message and a
newline.
//
*)
fun perror
  (msg: NSH(string)):<!wrt> void = "mac#%"
// end of [perror]

(* ****** ****** *)

abstype pmode_type (m:fm) = string
typedef pmode (m:fm) = pmode_type (m)

absview popen_view (l:addr)
viewdef popen_v (l:addr) = popen_view (l)

praxi popen_v_free_null (pf: popen_v (null)): void

fun popen{m:fm}
(
  cmd: NSH(string), mode: pmode (m)
) : [l:addr] (popen_v (l) | FILEptr (l, m))

fun popen_exn{m:fm}
(
  cmd: NSH(string), mode: pmode (m)
) : FILEref = "ext#%" // endfun

fun pclose0_exn (filr: FILEref): int = "ext#%"
fun pclose1_exn
  {l:agz}{m:fm}
  (pf: popen_v l | filr: FILEptr (l, m)): int= "ext#%"
// end of [pclose1_exn]

(* ****** ****** *)

fun remove
  (inp: NSH(string)):<!wrt> int = "mac#%"
fun remove_exn
  (inp: NSH(string)):<!exnwrt> void = "ext#%"

(* ****** ****** *)

fun rename
(
  oldpath: NSH(string), newpath: NSH(string)
) :<!wrt> int = "mac#%" // end of [fun]

fun rename_exn
(
  oldpath: NSH(string), newpath: NSH(string)
) :<!exnwrt> void = "ext#%" // end of [fun]

(* ****** ****** *)
(*
// HX: [rewind] generates no error
*)
//
symintr rewind
//
fun rewind0
  (fil: FILEref):<!wrt> void = "mac#%"
overload rewind with rewind0
fun rewind1
  (fil: !FILEptr1(*none*)):<!wrt> void = "mac#%"
overload rewind with rewind1

(* ****** ****** *)
//
fun
tmpfile() :<!wrt> FILEptr0 (rw()) = "mac#%"
//
fun
tmpfile_exn() :<!exnwrt> FILEptr1 (rw()) = "ext#%"
//
fun
tmpfile_ref_exn() :<!exnwrt> FILEref(*none*) = "ext#%"
//
(* ****** ****** *)
(*
//
// int ungetc(int c, FILE *stream);
//
[ungetc] pushes [c] back to stream, cast to unsigned char, where it is
available for subsequent read operations.  Pushed-back characters will be
returned in reverse order; only one pushback is guaranteed.
//
*)
//
symintr ungetc
//
fun
ungetc0
  (c: char, f: FILEref):<!wrt> int = "mac#%"
fun
ungetc1
  {l:agz}{m:fm}
(
  pfm: fmlte (m, rw()) | c: char, f: !FILEptr (l, m)
) :<!wrt> [i:int | i <= UCHAR_MAX] int (i) = "mac#%"
//
overload ungetc with ungetc0
overload ungetc with ungetc1
//
symintr ungetc_exn
//
fun ungetc0_exn
  (c: char, f: FILEref) :<!exnwrt> void = "ext#%"
//
overload ungetc_exn with ungetc0_exn
//
(* ****** ****** *)

stacst BUFSIZ : int
praxi BUFSIZ_gtez (): [BUFSIZ >= 0] void
macdef BUFSIZ = $extval (int(BUFSIZ), "BUFSIZ")

(* ****** ****** *)
//
abst@ype bufmode_t = int
//
macdef _IOFBF = $extval (bufmode_t, "_IOFBF") // fully buffered
macdef _IOLBF = $extval (bufmode_t, "_IOLBF") // line buffered
macdef _IONBF = $extval (bufmode_t, "_IONBF") // no buffering
//
(* ****** ****** *)
//
symintr setbuf_null
//
fun setbuf0_null
  (f: FILEref): void = "mac#%"
overload setbuf_null with setbuf0_null
fun setbuf1_null
  (f: !FILEptr1(*none*)): void = "mac#%"
overload setbuf_null with setbuf1_null

(* ****** ****** *)
(*
//
// HX-2010-10-03:
// the buffer can be freed only after it is no longer used by
// the stream to which it is attached!!!
*)
//
symintr setbuffer
//
fun
setbuffer0
  {n1,n2:nat | n2 <= n1}{l:addr}
(
  pf_buf: !b0ytes n1 @ l | f: FILEref, p_buf: ptr l, n2: size_t n2
) : void = "mac#%"
overload setbuffer with setbuffer0
fun
setbuffer1
  {n1,n2:nat | n2 <= n1}{lbf:addr}
(
  pf_buf: !b0ytes n1 @ lbf | f: !FILEptr1(*none*), p_buf: ptr lbf, n2: size_t n2
) : void = "mac#%"
overload setbuffer with setbuffer1

(* ****** ****** *)
//
symintr setlinebuf
//
fun setlinebuf0
  (f: FILEref): void = "mac#%"
overload setlinebuf with setlinebuf0
fun setlinebuf1
  (f: !FILEptr1(*none*)): void = "mac#%"
overload setlinebuf with setlinebuf1

(* ****** ****** *)
//
symintr setvbuf_null
//
fun setvbuf0_null
  (f: FILEref, mode: bufmode_t): int = "mac#%"
overload setvbuf_null with setvbuf0_null
fun setvbuf1_null
  (f: !FILEptr1(*none*), mode: bufmode_t): int = "mac#%"
overload setvbuf_null with setvbuf1_null

(* ****** ****** *)
//
symintr setvbuf
//
fun
setvbuf0
  {n1,n2:nat | n2 <= n1}{lbf:addr}
(
  pf_buf: !b0ytes(n1) @ lbf | fil: FILEref, mode: bufmode_t, n2: size_t n2
) : int = "mac#%"
overload setvbuf with setvbuf0
fun
setvbuf1
  {n1,n2:nat | n2 <= n1}{lbf:addr}
(
  pf_buf: !b0ytes(n1) @ lbf | fil: !FILEptr1(*none*), mode: bufmode_t, n2: size_t n2
) : int = "mac#%"
overload setvbuf with setvbuf1

(* ****** ****** *)

(* end of [stdio.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: March, 2013
//
(* ****** ****** *)

%{#
#include "libc/CATS/fcntl.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

vtypedef
RD(a:vt0p) = a // for commenting: read-only
#define NSH(x) x // for commenting: no sharing
#define SHR(x) x // for commenting: it is shared

(* ****** ****** *)
//
staload
TYPES =
"libc/sys/SATS/types.sats"
//
typedef mode_t = $TYPES.mode_t
//
vtypedef
fildes (i:int) = $TYPES.fildes (i)
//
vtypedef Fildes = $TYPES.Fildes
vtypedef Fildes0 = $TYPES.Fildes0
//
(* ****** ****** *)

praxi
fildes_neg_elim {fd:int | fd < 0} (fd: fildes (fd)): void

(* ****** ****** *)
//
// HX: this is just a castfn
//
fun fildes_get_int
  {fd:int} (fd: !fildes (fd)):<> int (fd) = "mac#%"
//
fun fildes_isgtez
  {fd:int} (fd: !fildes (fd)):<> bool (fd >= 0) = "mac#%"
//
(* ****** ****** *)
//
fun fildes_iget_int
  (fd: int):<> [fd:int] vttakeout0 (fildes (fd)) = "ext#%"
//
(* ****** ****** *)

abst@ype fcntlflags = int
//
macdef O_CREAT  = $extval (fcntlflags, "O_CREAT")
macdef O_EXCL   = $extval (fcntlflags, "O_EXCL")
macdef O_TRUNC  = $extval (fcntlflags, "O_TRUNC")
macdef O_APPEND = $extval (fcntlflags, "O_APPEND")
//
macdef O_RDWR   = $extval (fcntlflags, "O_RDWR")
macdef O_RDONLY = $extval (fcntlflags, "O_RDONLY")
macdef O_WRONLY = $extval (fcntlflags, "O_WRONLY")
//
macdef O_SYNC   = $extval (fcntlflags, "O_SYNC")
macdef O_ASYNC  = $extval (fcntlflags, "O_ASYNC")
//
macdef O_NOCTTY = $extval (fcntlflags, "O_NOCTTY")
//  
(* ****** ****** *)

fun lor_fcntlflags_fcntlflags
  : (fcntlflags, fcntlflags) -<> fcntlflags = "ext#atspre_lor_int_int"
overload lor with lor_fcntlflags_fcntlflags

(* ****** ****** *)

fun open_flags
(
  path: NSH(string), flags: fcntlflags
) : Fildes = "mac#%" // endfun

fun open_flags_mode
(
  path: NSH(string), flags: fcntlflags, mode: mode_t
) : Fildes = "mac#%" // endfun

(* ****** ****** *)

fun fcntl_getfl (fd: !Fildes0): fcntlflags = "mac#%"
fun fcntl_setfl (fd: !Fildes0, flags: fcntlflags): int = "mac#%"

(* ****** ****** *)

(* end of [fcntl.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: April, 2012 *)

(* ****** ****** *)

typedef sysconfname = int

(* ****** ****** *)
//
// HX: error reporting:
// -1 is returned and errno is set
//
fun sysconf (name: sysconfname): lint = "mac#%"
//
(* ****** ****** *)

macdef _SC_ARG_MAX = $extval (sysconfname, "_SC_ARG_MAX")
macdef _SC_CHILD_MAX = $extval (sysconfname, "_SC_CHILD_MAX")
macdef _SC_CLK_TCK = $extval (sysconfname, "_SC_CLK_TCK")
macdef _SC_NGROUPS_MAX = $extval (sysconfname, "_SC_NGROUPS_MAX")
macdef _SC_OPEN_MAX = $extval (sysconfname, "_SC_OPEN_MAX")
macdef _SC_STREAM_MAX = $extval (sysconfname, "_SC_STREAM_MAX")
macdef _SC_TZNAME_MAX = $extval (sysconfname, "_SC_TZNAME_MAX")
macdef _SC_JOB_CONTROL = $extval (sysconfname, "_SC_JOB_CONTROL")
macdef _SC_SAVED_IDS = $extval (sysconfname, "_SC_SAVED_IDS")
macdef _SC_REALTIME_SIGNALS = $extval (sysconfname, "_SC_REALTIME_SIGNALS")
macdef _SC_PRIORITY_SCHEDULING = $extval (sysconfname, "_SC_PRIORITY_SCHEDULING")
macdef _SC_TIMERS = $extval (sysconfname, "_SC_TIMERS")
macdef _SC_ASYNCHRONOUS_IO = $extval (sysconfname, "_SC_ASYNCHRONOUS_IO")
macdef _SC_PRIORITIZED_IO = $extval (sysconfname, "_SC_PRIORITIZED_IO")
macdef _SC_SYNCHRONIZED_IO = $extval (sysconfname, "_SC_SYNCHRONIZED_IO")
macdef _SC_FSYNC = $extval (sysconfname, "_SC_FSYNC")
macdef _SC_MAPPED_FILES = $extval (sysconfname, "_SC_MAPPED_FILES")
macdef _SC_MEMLOCK = $extval (sysconfname, "_SC_MEMLOCK")
macdef _SC_MEMLOCK_RANGE = $extval (sysconfname, "_SC_MEMLOCK_RANGE")
macdef _SC_MEMORY_PROTECTION = $extval (sysconfname, "_SC_MEMORY_PROTECTION")
macdef _SC_MESSAGE_PASSING = $extval (sysconfname, "_SC_MESSAGE_PASSING")
macdef _SC_SEMAPHORES = $extval (sysconfname, "_SC_SEMAPHORES")
macdef _SC_SHARED_MEMORY_OBJECTS = $extval (sysconfname, "_SC_SHARED_MEMORY_OBJECTS")
macdef _SC_AIO_LISTIO_MAX = $extval (sysconfname, "_SC_AIO_LISTIO_MAX")
macdef _SC_AIO_MAX = $extval (sysconfname, "_SC_AIO_MAX")
macdef _SC_AIO_PRIO_DELTA_MAX = $extval (sysconfname, "_SC_AIO_PRIO_DELTA_MAX")
macdef _SC_DELAYTIMER_MAX = $extval (sysconfname, "_SC_DELAYTIMER_MAX")
macdef _SC_MQ_OPEN_MAX = $extval (sysconfname, "_SC_MQ_OPEN_MAX")
macdef _SC_MQ_PRIO_MAX = $extval (sysconfname, "_SC_MQ_PRIO_MAX")
macdef _SC_VERSION = $extval (sysconfname, "_SC_VERSION")
macdef _SC_PAGESIZE = $extval (sysconfname, "_SC_PAGESIZE")
macdef _SC_PAGE_SIZE = $extval (sysconfname, "_SC_PAGE_SIZE")
macdef _SC_RTSIG_MAX = $extval (sysconfname, "_SC_RTSIG_MAX")
macdef _SC_SEM_NSEMS_MAX = $extval (sysconfname, "_SC_SEM_NSEMS_MAX")
macdef _SC_SEM_VALUE_MAX = $extval (sysconfname, "_SC_SEM_VALUE_MAX")
macdef _SC_SIGQUEUE_MAX = $extval (sysconfname, "_SC_SIGQUEUE_MAX")
macdef _SC_TIMER_MAX = $extval (sysconfname, "_SC_TIMER_MAX")
//
macdef _SC_BC_BASE_MAX = $extval (sysconfname, "_SC_BC_BASE_MAX")
macdef _SC_BC_DIM_MAX = $extval (sysconfname, "_SC_BC_DIM_MAX")
macdef _SC_BC_SCALE_MAX = $extval (sysconfname, "_SC_BC_SCALE_MAX")
macdef _SC_BC_STRING_MAX = $extval (sysconfname, "_SC_BC_STRING_MAX")
macdef _SC_COLL_WEIGHTS_MAX = $extval (sysconfname, "_SC_COLL_WEIGHTS_MAX")
macdef _SC_EQUIV_CLASS_MAX = $extval (sysconfname, "_SC_EQUIV_CLASS_MAX")
macdef _SC_EXPR_NEST_MAX = $extval (sysconfname, "_SC_EXPR_NEST_MAX")
macdef _SC_LINE_MAX = $extval (sysconfname, "_SC_LINE_MAX")
macdef _SC_RE_DUP_MAX = $extval (sysconfname, "_SC_RE_DUP_MAX")
macdef _SC_CHARCLASS_NAME_MAX = $extval (sysconfname, "_SC_CHARCLASS_NAME_MAX")
//
macdef _SC_2_VERSION = $extval (sysconfname, "_SC_2_VERSION")
macdef _SC_2_C_BIND = $extval (sysconfname, "_SC_2_C_BIND")
macdef _SC_2_C_DEV = $extval (sysconfname, "_SC_2_C_DEV")
macdef _SC_2_FORT_DEV = $extval (sysconfname, "_SC_2_FORT_DEV")
macdef _SC_2_FORT_RUN = $extval (sysconfname, "_SC_2_FORT_RUN")
macdef _SC_2_SW_DEV = $extval (sysconfname, "_SC_2_SW_DEV")
macdef _SC_2_LOCALEDEF = $extval (sysconfname, "_SC_2_LOCALEDEF")
//
macdef _SC_PII = $extval (sysconfname, "_SC_PII")
macdef _SC_PII_XTI = $extval (sysconfname, "_SC_PII_XTI")
macdef _SC_PII_SOCKET = $extval (sysconfname, "_SC_PII_SOCKET")
macdef _SC_PII_INTERNET = $extval (sysconfname, "_SC_PII_INTERNET")
macdef _SC_PII_OSI = $extval (sysconfname, "_SC_PII_OSI")
macdef _SC_POLL = $extval (sysconfname, "_SC_POLL")
macdef _SC_SELECT = $extval (sysconfname, "_SC_SELECT")
macdef _SC_UIO_MAXIOV = $extval (sysconfname, "_SC_UIO_MAXIOV")
macdef _SC_IOV_MAX = _SC_UIO_MAXIOV = $extval (sysconfname, "_SC_IOV_MAX = _SC_UIO_MAXIOV")
macdef _SC_PII_INTERNET_STREAM = $extval (sysconfname, "_SC_PII_INTERNET_STREAM")
macdef _SC_PII_INTERNET_DGRAM = $extval (sysconfname, "_SC_PII_INTERNET_DGRAM")
macdef _SC_PII_OSI_COTS = $extval (sysconfname, "_SC_PII_OSI_COTS")
macdef _SC_PII_OSI_CLTS = $extval (sysconfname, "_SC_PII_OSI_CLTS")
macdef _SC_PII_OSI_M = $extval (sysconfname, "_SC_PII_OSI_M")
macdef _SC_T_IOV_MAX = $extval (sysconfname, "_SC_T_IOV_MAX")
//
macdef _SC_THREADS = $extval (sysconfname, "_SC_THREADS")
macdef _SC_THREAD_SAFE_FUNCTIONS =
  $extval (sysconfname, "_SC_THREAD_SAFE_FUNCTIONS")
macdef _SC_GETGR_R_SIZE_MAX = $extval (sysconfname, "_SC_GETGR_R_SIZE_MAX")
macdef _SC_GETPW_R_SIZE_MAX = $extval (sysconfname, "_SC_GETPW_R_SIZE_MAX")
macdef _SC_LOGIN_NAME_MAX = $extval (sysconfname, "_SC_LOGIN_NAME_MAX")
macdef _SC_TTY_NAME_MAX = $extval (sysconfname, "_SC_TTY_NAME_MAX")
macdef _SC_THREAD_DESTRUCTOR_ITERATIONS =
  $extval (sysconfname, "_SC_THREAD_DESTRUCTOR_ITERATIONS")
macdef _SC_THREAD_KEYS_MAX = $extval (sysconfname, "_SC_THREAD_KEYS_MAX")
macdef _SC_THREAD_STACK_MIN = $extval (sysconfname, "_SC_THREAD_STACK_MIN")
macdef _SC_THREAD_THREADS_MAX = $extval (sysconfname, "_SC_THREAD_THREADS_MAX")
macdef _SC_THREAD_ATTR_STACKADDR = $extval (sysconfname, "_SC_THREAD_ATTR_STACKADDR")
macdef _SC_THREAD_ATTR_STACKSIZE = $extval (sysconfname, "_SC_THREAD_ATTR_STACKSIZE")
macdef _SC_THREAD_PRIORITY_SCHEDULING =
  $extval (sysconfname, "_SC_THREAD_PRIORITY_SCHEDULING")
macdef _SC_THREAD_PRIO_INHERIT = $extval (sysconfname, "_SC_THREAD_PRIO_INHERIT")
macdef _SC_THREAD_PRIO_PROTECT = $extval (sysconfname, "_SC_THREAD_PRIO_PROTECT")
macdef _SC_THREAD_PROCESS_SHARED = $extval (sysconfname, "_SC_THREAD_PROCESS_SHARED")
//
macdef _SC_NPROCESSORS_CONF = $extval (sysconfname, "_SC_NPROCESSORS_CONF")
macdef _SC_NPROCESSORS_ONLN = $extval (sysconfname, "_SC_NPROCESSORS_ONLN")
macdef _SC_PHYS_PAGES = $extval (sysconfname, "_SC_PHYS_PAGES")
macdef _SC_AVPHYS_PAGES = $extval (sysconfname, "_SC_AVPHYS_PAGES")
macdef _SC_ATEXIT_MAX = $extval (sysconfname, "_SC_ATEXIT_MAX")
macdef _SC_PASS_MAX = $extval (sysconfname, "_SC_PASS_MAX")
//
macdef _SC_XOPEN_VERSION = $extval (sysconfname, "_SC_XOPEN_VERSION")
macdef _SC_XOPEN_XCU_VERSION = $extval (sysconfname, "_SC_XOPEN_XCU_VERSION")
macdef _SC_XOPEN_UNIX = $extval (sysconfname, "_SC_XOPEN_UNIX")
macdef _SC_XOPEN_CRYPT = $extval (sysconfname, "_SC_XOPEN_CRYPT")
macdef _SC_XOPEN_ENH_I18N = $extval (sysconfname, "_SC_XOPEN_ENH_I18N")
macdef _SC_XOPEN_SHM = $extval (sysconfname, "_SC_XOPEN_SHM")
//
macdef _SC_2_CHAR_TERM = $extval (sysconfname, "_SC_2_CHAR_TERM")
macdef _SC_2_C_VERSION = $extval (sysconfname, "_SC_2_C_VERSION")
macdef _SC_2_UPE = $extval (sysconfname, "_SC_2_UPE")
//
macdef _SC_XOPEN_XPG2 = $extval (sysconfname, "_SC_XOPEN_XPG2")
macdef _SC_XOPEN_XPG3 = $extval (sysconfname, "_SC_XOPEN_XPG3")
macdef _SC_XOPEN_XPG4 = $extval (sysconfname, "_SC_XOPEN_XPG4")
//
macdef _SC_CHAR_BIT = $extval (sysconfname, "_SC_CHAR_BIT")
macdef _SC_CHAR_MAX = $extval (sysconfname, "_SC_CHAR_MAX")
macdef _SC_CHAR_MIN = $extval (sysconfname, "_SC_CHAR_MIN")
macdef _SC_INT_MAX = $extval (sysconfname, "_SC_INT_MAX")
macdef _SC_INT_MIN = $extval (sysconfname, "_SC_INT_MIN")
macdef _SC_LONG_BIT = $extval (sysconfname, "_SC_LONG_BIT")
macdef _SC_WORD_BIT = $extval (sysconfname, "_SC_WORD_BIT")
macdef _SC_MB_LEN_MAX = $extval (sysconfname, "_SC_MB_LEN_MAX")
macdef _SC_NZERO = $extval (sysconfname, "_SC_NZERO")
macdef _SC_SSIZE_MAX = $extval (sysconfname, "_SC_SSIZE_MAX")
macdef _SC_SCHAR_MAX = $extval (sysconfname, "_SC_SCHAR_MAX")
macdef _SC_SCHAR_MIN = $extval (sysconfname, "_SC_SCHAR_MIN")
macdef _SC_SHRT_MAX = $extval (sysconfname, "_SC_SHRT_MAX")
macdef _SC_SHRT_MIN = $extval (sysconfname, "_SC_SHRT_MIN")
macdef _SC_UCHAR_MAX = $extval (sysconfname, "_SC_UCHAR_MAX")
macdef _SC_UINT_MAX = $extval (sysconfname, "_SC_UINT_MAX")
macdef _SC_ULONG_MAX = $extval (sysconfname, "_SC_ULONG_MAX")
macdef _SC_USHRT_MAX = $extval (sysconfname, "_SC_USHRT_MAX")
//
macdef _SC_NL_ARGMAX = $extval (sysconfname, "_SC_NL_ARGMAX")
macdef _SC_NL_LANGMAX = $extval (sysconfname, "_SC_NL_LANGMAX")
macdef _SC_NL_MSGMAX = $extval (sysconfname, "_SC_NL_MSGMAX")
macdef _SC_NL_NMAX = $extval (sysconfname, "_SC_NL_NMAX")
macdef _SC_NL_SETMAX = $extval (sysconfname, "_SC_NL_SETMAX")
macdef _SC_NL_TEXTMAX = $extval (sysconfname, "_SC_NL_TEXTMAX")
//
macdef _SC_XBS5_ILP32_OFF32 = $extval (sysconfname, "_SC_XBS5_ILP32_OFF32")
macdef _SC_XBS5_ILP32_OFFBIG = $extval (sysconfname, "_SC_XBS5_ILP32_OFFBIG")
macdef _SC_XBS5_LP64_OFF64 = $extval (sysconfname, "_SC_XBS5_LP64_OFF64")
macdef _SC_XBS5_LPBIG_OFFBIG = $extval (sysconfname, "_SC_XBS5_LPBIG_OFFBIG")
//
macdef _SC_XOPEN_LEGACY = $extval (sysconfname, "_SC_XOPEN_LEGACY")
macdef _SC_XOPEN_REALTIME = $extval (sysconfname, "_SC_XOPEN_REALTIME")
macdef _SC_XOPEN_REALTIME_THREADS = $extval (sysconfname, "_SC_XOPEN_REALTIME_THREADS")
//
macdef _SC_ADVISORY_INFO =
  $extval (sysconfname, "_SC_ADVISORY_INFO")
macdef _SC_BARRIERS = $extval (sysconfname, "_SC_BARRIERS")
macdef _SC_BASE = $extval (sysconfname, "_SC_BASE")
macdef _SC_C_LANG_SUPPORT =
  $extval (sysconfname, "_SC_C_LANG_SUPPORT")
macdef _SC_C_LANG_SUPPORT_R =
  $extval (sysconfname, "_SC_C_LANG_SUPPORT_R")
macdef _SC_CLOCK_SELECTION = $extval (sysconfname, "_SC_CLOCK_SELECTION")
macdef _SC_CPUTIME = $extval (sysconfname, "_SC_CPUTIME")
macdef _SC_THREAD_CPUTIME = $extval (sysconfname, "_SC_THREAD_CPUTIME")
macdef _SC_DEVICE_IO = $extval (sysconfname, "_SC_DEVICE_IO")
macdef _SC_DEVICE_SPECIFIC = $extval (sysconfname, "_SC_DEVICE_SPECIFIC")
macdef _SC_DEVICE_SPECIFIC_R = $extval (sysconfname, "_SC_DEVICE_SPECIFIC_R")
macdef _SC_FD_MGMT = $extval (sysconfname, "_SC_FD_MGMT")
macdef _SC_FIFO = $extval (sysconfname, "_SC_FIFO")
macdef _SC_PIPE = $extval (sysconfname, "_SC_PIPE")
macdef _SC_FILE_ATTRIBUTES = $extval (sysconfname, "_SC_FILE_ATTRIBUTES")
macdef _SC_FILE_LOCKING = $extval (sysconfname, "_SC_FILE_LOCKING")
macdef _SC_FILE_SYSTEM = $extval (sysconfname, "_SC_FILE_SYSTEM")
macdef _SC_MONOTONIC_CLOCK = $extval (sysconfname, "_SC_MONOTONIC_CLOCK")
macdef _SC_MULTI_PROCESS = $extval (sysconfname, "_SC_MULTI_PROCESS")
macdef _SC_SINGLE_PROCESS = $extval (sysconfname, "_SC_SINGLE_PROCESS")
macdef _SC_NETWORKING = $extval (sysconfname, "_SC_NETWORKING")
macdef _SC_READER_WRITER_LOCKS =
  $extval (sysconfname, "_SC_READER_WRITER_LOCKS")
macdef _SC_SPIN_LOCKS = $extval (sysconfname, "_SC_SPIN_LOCKS")
macdef _SC_REGEXP = $extval (sysconfname, "_SC_REGEXP")
macdef _SC_REGEX_VERSION = $extval (sysconfname, "_SC_REGEX_VERSION")
macdef _SC_SHELL = $extval (sysconfname, "_SC_SHELL")
macdef _SC_SIGNALS = $extval (sysconfname, "_SC_SIGNALS")
macdef _SC_SPAWN = $extval (sysconfname, "_SC_SPAWN")
macdef _SC_SPORADIC_SERVER = $extval (sysconfname, "_SC_SPORADIC_SERVER")
macdef _SC_THREAD_SPORADIC_SERVER =
  $extval (sysconfname, "_SC_THREAD_SPORADIC_SERVER")
macdef _SC_SYSTEM_DATABASE =
  $extval (sysconfname, "_SC_SYSTEM_DATABASE")
macdef _SC_SYSTEM_DATABASE_R =
  $extval (sysconfname, "_SC_SYSTEM_DATABASE_R")
macdef _SC_TIMEOUTS = $extval (sysconfname, "_SC_TIMEOUTS")
macdef _SC_TYPED_MEMORY_OBJECTS =
  $extval (sysconfname, "_SC_TYPED_MEMORY_OBJECTS")
macdef _SC_USER_GROUPS = $extval (sysconfname, "_SC_USER_GROUPS")
macdef _SC_USER_GROUPS_R = $extval (sysconfname, "_SC_USER_GROUPS_R")
macdef _SC_2_PBS = $extval (sysconfname, "_SC_2_PBS")
macdef _SC_2_PBS_ACCOUNTING = $extval (sysconfname, "_SC_2_PBS_ACCOUNTING")
macdef _SC_2_PBS_LOCATE = $extval (sysconfname, "_SC_2_PBS_LOCATE")
macdef _SC_2_PBS_MESSAGE = $extval (sysconfname, "_SC_2_PBS_MESSAGE")
macdef _SC_2_PBS_TRACK = $extval (sysconfname, "_SC_2_PBS_TRACK")
macdef _SC_SYMLOOP_MAX = $extval (sysconfname, "_SC_SYMLOOP_MAX")
macdef _SC_STREAMS = $extval (sysconfname, "_SC_STREAMS")
macdef _SC_2_PBS_CHECKPOINT = $extval (sysconfname, "_SC_2_PBS_CHECKPOINT")
//
macdef _SC_V6_ILP32_OFF32 = $extval (sysconfname, "_SC_V6_ILP32_OFF32")
macdef _SC_V6_ILP32_OFFBIG = $extval (sysconfname, "_SC_V6_ILP32_OFFBIG")
macdef _SC_V6_LP64_OFF64 = $extval (sysconfname, "_SC_V6_LP64_OFF64")
macdef _SC_V6_LPBIG_OFFBIG = $extval (sysconfname, "_SC_V6_LPBIG_OFFBIG")
//
macdef _SC_HOST_NAME_MAX =
  $extval (sysconfname, "_SC_HOST_NAME_MAX")
macdef _SC_TRACE = $extval (sysconfname, "_SC_TRACE")
macdef _SC_TRACE_EVENT_FILTER =
  $extval (sysconfname, "_SC_TRACE_EVENT_FILTER")
macdef _SC_TRACE_INHERIT =
  $extval (sysconfname, "_SC_TRACE_INHERIT")
macdef _SC_TRACE_LOG = $extval (sysconfname, "_SC_TRACE_LOG")
//
macdef _SC_LEVEL1_ICACHE_SIZE =
  $extval (sysconfname, "_SC_LEVEL1_ICACHE_SIZE")
macdef _SC_LEVEL1_ICACHE_ASSOC =
  $extval (sysconfname, "_SC_LEVEL1_ICACHE_ASSOC")
macdef _SC_LEVEL1_ICACHE_LINESIZE =
  $extval (sysconfname, "_SC_LEVEL1_ICACHE_LINESIZE")
macdef _SC_LEVEL1_DCACHE_SIZE =
  $extval (sysconfname, "_SC_LEVEL1_DCACHE_SIZE")
macdef _SC_LEVEL1_DCACHE_ASSOC =
  $extval (sysconfname, "_SC_LEVEL1_DCACHE_ASSOC")
macdef _SC_LEVEL1_DCACHE_LINESIZE =
  $extval (sysconfname, "_SC_LEVEL1_DCACHE_LINESIZE")
macdef _SC_LEVEL2_CACHE_SIZE =
  $extval (sysconfname, "_SC_LEVEL2_CACHE_SIZE")
macdef _SC_LEVEL2_CACHE_ASSOC =
  $extval (sysconfname, "_SC_LEVEL2_CACHE_ASSOC")
macdef _SC_LEVEL2_CACHE_LINESIZE =
  $extval (sysconfname, "_SC_LEVEL2_CACHE_LINESIZE")
macdef _SC_LEVEL3_CACHE_SIZE =
  $extval (sysconfname, "_SC_LEVEL3_CACHE_SIZE")
macdef _SC_LEVEL3_CACHE_ASSOC =
  $extval (sysconfname, "_SC_LEVEL3_CACHE_ASSOC")
macdef _SC_LEVEL3_CACHE_LINESIZE =
  $extval (sysconfname, "_SC_LEVEL3_CACHE_LINESIZE")
macdef _SC_LEVEL4_CACHE_SIZE =
  $extval (sysconfname, "_SC_LEVEL4_CACHE_SIZE")
macdef _SC_LEVEL4_CACHE_ASSOC =
  $extval (sysconfname, "_SC_LEVEL4_CACHE_ASSOC")
macdef _SC_LEVEL4_CACHE_LINESIZE =
  $extval (sysconfname, "_SC_LEVEL4_CACHE_LINESIZE")
//
macdef _SC_IPV6 = $extval (sysconfname, "_SC_IPV6")
macdef _SC_RAW_SOCKETS = $extval (sysconfname, "_SC_RAW_SOCKETS")
//
macdef _SC_V7_ILP32_OFF32 = $extval (sysconfname, "_SC_V7_ILP32_OFF32")
macdef _SC_V7_ILP32_OFFBIG = $extval (sysconfname, "_SC_V7_ILP32_OFFBIG")
macdef _SC_V7_LP64_OFF64 = $extval (sysconfname, "_SC_V7_LP64_OFF64")
macdef _SC_V7_LPBIG_OFFBIG = $extval (sysconfname, "_SC_V7_LPBIG_OFFBIG")
//
macdef _SC_SS_REPL_MAX = $extval (sysconfname, "_SC_SS_REPL_MAX")
//
macdef _SC_TRACE_EVENT_NAME_MAX =
  $extval (sysconfname, "_SC_TRACE_EVENT_NAME_MAX")
macdef _SC_TRACE_NAME_MAX =
  $extval (sysconfname, "_SC_TRACE_NAME_MAX")
macdef _SC_TRACE_SYS_MAX =
  $extval (sysconfname, "_SC_TRACE_SYS_MAX")
macdef _SC_TRACE_USER_EVENT_MAX =
  $extval (sysconfname, "_SC_TRACE_USER_EVENT_MAX")
//
macdef _SC_XOPEN_STREAMS =
  $extval (sysconfname, "_SC_XOPEN_STREAMS")
//
macdef _SC_THREAD_ROBUST_PRIO_INHERIT =
  $extval (sysconfname, "_SC_THREAD_ROBUST_PRIO_INHERIT")
macdef _SC_THREAD_ROBUST_PRIO_PROTEC =
  $extval (sysconfname, "_SC_THREAD_ROBUST_PRIO_PROTEC")

(* ****** ****** *)

(* end of [unistd_sysconf.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: April, 2012 *)

(* ****** ****** *)

%{#
#include "libc/CATS/unistd.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

#define SHR(x) x // SHARED // HX: for commenting
#define NSH(x) x // NSHARED // HX: for commenting

(* ****** ****** *)

typedef interr = int

(* ****** ****** *)
//
staload
TYPES =
"libc/sys/SATS/types.sats"
//
typedef off_t = $TYPES.off_t
//
typedef pid_t = $TYPES.pid_t
typedef uid_t = $TYPES.uid_t
typedef gid_t = $TYPES.gid_t
//
stadef fildes_v = $TYPES.fildes_v
//
vtypedef
fildes (i:int) = $TYPES.fildes (i)
//
vtypedef Fildes = $TYPES.Fildes
vtypedef Fildes0 = $TYPES.Fildes0
//
(* ****** ****** *)

macdef STDIN_FILENO = $extval(int, "STDIN_FILENO")
macdef STDOUT_FILENO = $extval(int, "STDOUT_FILENO")
macdef STDERR_FILENO = $extval(int, "STDERR_FILENO")

(* ****** ****** *)
/*
int close (int);
*/
symintr close
symintr close_exn
//
fun close0 (fd: int): interr = "mac#%"
//
// HX-2013-03-25: should this be moved to unistd.sats?
//
dataview
close_v (fd:int, int) =
  | close_v_succ (fd, 0) of ()
  | {i:int | i < 0} close_v_fail (fd, i) of fildes_v (fd)
//
fun close1{fd:nat}
  (fd: fildes (fd)): [i:int] (close_v (fd, i) | int i) = "mac#%"
//
overload close with close0
overload close with close1
//
fun close0_exn (fd: int): void = "ext#%"
fun close1_exn (fd: Fildes0):<!exn> void = "ext#%"
//
overload close_exn with close0_exn
overload close_exn with close1_exn
//
(* ****** ****** *)

fun dup (fildes: int): int = "mac#%"
fun dup_fildes (fd: !Fildes0): Fildes = "mac#%"

(* ****** ****** *)
//
fun dup2
  (fildes: int, fildes2: int): int = "mac#%"
//
// HX-2013-05:
// this one requires that [fd2] be not in use
//
fun dup2_fildes{fd2:nat}
  (fd: !Fildes0, fd2: int (fd2)): Fildes = "mac#%"
//
(* ****** ****** *)
//
// HX: this one requires -D_GNU_SOURCE
//
fun dup3
  (fildes: int, fildes2: int, flags: int): int = "mac#%"
//
(* ****** ****** *)

fun execv {n:pos}{l:addr}
(
  pf: !parray_v (string, l, n) | path: NSH(string), argv: ptr l
) : intLt(0) = "mac#atslib_execv"
fun execv_unsafe // HX: for failure, ~1 is returned
  (path: NSH(string), argv: ptr): intLt(0) = "mac#atslib_execv"

fun execvp {n:pos}{l:addr}
(
  pf: !parray_v (string, l, n) | fname: NSH(string), argv: ptr l
) : intLt(0) = "mac#atslib_execvp"
fun execvp_unsafe // HX: for failure, ~1 is returned
  (fname: NSH(string), argv: ptr): intLt(0) = "mac#atslib_execvp"

(* ****** ****** *)
/*
int execve(const char *filename, char *const argv[], char *const envp[]);
*/
fun execve
  {n1,n2:pos}{l1,l2:addr}
(
  pf1: !parray_v (string, l1, n1)
, pf2: !parray_v (string, l2, n2)
| fname: NSH(string), argv: ptr l1, envp: ptr l2
) : intLt(0) = "mac#atslib_execve"
fun execve_unsafe // HX: for failure, ~1 is returned
  (fname: NSH(string), argv: ptr, envp: ptr): intLt(0) = "mac#atslib_execve"
// end of [execve_unsafe]

(* ****** ****** *)

/*
void encrypt(char block[64], int edflag);
*/
fun encrypt
(
  block: &(@[char][64]), edflag: int
) :<!ref> void = "mac#%" // endfun

(* ****** ****** *)

fun fork ((*void*)): pid_t = "mac#%"

(* ****** ****** *)

dataview
getcwd_v
(
  m:int, l:addr, addr
) =
  | {l>null} {n:nat}
    getcwd_v_succ (m, l, l) of strbuf_v (l, m, n)
  | getcwd_v_fail (m, l, null) of b0ytes (m) @ (l)
// end of [getcwd_v]

fun getcwd
  {m:nat} {l:addr}
(
  pf: !b0ytes (m) @ l >> getcwd_v (m, l, l1) | p: ptr l, m: size_t m
) : #[l1:addr] ptr (l1) = "mac#%" // end of [getcwd]

fun getcwd_gc (): Strptr0 = "ext#%" // HX: this is a convenient function

(* ****** ****** *)
/*
pid_t getpid(void);
pid_t getppid(void);
*/
fun getpid ((*void*)): pid_t = "mac#%"
fun getppid ((*void*)): pid_t = "mac#%"
//
(* ****** ****** *)

fun getuid (): uid_t = "mac#%"
fun setuid (uid: uid_t): int = "mac#%"
fun geteuid (): uid_t = "mac#%"
fun seteuid (uid: uid_t): int = "mac#%"

(* ****** ****** *)

fun getgid (): gid_t = "mac#%"
fun setgid (gid: gid_t): int = "mac#%"
fun getegid (): gid_t = "mac#%"
fun setegid (gid: gid_t): int = "mac#%"
        
(* ****** ****** *)

fun setreuid (ruid: uid_t, euid: uid_t): int = "mac#%"
fun setregid (rgid: gid_t, egid: gid_t): int = "mac#%"

(* ****** ****** *)

fun setresuid (ruid: uid_t, euid: uid_t, suid: uid_t): int = "mac#%"
fun setresgid (rgid: gid_t, egid: gid_t, sgid: gid_t): int = "mac#%"
          
(* ****** ****** *)
//
// HX: these are linux-specific!
//
fun setfsuid(fsuid: uid_t): int = "mac#%"
fun setfsgid(fsgid: gid_t): int = "mac#%"
//
(* ****** ****** *)

fun getlogin (): vStrptr0 = "mac#%"
fun getlogin_r{n:int | n >= 2}
  (buf: &bytes(n), n: size_t n): int = "mac#%"
fun getlogin_r_gc (): Strptr0 = "ext#%"

(* ****** ****** *)
//
// HX: [pause] can only returns -1
//
fun pause ((*void*)): int = "mac#%"
//
(* ****** ****** *)

fun read_err
  {sz,n:nat | n <= sz}
(
  fd: !Fildes0
, buf: &b0ytes(sz) >> bytes(sz), ntotal: size_t(n)
) : ssizeBtw(~1, n+1) = "mac#%" // end-of-fun

fun write_err
  {sz,n:nat | n <= sz}
(
  fd: !Fildes0, buf: &RD(bytes(sz)), ntotal: size_t(n)
) : ssizeBtw(~1, n+1) = "mac#%" // end-of-fun

(* ****** ****** *)

fun pread{n:int}
(
  fd: !Fildes0, buf: &(@[byte][n])>>_, n: size_t (n), ofs: off_t
) : ssize_t = "mac#%" // end of [pread]

fun pwrite{n:int}
(
  fd: !Fildes0, buf: &RD(array(byte, n)), n: size_t (n), ofs: off_t
) : ssize_t = "mac#%" // end of [pwrite]

(* ****** ****** *)
//
absview
alarm_v (n: int) // n: remaining seconds
//
praxi alarm_v_elim (pf: alarm_v (0)): void
//
fun
alarm_set{i:int}
  (t: uint i): (alarm_v (i) | uInt) = "mac#%"
// end of [alarm_set]
fun
alarm_cancel{i:int}
  (pf: alarm_v (i) | (*none*)): uInt = "mac#%"
// end of [alarm_cancel]
//
(* ****** ****** *)
//
// HX: [sleep] may be implemented using SIGARM
//
symintr sleep
//
fun sleep_int
  {i:nat} (t: int i): [j:nat | j <= i] int j = "mac#%"
fun sleep_uint
  {i:int} (t: uint i): [j:nat | j <= i] uint j = "mac#%"
//
overload sleep with sleep_int
overload sleep with sleep_uint
//
(* ****** ****** *)
//
// HX: some systems require that the argument <= 1 million
//
symintr usleep
//
fun usleep_int // succ/fail: 0/~1
  {i:nat | i <= 1000000} (n: int i): intLte(0) = "mac#%"
fun usleep_uint // succ/fail: 0/~1
  {i:int | i <= 1000000} (n: uint i): intLte(0) = "mac#%"
//
overload usleep with usleep_int
overload usleep with usleep_uint
//
(* ****** ****** *)

/*
int rmdir(const char *pathname);
*/
fun rmdir (path: NSH(string)): int = "mac#%"
fun rmdir_exn (path: NSH(string)): void = "ext#%"

(* ****** ****** *)
/*
int link(const char *old, const char *new)
*/
fun link
(
  old: NSH(string)
, new: NSH(string)
) :<!ref> intLte(0) = "mac#%"
fun link_exn
  (old: NSH(string), new: NSH(string)):<!ref> void = "ext#%"
//
(* ****** ****** *)
/*
int symlink(const char *old, const char *new)
*/
fun symlink
(
  old: NSH(string)
, new: NSH(string)
) :<!ref> intLte(0) = "mac#%"
fun symlink_exn
  (old: NSH(string), new: NSH(string)):<!ref> void = "ext#%"
//
(* ****** ****** *)
/*
int unlink(const char *pathname);
*/
fun unlink (path: NSH(string)):<!ref> intLte(0) = "mac#%"
fun unlink_exn (path: NSH(string)):<!exnref> void = "ext#%"

(* ****** ****** *)

fun readlink{n:int}
(
  path: NSH(string), buf: &(@[byte][n]) >> _, n: size_t (n)
) : ssizeLte(n) = "mac#%" // end of [readlink]

fun readlink_gc (path: NSH(string)): Strptr0 = "ext#%"

(* ****** ****** *)

fun sync ((*void*)): void = "mac#%"
fun fsync (fd: !Fildes0): int = "mac#%"
fun fdatasync (fd: !Fildes0): int = "mac#%"

(* ****** ****** *)
//
fun truncate
  (path: NSH(string), ofs: off_t): int = "mac#%"
//
fun ftruncate (fd: !Fildes0, ofs: off_t): int = "mac#%"
//
(* ****** ****** *)

#include "./unistd_sysconf.sats"
#include "./unistd_pathconf.sats"

(* ****** ****** *)

(* end of [unistd.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: April, 2012 *)

(* ****** ****** *)

typedef pathconfname = int

(* ****** ****** *)
//
fun pathconf
  (path: NSH(string), name: pathconfname): lint = "mac#%"
//
fun fpathconf (fd: int, name: pathconfname): lint = "mac#%"
//
(* ****** ****** *)

macdef _PC_LINK_MAX = $extval (pathconfname, "_PC_LINK_MAX")
macdef _PC_MAX_CANON = $extval (pathconfname, "_PC_MAX_CANON")
macdef _PC_MAX_INPUT = $extval (pathconfname, "_PC_MAX_INPUT")
macdef _PC_NAME_MAX = $extval (pathconfname, "_PC_NAME_MAX")
macdef _PC_PATH_MAX = $extval (pathconfname, "_PC_PATH_MAX")
macdef _PC_PIPE_BUF = $extval (pathconfname, "_PC_PIPE_BUF")
macdef _PC_CHOWN_RESTRICTED = $extval (pathconfname, "_PC_CHOWN_RESTRICTED")
macdef _PC_NO_TRUNC = $extval (pathconfname, "_PC_NO_TRUNC")
macdef _PC_VDISABLE = $extval (pathconfname, "_PC_VDISABLE")
macdef _PC_SYNC_IO = $extval (pathconfname, "_PC_SYNC_IO")
macdef _PC_ASYNC_IO = $extval (pathconfname, "_PC_ASYNC_IO")
macdef _PC_PRIO_IO = $extval (pathconfname, "_PC_PRIO_IO")
macdef _PC_SOCK_MAXBUF = $extval (pathconfname, "_PC_SOCK_MAXBUF")
macdef _PC_FILESIZEBITS = $extval (pathconfname, "_PC_FILESIZEBITS")
macdef _PC_REC_INCR_XFER_SIZE = $extval (pathconfname, "_PC_REC_INCR_XFER_SIZE")
macdef _PC_REC_MAX_XFER_SIZE = $extval (pathconfname, "_PC_REC_MAX_XFER_SIZE")
macdef _PC_REC_MIN_XFER_SIZE = $extval (pathconfname, "_PC_REC_MIN_XFER_SIZE")
macdef _PC_REC_XFER_ALIGN = $extval (pathconfname, "_PC_REC_XFER_ALIGN")
macdef _PC_ALLOC_SIZE_MIN = $extval (pathconfname, "_PC_ALLOC_SIZE_MIN")
macdef _PC_SYMLINK_MAX = $extval (pathconfname, "_PC_SYMLINK_MAX")
macdef _PC_2_SYMLINK = $extval (pathconfname, "_PC_2_SYMLINK")

(* ****** ****** *)

(* end of [unistd_pathconf.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: April, 2013
//
(* ****** ****** *)

%{#
#include "libc/CATS/math.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

#define RD(x) x // for commenting: read-only
#define NSH(x) x // for commenting: no sharing
#define SHR(x) x // for commenting: it is shared

(* ****** ****** *)

macdef M_E = 2.7182818284590452354	// e
macdef M_PI = 3.14159265358979323846	// pi
macdef M_PI_2 = 1.57079632679489661923	// pi/2
macdef M_PI_4 = 0.78539816339744830962	// pi/4

(* ****** ****** *)

macdef INFINITY = $extval (float, "INFINITY")

(* ****** ****** *)
//
// _XOPEN_SOURCE >= 600 || ...
//
fun{a:t0p} isfinite (x: INV(a)):<> int
fun isfinite_float (x: float):<> int = "mac#%"
fun isfinite_double (x: double):<> int = "mac#%"
fun isfinite_ldouble (x: ldouble):<> int = "mac#%"
//
fun{a:t0p} isnormal (x: INV(a)):<> int
fun isnormal_float (x: float):<> int = "mac#%"
fun isnormal_double (x: double):<> int = "mac#%"
fun isnormal_ldouble (x: ldouble):<> int = "mac#%"
//
fun{a:t0p} fpclassify (x: INV(a)):<> int
fun fpclassify_float (x: float):<> int = "mac#%"
fun fpclassify_double (x: double):<> int = "mac#%"
fun fpclassify_ldouble (x: ldouble):<> int = "mac#%"

(* ****** ****** *)
//
// _BSD_SOURCE || _XOPEN_SOURCE || ...
//
fun{a:t0p} isnan (x: INV(a)):<> int
fun isnan_float (x: float):<> int = "mac#%"
fun isnan_double (x: double):<> int = "mac#%"
fun isnan_ldouble (x: ldouble):<> int = "mac#%"
//
(* ****** ****** *)
//
// _BSD_SOURCE || _XOPEN_SOURCE >= 600 || ...
//
fun{a:t0p} isinf (x: INV(a)):<> int
fun isinf_float (x: float):<> int = "mac#%"
fun isinf_double (x: double):<> int = "mac#%"
fun isinf_ldouble (x: ldouble):<> int = "mac#%"
//
(* ****** ****** *)
//
fun{a:t0p} ceil (x: INV(a)):<> a
//
fun ceil_float (x: float):<> float = "mac#%"
fun ceil_double (x: double):<> double = "mac#%"
fun ceil_ldouble (x: ldouble):<> ldouble = "mac#%"
//
(* ****** ****** *)
//
fun{a:t0p} floor (x: INV(a)):<> a
//
fun floor_float (x: float):<> float = "mac#%"
fun floor_double (x: double):<> double = "mac#%"
fun floor_ldouble (x: ldouble):<> ldouble = "mac#%"
//
(* ****** ****** *)
//
fun{a:t0p} round (x: INV(a)):<> a
//
fun round_float (x: float):<> float = "mac#%"
fun round_double (x: double):<> double = "mac#%"
fun round_ldouble (x: ldouble):<> ldouble = "mac#%"
//
(* ****** ****** *)
//
fun{a:t0p} trunc (x: INV(a)):<> a
//
fun trunc_float (x: float):<> float = "mac#%"
fun trunc_double (x: double):<> double = "mac#%"
fun trunc_ldouble (x: ldouble):<> ldouble = "mac#%"
//
(* ****** ****** *)

fun{
a:t0p
} fmod (x1: INV(a), x2: a):<> a
fun fmod_float (x1: float, x2: float):<> float = "mac#%"
fun fmod_double (x1: double, x2: double):<> double = "mac#%"
fun fmod_ldouble (x1: ldouble, x2: ldouble):<> ldouble = "mac#%"

(* ****** ****** *)
//
fun{
a:t0p
} fmax (x1: INV(a), x2: a):<> a
fun fmax_float (x1: float, x2: float):<> float = "mac#%"
fun fmax_double (x1: double, x2: double):<> double = "mac#%"
fun fmax_ldouble (x1: ldouble, x2: ldouble):<> ldouble = "mac#%"
//
fun{
a:t0p
} fmin (x1: INV(a), x2: a):<> a
fun fmin_float (x1: float, x2: float):<> float = "mac#%"
fun fmin_double (x1: double, x2: double):<> double = "mac#%"
fun fmin_ldouble (x1: ldouble, x2: ldouble):<> ldouble = "mac#%"
//
(* ****** ****** *)

fun{
a:t0p
} fdim (x1: INV(a), x2: a):<> a
fun fdim_float (x1: float, x2: float):<> float = "mac#%"
fun fdim_double (x1: double, x2: double):<> double = "mac#%"
fun fdim_ldouble (x1: ldouble, x2: ldouble):<> ldouble = "mac#%"

(* ****** ****** *)
//
// HX: fma (x, y, z) = x * y + z
//
fun{a:t0p} fma (x1: INV(a), x2: a, x3: a):<> a
fun fma_float (x1: float, x2: float, x3: float):<> float = "mac#%"
fun fma_double (x1: double, x2: double, x3: double):<> double = "mac#%"
fun fma_ldouble (x1: ldouble, x2: ldouble, x3: ldouble):<> ldouble = "mac#%"
//
(* ****** ****** *)

fun{a:t0p} sqrt (x: INV(a)):<> a
fun sqrt_float (f: float):<> float = "mac#%"
fun sqrt_double (d: double):<> double = "mac#%"
fun sqrt_ldouble (ld: ldouble):<> ldouble = "mac#%"

(* ****** ****** *)

fun{a:t0p} cbrt (x: INV(a)):<> a
fun cbrt_float (f: float):<> float = "mac#%"
fun cbrt_double (d: double):<> double = "mac#%"
fun cbrt_ldouble (ld: ldouble):<> ldouble = "mac#%"

(* ****** ****** *)

fun{a:t0p} pow (x1: INV(a), x2: a):<> a
fun pow_float (x1: float, x2: float):<> float = "mac#%"
fun pow_double (x1: double, x2: double):<> double = "mac#%"
fun pow_ldouble (x1: ldouble, x2: ldouble):<> ldouble = "mac#%"

(* ****** ****** *)

fun{a:t0p} exp (x: INV(a)):<> a
fun exp_float (f: float):<> float = "mac#%"
fun exp_double (d: double):<> double = "mac#%"
fun exp_ldouble (ld: ldouble):<> ldouble = "mac#%"

(* ****** ****** *)

fun{a:t0p} log (x: INV(a)):<> a
fun log_float (f: float):<> float = "mac#%"
fun log_double (d: double):<> double = "mac#%"
fun log_ldouble (ld: ldouble):<> ldouble = "mac#%"

fun{a:t0p} log10 (x: INV(a)):<> a
fun log10_float (f: float):<> float = "mac#%"
fun log10_double (d: double):<> double = "mac#%"
fun log10_ldouble (ld: ldouble):<> ldouble = "mac#%"

(* ****** ****** *)

fun{a:t0p} sin (x: INV(a)):<> a
fun sin_float (x: float):<> float = "mac#%"
fun sin_double (x: double):<> double = "mac#%"
fun sin_ldouble (x: ldouble):<> ldouble = "mac#%"

fun{a:t0p} cos (x: INV(a)):<> a
fun cos_float (x: float):<> float = "mac#%"
fun cos_double (x: double):<> double = "mac#%"
fun cos_ldouble (x: ldouble):<> ldouble = "mac#%"

fun{a:t0p} tan (x: INV(a)):<> a
fun tan_float (x: float):<> float = "mac#%"
fun tan_double (x: double):<> double = "mac#%"
fun tan_ldouble (x: ldouble):<> ldouble = "mac#%"

(* ****** ****** *)

fun{a:t0p} asin (x: INV(a)):<> a
fun asin_float (x: float):<> float = "mac#%"
fun asin_double (x: double):<> double = "mac#%"
fun asin_ldouble (x: ldouble):<> ldouble = "mac#%"

fun{a:t0p} acos (x: INV(a)):<> a
fun acos_float (x: float):<> float = "mac#%"
fun acos_double (x: double):<> double = "mac#%"
fun acos_ldouble (x: ldouble):<> ldouble = "mac#%"

fun{a:t0p} atan (x: INV(a)):<> a
fun atan_float (x: float):<> float = "mac#%"
fun atan_double (x: double):<> double = "mac#%"
fun atan_ldouble (x: ldouble):<> ldouble = "mac#%"

fun{a:t0p} atan2 (x1: INV(a), x2: a):<> a
fun atan2_float (x1: float, x2: float):<> float = "mac#%"
fun atan2_double (x1: double, x2: double):<> double = "mac#%"
fun atan2_ldouble (x1: ldouble, x2: ldouble):<> ldouble = "mac#%"

(* ****** ****** *)

fun{a:t0p} sinh (x: INV(a)):<> a
fun sinh_float (x: float):<> float = "mac#%"
fun sinh_double (x: double):<> double = "mac#%"
fun sinh_ldouble (x: ldouble):<> ldouble = "mac#%"

fun{a:t0p} cosh (x: INV(a)):<> a
fun cosh_float (x: float):<> float = "mac#%"
fun cosh_double (x: double):<> double = "mac#%"
fun cosh_ldouble (x: ldouble):<> ldouble = "mac#%"

fun{a:t0p} tanh (x: INV(a)):<> a
fun tanh_float (x: float):<> float = "mac#%"
fun tanh_double (x: double):<> double = "mac#%"
fun tanh_ldouble (x: ldouble):<> ldouble = "mac#%"

(* ****** ****** *)

fun{a:t0p} asinh (x: INV(a)):<> a
fun asinh_float (x: float):<> float = "mac#%"
fun asinh_double (x: double):<> double = "mac#%"
fun asinh_ldouble (x: ldouble):<> ldouble = "mac#%"

fun{a:t0p} acosh (x: INV(a)):<> a
fun acosh_float (x: float):<> float = "mac#%"
fun acosh_double (x: double):<> double = "mac#%"
fun acosh_ldouble (x: ldouble):<> ldouble = "mac#%"

fun{a:t0p} atanh (x: INV(a)):<> a
fun atanh_float (x: float):<> float = "mac#%"
fun atanh_double (x: double):<> double = "mac#%"
fun atanh_ldouble (x: ldouble):<> ldouble = "mac#%"

(* ****** ****** *)

(* end of [math.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: March, 2013
//
(* ****** ****** *)

%{#
#include "libc/CATS/errno.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

vtypedef
RD(a:vt0p) = a // for commenting: read-only
#define NSH(x) x // for commenting: no sharing
#define SHR(x) x // for commenting: it is shared

(* ****** ****** *)

typedef errno_t = int

(* ****** ****** *)
//
macdef ENONE = $extval (errno_t, "ENONE") // = 0
//
macdef E2BIG = $extval (errno_t, "E2BIG") // POSIX.1
macdef EACCES = $extval (errno_t, "EACCES") // POSIX.1
macdef EADDRINUSE = $extval (errno_t, "EADDRINUSE") // POSIX.1
macdef EADDRNOTAVAIL = $extval (errno_t, "EADDRNOTAVAIL") // POSIX.1
macdef EAGAIN = $extval (errno_t, "EAGAIN") // POSIX.1
macdef EALREADY = $extval (errno_t, "EALREADY") // POSIX.1
macdef EBADE = $extval (errno_t, "EBADE")
macdef EBADF = $extval (errno_t, "EBADF") // POSIX.1
macdef EBADFD = $extval (errno_t, "EBADFD")
macdef EBADMSG = $extval (errno_t, "EBADMSG") // POSIX.1
macdef EBADR = $extval (errno_t, "EBADR")
macdef EBUSY = $extval (errno_t, "EBUSY") // POSIX.1
macdef ECANCELED = $extval (errno_t, "ECANCELED") // POSIX.1
macdef ECHILD = $extval (errno_t, "ECHILD") // POSIX.1
macdef ECONNABORTED = $extval (errno_t, "ECONNABORTED") // POSIX.1
macdef ECONNREFUSED = $extval (errno_t, "ECONNREFUSED") // POSIX.1
macdef ECONNRESET = $extval (errno_t, "ECONNRESET") // POSIX.1
macdef EDEADLK = $extval (errno_t, "EDEADLK") // POSIX.1
macdef EDEADLOCK = $extval (errno_t, "EDEADLOCK") // POSIX.1
macdef EDESTADDRREQ = $extval (errno_t, "EDESTADDRREQ") // POSIX.1
macdef EDOM = $extval (errno_t, "EDOM") // POSIX.1 // C99
macdef EDQUOT = $extval (errno_t, "EDQUOT") // POSIX.1
macdef EEXIST = $extval (errno_t, "EEXIST") // POSIX.1
macdef EFAULT = $extval (errno_t, "EFAULT") // POSIX.1
macdef EFBIG = $extval (errno_t, "EFBIG") // POSIX.1
macdef EHOSTDOWN = $extval (errno_t, "EHOSTDOWN")
macdef EHOSTUNREACH = $extval (errno_t, "EHOSTUNREACH") // POSIX.1
macdef EIDRM = $extval (errno_t, "EIDRM") // POSIX.1
macdef EILSEQ = $extval (errno_t, "EILSEQ") // POSIX.1 // C99
macdef EINPROGRESS = $extval (errno_t, "EINPROGRESS") // POSIX.1
macdef EINTR = $extval (errno_t, "EINTR") // POSIX.1
macdef EINVAL = $extval (errno_t, "EINVAL") // POSIX.1
macdef EIO = $extval (errno_t, "EIO") // POSIX.1
macdef EISCONN = $extval (errno_t, "EISCONN") // POSIX.1
macdef EISDIR = $extval (errno_t, "EISDIR") // POSIX.1
macdef ELOOP = $extval (errno_t, "ELOOP") // POSIX.1
macdef EMFILE = $extval (errno_t, "EMFILE") // POSIX.1
macdef EMLINK = $extval (errno_t, "EMLINK") // POSIX.1
macdef EMSGSIZE = $extval (errno_t, "EMSGSIZE") // POSIX.1
macdef EMULTIHOP = $extval (errno_t, "EMULTIHOP") // POSIX.1
macdef ENAMETOOLONG = $extval (errno_t, "ENAMETOOLONG") // POSIX.1
macdef ENETDOWN = $extval (errno_t, "ENETDOWN") // POSIX.1
macdef ENETRESET = $extval (errno_t, "ENETRESET") // POSIX.1
macdef ENETUNREACH = $extval (errno_t, "ENETUNREACH") // POSIX.1
macdef ENFILE = $extval (errno_t, "ENFILE") // POSIX.1
macdef ENOBUFS = $extval (errno_t, "ENOBUFS") // POSIX.1
macdef ENODATA = $extval (errno_t, "ENODATA") // POSIX.1
macdef ENODEV = $extval (errno_t, "ENODEV") // POSIX.1
macdef ENOENT = $extval (errno_t, "ENOENT") // POSIX.1
macdef ENOEXEC = $extval (errno_t, "ENOEXEC") // POSIX.1
macdef ENOLCK = $extval (errno_t, "ENOLCK") // POSIX.1
macdef ENOLINK = $extval (errno_t, "ENOLINK") // POSIX.1
macdef ENOMEM = $extval (errno_t, "ENOMEM") // POSIX.1
macdef ENOMSG = $extval (errno_t, "ENOMSG") // POSIX.1
macdef ENOPROTOOPT = $extval (errno_t, "ENOPROTOOPT") // POSIX.1
macdef ENOSPC = $extval (errno_t, "ENOSPC") // POSIX.1
macdef ENOSR = $extval (errno_t, "ENOSR") // POSIX.1
macdef ENOSTR = $extval (errno_t, "ENOSTR") // POSIX.1
macdef ENOSYS = $extval (errno_t, "ENOSYS") // POSIX.1
macdef ENOTCONN = $extval (errno_t, "ENOTCONN") // POSIX.1
macdef ENOTDIR = $extval (errno_t, "ENOTDIR") // POSIX.1
macdef ENOTEMPTY = $extval (errno_t, "ENOTEMPTY") // POSIX.1
macdef ENOTSOCK = $extval (errno_t, "ENOTSOCK") // POSIX.1
macdef ENOTSUP = $extval (errno_t, "ENOTSUP") // POSIX.1
macdef ENOTTY = $extval (errno_t, "ENOTTY") // POSIX.1
macdef ENXIO = $extval (errno_t, "ENXIO") // POSIX.1
macdef EOPNOTSUPP = $extval (errno_t, "EOPNOTSUPP") // POSIX.1
macdef EOVERFLOW = $extval (errno_t, "EOVERFLOW") // POSIX.1
macdef EPERM = $extval (errno_t, "EPERM") // POSIX.1
macdef EPIPE = $extval (errno_t, "EPIPE") // POSIX.1
macdef EPFNOSUPPORT = $extval (errno_t, "EPFNOSUPPORT")
macdef EPROTO = $extval (errno_t, "EPROTO") // POSIX.1
macdef EPROTONOSUPPORT = $extval (errno_t, "EPROTONOSUPPORT") // POSIX.1
macdef EPROTOTYPE = $extval (errno_t, "EPROTOTYPE") // POSIX.1
macdef ERANGE = $extval (errno_t, "ERANGE") // C99 // POSIX.1
macdef EREMCHG = $extval (errno_t, "EREMCHG")
macdef EREMOTE = $extval (errno_t, "EREMOTE")
macdef EREMOTEIO = $extval (errno_t, "EREMOTEIO")
macdef ERESTART = $extval (errno_t, "ERESTART")
macdef EROFS = $extval (errno_t, "EROFS") // POSIX.1
macdef ESHUTDOWN = $extval (errno_t, "ESHUTDOWN")
macdef ESPIPE = $extval (errno_t, "ESPIPE") // POSIX.1
macdef ESOCKTNOSUPPORT = $extval (errno_t, "ESOCKTNOSUPPORT")
macdef ESRCH = $extval (errno_t, "ESRCH") // POSIX.1
macdef ESTALE = $extval (errno_t, "ESTALE") // POSIX.1
macdef ESTRPIPE = $extval (errno_t, "ESTRPIPE")
macdef ETIME = $extval (errno_t, "ETIME")
macdef ETIMEDOUT = $extval (errno_t, "ETIMEDOUT")
macdef ETXTBSY = $extval (errno_t, "ETXTBSY")
macdef EUCLEAN = $extval (errno_t, "EUCLEAN")
macdef EUNATCH = $extval (errno_t, "EUNATCH")
macdef EUSERS = $extval (errno_t, "EUSERS")
macdef EWOULDBLOCK = $extval (errno_t, "EWOULDBLOCK") // POSIX.1
macdef EXDEV = $extval (errno_t, "EXDEV")
macdef EXFULL = $extval (errno_t, "EXFULL")

(* ****** ****** *)
//
// HX: these functions are reentrant!
//
fun the_errno_get ():<> errno_t = "mac#%"
fun the_errno_set (eno: errno_t):<> void = "mac#%"
//
fun the_errno_reset ():<> void = "mac#%"
//
fun the_errno_test (errno_t):<> bool = "mac#%"
//
(* ****** ****** *)

(* end of [errno.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: March, 2013
//
(* ****** ****** *)

%{#
#include "libc/CATS/malloc.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

#define NSH (x) x // for commenting: no sharing
#define SHR (x) x // for commenting: it is shared

(* ****** ****** *)
//
abst@ype
mallopt_param = int
//
macdef M_MXFAST = $extval (mallopt_param, "M_MXFAST")
macdef M_TRIM_THRESHOLD = $extval (mallopt_param, "M_TRIM_THRESHOLD")
macdef M_TOP_PAD = $extval (mallopt_param, "M_TOP_PAD")
macdef M_MMAP_THRESHOLD = $extval (mallopt_param, "M_MMAP_THRESHOLD")
macdef M_MMAP_MAX = $extval (mallopt_param, "M_MMAP_MAX")
macdef M_CHECK_ACTION = $extval (mallopt_param, "M_CHECK_ACTION")
//
(* ****** ****** *)

fun mallopt
(
  param: mallopt_param, value: int(*bsz*)
) : int = "mac#%" // endfun // succ/fail: 1/0

(* ****** ****** *)

fun malloc_trim
  (pad: size_t): int (*1/0:some/none*) = "mac#%"

(* ****** ****** *)

fun malloc_usable_size
  {l:addr} (!mfree_libc_v l | ptr l): size_t = "mac#%"
// end of [malloc_usable_size]

(* ****** ****** *)

fun malloc_stats (): void = "mac#%" // it outputs to stderr

(* ****** ****** *)

(*
fun malloc_get_state (): ptr = "mac#%"
fun malloc_set_state (ptr: ptr): int = "mac#%"
*)

(* ****** ****** *)

(* end of [malloc.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: March, 2013
//
(* ****** ****** *)

%{#
#include "libc/CATS/dirent.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

#define RD(x) x // for commenting: read-only
#define NSH(x) x // for commenting: no sharing
#define SHR(x) x // for commenting: it is shared

(* ****** ****** *)

staload
TYPES = "libc/sys/SATS/types.sats"
typedef ino_t = $TYPES.ino_t
typedef off_t = $TYPES.off_t

(* ****** ****** *)

(*
abst@ype
DIR_t0ype = $extype"atslib_DIR_type" // = DIR
typedef DIR = DIR_t0ype
*)
absvtype DIRptr_vtype (l:addr)  = ptr
vtypedef DIRptr (l:addr) = DIRptr_vtype (l)
vtypedef DIRptr0 = [l:addr | l >= null] DIRptr (l)
vtypedef DIRptr1 = [l:addr | l >  null] DIRptr (l)

absview DIR_view (l:addr)
viewdef DIR_v (l:addr) = DIR_view (l)

(* ****** ****** *)

praxi
DIRptr_free_null (dirp: DIRptr (null)): void

(* ****** ****** *)

castfn
DIRptr2ptr{l:addr} (dirp: !DIRptr l):<> ptr (l)
overload ptrcast with DIRptr2ptr

(* ****** ****** *)

abst@ype
dirent_t0ype =
$extype"atslib_dirent_type" // = struct dirent
typedef dirent = dirent_t0ype

(* ****** ****** *)

fun{}
dirent$PC_NAME_MAX (): intGte(0) // HX: default=256

(* ****** ****** *)

absvtype direntp_vtype (l:addr) = ptr
vtypedef direntp (l:addr) = direntp_vtype (l)
vtypedef Direntp0 = [l:addr] direntp (l)
vtypedef Direntp1 = [l:addr | l > null] direntp (l)

(* ****** ****** *)
//
castfn
direntp2ptr{l:addr} (x: !direntp (l)):<> ptr (l)
overload ptrcast with direntp2ptr
//
(* ****** ****** *)

castfn
direntp_get_viewptr{l:agz}
(
  x: !direntp l
) :<> (
  dirent @ l, minus (direntp l, dirent @ l) | ptr l
) // end of [direntp_get_viewptr]

praxi
direntp_free_null (direntp (null)): void

fun direntp_free (x: Direntp0): void = "mac#%"

(* ****** ****** *)

fun dirent_get_d_ino (ent: &RD(dirent)):<> ino_t = "mac#%"

(* ****** ****** *)
//
fun
dirent_get_d_name
  (ent: &RD(dirent)):<> vStrptr1 = "mac#%"
fun{}
dirent_get_d_name_gc (ent: &RD(dirent)):<!wrt> Strptr1
//
(* ****** ****** *)
//
fun
direntp_get_d_name
  (entp: !Direntp1):<> vStrptr1 = "mac#%"
fun{}
direntp_get_d_name_gc (entp: !Direntp1):<!wrt> Strptr1
//
(* ****** ****** *)
//
fun{}
compare_dirent_string
  (ent: &RD(dirent), str: NSH(string)):<> int
//
(* ****** ****** *)

fun opendir (dname: NSH(string)): DIRptr0 = "mac#%"
fun opendir_exn (dname: NSH(string)): DIRptr1 = "ext#%"

(* ****** ****** *)

fun closedir{l:agz}
(
  dirp: !DIRptr (l) >> ptr l
) :<!wrt>
  [i:int | i <= 0]
(
  option_v (DIR_v (l), i < 0) | int i
) = "mac#%" // end of [closedir]

fun closedir_exn (dirp: DIRptr1):<!exnwrt> void = "ext#%"

(* ****** ****** *)

fun readdir
(
  dirp: !DIRptr1
) :<!refwrt> [l:addr]
(
  option_v (vtakeout0 (dirent@l), l > null) | ptr (l)
) = "mac#%" // end of [readdir]

(* ****** ****** *)

fun readdir_r
(
  dirp: !DIRptr1
, ent: &dirent? >> opt (dirent, l > null)
, result: &ptr? >> ptr(l)
) :<!wrt> #[l:addr;i:int | i >= 0] int(i) = "mac#%"

fun{} readdir_r_gc (dirp: !DIRptr1): Direntp0

(* ****** ****** *)

/*
int scandir
(
  const char *dirp
, struct dirent ***namelist
, int (*filter)(const struct dirent *)
, int (*compar)(const struct dirent **, const struct dirent**)
) ;
*/
fun scandir
(
  dirp: NSH(string)
, namelst: &(ptr?) >> ptr(*direntpp*)
, filter: (&dirent) -> int
, compar: (&ptr(*direntp*), &ptr(*direntp*)) -> int
) : int = "mac#%" // endfun

fun alphasort // POSIX-2008
  (entp1: &ptr, entp2: &ptr):<> int = "mac#%"
fun versionsort // GNU-extension
  (entp1: &ptr, entp2: &ptr):<> int = "mac#%"

(* ****** ****** *)

fun rewinddir (dirp: !DIRptr1): void = "mac#%"

(* ****** ****** *)

fun seekdir
  (dirp: !DIRptr1, off: off_t): void = "mac#%"
// end of [seekdir]

(* ****** ****** *)

fun telldir (dirp: !DIRptr1): off_t = "mac#%"

(* ****** ****** *)

(* end of [dirent.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: July, 2012
//
(* ****** ****** *)

typedef
size_t0ype = g0uint(size_kind)

(* ****** ****** *)

abst@ype
wchar_t0ype = $extype"wchar_t"
abst@ype
ptrdiff_t0ype = $extype"ptrdiff_t"

(* ****** ****** *)

typedef size = size_t0ype
typedef size_t = size_t0ype
typedef wchar = wchar_t0ype
typedef wchar_t = wchar_t0ype
typedef ptrdiff = ptrdiff_t0ype
typedef ptrdiff_t = ptrdiff_t0ype

(* ****** ****** *)

(* end of [stddef.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: March, 2013
//
(* ****** ****** *)

%{#
#include "libc/CATS/strings.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

#define NSH (x) x // for commenting: no sharing
#define SHR (x) x // for commenting: it is shared

(* ****** ****** *)

symintr index
fun index_int (s: string, c: int): Ptr0 = "mac#%"
fun index_char (s: string, c: char): Ptr0 = "mac#%"
overload index with index_int
overload index with index_char

(* ****** ****** *)

symintr rindex
fun rindex_int (s: string, c: int): Ptr0 = "mac#%"
fun rindex_char (s: string, c: char): Ptr0 = "mac#%"
overload rindex with rindex_int
overload rindex with rindex_char

(* ****** ****** *)
                      
fun strcasecmp (x1: string, x2: string):<> int = "mac#%"
fun strncasecmp (x1: string, x2: string, n: size_t):<> int = "mac#%"

(* ****** ****** *)

(* end of [strings.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: November, 2014
//
(* ****** ****** *)

%{#
#include "libc/netinet/CATS/in.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)
//
staload
SOCKET = "libc/sys/SATS/socket.sats"  
typedef sa_family_t = $SOCKET.sa_family_t
typedef socklen_t(n:int) = $SOCKET.socklen_t(n)
typedef sockaddr_struct(n:int) = $SOCKET.sockaddr_struct(n)
//
(* ****** ****** *)

stadef socklen_max = $SOCKET.socklen_max

(* ****** ****** *)
//
abst@ype
in_port_t = $extype"in_port_t"
//
abst@ype
in_port_nbo_t = $extype"in_port_t"
//
(* ****** ****** *)
//
abst@ype in_addr_hbo_t = $extype"in_addr_t"
abst@ype in_addr_nbo_t = $extype"in_addr_t"
//
(* ****** ****** *)
//
abst@ype
ipproto_t = int
//
macdef IPPROTO_IP = $extval (ipproto_t, "IPPROTO_IP")
macdef IPPROTO_HOPOPTS = $extval (ipproto_t, "IPPROTO_HOPOPTS")
macdef IPPROTO_ICMP = $extval (ipproto_t, "IPPROTO_ICMP")
macdef IPPROTO_IGMP = $extval (ipproto_t, "IPPROTO_IGMP")
macdef IPPROTO_IPIP = $extval (ipproto_t, "IPPROTO_IPIP")
macdef IPPROTO_TCP = $extval (ipproto_t, "IPPROTO_TCP")
macdef IPPROTO_EGP = $extval (ipproto_t, "IPPROTO_EGP")
macdef IPPROTO_PUP = $extval (ipproto_t, "IPPROTO_PUP")
macdef IPPROTO_UDP = $extval (ipproto_t, "IPPROTO_UDP")
macdef IPPROTO_IDP = $extval (ipproto_t, "IPPROTO_IDP")
macdef IPPROTO_TP = $extval (ipproto_t, "IPPROTO_TP")
macdef IPPROTO_DCCP = $extval (ipproto_t, "IPPROTO_DCCP")
macdef IPPROTO_IPV6 = $extval (ipproto_t, "IPPROTO_IPV6")
macdef IPPROTO_ROUTING = $extval (ipproto_t, "IPPROTO_ROUTING")
macdef IPPROTO_FRAGMENT = $extval (ipproto_t, "IPPROTO_FRAGMENT")
macdef IPPROTO_RSVP = $extval (ipproto_t, "IPPROTO_RSVP")
macdef IPPROTO_GRE = $extval (ipproto_t, "IPPROTO_GRE")
macdef IPPROTO_ESP = $extval (ipproto_t, "IPPROTO_ESP")
macdef IPPROTO_AH = $extval (ipproto_t, "IPPROTO_AH")
macdef IPPROTO_ICMPV6 = $extval (ipproto_t, "IPPROTO_ICMPV6")
macdef IPPROTO_NONE = $extval (ipproto_t, "IPPROTO_NONE")
macdef IPPROTO_DSTOPTS = $extval (ipproto_t, "IPPROTO_DSTOPTS")
macdef IPPROTO_MTP = $extval (ipproto_t, "IPPROTO_MTP")
macdef IPPROTO_ENCAP = $extval (ipproto_t, "IPPROTO_ENCAP")
macdef IPPROTO_PIM = $extval (ipproto_t, "IPPROTO_PIM")
macdef IPPROTO_COMP = $extval (ipproto_t, "IPPROTO_COMP")
macdef IPPROTO_SCTP = $extval (ipproto_t, "IPPROTO_SCTP")
macdef IPPROTO_UDPLITE = $extval (ipproto_t, "IPPROTO_UDPLITE")
macdef IPPROTO_RAW = $extval (ipproto_t, "IPPROTO_RAW")
macdef IPPROTO_MAX = $extval (ipproto_t, "IPPROTO_MAX")
//
(* ****** ****** *)
//
macdef IPPORT_ECHO = $extval (in_port_t, "IPPORT_ECHO")
macdef IPPORT_DISCARD = $extval (in_port_t, "IPPORT_DISCARD")
macdef IPPORT_SYSTAT = $extval (in_port_t, "IPPORT_SYSTAT")
macdef IPPORT_DAYTIME = $extval (in_port_t, "IPPORT_DAYTIME")
macdef IPPORT_NETSTAT = $extval (in_port_t, "IPPORT_NETSTAT")
macdef IPPORT_FTP = $extval (in_port_t, "IPPORT_FTP")
macdef IPPORT_TELNET = $extval (in_port_t, "IPPORT_TELNET")
macdef IPPORT_SMTP = $extval (in_port_t, "IPPORT_SMTP")
macdef IPPORT_TIMESERVER = $extval (in_port_t, "IPPORT_TIMESERVER")
macdef IPPORT_NAMESERVER = $extval (in_port_t, "IPPORT_NAMESERVER")
macdef IPPORT_WHOIS = $extval (in_port_t, "IPPORT_WHOIS")
macdef IPPORT_MTP = $extval (in_port_t, "IPPORT_MTP")
macdef IPPORT_TFTP = $extval (in_port_t, "IPPORT_TFTP")
macdef IPPORT_RJE = $extval (in_port_t, "IPPORT_RJE")
macdef IPPORT_FINGER = $extval (in_port_t, "IPPORT_FINGER")
macdef IPPORT_TTYLINK = $extval (in_port_t, "IPPORT_TTYLINK")
macdef IPPORT_SUPDUP = $extval (in_port_t, "IPPORT_SUPDUP")
macdef IPPORT_EXECSERVER = $extval (in_port_t, "IPPORT_EXECSERVER")
macdef IPPORT_LOGINSERVER = $extval (in_port_t, "IPPORT_LOGINSERVER")
macdef IPPORT_CMDSERVER = $extval (in_port_t, "IPPORT_CMDSERVER")
macdef IPPORT_EFSSERVER = $extval (in_port_t, "IPPORT_EFSSERVER")
macdef IPPORT_BIFFUDP = $extval (in_port_t, "IPPORT_BIFFUDP")
macdef IPPORT_WHOSERVER = $extval (in_port_t, "IPPORT_WHOSERVER")
macdef IPPORT_ROUTESERVER = $extval (in_port_t, "IPPORT_ROUTESERVER")
macdef IPPORT_RESERVED = $extval (in_port_t, "IPPORT_RESERVED")
macdef IPPORT_USERRESERVED = $extval (in_port_t, "IPPORT_USERRESERVED")
//
(* ****** ****** *)

(*
//
// for IPv4 dotted-decimal
macdef INET_ADDRSTRLEN = 16 // string
//
macdef INET6_ADDRSTRLEN = 46 // for IPv6 hex string
//
*)

(* ****** ****** *)
//
fun
in_port_nbo_int (int): in_port_nbo_t = "mac#%"
fun
in_port_nbo_uint (uint): in_port_nbo_t = "mac#%"
//
symintr in_port_nbo
overload in_port_nbo with in_port_nbo_int
overload in_port_nbo with in_port_nbo_uint
//
(* ****** ****** *)
//
fun
in_addr_hbo2nbo (in_addr_hbo_t): in_addr_nbo_t = "mac#%"
//
(* ****** ****** *)
//
(* constant addresses in host-byte-order *)
//
// Address to accept any incoming messages: 0x00000000
//
macdef INADDR_ANY = $extval (in_addr_hbo_t, "INADDR_ANY")
//
// Address to send to all hosts: 0xffffffff
//
macdef INADDR_BROADCAST	= $extval (in_addr_hbo_t, "INADDR_BROADCAST")
//
// Address indicating an error return: 0xffffffff
//
macdef INADDR_NONE = $extval (in_addr_hbo_t, "INADDR_NONE")
//
// Network number for local host loopback
//
#define	IN_LOOPBACKNET 127
//
// Address to loopback in software to local host: 127.0.0.1
//
macdef INADDR_LOOPBACK = $extval (in_addr_hbo_t, "INADDR_LOOPBACK")
//
(* ****** ****** *)
//
(*
** Defined for Multicast
*)
//
// 0xe0000000 // 224.0.0.0
//
macdef
INADDR_UNSPEC_GROUP =
$extval (in_addr_hbo_t, "INADDR_UNSPEC_GROUP")
//
// 0xe0000001 // 224.0.0.1
//
macdef
INADDR_ALLHOSTS_GROUP =
$extval (in_addr_hbo_t, "INADDR_ALLHOSTS_GROUP")
//
// 0xe0000002 // 224.0.0.2
//
macdef
INADDR_ALLRTRS_GROUP =
$extval (in_addr_hbo_t, "INADDR_ALLRTRS_GROUP")
//
// 0xe00000ff // 224.0.0.255
//
macdef
INADDR_MAX_LOCAL_GROUP =
$extval (in_addr_hbo_t, "INADDR_MAX_LOCAL_GROUP")
//
(* ****** ****** *)
//
(*
** HX: [in_addr_struct] is taken by C++
*)
typedef
in_addr_struct =
$extype_struct
"in_addr_structats" of {
  s_addr= in_addr_nbo_t // IPv4 address of ulint
} (* end of [in_addr_struct] *)
//
(* ****** ****** *)
//
(*
** HX: [in6_addr_struct] may be taken by C++
*)
typedef
in6_addr_struct =
$extype_struct
"in6_addr_structats" of {
  s6_addr= @[uint8][16] // IPv6 address of 16 bytes
} (* end of [in6_addr_struct] *)

(* ****** ****** *)

(* end of [in.sats] *)
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: November, 2014 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_NETINET_IN_CATS
#define ATSLIB_LIBC_NETINET_IN_CATS

/* ****** ****** */
//
#include <arpa/inet.h>
#include <netinet/in.h>
//
/* ****** ****** */
//
typedef
struct in_addr in_addr_structats;
typedef
struct in6_addr in6_addr_structats;
//
/* ****** ****** */
//
typedef
struct sockaddr_in sockaddr_in_struct ;
typedef
struct sockaddr_in6 sockaddr_in6_struct ;
//
#define atslib_socklen_in (sizeof(sockaddr_in_struct))
#define atslib_socklen_in6 (sizeof(sockaddr_in6_struct))
//
/* ****** ****** */

#define atslib_in_port_nbo_int(nport) htons(nport)
#define atslib_in_port_nbo_uint(nport) htons(nport)

/* ****** ****** */

ATSinline()
in_addr_t
atslib_in_addr_hbo2nbo
  (in_addr_t addr_hbo) { return htonl (addr_hbo) ; }
/* end of [atslib_in_addr_hbo2nbo] */

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_NETINET_IN_CATS

/* ****** ****** */

/* end of [in.cats] */
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: November, 2014
//
(* ****** ****** *)

%{#
#include "libc/arpa/CATS/inet.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

#define NSH (x) x // for commenting: no sharing
#define SHR (x) x // for commenting: it is shared

(* ****** ****** *)

staload IN = "libc/netinet/SATS/in.sats"
typedef in_port_nbo_t = $IN.in_port_nbo_t
typedef in_addr_hbo_t = $IN.in_addr_hbo_t
typedef in_addr_nbo_t = $IN.in_addr_nbo_t
typedef in_addr_struct = $IN.in_addr_struct

(* ****** ****** *)
//
abst@ype
uint16_t0ype_netbyteord = uint16
typedef uint16_nbo = uint16_t0ype_netbyteord
//
fun htons
  (i: uint16): uint16_nbo = "mac#%"
fun ntohs
  (i: uint16_nbo): uint16 = "mac#%"
//
(* ****** ****** *)
//
abst@ype
uint32_t0ype_netbyteord = uint32
typedef uint32_nbo = uint32_t0ype_netbyteord
//
fun htonl (i: uint32): uint32_nbo = "mac#%"
fun ntohl (i: uint32_nbo): uint32 = "mac#%"
//
(* ****** ****** *)
//
castfn
in_port_of_uint16_nbo (x: uint16_nbo): in_port_nbo_t
castfn
uint16_of_in_port_nbo (x: in_port_nbo_t): uint16_nbo
//
(* ****** ****** *)

fun
inet_aton
(
  cp: string
, inp: &in_addr_struct? >> opt(in_addr_struct, b)
) : #[b:bool] bool(b) = "mac#%" // end-of-function

(* ****** ****** *)
//
// HX: note that this one cannot tell
// -1 from 255.255.255.255 (a valid address)
//
fun inet_addr (cp: string): in_addr_nbo_t = "mac#%"
fun inet_network (cp: string): in_addr_hbo_t = "mac#%"
//
(* ****** ****** *)
//
fun
inet_makeaddr
  (net: int, host: int): in_addr_struct = "mac#%"
// end of [inet_makeaddr]
//
(* ****** ****** *)
//
// HX: this function is not reentrant
//
fun
inet_ntoa
  (inp: in_addr_struct) :<!ref> vStrptr1 = "mac#%"
//
(* ****** ****** *)
//
fun
inet_lnaof
  (addr: in_addr_struct): in_addr_hbo_t = "mac#%"
//
fun inet_netof
  (addr: in_addr_struct): in_addr_hbo_t = "mac#%"
//
(* ****** ****** *)

fun
inet4_pton
(
  cp: string // af=AF_INET
, inp: &in_addr_struct? >> opt (in_addr_struct, i > 0)
) : #[i:int] int (i) = "mac#%" // end-of-fun

fun
inet6_pton
(
  cp: string // af= AF_INET6
, inp: &in_addr_struct? >> opt (in_addr_struct, i > 0)
) : #[i:int] int (i) = "mac#%" // end-of-fun

(* ****** ****** *)

(* end of [inet.sats] *)
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: November, 2014 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_ARPA_INET_CATS
#define ATSLIB_LIBC_ARPA_INET_CATS

/* ****** ****** */
//
#include <arpa/inet.h>
#include <netinet/in.h>
//
/* ****** ****** */

#ifndef EXIT_SUCCESS
#define	EXIT_SUCCESS 0
#endif // EXIT_SUCCESS
#ifndef EXIT_FAILURE
#define EXIT_FAILURE 1
#endif // EXIT_FAILURE

/* ****** ****** */
//
#define atslib_htons htons
#define atslib_ntohs ntohs
//
#define atslib_htonl htonl
#define atslib_ntohl ntohl
//
/* ****** ****** */

extern
int
inet_aton
(
  const char *cp, struct in_addr *inp
) ; // end of [inet_aton]

ATSinline()
atstype_bool
atslib_inet_aton
(
  atstype_ptr cp, atstype_ref inp
) {
//
  int rtn ;
//
  rtn =
  inet_aton((char*)cp, (struct in_addr*)inp) ;
//
  return (rtn ? atsbool_true : atsbool_false) ;
//
} // end of [atslib_inet_aton]

/* ****** ****** */

#define atslib_inet_addr inet_addr
#define atslib_inet_network inet_network

/* ****** ****** */

#define atslib_inet_makeaddr inet_makeaddr

/* ****** ****** */

#define atslib_inet_ntoa inet_ntoa

/* ****** ****** */

#define atslib_inet4_pton(cp, inp) inet_pton(AF_INET4, cp, inp)
#define atslib_inet6_pton(cp, inp) inet_pton(AF_INET6, cp, inp)

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_ARPA_INET_CATS

/* ****** ****** */

/* end of [inet.cats] */
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: July, 2013
//
(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc.gdbm_gdbm"
#define ATS_STALOADFLAG 0 // no static loading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

%{#
#include "libc/gdbm/CATS/gdbm.cats"
%} // end of [%{#]

(* ****** ****** *)

staload FCNTL = "libc/SATS/fcntl.sats"
staload TYPES = "libc/sys/SATS/types.sats"
typedef mode_t = $TYPES.mode_t

(* ****** ****** *)

#include "./SHARE/datum.hats"

(* ****** ****** *)

absvtype GDBMfilptr (lf:addr) = ptr

vtypedef GDBMfilptr = [lf:addr] GDBMfilptr (lf)
vtypedef GDBMfilptr0 = [lf:addr | lf >= null] GDBMfilptr (lf)
vtypedef GDBMfilptr1 = [lf:addr | lf >  null] GDBMfilptr (lf)

(* ****** ****** *)

praxi
GDBMfilptr_free_null (GDBMfilptr (null)): void
castfn
GDBMfilptr2ptr {lf:addr} (!GDBMfilptr lf):<> ptr (lf)
overload ptrcast with GDBMfilptr2ptr

(* ****** ****** *)
//
typedef GDBMerror = int
//
macdef
GDBM_NO_ERROR = $extval (GDBMerror, "GDBM_NO_ERROR")
macdef
GDBM_MALLOC_ERROR = $extval (GDBMerror, "GDBM_MALLOC_ERROR")
macdef
GDBM_BLOCK_SIZE_ERROR = $extval (GDBMerror, "GDBM_BLOCK_SIZE_ERROR")
macdef
GDBM_FILE_OPEN_ERROR = $extval (GDBMerror, "GDBM_FILE_OPEN_ERROR")
macdef
GDBM_FILE_WRITE_ERROR = $extval (GDBMerror, "GDBM_FILE_WRITE_ERROR")
macdef
GDBM_FILE_SEEK_ERROR = $extval (GDBMerror, "GDBM_FILE_SEEK_ERROR")
macdef
GDBM_FILE_READ_ERROR = $extval (GDBMerror, "GDBM_FILE_READ_ERROR")
macdef
GDBM_BAD_MAGIC_NUMBER = $extval (GDBMerror, "GDBM_BAD_MAGIC_NUMBER")
macdef
GDBM_EMPTY_DATABASE = $extval (GDBMerror, "GDBM_EMPTY_DATABASE")
macdef
GDBM_CANT_BE_READER = $extval (GDBMerror, "GDBM_CANT_BE_READER")
macdef
GDBM_CANT_BE_WRITER = $extval (GDBMerror, "GDBM_CANT_BE_WRITER")
macdef
GDBM_READER_CANT_DELETE = $extval (GDBMerror, "GDBM_READER_CANT_DELETE")
macdef
GDBM_READER_CANT_STORE = $extval (GDBMerror, "GDBM_READER_CANT_STORE")
macdef
GDBM_READER_CANT_REORGANIZE = $extval (GDBMerror, "GDBM_READER_CANT_REORGANIZE")
macdef
GDBM_UNKNOWN_UPDATE = $extval (GDBMerror, "GDBM_UNKNOWN_UPDATE")
macdef
GDBM_ITEM_NOT_FOUND = $extval (GDBMerror, "GDBM_ITEM_NOT_FOUND")
macdef
GDBM_REORGANIZE_FAILED = $extval (GDBMerror, "GDBM_REORGANIZE_FAILED")
macdef
GDBM_CANNOT_REPLACE = $extval (GDBMerror, "GDBM_CANNOT_REPLACE")
macdef
GDBM_ILLEGAL_DATA = $extval (GDBMerror, "GDBM_ILLEGAL_DATA")
macdef
GDBM_OPT_ALREADY_SET = $extval (GDBMerror, "GDBM_OPT_ALREADY_SET")
macdef
GDBM_OPT_ILLEGAL = $extval (GDBMerror, "GDBM_OPT_ILLEGAL")
macdef
GDBM_BYTE_SWAPPED = $extval (GDBMerror, "GDBM_BYTE_SWAPPED")
macdef
GDBM_BAD_FILE_OFFSET = $extval (GDBMerror, "GDBM_BAD_FILE_OFFSET")
macdef
GDBM_BAD_OPEN_FLAGS = $extval (GDBMerror, "GDBM_BAD_OPEN_FLAGS")
//
(* ****** ****** *)
//
fun gdbm_errno_get (): GDBMerror = "mac#%"
//
(* ****** ****** *)
//
// statically-allocated
//
val gdbm_version : string = "mac#%"
val gdbm_version_number : array (int, 3) = "mac#mac%"
//
(* ****** ****** *)

fun gdm_version_cmp
  (v1: &(@[int][3]), v2: &(@[int][3])):<> int = "mac#%"
// end of [gdm_version_cmp]
  
(* ****** ****** *)

(*
#define  GDBM_READER  0		/* A reader. */
#define  GDBM_WRITER  1		/* A writer. */
#define  GDBM_WRCREAT 2		/* A writer.  Create the db if needed. */
#define  GDBM_NEWDB   3		/* A writer.  Always create a new db. */
*)
macdef GDBM_READER = $extval (int, "GDBM_READER")
macdef GDBM_WRITER = $extval (int, "GDBM_WRITER")
macdef GDBM_WRCREAT = $extval (int, "GDBM_WRCREAT")
macdef GDBM_NEWDB = $extval (int, "GDBM_NEWDB")

(*
#define  GDBM_FAST    0x10	/* Write fast! => No fsyncs.  OBSOLETE. */
#define  GDBM_SYNC    0x20	/* Sync operations to the disk. */
#define  GDBM_NOLOCK  0x40	/* Don't do file locking operations. */
*)
macdef GDBM_FAST = $extval (int, "GDBM_FAST")
macdef GDBM_SYNC = $extval (int, "GDBM_SYNC")
macdef GDBM_NOLOCK = $extval (int, "GDBM_NOLOCK")


(* ****** ****** *)

(*
GDBM_FILE gdbm_open
  (name, block_size, flags, mode, fatal_func);
*)
//
// fatal_func: (string) -> void
//
fun gdbm_open
(
  name: string
, block_size: int, flags: int, mode: mode_t, fatal_func: ptr
) : GDBMfilptr0 = "mac#%" // end of [gdbm_open]

(* ****** ****** *)

(*
void gdbm_close(dbf);
*)
fun gdbm_close (dbf: GDBMfilptr) : void = "mac#%"

(* ****** ****** *)

(*
int gdbm_store(dbf, key, content, flag);
*)
(*
#define  GDBM_INSERT  0		/* Never replace old data with new. */
#define  GDBM_REPLACE 1		/* Always replace old data with new. */
*)
macdef GDBM_INSERT = $extval (int, "GDBM_INSERT")
macdef GDBM_REPLACE = $extval (int, "GDBM_REPLACE")

fun gdbm_store
  {l1,l2:addr}{n1,n2:nat}
(
  dbf: !GDBMfilptr1, key: !datum(l1, n1), content: !datum(l2, n2), flag: int
) : int(*err*) = "mac#%" // end of [gdbm_store]

(* ****** ****** *)

(*
datum gdbm_fetch(dbf, key);
*)
//
// HX: the return value is allocated
//
fun gdbm_fetch
  {l:agz}{n:int}
  (dbf: !GDBMfilptr1, key: !datum (l, n)): datum0 = "mac#%"
// end of [gdbm_fetch]

(* ****** ****** *)

(*
int gdbm_exists(dbf, key);
*)
fun gdbm_exists
  {l:agz}{n:int} // true/false: 0/1
  (dbf: !GDBMfilptr1, key: !datum (l, n)): int = "mac#%"
// end of [gdbm_exists]

(* ****** ****** *)

(*
int gdbm_delete(dbf, key);
*)
fun gdbm_delete
  {l:agz}{n:int} // succ/fail: 0/-1
  (dbf: !GDBMfilptr1, key: !datum (l, n)) : int = "mac#%"
// end of [gdbm_delete]

(* ****** ****** *)

(*
datum gdbm_firstkey(dbf);
*)
fun gdbm_firstkey (dbf: !GDBMfilptr1): datum0 = "mac#%"

(* ****** ****** *)

(*
datum gdbm_nextkey(dbf, key);
*)

fun gdbm_nextkey
  {l:agz}{n:int}
  (dbf: !GDBMfilptr, key: !datum(l, n) >> _): datum0 = "mac#%"
// end of [gdbm_nextkey]

(* ****** ****** *)

(*
int gdbm_reorganize(dbf);
*)
fun gdbm_reorganize (!GDBMfilptr1): int = "mac#%"

(* ****** ****** *)

(*
void gdbm_sync(dbf);
*)
fun gdbm_sync (dbf: !GDBMfilptr1): void = "mac#%"

(* ****** ****** *)

(*
int gdbm_export
(
  GDBM FILE dbf
, const char *exportfile,int flag, int mode
) ;
*)
fun gdbm_export
(
  dbf: !GDBMfilptr1
, exportfile: string, flag: int, mode: mode_t
) : int = "mac#%" // end of [gdbm_export]

(* ****** ****** *)

(*
int gdbm_import
(
  GDBM FILE dbf , const char *importfile , int flag
) ;
*)
fun gdbm_import
(
  dbf: !GDBMfilptr1, importfile: string, flag: int
) : int = "mac#%" // end of [gdbm_import]

(* ****** ****** *)

(*
char *gdbm_strerror(int errno);
*)
fun gdbm_strerror
  (errno: GDBMerror): string(*pre-allocated*) = "mac#%"
// end of [gdbm_strerror]

(* ****** ****** *)

(*
int gdbm_setopt(dbf, option, value, size);
*)
abst@ype
gdbmsetopt_t0ype (a:t@ype) = int
stadef gdbmsetopt = gdbmsetopt_t0ype
abst@ype
gdbmgetopt_t0ype (a:t@ype) = int
stadef gdbmgetopt = gdbmgetopt_t0ype
//
macdef
GDBM_CACHESIZE = $extval (gdbmsetopt(size_t), "GDBM_CACHESIZE")
macdef
GDBM_SETCACHESIZE = $extval (gdbmsetopt(size_t), "GDBM_SETCACHESIZE")
macdef
GDBM_GETCACHESIZE = $extval (gdbmgetopt(size_t), "GDBM_GETCACHESIZE")
//
macdef GDBM_GETFLAGS = $extval (gdbmgetopt(int), "GDBM_GETFLAGS")
//
macdef GDBM_FASTMODE = $extval (gdbmsetopt(int), "GDBM_FASTMODE")
//
macdef
GDBM_SYNCMODE = $extval (gdbmsetopt(int), "GDBM_SYNCMODE")
macdef
GDBM_SETSYNCMODE = $extval (gdbmsetopt(int), "GDBM_SETSYNCMODE")
macdef
GDBM_GETSYNCMODE = $extval (gdbmgetopt(int), "GDBM_GETSYNCMODE")
//
macdef
GDBM_COALESCEBLKS = $extval (gdbmsetopt(int), "GDBM_COALESCEBLKS")
macdef
GDBM_SETCOALESCEBLKS = $extval (gdbmsetopt(int), "GDBM_SETCOALESCEBLKS")
macdef
GDBM_GETCOALESCEBLKS = $extval (gdbmgetopt(int), "GDBM_GETCOALESCEBLKS")
//
macdef
GDBM_SETMAXMAPSIZE = $extval (gdbmsetopt(size_t), "GDBM_SETMAXMAPSIZE")
macdef
GDBM_GETMAXMAPSIZE = $extval (gdbmgetopt(size_t), "GDBM_GETMAXMAPSIZE")
//
macdef
GDBM_SETMMAP = $extval (gdbmsetopt(int), "GDBM_SETMMAP")
macdef
GDBM_GETMMAP = $extval (gdbmgetopt(int), "GDBM_GETMMAP")
//
macdef
GDBM_GETDBNAME = $extval (gdbmgetopt(ptr), "GDBM_GETDBNAME")
//
(* ****** ****** *)

fun
gdbm_setopt
  {a:t@ype} (
  dbf: !GDBMfilptr1
, option: gdbmsetopt(a), value: &a, size: sizeof_t(a)
) : int(*err*) = "mac#%" // end of [gdbm_setopt]
fun
gdbm_getopt
  {a:t@ype} (
  dbf: !GDBMfilptr1
, option: gdbmgetopt(a), value: &a? >> a, size: sizeof_t(a)
) : int(*err*) = "mac#%" // end of [gdbm_getopt]

fun gdbm_getdbname (dbf: !GDBMfilptr1): Strptr0 = "mac#%"

(* ****** ****** *)

(*
int gdbm_fdesc(dbf);
*)
fun gdbm_fdesc (!GDBMfilptr1): int(*fd*) = "mac#%" // no failure

(* ****** ****** *)

(* end of [gdbm.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: July, 2013
//
(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libc.gdbm_ndbm"
#define ATS_STALOADFLAG 0 // no static loading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

%{#
#include "libc/gdbm/CATS/ndbm.cats"
%} // end of [%{#]

(* ****** ****** *)

(* end of [ndbm.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: July, 2013
//
(* ****** ****** *)

absvtype
dptr_addr_int_vtype (addr, int)
//
vtypedef dptr
  (l:addr, n:int) = dptr_addr_int_vtype (l, n)
//
(* ****** ****** *)

viewdef dptrout
  (l:addr, n:int) = dptr (l, n) -<lin,prf> void

(* ****** ****** *)

castfn dptr2ptr
  {l:addr} {n:int} (x: !dptr(l, n)):<> ptr (l)
overload ptrcast with dptr2ptr

(* ****** ****** *)

vtypedef
datum
  (l:addr, n:int) =
$extype_struct
"atslib_datum_type" of { dptr= dptr(l, n), dsize= int(n) }
// end of [datum]

(* ****** ****** *)

vtypedef
datum0 = [l:addr;n:int] datum (l, n)
vtypedef // for valid data
datum1 = [l:addr;n:int | l > null; n >= 0] datum (l, n)

(* ****** ****** *)

fun datum_is_valid
  {l:addr}{n:int}
  (x: datum (l, n))
: bool (l > null) = "mac#atslib_gdbm_datum_is_valid"
// end of [datum_is_valid]

fun datum_takeout_ptr
  {l:addr}{n:int}
  (datum (l, n)):<> dptr (l, n) = "mac#atslib_gdbm_datum_takeout_ptr"
// end of [datum_takeout_ptr]

(* ****** ****** *)
//
// HX: implemented in [gdbm.cats]
//
fun
datum_make0_string
  (string)
: [l:agz;n:nat]
(
  dptrout (l, n) | datum (l, n)
) = "mac#atslib_gdbm_datum_make0_string"
//
fun datum_make1_string
  (string): datum1 = "mac#atslib_gdbm_datum_make1_string"
//
(* ****** ****** *)

fun datum_free (x: datum0): void = "mac#atslib_gdbm_datum_free"

(* ****** ****** *)

(* end of [datum.hats] *)
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-20?? Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: July, 2013
//
/* ****** ****** */

#include "libc/CATS/string.cats"

/* ****** ****** */

typedef datum atslib_datum_type ;

/* ****** ****** */

ATSinline()
atstype_bool
atslib_gdbm_datum_is_valid
  (datum x) { return (x.dptr != 0) ; }
// end of [atslib_gdbm_datum_is_valid]

ATSinline()
atstype_ptr
atslib_gdbm_datum_takeout_ptr
  (datum x) { return x.dptr ; }
// end of [atslib_gdbm_datum_takeout_ptr]

/* ****** ****** */

ATSinline()
datum
atslib_gdbm_datum_make0_string
  (char *str) {
  datum res ;
  res.dptr = str ;
  res.dsize = (int)(atslib_strlen(str) + 1) ; // HX: account for the trailing null char!
  return res ;
} // end of [atslib_gdbm_datum_make0_string]

ATSinline()
datum
atslib_gdbm_datum_make1_string
  (char *str) {
  datum res ;
  res.dptr = (char*)atslib_strdup_gc(str) ;
  res.dsize = (int)(atslib_strlen(str) + 1) ; // HX: account for the trailing null char!
  return res ;
} // end of [atslib_gdbm_datum_make1_string]

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atslib_gdbm_datum_free
  (datum x) {
  if (x.dptr) atspre_mfree_gc(x.dptr) ; return ;
} // end of [atslib_gdbm_datum_free]

/* ****** ****** */

/* end of [datum.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-20?? Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */
//
// Author: Hongwei Xi (gmhwxi AT gmail DOT com)
// Start Time: July, 2013
//
/* ****** ****** */

#include <gdbm.h>

/* ****** ****** */

#include "libc/gdbm/CATS/datum.cats"

/* ****** ****** */

ATSinline()
gdbm_error
atslib_gdbm_errno_get () { return gdbm_errno ; }

/* ****** ****** */

#define atslib_gdbm_open gdbm_open
#define atslib_gdbm_close gdbm_close

#define atslib_gdbm_store gdbm_store

#define atslib_gdbm_fetch gdbm_fetch
#define atslib_gdbm_exists gdbm_exists

#define atslib_gdbm_delete gdbm_delete

#define atslib_gdbm_firstkey gdbm_firstkey
#define atslib_gdbm_nextkey gdbm_nextkey

#define atslib_gdbm_reorganize gdbm_reorganize

#define atslib_gdbm_sync gdbm_sync

#define atslib_gdbm_export gdbm_export
#define atslib_gdbm_import gdbm_import

#define atslib_gdbm_strerror gdbm_strerror

/* ****** ****** */

#define atslib_gdbm_setopt gdbm_setopt
#define atslib_gdbm_getopt gdbm_setopt

/* ****** ****** */

#ifdef GDBM_GETDBNAME
ATSinline()
gdbm_getdbname
(
  atstype_ptr dbf
) {
  int err ; char *dbname ;
  err = gdbm_setopt((GDBM_FILE)dbf, GDBM_GETDBNAME, &dbname, sizeof(void*)) ;
  if (err < 0) return (char*)0 ;
  return dbname ;
} // end of [gdbm_getdbname]
#endif // end of [GDBM_GETDBNAME]

/* ****** ****** */

#define atslib_gdbm_fdesc gdbm_fdesc

/* ****** ****** */

/* end of [gdbm.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/CATS/CODEGEN/fnmatch.atxt
** Time of generation: Wed Sep 23 16:09:11 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_CATS_FNMATCH
#define ATSLIB_LIBC_CATS_FNMATCH

/* ****** ****** */

#include <fnmatch.h>

/* ****** ****** */

#define atslib_fnmatch_null(pat, str) fnmatch((char*)pat, (char*)str, 0)
#define atslib_fnmatch_flags(pat, str, flags) fnmatch((char*)pat, (char*)str, flags)

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_CATS_FNMATCH

/* ****** ****** */

/* end of [fnmatch.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/CATS/CODEGEN/strings.atxt
** Time of generation: Wed Sep 23 16:09:12 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_CATS_STRINGS
#define ATSLIB_LIBC_CATS_STRINGS

/* ****** ****** */

#include <strings.h>

/* ****** ****** */

#define atslib_index_int index
#define atslib_index_char(c) index((int)c)

#define atslib_rindex_int rindex
#define atslib_rindex_char(c) rindex((int)c)

/* ****** ****** */

#define atslib_strcasecmp strcasecmp
#define atslib_strncasecmp strncasecmp

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_CATS_STRINGS

/* ****** ****** */

/* end of [strings.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/CATS/CODEGEN/unistd.atxt
** Time of generation: Wed Sep 23 16:09:13 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: April, 2012 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_CATS_UNISTD
#define ATSLIB_LIBC_CATS_UNISTD

/* ****** ****** */

#include <unistd.h>

/* ****** ****** */

#include "share/H/pats_atslib.h"

/* ****** ****** */

#define atslib_close close
#define atslib_close0 atslib_close
#define atslib_close1 atslib_close
#define atslib_close0_exn atslib_close_exn
#define atslib_close1_exn atslib_close_exn

/* ****** ****** */

#define atslib_dup dup
#define atslib_dup_fildes dup
#define atslib_dup2 dup2
#define atslib_dup3 dup3

/* ****** ****** */

#define atslib_execv(path, argv) execv((char*)path, (char**)argv)
#define atslib_execvp(path, argv) execvp((char*)path, (char**)argv)

/* ****** ****** */

#define atslib_encrypt encrypt

/* ****** ****** */

#define atslib_fork fork

/* ****** ****** */

#define atslib_getcwd getcwd

/* ****** ****** */

#define atslib_getlogin getlogin
#define atslib_getlogin_r getlogin_r

/* ****** ****** */

#define atslib_getpid getpid
#define atslib_getppid getppid

/* ****** ****** */

#define atslib_getuid getuid
#define atslib_setuid setuid
#define atslib_geteuid geteuid
#define atslib_seteuid seteuid

/* ****** ****** */

#define atslib_getgid getgid
#define atslib_setgid setgid
#define atslib_getegid getegid
#define atslib_setegid setegid

/* ****** ****** */

#define atslib_setreuid setreuid
#define atslib_setregid setregid
#define atslib_setresuid setresuid
#define atslib_setresgid setresgid

/* ****** ****** */

#define atslib_setfsuid setfsuid
#define atslib_setfsgid setfsgid

/* ****** ****** */

#define atslib_pause pause

/* ****** ****** */

#define atslib_read_err read
#define atslib_write_err write

/* ****** ****** */

#define atslib_pread pread
#define atslib_pwrite pwrite

/* ****** ****** */

#define atslib_alarm alarm
#define atslib_alarm_set alarm
#define atslib_alarm_cancel() alarm(0)

/* ****** ****** */

#define atslib_sleep_int sleep
#define atslib_sleep_uint sleep

/* ****** ****** */

#define atslib_usleep_int usleep
#define atslib_usleep_uint usleep

/* ****** ****** */

#define atslib_rmdir rmdir

/* ****** ****** */

#define atslib_link link
#define atslib_unlink unlink

/* ****** ****** */

#define atslib_symlink symlink
#define atslib_readlink readlink

/* ****** ****** */

#define atslib_sync sync
#define atslib_fsync fsync
#define atslib_fdatasync fdatasync

/* ****** ****** */

#define atslib_truncate truncate
#define atslib_ftruncate ftruncate

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_CATS_UNISTD

/* ****** ****** */

/* end of [unistd.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/CATS/CODEGEN/time.atxt
** Time of generation: Wed Sep 23 16:09:13 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_CATS_TIME
#define ATSLIB_LIBC_CATS_TIME

/* ****** ****** */

#include <time.h>

/* ****** ****** */

typedef time_t atslib_time_type ;
typedef struct tm atslib_tm_struct_type ;

/* ****** ****** */

typedef clock_t atslib_clock_type ;

/* ****** ****** */

typedef struct timespec atslib_timespec_type ;

/* ****** ****** */

#define atslib_difftime difftime

/* ****** ****** */

#define atslib_time_get() time((time_t*)0)

ATSinline()
atstype_bool
atslib_time_getset
(
  atstype_ref tval
) {
  return (time((time_t*)tval) >= 0 ? atsbool_true : atsbool_false) ;
} // end of [atslib_time_getset]

/* ****** ****** */

#define atslib_ctime ctime
#define atslib_ctime_r ctime_r

/* ****** ****** */

ATSinline()
atstype_int
atslib_tm_get_sec
  (atstype_ptr tm) {
  return ((struct tm*)tm)->tm_sec ;
} // end of [atslib_tm_get_sec]

ATSinline()
atstype_int
atslib_tm_get_min
  (atstype_ptr tm) {
  return ((struct tm*)tm)->tm_min ;
} // end of [atslib_tm_get_min]

ATSinline()
atstype_int
atslib_tm_get_hour
  (atstype_ptr tm) {
  return ((struct tm*)tm)->tm_hour ;
} // end of [atslib_tm_get_hour]

ATSinline()
atstype_int
atslib_tm_get_mday
  (atstype_ptr tm) {
  return ((struct tm*)tm)->tm_mday ;
} // end of [atslib_tm_get_mday]

ATSinline()
atstype_int
atslib_tm_get_mon
  (atstype_ptr tm) {
  return ((struct tm*)tm)->tm_mon ;
} // end of [atslib_tm_get_mon]

ATSinline()
atstype_int
atslib_tm_get_year
  (atstype_ptr tm) {
  return ((struct tm*)tm)->tm_year ;
} // end of [atslib_tm_get_year]

ATSinline()
atstype_int
atslib_tm_get_wday
  (atstype_ptr tm) {
  return ((struct tm*)tm)->tm_wday ;
} // end of [atslib_tm_get_wday]

ATSinline()
atstype_int
atslib_tm_get_yday
  (atstype_ptr tm) {
  return ((struct tm*)tm)->tm_yday ;
} // end of [atslib_tm_get_yday]

ATSinline()
atstype_int
atslib_tm_get_isdst
  (atstype_ptr tm) {
  return ((struct tm*)tm)->tm_isdst ;
} // end of [atslib_tm_get_isdst]

/* ****** ****** */

#define atslib_mktime mktime

/* ****** ****** */

#define atslib_asctime asctime

/* ****** ****** */

#define atslib_gmtime gmtime
#define atslib_gmtime_r gmtime_r

/* ****** ****** */

#define atslib_localtime localtime
#define atslib_localtime_r localtime_r

/* ****** ****** */

#define atslib_tzset tzset

/* ****** ****** */

#define atslib_clock clock

#define atslib_clock_getres clock_getres

/* ****** ****** */

#define atslib_clock_gettime clock_gettime
#define atslib_clock_settime clock_settime

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_CATS_TIME

/* ****** ****** */

/* end of [time.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/CATS/CODEGEN/fcntl.atxt
** Time of generation: Wed Sep 23 16:09:11 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_CATS_FCNTL
#define ATSLIB_LIBC_CATS_FCNTL

/* ****** ****** */

#include <sys/types.h>
#include <fcntl.h> // HX: after sys/types

/* ****** ****** */

#define atslib_fildes_get_int(fd) (fd)

/* ****** ****** */

ATSinline()
atstype_bool
atslib_fildes_isgtez
  (atstype_int fd)
{
  return (fd >= 0 ? atsbool_true : atsbool_false) ;
} // end of [atslib_fildes_isgtez]

/* ****** ****** */

#define atslib_fcntlflags_lor(x1, x2) ((x1)|(x2))

/* ****** ****** */

#define atslib_open_flags(path, flags) open((char*)path, flags)
#define atslib_open_flags_mode(path, flags, mode) open((char*)path, flags, mode)

/* ****** ****** */

#define atslib_fcntl_getfl(fd) fcntl(fd, F_GETFL)
#define atslib_fcntl_setfl(fd, flags) fcntl(fd, F_SETFL, flags)

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_CATS_FCNTL

/* ****** ****** */

/* end of [fcntl.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/CATS/CODEGEN/stdlib.atxt
** Time of generation: Wed Sep 23 16:09:12 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_CATS_STDLIB
#define ATSLIB_LIBC_CATS_STDLIB

/* ****** ****** */

#include <stdlib.h>

/* ****** ****** */

#include "share/H/pats_atslib.h"

/* ****** ****** */

#define atslib__Exit _Exit
#define atslib_atexit atexit

/* ****** ****** */

#define atslib_abort abort

/* ****** ****** */

#define atslib_abs abs
#define atslib_labs labs
#define atslib_llabs llabs

/* ****** ****** */

#define atslib_div div
#define atslib_ldiv ldiv
#define atslib_lldiv lldiv

/* ****** ****** */

#define atslib_a64l a64l
#define atslib_l64a l64a

/* ****** ****** */

#define atslib_atoi atoi
#define atslib_atol atol
#define atslib_atoll atoll
#define atslib_atof atof

/* ****** ****** */

#define atslib_strtol0(nptr, base) atslib_strtol_unsafe(nptr, 0, base)
#define atslib_strtol1(nptr, endptr, base) atslib_strtol_unsafe(nptr, endptr, base)
#define atslib_strtol_unsafe(nptr, endptr, base) strtol((char*)(nptr), (char**)(endptr), base)

/* ****** ****** */

#define atslib_strtoll0(nptr, base) atslib_strtoll_unsafe(nptr, 0, base)
#define atslib_strtoll1(nptr, endptr, base) atslib_strtoll_unsafe(nptr, endptr, base)
#define atslib_strtoll_unsafe(nptr, endptr, base) strtoll((char*)(nptr), (char**)(endptr), base)

/* ****** ****** */

#define atslib_strtof0(nptr) atslib_strtof_unsafe(nptr, 0)
#define atslib_strtof1(nptr, endptr) atslib_strtof_unsafe(nptr, endptr)
#define atslib_strtof_unsafe(nptr, endptr) strtof((char*)(nptr), (char**)(endptr))

/* ****** ****** */

#define atslib_strtod0(nptr) atslib_strtod_unsafe(nptr, 0)
#define atslib_strtod1(nptr, endptr) atslib_strtod_unsafe(nptr, endptr)
#define atslib_strtod_unsafe(nptr, endptr) strtod((char*)(nptr), (char**)(endptr))

/* ****** ****** */

#define atslib_getenv getenv
#define atslib_putenv putenv
#define atslib_setenv setenv
#define atslib_unsetenv unsetenv

/* ****** ****** */

#define atslib_rand rand
#define atslib_srand srand
#define atslib_rand_r rand_r

/* ****** ****** */

#define atslib_random random
#define atslib_srandom srandom

/* ****** ****** */

#define atslib_drand48 drand48
#define atslib_erand48 erand48
#define atslib_lrand48 lrand48
#define atslib_nrand48 nrand48
#define atslib_mrand48 mrand48
#define atslib_jrand48 jrand48
#define atslib_srand48 srand48
#define atslib_seed48 seed48
#define atslib_lcong48 lcong48

/* ****** ****** */

#define \
atslib_qsort(base, nmemb, size, compar) \
  qsort(base, nmemb, size, (void*)compar)

/* ****** ****** */

#define \
atslib_bsearch(key, base, nmemb, size, compar) \
  bsearch(key, base, nmemb, size, (void*)compar)

/* ****** ****** */

#define atslib_mkstemp mkstemp
#define atslib_mkostemp mkostemp

/* ****** ****** */

#define atslib_mfree_libc free
#define atslib_malloc_libc malloc

/* ****** ****** */

#define atslib_system system

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_CATS_STDLIB

/* ****** ****** */

/* end of [stdlib.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/CATS/CODEGEN/signal.atxt
** Time of generation: Wed Sep 23 16:09:12 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: April, 2014 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_CATS_SIGNAL
#define ATSLIB_LIBC_CATS_SIGNAL

/* ****** ****** */

#include <signal.h>

/* ****** ****** */

typedef int signum_t ;
typedef void (*sighandler_t)(signum_t) ;

/* ****** ****** */

typedef struct sigaction atslib_sigaction_struct ;

/* ****** ****** */

#define atslib_sigaddset sigaddset
#define atslib_sigdelset sigdelset
#define atslib_sigemptyset sigemptyset
#define atslib_sigfillset sigfillset

/* ****** ****** */

#define atslib_signal signal

/* ****** ****** */

#define atslib_sigaction sigaction
#define atslib_sigaction_null(sgn, act) \
  atslib_sigaction(sgn, act, (atslib_sigaction_struct*)0)

/* ****** ****** */

#define atslib_sigset sigset
#define atslib_sighold sighold
#define atslib_sigignore sigignore
#define atslib_sigrelse sigrelse

/* ****** ****** */

#define atslib_kill kill
#define atslib_killpg killpg
#define atslib_raise raise

/* ****** ****** */

#define atslib_sigwait sigwait

/* ****** ****** */

#define atslib_sigpause sigpause
#define atslib_sigsuspend sigsuspend

/* ****** ****** */

#define atslib_sigpending sigpending
#define atslib_siginterrupt siginterrupt

/* ****** ****** */

#define atslib_psignal psignal

/* ****** ****** */

/*
extern
char* strsignal (int signum) ; // declared in <string.h>
*/
#define atslib_strsignal strsignal

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_CATS_SIGNAL

/* ****** ****** */

/* end of [signal.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/CATS/CODEGEN/malloc.atxt
** Time of generation: Wed Sep 23 16:09:12 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: March, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_CATS_MALLOC
#define ATSLIB_LIBC_CATS_MALLOC

/* ****** ****** */

#include <malloc.h>

/* ****** ****** */

#define atslib_mallopt mallopt
#define atslib_malloc_trim malloc_trim
#define atslib_malloc_usable_size malloc_usable_size
#define atslib_malloc_stats malloc_stats
#define atslib_malloc_get_state malloc_get_state
#define atslib_malloc_set_state malloc_set_state

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_CATS_MALLOC

/* ****** ****** */

/* end of [malloc.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/CATS/CODEGEN/alloca.atxt
** Time of generation: Wed Sep 23 16:09:10 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: February, 2014 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_CATS_ALLOCA
#define ATSLIB_LIBC_CATS_ALLOCA

/* ****** ****** */

#include <alloca.h>

/* ****** ****** */
//
#define atslib_alloca(bsz) alloca(bsz)
//
/* ****** ****** */
//
#define atslib_ptr_alloca_tsz(tsz) alloca(tsz)
//
#define atslib_array_ptr_alloca_tsz(asz, tsz) alloca((asz)*(tsz))
//
/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_CATS_ALLOCA

/* ****** ****** */

/* end of [alloca.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/CATS/CODEGEN/math.atxt
** Time of generation: Wed Sep 23 16:09:12 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_CATS_MATH
#define ATSLIB_LIBC_CATS_MATH

/* ****** ****** */

#include <math.h>

/* ****** ****** */

#define atslib_isfinite_float isfinite
#define atslib_isfinite_double isfinite
#define atslib_isfinite_ldouble isfinite

/* ****** ****** */

#define atslib_isnormal_float isnormal
#define atslib_isnormal_double isnormal
#define atslib_isnormal_ldouble isnormal

/* ****** ****** */

#define atslib_isinf_float isinf
#define atslib_isinf_double isinf
#define atslib_isinf_ldouble isinf

/* ****** ****** */

#define atslib_isnan_float isnan
#define atslib_isnan_double isnan
#define atslib_isnan_ldouble isnan

/* ****** ****** */

#define atslib_fpclassify_float fpclassify
#define atslib_fpclassify_double fpclassify
#define atslib_fpclassify_ldouble fpclassify

/* ****** ****** */

#define atslib_ceil_float ceilf
#define atslib_ceil_double ceil
#define atslib_ceil_ldouble ceill

/* ****** ****** */

#define atslib_floor_float floorf
#define atslib_floor_double floor
#define atslib_floor_ldouble floorl

/* ****** ****** */

#define atslib_round_float roundf
#define atslib_round_double round
#define atslib_round_ldouble roundl

/* ****** ****** */

#define atslib_trunc_float truncf
#define atslib_trunc_double trunc
#define atslib_trunc_ldouble truncl

/* ****** ****** */

#define atslib_fmod_float fmodf
#define atslib_fmod_double fmod
#define atslib_fmod_ldouble fmodl

/* ****** ****** */

#define atslib_fmax_float fmaxf
#define atslib_fmax_double fmax
#define atslib_fmax_ldouble fmaxl

/* ****** ****** */

#define atslib_fmin_float fminf
#define atslib_fmin_double fmin
#define atslib_fmin_ldouble fminl

/* ****** ****** */

#define atslib_fdim_float fdimf
#define atslib_fdim_double fdim
#define atslib_fdim_ldouble fdiml

/* ****** ****** */

#define atslib_fma_float fmaf
#define atslib_fma_double fma
#define atslib_fma_ldouble fmal

/* ****** ****** */

#define atslib_sqrt_float sqrtf
#define atslib_sqrt_double sqrt
#define atslib_sqrt_ldouble sqrtl

/* ****** ****** */

#define atslib_cbrt_float cbrtf
#define atslib_cbrt_double cbrt
#define atslib_cbrt_ldouble cbrtl

/* ****** ****** */

#define atslib_pow_float powf
#define atslib_pow_double pow
#define atslib_pow_ldouble powl

/* ****** ****** */

#define atslib_exp_float expf
#define atslib_exp_double exp
#define atslib_exp_ldouble expl

/* ****** ****** */
//
#define atslib_log_float logf
#define atslib_log_double log
#define atslib_log_ldouble logl
//
#define atslib_log10_float log10f
#define atslib_log10_double log10
#define atslib_log10_ldouble log10l
//
/* ****** ****** */
//
#define atslib_sin_float sinf
#define atslib_sin_double sin
#define atslib_sin_ldouble sinl
//
#define atslib_cos_float cosf
#define atslib_cos_double cos
#define atslib_cos_ldouble cosl
//
#define atslib_tan_float tanf
#define atslib_tan_double tan
#define atslib_tan_ldouble tanl
//
/* ****** ****** */
//
#define atslib_asin_float asinf
#define atslib_asin_double asin
#define atslib_asin_ldouble asinl
//
#define atslib_acos_float acosf
#define atslib_acos_double acos
#define atslib_acos_ldouble cosl
//
#define atslib_atan_float atanf
#define atslib_atan_double atan
#define atslib_atan_ldouble atanl
//
#define atslib_atan2_float atan2f
#define atslib_atan2_double atan2
#define atslib_atan2_ldouble atan2l
//
/* ****** ****** */
//
#define atslib_sinh_float sinhf
#define atslib_sinh_double sinh
#define atslib_sinh_ldouble sinhl
//
#define atslib_cosh_float coshf
#define atslib_cosh_double cosh
#define atslib_cosh_ldouble coshl
//
#define atslib_tanh_float tanhf
#define atslib_tanh_double tanh
#define atslib_tanh_ldouble tanhl
//
/* ****** ****** */

#define atslib_asinh_float asinhf
#define atslib_asinh_double asinh
#define atslib_asinh_ldouble asinhl
//
#define atslib_acosh_float acoshf
#define atslib_acosh_double acosh
#define atslib_acosh_ldouble acoshl
//
#define atslib_atanh_float atanhf
#define atslib_atanh_double atanh
#define atslib_atanh_ldouble atanhl
//
/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_CATS_MATH

/* ****** ****** */

/* end of [math.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/CATS/CODEGEN/errno.atxt
** Time of generation: Wed Sep 23 16:09:11 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_CATS_ERRNO
#define ATSLIB_LIBC_CATS_ERRNO

/* ****** ****** */

#include <errno.h>

/* ****** ****** */

typedef int errno_t ;

/* ****** ****** */

#define ENONE 0

/* ****** ****** */

#define atslib_the_errno_get() (errno)
#define atslib_the_errno_set(eno) (errno = (eno))
#define atslib_the_errno_reset() (errno = ENONE)

ATSinline()
atstype_bool
atslib_the_errno_test(errno_t eno)
{
  return (errno==(eno)) ? atsbool_true : atsbool_false ;
}

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_CATS_ERRNO

/* ****** ****** */

/* end of [errno.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/CATS/CODEGEN/dirent.atxt
** Time of generation: Wed Sep 23 16:09:11 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_CATS_DIRENT
#define ATSLIB_LIBC_CATS_DIRENT

/* ****** ****** */

#include <sys/types.h>
#include <dirent.h> // HX: after sys/types

/* ****** ****** */

#include "share/H/pats_atslib.h"

/* ****** ****** */

typedef DIR atslib_DIR_type ;
typedef struct dirent atslib_dirent_type ;

/* ****** ****** */

#define atslib_direntp_free(x) atspre_mfree_gc(x)

/* ****** ****** */

#define atslib_dirent_get_d_ino(ent) (((atslib_dirent_type*)ent)->d_ino)
#define atslib_dirent_get_d_name(ent) (((atslib_dirent_type*)ent)->d_name)

/* ****** ****** */

#define atslib_direntp_get_d_name(entp) (((atslib_dirent_type*)entp)->d_name)

/* ****** ****** */

#define atslib_alphasort alphasort
#define atslib_versionsort versionsort

/* ****** ****** */

#define atslib_opendir opendir

/* ****** ****** */

#define atslib_closedir closedir

/* ****** ****** */

#define atslib_readdir readdir
#define \
atslib_readdir_r(dirp, ent, res) \
  readdir_r((DIR*)dirp, (atslib_dirent_type*)ent, (atslib_dirent_type**)res)

/* ****** ****** */

#define \
atslib_scandir(dirp, namelst, filter, compar) \
  scandir((char*)dirp, (atslib_dirent_type***)namelst, (void*)filter, (void*)compar)

/* ****** ****** */

#define atslib_rewinddir rewinddir

/* ****** ****** */

#define atslib_seekdir seekdir
#define atslib_telldir telldir

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_CATS_DIRENT

/* ****** ****** */

/* end of [dirent.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/CATS/CODEGEN/string.atxt
** Time of generation: Wed Sep 23 16:09:12 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_CATS_STRING
#define ATSLIB_LIBC_CATS_STRING

/* ****** ****** */

#include <errno.h>
#include <string.h>

/* ****** ****** */

#define atslib_strcmp strcmp
#define atslib_strncmp strncmp

/* ****** ****** */

#define atslib_strcoll strcoll

/* ****** ****** */

#define atslib_strspn strspn
#define atslib_strcspn strcspn

/* ****** ****** */

#define atslib_strlen strlen
#define atslib_strnlen strnlen

/* ****** ****** */

#define atslib_strcat strcat
#define atslib_strcat_unsafe strcat
#define atslib_strncat_unsafe strncat

/* ****** ****** */

#define atslib_strcpy strcpy
#define atslib_strcpy_unsafe strcpy
#define atslib_strncpy_unsafe strncpy

/* ****** ****** */

#define atslib_strdup strdup
#define atslib_strndup strndup
#define atslib_strdup_free atsruntime_mfree_libc

#define atslib_strdupa strdupa
#define atslib_strndupa strndupa
#define atslib_strdupa_free atsruntime_afree_libc

/* ****** ****** */

#define atslib_strfry strfry

/* ****** ****** */

#define atslib_memcpy memcpy
#define atslib_memcpy_unsafe memcpy

/* ****** ****** */

#define atslib_memccpy_unsafe memccpy

/* ****** ****** */

#define atslib_mempcpy mempcpy
#define atslib_mempcpy_unsafe mempcpy

/* ****** ****** */

#define atslib_memset_unsafe memset

/* ****** ****** */

#define atslib_memmove_unsafe memmove

/* ****** ****** */

#define atslib_strerror strerror
#define atslib_strerror_r strerror_r

/* ****** ****** */

ATSinline()
atstype_ptr
atslib_strdup_gc
  (atstype_string src)
{
  char *dst ;
  size_t len, len1 ;
  len = atslib_strlen((char*)src) ;
  len1 = len + 1;
  dst = atspre_malloc_gc(len1) ;
  return atslib_memcpy(dst, src, len1) ;
} // end of [atslib_strdup_gc]

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_CATS_STRING

/* ****** ****** */

/* end of [string.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/CATS/CODEGEN/float.atxt
** Time of generation: Wed Sep 23 16:09:11 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: October, 2014 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_CATS_FLOAT
#define ATSLIB_LIBC_CATS_FLOAT

/* ****** ****** */

#include <float.h>

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_CATS_FLOAT

/* ****** ****** */

/* end of [float.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/CATS/CODEGEN/stdio.atxt
** Time of generation: Wed Sep 23 16:09:12 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: September, 2011 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_CATS_STDIO
#define ATSLIB_LIBC_CATS_STDIO

/* ****** ****** */

#include <stdio.h>
/*
extern
void perror (const char* str) ; // in [stdio.h]
*/
extern void exit (int status) ; // in [stdlib.h]

/* ****** ****** */

#include "share/H/pats_atslib.h"

/* ****** ****** */

#define \
atslib_clearerr(p) clearerr(((FILE*)p))

/* ****** ****** */

#define atslib_fopen fopen
#define atslib_fopen_ref_exn atslib_fopen_exn

/* ****** ****** */

#define atslib_fclose fclose
#define atslib_fclose0 atslib_fclose
#define atslib_fclose1 atslib_fclose
#define atslib_fclose0_exn atslib_fclose_exn
#define atslib_fclose1_exn atslib_fclose_exn

/*
#define atslib_fclose_stdin() atslib_fclose_exn(stdin)
#define atslib_fclose_stdout() atslib_fclose_exn(stdout)
#define atslib_fclose_stderr() atslib_fclose_exn(stderr)
*/

/* ****** ****** */
//
#define atslib_fflush0_exn atslib_fflush_exn
//
#define atslib_fflush_all() atslib_fclose_exn((FILE*)0)
#define atslib_fflush_stdout() atslib_fclose_exn(stdout)
//
/* ****** ****** */

#define atslib_fileno fileno
#define atslib_fileno0 atslib_fileno
#define atslib_fileno1 atslib_fileno

/* ****** ****** */

#define atslib_fdopen fdopen

/* ****** ****** */

#define \
atslib_feof(p) feof(((FILE*)p))
#define atslib_feof0 atslib_feof
#define atslib_feof1 atslib_feof

/* ****** ****** */

#define \
atslib_ferror(p) ferror(((FILE*)p))
#define atslib_ferror0 atslib_ferror
#define atslib_ferror1 atslib_ferror

/* ****** ****** */

#define atslib_fgetc fgetc
#define atslib_fgetc0 atslib_fgetc
#define atslib_fgetc1 atslib_fgetc

/* ****** ****** */

#define atslib_getchar getchar
#define atslib_getchar0 atslib_getchar
#define atslib_getchar1 atslib_getchar

/* ****** ****** */

#define atslib_fputc fputc
#define atslib_fputc0_int atslib_fputc
#define atslib_fputc0_char(c, fp) atslib_fputc((int)c, fp)
#define atslib_fputc1_int atslib_fputc
#define atslib_fputc1_char(c, fp) atslib_fputc((int)c, fp)

#define atslib_fputc0_exn_int atslib_fputc_exn
#define atslib_fputc0_exn_char atslib_fputc_exn

/* ****** ****** */

#define atslib_putchar putchar
#define atslib_putchar0 atslib_putchar
#define atslib_putchar1 atslib_putchar

/* ****** ****** */

#define atslib_fgets fgets
#define atslib_fgets0 atslib_fgets
#define atslib_fgets1 atslib_fgets
#define atslib_fgets1_err atslib_fgets
#define atslib_fgets0_gc atslib_fgets_gc
#define atslib_fgets1_gc atslib_fgets_gc

/* ****** ****** */

#define atslib_fputs fputs
#define atslib_fputs0 atslib_fputs
#define atslib_fputs1 atslib_fputs
#define atslib_fputs0_exn atslib_fputs_exn
#define atslib_fputs1_exn atslib_fputs_exn

/* ****** ****** */

#define atslib_puts puts

/* ****** ****** */

#define atslib_fread fread
#define atslib_fread0 atslib_fread
#define atslib_fread1 atslib_fread

/* ****** ****** */

#define atslib_fwrite fwrite
#define atslib_fwrite0 atslib_fwrite
#define atslib_fwrite1 atslib_fwrite

/* ****** ****** */

#define atslib_fseek fseek
#define atslib_fseek0 atslib_fseek
#define atslib_fseek1 atslib_fseek

/* ****** ****** */

#define atslib_ftell ftell
#define atslib_ftell0 atslib_ftell
#define atslib_ftell1 atslib_ftell

/* ****** ****** */

#define atslib_perror perror

/* ****** ****** */

#define atslib_popen popen

/* ****** ****** */

#define atslib_pclose0_exn atslib_pclose_exn
#define atslib_pclose1_exn atslib_pclose_exn

/* ****** ****** */

#define atslib_rewind rewind
#define atslib_rewind0 atslib_rewind
#define atslib_rewind1 atslib_rewind

/* ****** ****** */

#define atslib_tmpfile tmpfile
#define atslib_tmpfile_ref_exn atslib_tmpfile_exn

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_CATS_STDIO

/* ****** ****** */

/* end of [stdio.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/libc/CATS/CODEGEN/dlfcn.atxt
** Time of generation: Wed Sep 23 16:09:11 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: December, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBC_CATS_DLFCN
#define ATSLIB_LIBC_CATS_DLFCN

/* ****** ****** */

#include <dlfcn.h>

/* ****** ****** */

#define atslib_dlopen dlopen
#define atslib_dlclose dlclose

/* ****** ****** */

#define atslib_dlerror dlerror

/* ****** ****** */

#define atslib_dlsym dlsym

/* ****** ****** */

#define atslib_dladdr dladdr
#define atslib_dlvsym dlvsym

/* ****** ****** */

#endif // ifndef ATSLIB_LIBC_CATS_DLFCN

/* ****** ****** */

/* end of [dlfcn.cats] */
(*
** HX-2013-09:
** This file contains toplevel defines
*)
(* ****** ****** *)
//
(*
** Various defines for packages
*)
#include "./HATS/atspre_define_pkgreloc.hats"
//
(* ****** ****** *)

(* end of [atspre_define.hats] *)
(*
** This is mostly for staloading
** template code in ATSLIB/prelude
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// AuthorEmail: gmhwxiATgmailCOM
//
(* ****** ****** *)

#ifndef SHARE_ATSPRE_STALOAD
#define SHARE_ATSPRE_STALOAD 1

(* ****** ****** *)
//
#define
PATSPRE_targetloc "$PATSHOME/prelude"
//
(* ****** ****** *)
//
staload _ = "{$PATSPRE}/DATS/basics.dats"
//
(* ****** ****** *)
//
staload _ = "{$PATSPRE}/DATS/pointer.dats"
//
(* ****** ****** *)
//
staload _ = "{$PATSPRE}/DATS/integer.dats"
staload _ = "{$PATSPRE}/DATS/integer_ptr.dats"
staload _ = "{$PATSPRE}/DATS/integer_fixed.dats"
//
(* ****** ****** *)
//
staload _ = "{$PATSPRE}/DATS/char.dats"
staload _ = "{$PATSPRE}/DATS/bool.dats"
staload _ = "{$PATSPRE}/DATS/float.dats"
//
(* ****** ****** *)

staload _ = "{$PATSPRE}/DATS/tuple.dats"

(* ****** ****** *)

staload _ = "{$PATSPRE}/DATS/memory.dats"

(* ****** ****** *)

staload _ = "{$PATSPRE}/DATS/string.dats"
staload _ = "{$PATSPRE}/DATS/strptr.dats"

(* ****** ****** *)

staload _ = "{$PATSPRE}/DATS/reference.dats"

(* ****** ****** *)

staload _ = "{$PATSPRE}/DATS/filebas.dats"
staload _ = "{$PATSPRE}/DATS/intrange.dats"

(* ****** ****** *)

staload _ = "{$PATSPRE}/DATS/gorder.dats"
staload _ = "{$PATSPRE}/DATS/gnumber.dats"
staload _ = "{$PATSPRE}/DATS/grandom.dats"

(* ****** ****** *)
//
staload _ = "{$PATSPRE}/DATS/list.dats"
staload _ = "{$PATSPRE}/DATS/list_vt.dats"
//
(* ****** ****** *)
//
staload _ = "{$PATSPRE}/DATS/option.dats"
staload _ = "{$PATSPRE}/DATS/option_vt.dats"
//
(* ****** ****** *)
//
staload _ = "{$PATSPRE}/DATS/array.dats"
staload _ = "{$PATSPRE}/DATS/arrayptr.dats"
staload _ = "{$PATSPRE}/DATS/arrayref.dats"
//
(* ****** ****** *)
//
staload _ = "{$PATSPRE}/DATS/matrix.dats"
staload _ = "{$PATSPRE}/DATS/matrixptr.dats"
staload _ = "{$PATSPRE}/DATS/matrixref.dats"
//
(* ****** ****** *)
//
staload _ = "{$PATSPRE}/DATS/stream.dats"
staload _ = "{$PATSPRE}/DATS/stream_vt.dats"
//
(* ****** ****** *)
//
staload _ = "{$PATSPRE}/DATS/gprint.dats"
//
staload _ = "{$PATSPRE}/DATS/tostring.dats"
//
(* ****** ****** *)
//
staload UNSAFE = "{$PATSPRE}/SATS/unsafe.sats"
//
staload _(*UNSAFE*) = "{$PATSPRE}/DATS/unsafe.dats"
//
(* ****** ****** *)

staload _(*CHECKAST*) = "{$PATSPRE}/DATS/checkast.dats"

(* ****** ****** *)

#endif // end of [#ifndef SHARE_ATSPRE_STALOAD]

(* ****** ****** *)

(* end of [atspre_staload.hats] *)
(*
** This is mostly for
** staloading ATSLIB/libats/ML
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// AuthorEmail: gmhwxiATgmailCOM
//
(* ****** ****** *)

#ifndef SHARE_ATSPRE_STALOAD_LIBATS_ML
#define SHARE_ATSPRE_STALOAD_LIBATS_ML 1

(* ****** ****** *)

#define
PATSLIBATS_targetloc "$PATSHOME/libats"

(* ****** ****** *)

staload "{$PATSLIBATS}/ML/SATS/basis.sats"

(* ****** ****** *)
//
staload "{$PATSLIBATS}/ML/SATS/list0.sats"
//
staload "{$PATSLIBATS}/ML/SATS/option0.sats"
//
staload "{$PATSLIBATS}/ML/SATS/array0.sats"
//
staload "{$PATSLIBATS}/ML/SATS/matrix0.sats"
//
staload "{$PATSLIBATS}/ML/SATS/string.sats"
staload "{$PATSLIBATS}/ML/SATS/strarr.sats"
//
staload "{$PATSLIBATS}/ML/SATS/filebas.sats"
staload "{$PATSLIBATS}/ML/SATS/intrange.sats"
//
staload "{$PATSLIBATS}/ML/SATS/stdlib.sats"
//
staload _(*anon*) = "{$PATSLIBATS}/ML/DATS/list0.dats"
//
staload _(*anon*) = "{$PATSLIBATS}/ML/DATS/option0.dats"
//
staload _(*anon*) = "{$PATSLIBATS}/ML/DATS/array0.dats"
staload _(*anon*) = "{$PATSLIBATS}/ML/DATS/matrix0.dats"
//
staload _(*anon*) = "{$PATSLIBATS}/ML/DATS/string.dats"
staload _(*anon*) = "{$PATSLIBATS}/ML/DATS/strarr.dats"
//
staload _(*anon*) = "{$PATSLIBATS}/ML/DATS/filebas.dats"
staload _(*anon*) = "{$PATSLIBATS}/ML/DATS/intrange.dats"
//
staload _(*anon*) = "{$PATSLIBATS}/ML/DATS/stdlib.dats"
//
(* ****** ****** *)
//
staload "{$PATSLIBATS}/ML/SATS/funmap.sats"
//
staload "{$PATSLIBATS}/ML/SATS/funset.sats"
//
staload _(*anon*) = "{$PATSLIBATS}/ML/DATS/funmap.dats"
staload _(*anon*) = "{$PATSLIBATS}/ML/DATS/funset.dats"
//
(* ****** ****** *)
//
staload "{$PATSLIBATS}/ML/SATS/hashtblref.sats"
//
staload _(*anon*) = "{$PATSLIBATS}/DATS/hashfun.dats"
staload _(*anon*) = "{$PATSLIBATS}/DATS/linmap_list.dats"
staload _(*anon*) = "{$PATSLIBATS}/DATS/hashtbl_chain.dats"
staload _(*anon*) = "{$PATSLIBATS}/ML/DATS/hashtblref.dats"
//
(* ****** ****** *)

#endif // SHARE_ATSPRE_STALOAD_LIBATS_ML

(* ****** ****** *)

(* end of [atslib_staload_libats_ML.hats] *)
(*
** For staloading
** some commonly used libc packages
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// AuthorEmail: gmhwxiATgmailCOM
//
(* ****** ****** *)

#ifndef SHARE_ATSLIB_STALOAD_LIBC
#define SHARE_ATSLIB_STALOAD_LIBC 1

(* ****** ****** *)

#define
PATSLIBC_targetloc "$PATSHOME/libc"

(* ****** ****** *)

staload ERRNO = "{$PATSLIBC}/SATS/errno.sats"
staload _(*ERRNO*) = "{$PATSLIBC}/DATS/errno.dats"

(* ****** ****** *)

staload DIRENT = "{$PATSLIBC}/SATS/dirent.sats"
staload _(*DIRENT*) = "{$PATSLIBC}/DATS/dirent.dats"

(* ****** ****** *)

staload MATH = "{$PATSLIBC}/SATS/float.sats"
staload _(*MATH*) = "{$PATSLIBC}/DATS/float.dats"

(* ****** ****** *)

staload MATH = "{$PATSLIBC}/SATS/math.sats"
staload _(*MATH*) = "{$PATSLIBC}/DATS/math.dats"

(* ****** ****** *)

staload SIGNAL = "{$PATSLIBC}/SATS/signal.sats"

(* ****** ****** *)

staload STDDEF = "{$PATSLIBC}/SATS/stddef.sats"

(* ****** ****** *)

staload STDIO = "{$PATSLIBC}/SATS/stdio.sats"
staload _(*STDIO*) = "{$PATSLIBC}/DATS/stdio.dats"

(* ****** ****** *)

staload STDLIB = "{$PATSLIBC}/SATS/stdlib.sats"
staload _(*STDLIB*) = "{$PATSLIBC}/DATS/stdlib.dats"

(* ****** ****** *)

staload STRING = "{$PATSLIBC}/SATS/string.sats"
staload _(*STRING*) = "{$PATSLIBC}/DATS/string.dats"
staload STRINGS = "{$PATSLIBC}/SATS/strings.sats"
staload _(*STRINGS*) = "{$PATSLIBC}/DATS/strings.dats"

(* ****** ****** *)

staload TIME = "{$PATSLIBC}/SATS/time.sats"
staload _(*TIME*) = "{$PATSLIBC}/DATS/time.dats"

(* ****** ****** *)

staload UNISTD = "{$PATSLIBC}/SATS/unistd.sats"
staload _(*UNISTD*) = "{$PATSLIBC}/DATS/unistd.dats"

(* ****** ****** *)

#endif // SHARE_ATSLIB_STALOAD_LIBC

(* ****** ****** *)

(* end of [atslib_staload_libc.hats] *)
(*
** For ATS2-package relocation
*)
(* ****** ****** *)
//
// HX-2014-08:
// PATSHOME is pre-defined
// PATSHOMERELOC is pre-defined
//
#define
PATSHOME_targetloc "$PATSHOME"
#define
PATSHOMERELOC_targetloc "$PATSHOMERELOC"
//
(* ****** ****** *)
//
#define
PATSPRE_targetloc "$PATSHOME/prelude"
#define
PATSLIBC_targetloc "$PATSHOME/libc"
#define
PATSLIBATS_targetloc "$PATSHOME/libats"
//
(* ****** ****** *)
//
#define
ATSLANGWEB "http://www.ats-lang.org"
#define
ATSLANGWEBLIB "http://www.ats-lang.org/LIBRARY"
//
(* ****** ****** *)
//
#define
PCRE_sourceloc "$ATSLANGWEBLIB/contrib/pcre"
#define
PCRE_targetloc "$PATSHOMERELOC/contrib/pcre"
//
(* ****** ****** *)
//
#define
LIBGMP_sourceloc "$ATSLANGWEBLIB/contrib/libgmp"
#define
LIBGMP_targetloc "$PATSHOMERELOC/contrib/libgmp"
//
(* ****** ****** *)
//
#define
ZLOG_targetloc "$PATSHOMERELOC/contrib/zlog"
//
(* ****** ****** *)
//
#define
ZEROMQ_targetloc "$PATSHOMERELOC/contrib/zeromq"
//
(* ****** ****** *)
//
#define
JSONC_sourceloc "$ATSLANGWEBLIB/contrib/json-c"
#define
JSONC_targetloc "$PATSHOMERELOC/contrib/json-c"
//
(* ****** ****** *)
//
#define
HIREDIS_sourceloc "$ATSLANGWEBLIB/contrib/hiredis"
#define
HIREDIS_targetloc "$PATSHOMERELOC/contrib/hiredis"
//
(* ****** ****** *)
//
#define
OPENSSL_sourceloc "$ATSLANGWEBLIB/contrib/OpenSSL"
#define
OPENSSL_targetloc "$PATSHOMERELOC/contrib/OpenSSL"
//
(* ****** ****** *)
//
#define
LIBCURL_sourceloc "$ATSLANGWEBLIB/contrib/libcurl"
#define
LIBCURL_targetloc "$PATSHOMERELOC/contrib/libcurl"
//
(* ****** ****** *)
//
#define
GTK_sourceloc "$ATSLANGWEBLIB/contrib/GTK"
#define
GTK_targetloc "$PATSHOMERELOC/contrib/GTK"
//
(* ****** ****** *)
//
#define
GLIB_sourceloc "$ATSLANGWEBLIB/contrib/glib"
#define
GLIB_targetloc "$PATSHOMERELOC/contrib/glib"
//
(* ****** ****** *)
//
#define
CAIRO_sourceloc "$ATSLANGWEBLIB/contrib/cairo"
#define
CAIRO_targetloc "$PATSHOMERELOC/contrib/cairo"
//
(* ****** ****** *)
//
#define
JNI_targetloc "$PATSHOMERELOC/contrib/JNI"
//
(* ****** ****** *)
//
#define
SDL2_targetloc "$PATSHOMERELOC/contrib/SDL2"
//
(* ****** ****** *)
//
#define
GUROBI_targetloc "$PATSHOMERELOC/contrib/gurobi"
//
(* ****** ****** *)
//
#define
KERNELATS_targetloc "$PATSHOMERELOC/contrib/kernelats"
//
(* ****** ****** *)
//
#define
LIBATSCC_targetloc
"$PATSHOMERELOC/contrib/libatscc"
//
#define
LIBATSCC2JS_targetloc
"$PATSHOMERELOC/contrib/libatscc/libatscc2js"
//
#define
LIBATSCC2ERL_targetloc
"$PATSHOMERELOC/contrib/libatscc/libatscc2erl"
//
#define
LIBATSCC2PHP_targetloc
"$PATSHOMERELOC/contrib/libatscc/libatscc2php"
//
#define
LIBATSCC2PL_targetloc
"$PATSHOMERELOC/contrib/libatscc/libatscc2pl"
//
#define
LIBATSCC2PY_targetloc
"$PATSHOMERELOC/contrib/libatscc/libatscc2py"
//
(* ****** ****** *)
//
// HX-2014-05-12:
// This is for backward compatibility
//
#define
LIBATSHWXI_sourceloc "$ATSLANGWEBLIB/contrib/libats-/hwxi"
#define
LIBATSHWXI_targetloc "$PATSHOMERELOC/contrib/libats-/hwxi"
//
#define
LIBATS_HWXI_sourceloc "$ATSLANGWEBLIB/contrib/libats-/hwxi"
#define
LIBATS_HWXI_targetloc "$PATSHOMERELOC/contrib/libats-/hwxi"
//
(* ****** ****** *)
//
// For applying ATS to AVR programming
//
#define AVR_sourceloc "$ATSLANGWEBLIB/contrib/AVR"
#define AVR_targetloc "$PATSHOMERELOC/contrib/AVR"
//
#define ARDUINO_sourceloc "$ATSLANGWEBLIB/contrib/arduino"
#define ARDUINO_targetloc "$PATSHOMERELOC/contrib/arduino"
//
(* ****** ****** *)
//
// For applying ATS to Linux kernel programming
//
#define LINUX_sourceloc "$ATSLANGWEBLIB/contrib/linux"
#define LINUX_targetloc "$PATSHOMERELOC/contrib/linux"
//
(* ****** ****** *)

#define EXTSOLVE_sourceloc "$ATSLANGWEBLIB/contrib/extsolve"
#define EXTSOLVE_targetloc "$PATSHOMERELOC/contrib/extsolve"

(* ****** ****** *)

(* end of [atspre_define_pkgreloc.hats] *)
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

#ifndef PATS_ATSLIB_H
#define PATS_ATSLIB_H

/* ****** ****** */

#include <errno.h> // for [errno]
#include <stdio.h> // for [perror]

/* ****** ****** */

#define \
ATSLIBfailexit(cmd) \
do { \
  fprintf(stderr, "exit(ATSLIB): [%s] failed\n", cmd) ; exit(1) ; \
} while (0) \

/* ****** ****** */

#define \
ATSLIBfailexit2(cmd) \
do { \
  perror(cmd) ; \
  fprintf(stderr, "exit(ATSLIB): [%s] failed\n", cmd) ; exit(1) ; \
} while (0) \

/* ****** ****** */

#endif // ifndef PATS_ATSLIB_H

/* ****** ****** */

/* end of [pats_atslib.h] */
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author of the file:
// Hongwei Xi (gmhwxiATgmailDOTcom)
// Start Time: March, 2013
//
(* ****** ****** *)
//
// HX-2013-03:
// lmacrodef: local macro definitions
//
(* ****** ****** *)
//
macdef :+= (x, a) = let val v = ,(x) in ,(x) := ,(a) + v end
macdef :-= (x, a) = let val v = ,(x) in ,(x) := ,(a) - v end
macdef :*= (x, a) = let val v = ,(x) in ,(x) := ,(a) * v end
macdef :/= (x, a) = let val v = ,(x) in ,(x) := ,(a) / v end
//
(* ****** ****** *)
//
macdef :=+ (x, a) = let val v = ,(x) in ,(x) := v + ,(a) end
macdef :=- (x, a) = let val v = ,(x) in ,(x) := v - ,(a) end
macdef :=* (x, a) = let val v = ,(x) in ,(x) := v * ,(a) end
macdef :=/ (x, a) = let val v = ,(x) in ,(x) := v / ,(a) end
//
(* ****** ****** *)

(*

//
// HX-2012-08:
//
// this example makes use of recursive macrodef
//
local

macrodef
rec
auxlist
  (xs, y) =
(
//
if iscons! (xs) then
  `(print ,(car! xs); ,(auxlist (cdr! xs, y)))
else y // end of [if]
//
) // end of [auxlist]

in // in of [local]

macdef
print_mac (x) =
,(
  if islist! (x) then auxlist (x, `()) else `(print ,(x))
) // end of [print_mac]

macdef
println_mac (x) =
,(
  if islist! (x)
    then auxlist (x, `(print_newline())) else `(print ,(x))
  // end of [if]
) // end of [println_mac]

end // end of [local]

*)

(* ****** ****** *)

(* end of [lmacrodef.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author of the file:
// Hongwei Xi (gmhwxiATgmailDOTcom)
// Start Time: July, 2012
//
(* ****** ****** *)

#include "prelude/params.hats"

(* ****** ****** *)

#if VERBOSE_PRELUDE #then
#print "Loading [basics_gen.sats] starts!\n"
#endif // end of [VERBOSE_PRELUDE]

(* ****** ****** *)
//
fun
{a:t0p}
gidentity (x: INV(a)):<> a
//
fun
{a:vt0p}
gidentity_vt (x: INV(a)):<> a
//
(* ****** ****** *)
//
fun
{a:t0p}
gcopy_val (x: INV(a)):<> a
//
fun
{a:vt0p}
gcopy_ref (x: &INV(a)):<!wrt> a
//
(* ****** ****** *)

fun
{a:vt0p}
gfree_val (x: INV(a)):<!wrt> void

(* ****** ****** *)

fun
{a:vt0p}
ginit_ref (x: &a? >> a):<!wrt> void

(* ****** ****** *)

fun
{a:vt0p}
gclear_ref (x: &a >> a?):<!wrt> void

(* ****** ****** *)
//
fun
{a:t0p}
gequal_val_val (x: a, y: a):<> bool
//
fun
{a:vt0p}
gequal_ref_ref (x: &INV(a), y: &a):<> bool
//
(* ****** ****** *)

fun{a:t0p}
tostring_val (x: a):<> string
fun{a:vt0p}
tostring_ref (x: &INV(a)):<> string

(* ****** ****** *)

fun{a:t0p}
tostrptr_val (x: a):<!wrt> Strptr1
fun{a:vt0p}
tostrptr_ref (x: &INV(a)):<!wrt> Strptr1

(* ****** ****** *)

fun{a:t0p}
fprint_val (out: FILEref, x: a): void
fun{a:vt0p}
fprint_ref (out: FILEref, x: &INV(a)): void

(* ****** ****** *)

(*
//
fun{a:t0p}
print_val (x: a): void // = fprint_val (stdout_ref, x)
fun{a:t0p}
prerr_val (x: a): void // = fprint_val (stderr_ref, x)
//
fun{a:vt0p}
print_ref (x: &INV(a)): void // = fprint_ref (stdout_ref, x)
fun{a:vt0p}
prerr_ref (x: &INV(a)): void // = fprint_ref (stderr_ref, x)
//
*)

(* ****** ****** *)

#if VERBOSE_PRELUDE #then
#print "Loading [basics_gen.sats] finishes!\n"
#endif // end of [VERBOSE_PRELUDE]

(* ****** ****** *)

(* end of [basics_gen.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author of the file:
// Hongwei Xi (gmhwxiATgmailDOTcom)
// Start Time: May, 2012
//
(* ****** ****** *)

#include "prelude/params.hats"

(* ****** ****** *)

(*
** HX: short form
*)
//
// [orelse] and [andalso] are declared as infix ops
//
macdef
orelse (x, y) = (if ,(x) then true else ,(y)): bool
macdef
andalso (x, y) = (if ,(x) then ,(y) else false): bool
//
(* ****** ****** *)

macdef assign (lv, rv) = ,(lv) := ,(rv)

(* ****** ****** *)

macdef exitloc (x) = exit_errmsg (,(x), $mylocation)

(* ****** ****** *)

macdef assertloc (x) = assert_errmsg (,(x), $mylocation)

(* ****** ****** *)
//
macdef
assertlocmsg
  (x, msg) = assert_errmsg2 (,(x), $mylocation, ,(msg))
macdef
assertmsgloc
  (x, msg) = assert_errmsg2 (,(x), ,(msg), $mylocation)
//
(* ****** ****** *)

macdef ignoret (x) = let val x = ,(x) in (*nothing*) end

(* ****** ****** *)

macdef foldret (x) = let val x = ,(x) in fold@ (x); x end

(* ****** ****** *)
//
macdef showtype (x) = $showtype ,(x)
//
macdef showview (x) = pridentity_v ($showtype ,(x))
//
macdef showvtype (x) = pridentity_vt ($showtype ,(x))
macdef showviewtype (x) = pridentity_vt ($showtype ,(x))
//
(* ****** ****** *)

(* end of [macrodef.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author of the file:
// Hongwei Xi (gmhwxiATgmailDOTcom)
// Start Time: September, 2011
//
(* ****** ****** *)
//
#define VERBOSE_FIXITY 0
(*
#define VERBOSE_FIXITY 1 (* used in [prelude/fixity.ats] *)
*)
//
(* ****** ****** *)
//
#define VERBOSE_PRELUDE 0
(*
#define VERBOSE_PRELUDE 1 (* mainly for the purpose of debugging *)
*)
//
(* ****** ****** *)

(* end of [params.hats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: hwxiATcsDOTbuDOTedu
//
// This one was
// there at the very beginning of ATS
//
(* ****** ****** *)
//
(*
HX: fixity declarations
*)
#include "prelude/params.hats"
//
(* ****** ****** *)

#if VERBOSE_FIXITY #then
#print "Loading [fixity.ats] starts!\n"
#endif // end of [VERBOSE_FIXITY]

(* ****** ****** *)
//
(*
prefix 00 ! (* static *)
*)
//
prefix 99 ! (* dynamic *)
//
(* ****** ****** *)

(*
prefix 81 ID (* identity *)
*)

(* ****** ****** *)

(*
postfix 80 .lab // dynamic
postfix 80 ->lab // dynamic
*)

(* ****** ****** *)

(*
prefix 79 & // dynamic
*)

(* ****** ****** *)

(*
infixl 70 app
*)

(* ****** ****** *)

(*
postfix 69 ?
*)

(* ****** ****** *)
//
// HX-2015-08-04:
// mostly following the Fortran convention
//
(* ****** ****** *)

infixr 61 ** (*exp*)

(* ****** ****** *)
//
// multiplicative
//
infixl 60 * / % mod
//
(*
infixl 60 nmul ndiv nmod
*)
//
(* ****** ****** *)

prefix 51 ~ (*negative*)

(* ****** ****** *)
//
infixl 50 + - (*additive*)
//
(*
infixr (+) ++ // concatenative
*)
//
(* ****** ****** *)

infixl 41 asl asr
infixl 41 lsl lsr

(* ****** ****** *)
//
infix 40 < <= > >=
//
(*
//
// HX-2012-07: removed
//
infixl ( < ) ilt flt plt ult
infixl ( <= ) ilte flte plte ulte
infixl ( > ) igt fgt pgt ugt
infixl ( >= ) igte fgte pgte ugte
*)
//
(* ****** ****** *)

infixr 40 :: @

(* ****** ****** *)

infix 30 = == != <>

(* ****** ****** *)

(*
//
// HX-2012-07: removed
//
infix ( = ) ieq feq peq ueq
infix ( <> ) ineq fneq pneq uneq
*)

(* ****** ****** *)

infixl 21 &&
infixl ( && ) andalso land

(* ****** ****** *)

infixl 20 ||
infixl ( || ) orelse lor lxor

(* ****** ****** *)

infixr 10 ->

(* ****** ****** *)

infix 0 := // HX: assign
infix 0 :=: // HX: exchange

(* ****** ****** *)

infixl 0 << (* g0int_asl, g0uint_lsl *)
infixr 0 >> (* g0int_asr, g0uint_lsr *)

(* ****** ****** *)

prefix 0 ++ -- // inc and dec
prefix 0 !++ --! // getinc and decget
infixr 0 =++ --= // setinc and decset

(* ****** ****** *)

infix 0 :+= :-= :*= :/= // x:=x+a, x:=x-a, ...
infix 0 :=+ :=- :=* :=/ // x:=a+x, x:=a-x, ...

(* ****** ****** *)

#if VERBOSE_FIXITY #then
#print "Loading [fixity.ats] finishes!\n"
#endif // end of [VERBOSE_FIXITY]

(* end of [fixity.ats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author of the file:
// Hongwei Xi (gmhwxiATgmailDOTcom)
// Start Time: September, 2011
//
(* ****** ****** *)

#include "prelude/params.hats"

(* ****** ****** *)

#if VERBOSE_PRELUDE #then
#print "Loading [basics_pre.sats] starts!\n"
#endif // end of [VERBOSE_PRELUDE]

(* ****** ****** *)
//
// HX:
// some built-in static boolean constants
//
stacst true_bool : bool and false_bool : bool
stadef true = true_bool and false = false_bool
//
stacst neg_bool
  : bool -> bool (* boolean negation *)
stadef ~ = neg_bool // overloaded
//
stacst add_bool_bool
  : (bool, bool) -> bool (* disjunction *)
stacst mul_bool_bool
  : (bool, bool) -> bool (* conjunction *)
stadef + = add_bool_bool and * = mul_bool_bool
stadef || = add_bool_bool and && = mul_bool_bool
//
stacst lt_bool_bool : (bool, bool) -> bool
stacst lte_bool_bool : (bool, bool) -> bool
stacst gt_bool_bool : (bool, bool) -> bool
stacst gte_bool_bool : (bool, bool) -> bool
stadef < = lt_bool_bool
stadef <= = lte_bool_bool
stadef > = gt_bool_bool
stadef >= = gte_bool_bool
//
stacst eq_bool_bool : (bool, bool) -> bool
stacst neq_bool_bool : (bool, bool) -> bool
stadef == = eq_bool_bool
stadef != = neq_bool_bool
stadef <> = neq_bool_bool // backward compatibility // deprecated
//
(* ****** ****** *)

(*
//
// HX-2012-06-12: removed
//
stacst
eq_char_char : (char, char) -> bool
stacst
neq_char_char : (char, char) -> bool
//
stadef == = eq_char_char
stadef != = neq_char_char
stadef <> = neq_char_char // backward compatibility // deprecated
//
*)

(* ****** ****** *)
//
stacst neg_int : (int) -> int
stadef ~ = neg_int // overloaded
//
stacst
add_int_int : (int, int) -> int
stacst
sub_int_int : (int, int) -> int
stacst
mul_int_int : (int, int) -> int
stacst
div_int_int : (int, int) -> int
//
stadef + = add_int_int
stadef - = sub_int_int
stadef * = mul_int_int
stadef / = div_int_int
//
// HX: ndiv: divisor is positive
// HX: idiv: alias for div_int_int
//
stacst
ndiv_int_int : (int, int) -> int
stacst
idiv_int_int : (int, int) -> int
//
stadef ndiv = ndiv_int_int
stadef idiv = idiv_int_int
//
stadef
nmod_int_int
(
  x:int, y:int
) = x - y * (x \ndiv_int_int y)
//
stadef mod = nmod_int_int
stadef nmod = nmod_int_int
stadef % (*adopted from C*) = nmod_int_int
//
(* ****** ****** *)
//
stacst lt_int_int : (int, int) -> bool
stacst lte_int_int : (int, int) -> bool
stacst gt_int_int : (int, int) -> bool
stacst gte_int_int : (int, int) -> bool
stadef < = lt_int_int and <= = lte_int_int
stadef > = gt_int_int and >= = gte_int_int
//
stacst eq_int_int : (int, int) -> bool
stacst neq_int_int : (int, int) -> bool
stadef == = eq_int_int
stadef != = neq_int_int
stadef <> = neq_int_int // HX: backward compatibility
//
(* ****** ****** *)
//
stacst abs_int : (int) -> int
stadef abs = abs_int
stadef absrel_int_int
  (x: int, v: int): bool =
  (x >= 0 && x == v) || (x <= 0 && ~x == v)
stadef absrel = absrel_int_int
//
stacst sgn_int : (int) -> int
stadef sgn = sgn_int
stadef sgnrel_int_int
  (x: int, v: int): bool =
  (x > 0 && v==1) || (x==0 && v==0) || (x < 0 && v==(~1))
stadef sgnrel = sgnrel_int_int
//
stacst max_int_int : (int, int) -> int
stadef max = max_int_int
stacst min_int_int : (int, int) -> int
stadef min = min_int_int
stadef maxrel_int_int_int
  (x: int, y: int, v: int): bool =
  (x >= y && x == v) || (x <= y && y == v)
stadef maxrel = maxrel_int_int_int
stadef minrel_int_int_int
  (x: int, y: int, v: int): bool =
  (x >= y && y == v) || (x <= y && x == v)
stadef minrel = minrel_int_int_int
//
stadef nsub (x:int, y:int) = max (x-y, 0)
//
stadef
ndivrel_int_int_int // HX: y > 0
  (x: int, y: int, q: int): bool =
  (q * y <= x) && (x < q * y + y)
stadef ndivrel = ndivrel_int_int_int
//
stadef
idivrel_int_int_int
  (x: int, y: int, q: int) = ( // HX: y != 0
  x >= 0 && y > 0 && ndivrel_int_int_int ( x,  y,  q)
) || (
  x >= 0 && y < 0 && ndivrel_int_int_int ( x, ~y, ~q)
) || (
  x <  0 && y > 0 && ndivrel_int_int_int (~x,  y, ~q)
) || (
  x <  0 && y < 0 && ndivrel_int_int_int (~x, ~y,  q)
) // end of [idivrel_int_int_int]
//
stadef idivrel = idivrel_int_int_int
//
stadef
divmodrel_int_int_int_int
  (x: int, y: int, q: int, r: int) : bool =
  (0 <= r && r < y && x == q*y + r)
stadef divmodrel = divmodrel_int_int_int_int
//
(* ****** ****** *)

stacst
ifint_bool_int_int
  : (bool, int, int) -> int
stadef ifint = ifint_bool_int_int
stadef
ifintrel_bool_int_int_int
  (b:bool, x:int, y:int, r:int): bool =
  (b && r==x) || (~b && r==y)
// end of [ifintrel]

(* ****** ****** *)

stadef
bool2int(b: bool): int = ifint (b, 1, 0)
stadef int2bool (i: int): bool = (i != 0)
stadef b2i = bool2int and i2b = int2bool

(* ****** ****** *)

(*
** HX: [char] = [int8]
** HX-2012-06-12: removed
//
stacst int_of_char: char -> int
stacst char_of_int : int -> char
stadef c2i = int_of_char and i2c = char_of_int
//
*)

(* ****** ****** *)

(*
** HX: pointer <-> integer
*)
stacst int_of_addr: addr -> int
stacst addr_of_int: int -> addr
stadef a2i = int_of_addr and i2a = addr_of_int

(* ****** ****** *)
//
stadef pow2_7 = 128
stadef pow2_8 = 256
stadef i2u_int8 (i:int) = ifint (i >= 0, i, i+pow2_8)
stadef i2u8 = i2u_int8
stadef u2i_int8 (u:int) = ifint (u < pow2_7, u, u-pow2_8)
stadef u2i8 = u2i_int8
//
stadef pow2_15 = 32768
stadef pow2_16 = 65536
stadef i2u_int16 (i:int) = ifint (i >= 0, i, i+pow2_16)
stadef i2u16 = i2u_int16
stadef u2i_int16 (u:int) = ifint (u < pow2_15, u, u-pow2_16)
stadef u2i16 = u2i_int16
//
(* ****** ****** *)

stadef pow2_32 = 0x100000000
stadef pow2_64 = 0x10000000000000000

(* ****** ****** *)

stacst null_addr : addr
stadef null = null_addr
stadef NULL = null_addr

stacst add_addr_int : (addr, int) -> addr
stacst sub_addr_int : (addr, int) -> addr
stacst sub_addr_addr : (addr, addr) -> int
stadef + = add_addr_int
stadef - = sub_addr_int
stadef - = sub_addr_addr

stacst lt_addr_addr : (addr, addr) -> bool
stacst lte_addr_addr : (addr, addr) -> bool
stadef < = lt_addr_addr
stadef <= = lte_addr_addr

stacst gt_addr_addr : (addr, addr) -> bool
stacst gte_addr_addr : (addr, addr) -> bool
stadef > = gt_addr_addr
stadef >= = gte_addr_addr

stacst eq_addr_addr : (addr, addr) -> bool
stacst neq_addr_addr : (addr, addr) -> bool
stadef == = eq_addr_addr
stadef != = neq_addr_addr and <> = neq_addr_addr

(* ****** ****** *)
//
// HX-2013-09:
// for supporting inheritance in OOP
//
stacst lte_cls_cls : (cls, cls) -> bool
stacst gte_cls_cls : (cls, cls) -> bool
stadef <= = lte_cls_cls
stadef >= = gte_cls_cls
//
stadef
lterel_cls_cls
(
  c1: cls, c2: cls, lterel_cls_cls_res: bool
) : bool = lterel_cls_cls_res
stadef
gterel_cls_cls
(
  c1: cls, c2: cls, gterel_cls_cls_res: bool
) : bool = gterel_cls_cls_res
//
(* ****** ****** *)
//
// HX: this is a special constant!
//
stacst
sizeof_t0ype_int : t@ype -> int
stadef
sizeof (a:viewt@ype): int = sizeof_t0ype_int (a?)
//
(* ****** ****** *)

sortdef nat = { i:int | i >= 0 } // natural numbers
sortdef pos = { i:int | i > 0 }
sortdef neg = { i:int | i < 0 }
sortdef npos = { i:int | i <= 0 } // non-positive integers

sortdef nat1 = { n:nat | n < 1 } // for 0
sortdef nat2 = { n:nat | n < 2 } // for 0, 1
sortdef nat3 = { n:nat | n < 3 } // for 0, 1, 2
sortdef nat4 = { n:nat | n < 4 } // for 0, 1, 2, 3

sortdef sgn = { i:int | ~1 <= i; i <= 1 }

sortdef agz = { l:addr | l > null }
sortdef agez = { l:addr | l >= null }
sortdef alez = { l:addr | l <= null }

(* ****** ****** *)

#define CHAR_MAX 127
#define CHAR_MIN ~128
#define UCHAR_MAX 0xFF

(* ****** ****** *)
//
stacst effnil : eff // nothing
stacst effall : eff // everything
//
stacst effntm : eff // nonterm
stacst effexn : eff // exception
stacst effref : eff // reference
stacst effwrt : eff // writeover
//
stacst add_eff_eff : (eff, eff) -> eff
stadef + = add_eff_eff // union of effsets
stacst sub_eff_eff : (eff, eff) -> eff
stadef - = add_eff_eff // difference of effsets
//
(* ****** ****** *)
//
// HX: some overloaded symbols
//
symintr ~ not
(*
symintr && || // macros
*)
symintr lnot lor lxor land
symintr + - * / % mod ndiv nmod
symintr < <= > >= = == != <> compare
symintr isltz isltez isgtz isgtez iseqz isneqz
symintr neg abs max min
symintr succ pred half double
symintr square sqrt cube cbrt pow
//
symintr [] // for subscripting
symintr << >> // for L/R-shifting
//
symintr inc dec
symintr ++ -- // inc and dec
symintr get set exch
symintr getinc setinc exchinc
symintr decget decset decexch
symintr !++ --! // getinc and decget
symintr =++ --= // setinc and decset
//
symintr assert
//
symintr encode decode
//
symintr g0ofg1 g1ofg0 // casting: dpt <-> ndpt
symintr ptrcast (* for functions taking the address of a boxed val *)
//
symintr copy free length
//
symintr print prerr fprint
//
(*
//
symintr forall
symintr iforall
//
symintr foreach
symintr foreach2
symintr iforeach
symintr rforeach
//
*)
//
symintr ofstring ofstrptr
symintr tostring tostrptr
//
(* ****** ****** *)
//
// HX-2014-02:
// for dot-notation overloading
//
symintr .size
symintr .length
symintr .get .set .exch
symintr .nrow .ncol
symintr .head .tail
symintr .next .prev
symintr .init .last
symintr .eval
//
(* ****** ****** *)
//
// HX-2012-05-23: for template args
//
abstype atstkind_type (tk: tkind)
abst@ype atstkind_t0ype (tk: tkind)
//
typedef
tkind_type (tk:tkind) = atstkind_type (tk)
typedef
tkind_t0ype (tk:tkind) = atstkind_t0ype (tk)
//
(* ****** ****** *)

absview // S2Eat
at_vt0ype_addr_view (vt@ype+, addr)
stadef @ = at_vt0ype_addr_view // HX: @ is infix

(* ****** ****** *)
//
absvt@ype
clo_t0ype_t0ype (a: t@ype) = a
absvt@ype
clo_vt0ype_vt0ype (a: vt@ype) = a
//
(* ****** ****** *)
(*
absview
read_view_int_int_view
  (v:view, stamp:int, n:int)
stadef READ = read_view_int_int_view
viewdef READ (v:view) = [s,n:int] READ (v, s, n)
stadef RD = READ
//
absview
readout_view_int_view (v:view, stamp:int)
stadef READOUT = readout_view_int_view
viewdef READOUT (v:view) = [s:int] READOUT (v, s)
//
absvt@ype
read_vt0ype_int_int_vt0ype
  (a:vt@ype, stamp:int, n:int) = a
stadef READ = read_vt0ype_int_int_vt0ype
vtypedef READ (a:vt@ype) = [s,n:int] READ (a, s, n)
stadef RD = READ
//
absvt@ype
readout_vt0ype_int_vt0ype (a:vt@ype, stamp: int) = a
stadef READOUT = readout_vt0ype_int_vt0ype
vtypedef READOUT (a:vt@ype) = [s:int] READOUT (a, s)
*)

(* ****** ****** *)

(*
absvt@ype
write_vt0ype_vt0ype (a: vt@ype) = a
vtypedef
WRITE (a:vt@ype) = write_vt0ype_vt0ype (a)
stadef WRT = WRITE
*)

(* ****** ****** *)
//
vtypedef READ (a:vt@ype) = a // HX: used as a comment
vtypedef WRITE (a:vt@ype) = a // HX: used as a comment (rarely)
//
(*
vtypedef SHARED (a:vt@ype) = a // HX: used as a comment
vtypedef NSHARED (a:vt@ype) = a // HX: used as a comment (rarely)
*)
//
(* ****** ****** *)
//
absprop invar_prop_prop (a:prop)
absview invar_view_view (a:view)
//
abst@ype // S2Einvar
invar_t0ype_t0ype (a:t@ype) = a
absvt@ype // S2Einvar
invar_vt0ype_vt0ype (a:vt@ype) = a
//
// HX: this order is significant
// 
viewdef
INV (a: view) = invar_view_view (a)
propdef
INV (a: prop) = invar_prop_prop (a)
//
vtypedef INV
  (a:vt@ype) = invar_vt0ype_vt0ype (a)
//
vtypedef
INV (a: t@ype) = invar_t0ype_t0ype (a)
//
(* ****** ****** *)
(*
//
absprop optarg_prop_prop (a:prop)
absview optarg_view_view (a:view)
//
abst@ype
optarg_t0ype_t0ype (a:t@ype) = a
absvt@ype
optarg_vt0ype_vt0ype (a:vt@ype) = a
//
// HX: this order is significant
// 
viewdef
OPT (a: view) = optarg_view_view (a)
propdef
OPT (a: prop) = optarg_prop_prop (a)
//
vtypedef OPT
  (a:vt@ype) = optarg_vt0ype_vt0ype (a)
//
vtypedef
OPT (a: t@ype) = optarg_t0ype_t0ype (a)
//
*)
(* ****** ****** *)
//
abst@ype
stamped_t0ype (a:t@ype, int) = a
stadef stamped_t = stamped_t0ype
//
absvt@ype
stamped_vt0ype (a:vt@ype, int) = a
stadef stamped_vt = stamped_vt0ype
//
(* ****** ****** *)
//
absview
vcopyenv_view_view (v:view)
stadef vcopyenv_v = vcopyenv_view_view
absvt@ype
vcopyenv_vt0ype_vt0ype (vt: vt0ype) = vt
stadef vcopyenv_vt = vcopyenv_vt0ype_vt0ype
//
(* ****** ****** *)

#if VERBOSE_PRELUDE #then
#print "Loading [basics_pre.sats] finishes!\n"
#endif // end of [VERBOSE_PRELUDE]

(* ****** ****** *)

(* end of [basics_pre.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author of the file:
// Hongwei Xi (gmhwxiATgmailDOTcom)
// Start Time: September, 2011
//
(* ****** ****** *)

#include "prelude/params.hats"

(* ****** ****** *)

#if VERBOSE_PRELUDE #then
#print "Loading [basics_sta.sats] starts!\n"
#endif // end of [VERBOSE_PRELUDE]

(* ****** ****** *)

#define RD(x) x // for commenting: read-only

(* ****** ****** *)
(*
//
// HX-2012-05-24:
// the following two styles are equivalent:
//
stadef
bool_kind = $extkind"atstype_bool"
tkindef bool_kind = "atstype_bool"
*)
(* ****** ****** *)
//
tkindef bool_kind = "atstype_bool"
//
abst@ype
bool_t0ype = tkind_t0ype (bool_kind)
stadef bool = bool_t0ype // shorthand
abst@ype
bool_bool_t0ype (b: bool) = bool_t0ype
stadef bool = bool_bool_t0ype // shorthand
//
typedef Bool = [b:bool] bool (b)
typedef boolLte
  (b1:bool) = [b2:bool] bool (b2 <= b1) // b2 -> b1
typedef boolGte
  (b1:bool) = [b2:bool] bool (b2 >= b1) // b1 -> b2
//
abst@ype atstype_bool // HX-2013-09: for internal use
//
(* ****** ****** *)

tkindef
byte_kind = "atstype_byte"
abst@ype
byte_t0ype = tkind_t0ype (byte_kind)
stadef byte = byte_t0ype

(* ****** ****** *)
//
// char is signed
//
sortdef int8 = {
  i:int | ~128 <= i; i < 128
} // end of [int8]
sortdef uint8 =
  { i:int | 0 <= i; i < 256 }
// end of [uint8]
//
tkindef char_kind = "atstype_char"
//
abst@ype
char_t0ype = tkind_t0ype (char_kind)
stadef char = char_t0ype // shorthand
abst@ype
char_int_t0ype (c:int) = char_t0ype
stadef char = char_int_t0ype // shorthand
typedef Char = [c:int8] char (c)
typedef charNZ = [c:int8 | c != 0] char (c)
//
// signed characters
//
tkindef schar_kind = "atstype_schar"
//
abst@ype
schar_t0ype = tkind_t0ype (schar_kind)
stadef schar = schar_t0ype // shorthand
abst@ype
schar_int_t0ype (c:int) = schar_t0ype
stadef schar = schar_int_t0ype // shorthand
typedef sChar = [c:int8] schar (c)
//
// unsigned characters
//
tkindef uchar_kind = "atstype_uchar"
//
abst@ype
uchar_t0ype = tkind_t0ype (uchar_kind)
stadef uchar = uchar_t0ype // shorthand
abst@ype
uchar_int_t0ype (c:int) = uchar_t0ype
stadef uchar = uchar_int_t0ype // shorthand
typedef uChar = [c:uint8] uchar (c)
//
(* ****** ****** *)

sortdef tk = tkind

(* ****** ****** *)
//
abst@ype
g0int_t0ype (tk:tk) = tkind_t0ype (tk)
stadef g0int = g0int_t0ype // shorthand
abst@ype
g1int_int_t0ype (tk:tkind, int) = g0int (tk)
stadef g1int = g1int_int_t0ype // shorthand
//
typedef g1int (tk:tkind) = [i:int] g1int (tk, i)
typedef g1int0 (tk:tkind) = [i:int | i >= 0] g1int (tk, i)
typedef g1int1 (tk:tkind) = [i:int | i >= 1] g1int (tk, i)
//
(* ****** ****** *)
//
typedef g1intLt
  (tk:tk, n:int) = [i:int | i < n] g1int (tk, i)
typedef g1intLte
  (tk:tk, n:int) = [i:int | i <= n] g1int (tk, i)
typedef g1intGt
  (tk:tk, n:int) = [i:int | i > n] g1int (tk, i)
typedef g1intGte
  (tk:tk, n:int) = [i:int | i >= n] g1int (tk, i)
typedef g1intBtw
  (tk:tk, lb:int, ub:int) = [i: int | lb <= i; i < ub] g1int (tk, i)
typedef g1intBtwe
  (tk:tk, lb:int, ub:int) = [i: int | lb <= i; i <= ub] g1int (tk, i)
//
(* ****** ****** *)
//
abst@ype
g0uint_t0ype (tk:tkind) = tkind_t0ype (tk)
stadef g0uint = g0uint_t0ype // shorthand
abst@ype
g1uint_int_t0ype (tk:tkind, int) = g0uint (tk)
stadef g1uint = g1uint_int_t0ype // shorthand
//
typedef g1uint (tk:tk) = [i:int] g1uint (tk, i)
typedef g1uint0 (tk:tk) = [i:int | i >= 0] g1uint (tk, i)
typedef g1uint1 (tk:tk) = [i:int | i >= 1] g1uint (tk, i)
//
(* ****** ****** *)
//
typedef g1uintLt
  (tk:tk, n:int) = [i:nat | i < n] g1uint (tk, i)
typedef g1uintLte
  (tk:tk, n:int) = [i:nat | i <= n] g1uint (tk, i)
typedef g1uintGt
  (tk:tk, n:int) = [i:int | i > n] g1uint (tk, i)
typedef g1uintGte
  (tk:tk, n:int) = [i:int | i >= n] g1uint (tk, i)
typedef g1uintBtw
  (tk:tk, lb:int, ub:int) = [i: int | lb <= i; i < ub] g1uint (tk, i)
typedef g1uintBtwe
  (tk:tk, lb:int, ub:int) = [i: int | lb <= i; i <= ub] g1uint (tk, i)
//
(* ****** ****** *)
//
tkindef int_kind = "atstype_int"
//
typedef int0 = g0int (int_kind)
typedef int1 (i:int) = g1int (int_kind, i)
//
stadef int = int1 // 2nd-select
stadef int = int0 // 1st-select
//
typedef Int = [i:int] int1 (i)
typedef Nat = [i:int | i >= 0] int1 (i)
//
typedef intLt (n:int) = g1intLt (int_kind, n)
typedef intLte (n:int) = g1intLte (int_kind, n)
typedef intGt (n:int) = g1intGt (int_kind, n)
typedef intGte (n:int) = g1intGte (int_kind, n)
typedef intBtw (lb:int, ub:int) = g1intBtw (int_kind, lb, ub)
typedef intBtwe (lb:int, ub:int) = g1intBtwe (int_kind, lb, ub)
//
typedef Two = intBtw (0, 2)
typedef Sgn = intBtwe (~1, 1)
//
typedef natLt (n:int) = intBtw (0, n)
typedef natLte (n:int) = intBtwe (0, n)
//
tkindef uint_kind = "atstype_uint"
//
typedef uint0 = g0uint (uint_kind)
typedef uint1 (n:int) = g1uint (uint_kind, n)
//
stadef uint = uint1 // 2nd-select
stadef uint = uint0 // 1st-select
//
stadef uInt = [n:int] uint1 (n)
//
typedef uintLt (n:int) = g1uintLt (uint_kind, n)
typedef uintLte (n:int) = g1uintLte (uint_kind, n)
typedef uintGt (n:int) = g1uintGt (uint_kind, n)
typedef uintGte (n:int) = g1uintGte (uint_kind, n)
typedef uintBtw (lb:int, ub:int) = g1uintBtw (uint_kind, lb, ub)
typedef uintBtwe (lb:int, ub:int) = g1uintBtwe (uint_kind, lb, ub)
//
abst@ype atstype_int // HX-2013-09: for internal use
abst@ype atstype_uint // HX-2013-09: for internal use
//
(* ****** ****** *)
//
tkindef
lint_kind = "atstype_lint"
typedef
lint0 = g0int (lint_kind)
typedef
lint1 (i:int) = g1int (lint_kind, i)
stadef lint = lint1 // 2nd-select
stadef lint = lint0 // 1st-select
//
tkindef
ulint_kind = "atstype_ulint"
typedef
ulint0 = g0uint (ulint_kind)
typedef
ulint1 (i:int) = g1uint (ulint_kind, i)
stadef ulint = ulint1 // 2nd-select
stadef ulint = ulint0 // 1st-select
//
tkindef
llint_kind = "atstype_llint"
typedef llint0 = g0int (llint_kind)
typedef llint1 (i:int) = g1int (llint_kind, i)
stadef llint = llint1 // 2nd-select
stadef llint = llint0 // 1st-select
//
tkindef
ullint_kind = "atstype_ullint"
typedef
ullint0 = g0uint (ullint_kind)
typedef
ullint1 (i:int) = g1uint (ullint_kind, i)
stadef ullint = ullint1 // 2nd-select
stadef ullint = ullint0 // 1st-select
//
(* ****** ****** *)
//
tkindef
intptr_kind = "atstype_intptr"
typedef
intptr0 = g0int (intptr_kind)
typedef
intptr1 (i:int) = g1int (intptr_kind, i)
stadef intptr = intptr1 // 2nd-select
stadef intptr = intptr0 // 1st-select
//
tkindef
uintptr_kind = "atstype_uintptr"
typedef
uintptr0 = g0uint (uintptr_kind)
typedef
uintptr1 (i:int) = g1uint (uintptr_kind, i)
stadef uintptr = uintptr1 // 2nd-select
stadef uintptr = uintptr0 // 1st-select
//
(* ****** ****** *)
//
tkindef
sint_kind = "atstype_sint"
typedef
sint0 = g0int (sint_kind)
typedef
sint1 (i:int) = g1int (sint_kind, i)
stadef sint = sint1 // 2nd-select
stadef sint = sint0 // 1st-select
//
tkindef
usint_kind = "atstype_usint"
typedef
usint0 = g0uint (usint_kind)
typedef
usint1 (i:int) = g1uint (usint_kind, i)
stadef usint = usint1 // 2nd-select
stadef usint = usint0 // 1st-select
//
(* ****** ****** *)
//
tkindef
size_kind = "atstype_size"
typedef size0_t = g0uint (size_kind)
typedef size1_t (i:int) = g1uint (size_kind, i)
//
stadef size_t = size1_t // 2nd-select
stadef size_t = size0_t // 1st-select
//
typedef Size =
  [i:int | i >= 0] g1uint (size_kind, i)
typedef Size_t = Size
//
typedef sizeLt (n:int) = g1uintLt (size_kind, n)
typedef sizeLte (n:int) = g1uintLte (size_kind, n)
typedef sizeGt (n:int) = g1uintGt (size_kind, n)
typedef sizeGte (n:int) = g1uintGte (size_kind, n)
typedef sizeBtw (lb:int, ub:int) = g1uintBtw (size_kind, lb, ub)
typedef sizeBtwe (lb:int, ub:int) = g1uintBtwe (size_kind, lb, ub)
//
tkindef
ssize_kind = "atstype_ssize"
typedef ssize0_t = g0int (ssize_kind)
typedef ssize1_t (i:int) = g1int (ssize_kind , i) 
//
stadef ssize_t = ssize1_t // 2nd-select
stadef ssize_t = ssize0_t // 1st-select
//
typedef SSize =
  [i:int] g1int (ssize_kind, i)
typedef SSize_t = SSize
//
typedef ssizeLt (n:int) = g1intLt (ssize_kind, n)
typedef ssizeLte (n:int) = g1intLte (ssize_kind, n)
typedef ssizeGt (n:int) = g1intGt (ssize_kind, n)
typedef ssizeGte (n:int) = g1intGte (ssize_kind, n)
typedef ssizeBtw (lb:int, ub:int) = g1intBtw (ssize_kind, lb, ub)
typedef ssizeBtwe (lb:int, ub:int) = g1intBtwe (ssize_kind, lb, ub)
//
abst@ype atstype_size // HX-2013-09: for internal use
abst@ype atstype_ssize // HX-2013-09: for internal use
//
(* ****** ****** *)

typedef sizeof_t (a:vt@ype) = size_t (sizeof(a?))

(* ****** ****** *)
//
tkindef
int8_kind = "atstype_int8"
typedef
int8_0 = g0int (int8_kind)
typedef
int8_1
  (i:int) = g1int (int8_kind, i)
//
stadef int8 = int8_1 // 2nd-select
stadef int8 = int8_0 // 1st-select
stadef Int8 = [i:int] int8_1 (i)
//
tkindef
uint8_kind = "atstype_uint8"
typedef
uint8_0 = g0uint (uint8_kind)
typedef
uint8_1
  (i:int) = g1uint (uint8_kind, i)
//
stadef uint8 = uint8_1 // 2nd-select
stadef uint8 = uint8_0 // 1st-select
stadef uInt8 = [i:nat] uint8_1 (i)
//
(* ****** ****** *)
//
tkindef
int16_kind = "atstype_int16"
typedef
int16_0 = g0int (int16_kind)
typedef
int16_1
  (i:int) = g1int (int16_kind, i)
//
stadef int16 = int16_1 // 2nd-select
stadef int16 = int16_0 // 1st-select
stadef Int16 = [i:int] int16_1 (i)
//
tkindef
uint16_kind = "atstype_uint16"
typedef
uint16_0 = g0uint (uint16_kind)
typedef
uint16_1
  (i:int) = g1uint (uint16_kind, i)
//
stadef uint16 = uint16_1 // 2nd-select
stadef uint16 = uint16_0 // 1st-select
stadef uInt16 = [i:nat] uint16_1 (i)
//
(* ****** ****** *)
//
tkindef
int32_kind = "atstype_int32"
typedef
int32_0 = g0int (int32_kind)
typedef
int32_1
  (i:int) = g1int (int32_kind, i)
//
stadef int32 = int32_1 // 2nd-select
stadef int32 = int32_0 // 1st-select
stadef Int32 = [i:int] int32_1 (i)
//
tkindef
uint32_kind = "atstype_uint32"
typedef
uint32_0 = g0uint (uint32_kind)
typedef
uint32_1
  (i:int) = g1uint (uint32_kind, i)
//
stadef uint32 = uint32_1 // 2nd-select
stadef uint32 = uint32_0 // 1st-select
stadef uInt32 = [i:nat] uint32_1 (i)
//
(* ****** ****** *)
//
tkindef
int64_kind = "atstype_int64"
typedef
int64_0 = g0int (int64_kind)
typedef
int64_1
  (i:int) = g1int (int64_kind, i)
//
stadef int64 = int64_1 // 2nd-select
stadef int64 = int64_0 // 1st-select
stadef Int64 = [i:int] int64_1 (i)
//
tkindef
uint64_kind = "atstype_uint64"
typedef
uint64_0 = g0uint (uint64_kind)
typedef
uint64_1
  (i:int) = g1uint (uint64_kind, i)
//
stadef uint64 = uint64_1 // 2nd-select
stadef uint64 = uint64_0 // 1st-select
stadef uInt64 = [i:nat] uint64_1 (i)
//
(* ****** ****** *)
//
abst@ype
g0float_t0ype (tk:tk) = tkind_t0ype (tk)
stadef g0float = g0float_t0ype // shorthand
//
tkindef float_kind = "atstype_float"
typedef float = g0float (float_kind)
//
tkindef double_kind = "atstype_double"
typedef double = g0float (double_kind)
//
tkindef ldouble_kind = "atstype_ldouble"
typedef ldouble = g0float (ldouble_kind)
//
(* ****** ****** *)
//
// HX: unindexed type for pointers
//
tkindef ptr_kind = "atstype_ptrk"
abstype ptr_type = tkind_type (ptr_kind)
stadef ptr = ptr_type // a shorthand
abstype ptr_addr_type (l:addr) = ptr_type
stadef ptr = ptr_addr_type // a shorthand
typedef Ptr = [l:addr] ptr (l)
typedef Ptr0 = [l:addr | l >= null] ptr (l)
typedef Ptr1 = [l:addr | l >  null] ptr (l)
typedef
Ptrnull (l:addr) =
  [l1:addr | l1 == null || l1 == l] ptr (l1)
// end of [Ptrnull]
//
// HX-2012-02-14: it is an expriment for now:
//
stadef ptr (n:int) = ptr_addr_type (addr_of_int(n))
//
(* ****** ****** *)

(*
** HX: persistent read-only strings
*)
(*
//
// HX-2013-04: this confuses type-erasure
//
abstype
string_type = $extype"atstype_string"
*)
abstype
string_type = ptr // = char* in C
abstype
string_int_type (n: int) = string_type
//
stadef string0 = string_type
stadef string1 = string_int_type
stadef string = string1 // 2nd-select
stadef string = string0 // 1st-select
typedef String = [n:int] string_int_type (n)
typedef String0 = [n:int | n >= 0] string_int_type (n)
typedef String1 = [n:int | n >= 1] string_int_type (n)
//
(* ****** ****** *)

abstype
stropt_int_type (n:int) = ptr
stadef stropt = stropt_int_type
typedef Stropt = [n:int] stropt_int_type (n)
typedef Stropt0 = [n:int] stropt_int_type (n)
typedef Stropt1 = [n:int | n >= 0] stropt_int_type (n)
stadef stropt = Stropt // HX: this may be a bit confusing :)

(* ****** ****** *)

(*
** HX: linear mutable strings
*)
absvtype
strptr_addr_vtype (l:addr) = ptr
stadef strptr = strptr_addr_vtype
vtypedef Strptr0 = [l:addr] strptr (l)
vtypedef Strptr1 = [l:addr | l > null] strptr (l)
stadef strptr = Strptr0

absvtype
strnptr_addr_int_vtype (l:addr, n:int) = ptr
stadef strnptr = strnptr_addr_int_vtype
vtypedef strnptr (n:int) = [l:addr] strnptr (l, n)
vtypedef Strnptr0 = [l:addr;n:int] strnptr (l, n)
vtypedef Strnptr1 = [l:addr;n:int | n >= 0] strnptr (l, n)

(* ****** ****** *)

(*
** HX: persistent mutable strings
*)
abstype
strref_addr_type (l:addr) = ptr
stadef strref = strref_addr_type
typedef Strref0 = [l:addr] strref (l)
typedef Strref1 = [l:addr | l > null] strref (l)

(* ****** ****** *)

abst@ype
atsvoid_t0ype
(*
= $extype"atsvoid_t0ype"
*)
typedef void = atsvoid_t0ype // = C-void

(* ****** ****** *)
//
absvtype
exception_vtype = $extype"atstype_exnconptr"
//
vtypedef exn = exception_vtype // boxed vtype
//
(* ****** ****** *)

absvt@ype // covariance
opt_vt0ype_bool_vt0ype (a:vt@ype+, opt:bool) = a
stadef opt = opt_vt0ype_bool_vt0ype

(* ****** ****** *)

typedef bytes (n:int) = @[byte][n]
viewdef bytes_v (l:addr, n:int) = bytes (n) @ l
typedef b0ytes (n:int) = @[byte?][n]
viewdef b0ytes_v (l:addr, n:int) = b0ytes (n) @ l

(* ****** ****** *)
//
abstype
cloref_t0ype_type (a:t@ype) = ptr
stadef cloref = cloref_t0ype_type
//
absvtype
cloptr_vt0ype_vtype (a:t@ype) = ptr
stadef cloptr = cloptr_vt0ype_vtype
vtypedef cloptr0 = cloptr_vt0ype_vtype (void)
//
(* ****** ****** *)
//
typedef
stamped_t(a:t@ype) = [x:int] stamped_t(a, x)
vtypedef
stamped_vt(a:vt@ype) = [x:int] stamped_vt(a, x)
//
(* ****** ****** *)
//
// HX: for memory deallocation (with/without GC)
//
absview
mfree_gc_addr_view (addr)
stadef mfree_gc_v = mfree_gc_addr_view
absview
mfree_ngc_addr_view (addr)
stadef mfree_ngc_v = mfree_ngc_addr_view
//
absview
mfree_libc_addr_view (addr) // libc-mfree
stadef mfree_libc_v = mfree_libc_addr_view
//
(* ****** ****** *)

absvt@ype
arrpsz_vt0ype_int_vt0ype
  (a:vt@ype+, n:int) = $extype"atstype_arrpsz"
stadef arrpsz = arrpsz_vt0ype_int_vt0ype

(* ****** ****** *)

absprop // invariance
vbox_view_prop (v:view)
propdef vbox (v:view) = vbox_view_prop (v)

abstype // invariance
ref_vt0ype_type (a:vt@ype) = ptr
typedef ref (a:vt@ype) = ref_vt0ype_type (a)

(* ****** ****** *)
//
viewdef vtakeout
  (v1: view, v2: view) = (v2, v2 -<lin,prf> v1)
viewdef vtakeout0 (v:view) = vtakeout (void, v)
//
vtypedef vttakeout
  (vt1: vt@ype, vt2: vt@ype) = (vt2 -<lin,prf> vt1 | vt2)
viewdef vttakeout0 (vt:vt@ype) = vttakeout (void, vt)
//
(* ****** ****** *)
//
vtypedef
vtakeoutptr
  (a:vt@ype) = [l:addr] (a@l, a@l -<lin,prf> void | ptr l)
//
(* ****** ****** *)
//
vtypedef
vstrptr (l:addr) = vttakeout0 (strptr l)
//
vtypedef vStrptr0 = [l:addr] vstrptr (l)
vtypedef vStrptr1 = [l:addr | l > null] vstrptr (l)
//
(* ****** ****** *)

typedef
bottom_t0ype_uni = {a:t@ype} (a)
typedef
bottom_t0ype_exi = [a:t@ype | false] (a)

vtypedef
bottom_vt0ype_uni = {a:vt@ype} (a)
vtypedef
bottom_vt0ype_exi = [a:vt@ype | false] (a)

(* ****** ****** *)

typedef
cmpval_fun
  (a: t@ype) = (a, a) -<fun> int
typedef
cmpval_funenv
  (a: t@ype, vt: t@ype) = (a, a, !vt) -<fun> int
stadef cmpval = cmpval_fun
stadef cmpval = cmpval_funenv

(* ****** ****** *)

typedef
cmpref_fun
  (a: vt@ype) = (&RD(a), &RD(a)) -<fun> int
typedef
cmpref_funenv
  (a: vt@ype, vt: vt@ype) = (&RD(a), &RD(a), !vt) -<fun> int
stadef cmpref = cmpref_fun
stadef cmpref = cmpref_funenv

(* ****** ****** *)
//
// HX: [lazy(T)] :
// suspended evaluation of type T
//
abstype
lazy_t0ype_type (t@ype+) = ptr
typedef lazy (a:t@ype) = lazy_t0ype_type (a)
//
(* ****** ****** *)
//
// HX: [lazy_vt(VT)] :
// suspended computation of viewtype VT
//
absvtype
lazy_vt0ype_vtype (vt@ype+) = ptr
vtypedef lazy_vt (a: vt@ype)= lazy_vt0ype_vtype (a)
//
(* ****** ****** *)
//
(*
abst@ype
literal_int(intlit) = $extype"atsliteral_int"
*)
abst@ype
literal_float(float) = $extype"atsliteral_float"
abst@ype
literal_string(string) = $extype"atsliteral_string"
//
(* ****** ****** *)
//
abst@ype
undefined_t0ype = $extype"atstype_undefined"
absvt@ype
undefined_vt0ype = $extype"atstype_undefined"
//
(* ****** ****** *)

#if VERBOSE_PRELUDE #then
#print "Loading [basics_sta.sats] finishes!\n"
#endif // end of [VERBOSE_PRELUDE]

(* ****** ****** *)

(* end of [basics_sta.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author of the file:
// Hongwei Xi (gmhwxiATgmailDOTcom)
// Start Time: September, 2011
//
(* ****** ****** *)

#include "prelude/params.hats"

(* ****** ****** *)

#if VERBOSE_PRELUDE #then
#print "Loading [basics_dyn.sats] starts!\n"
#endif // end of [VERBOSE_PRELUDE]

(* ****** ****** *)
//
sortdef t0p = t@ype and vt0p = vt@ype
//
(* ****** ****** *)

datatype TYPE(a:vt@ype) = TYPE(a) of ()

(* ****** ****** *)
//
// HX-2012: In $ATSHOME/ccomp/runtime:
// atsbool_true/atsbool_false are mapped to 1/0
// this mapping is fixed and should never be changed!
//
#define true true_bool // shorthand
val true_bool : bool (true)  = "mac#atsbool_true" // = 1
//
#define false false_bool // shorthand
val false_bool : bool (false) = "mac#atsbool_false" // = 0
//
(* ****** ****** *)
//
// HX: [false] implies all
//
prfun false_elim{X:prop | false} ((*void*)): X
//
(* ****** ****** *)
//
praxi
lemma_subcls_reflexive{c:cls} ((*void*)): [c <= c] void
praxi
lemma_subcls_transitive
  {c1,c2,c3:cls | c1 <= c2; c2 <= c3} (): [c1 <= c3] void
//
(* ****** ****** *)

praxi praxi_int{i:int} ((*void*)): int (i)
praxi praxi_bool{b:bool} ((*void*)): bool (b)
praxi praxi_ptr{l:addr} ((*void*)): ptr (l)

(* ****** ****** *)

dataprop
EQINT (int, int) = {x:int} EQINT (x, x)
//
prfun eqint_make {x,y:int | x == y} (): EQINT (x, y)
//
prfun
eqint_make_gint
  {tk:tk}{x:int} (x: g1int (tk, x)): [y:int] EQINT (x, y)
prfun
eqint_make_guint
  {tk:tk}{x:int} (x: g1uint (tk, x)): [y:int] EQINT (x, y)
//
(* ****** ****** *)

dataprop
EQADDR (addr, addr) = {x:addr} EQADDR (x, x)
//
prfun
eqaddr_make {x,y:addr | x == y} (): EQADDR (x, y)
//
prfun
eqaddr_make_ptr {x:addr} (x: ptr (x)): [y:addr] EQADDR (x, y)
//
(* ****** ****** *)

dataprop
EQBOOL (bool, bool) = {x:bool} EQBOOL (x, x)
//
prfun eqbool_make {x,y:bool | x == y} (): EQBOOL (x, y)
//
prfun eqbool_make_bool {x:bool} (x: bool (x)): [y:bool] EQBOOL (x, y)
//
(* ****** ****** *)

prfun prop_verify{b:bool | b} ():<prf> void
prfun prop_verify_and_add{b:bool | b} ():<prf> [b] void

(* ****** ****** *)

prfun pridentity_v{v:view} (x: !INV(v)): void
prfun pridentity_vt{vt:viewt@ype} (x: !INV(vt)): void

(* ****** ****** *)

dataprop
EQTYPE (vt@ype, vt@ype) = {a:vt@ype} EQTYPE (a, a)

(* ****** ****** *)

castfn
viewptr_match
  {a:vt0p}{l1,l2:addr | l1==l2}
  (pf: INV(a) @ l1 | p: ptr l2):<> [l:addr | l==l1] (a @ l | ptr l)
// end of [viewptr_match]

(* ****** ****** *)
//
val{a:vt@ype} sizeof : size_t (sizeof(a))
//
praxi
lemma_sizeof{a:vt@ype} (): [sizeof(a) >= 0] void
//
(* ****** ****** *)

praxi topize {a:t@ype} (x: !INV(a) >> a?): void

(* ****** ****** *)

castfn dataget {a:vt@ype} (x: !INV(a) >> a): a?!

(* ****** ****** *)
//
// HX: returning the pf to GC
//
praxi
mfree_gc_v_elim
  {l:addr} (pf: mfree_gc_v l):<prf> void
// end of [mfree_gc_v_elim]

(* ****** ****** *)

praxi
mfree_gcngc_v_nullify
  {l:addr} (
  pf1: mfree_gc_v (l), pf1: mfree_ngc_v (l)
) : void // end of [mfree_gcngc_nullify_v]

(* ****** ****** *)
//
fun
cloptr_free
  {a:t0p} (pclo: cloptr (a)):<!wrt> void = "mac#%"
//
(* ****** ****** *)
//
fun{a:t0p}
lazy_force (lazyval: lazy (a)):<!laz> a
fun{a:vt0p}
lazy_vt_force (lazyval: lazy_vt (a)): (a)
//
(* ****** ****** *)
//
// HX-2013:
// macro implemented in [pats_ccomp_instrset]
//
fun
lazy_vt_free
  {a:vt0p} (lazyval: lazy_vt (a)):<!wrt> void = "mac#%"
overload ~ with lazy_vt_free
//
(* ****** ****** *)
//
// HX-2014:
// macro implemented in [pats_ccomp_instrset]
//
fun
lazy2cloref
  {a:t0p}(lazy(a)): ((*void*)) -<cloref1> (a) = "mac#%"
//
(* ****** ****** *)

(*
// HX-2012-05-23: this seems TOO complicated!
(*
** HX-2012-03: handling read-only views and vtypes
*)
castfn
read_getval // copy out a non-linear value
  {a:t@ype}{s:int}{n:int} (x: !READ (a, s, n)):<> a
// end of [read_getval]

praxi
read_takeout{v:view}
  (pf: !v >> READOUT (v, s)): #[s:int] READ (v, s, 0)
// end of [read_takeout]
praxi
read_addback // HX: there is no need to check
  {v1:view}{v2:view}{s:int} // if v1 and v2 match
  (pf1: !READOUT (v1, s) >> v1, pf2: READ (v2, s, 0)): void
// end of [read0_addback]

praxi
read_split
  {v:view}{s:int}{n:int}
  (pf: !READ (v, s, n) >> READ (v, s, n+1)): READ (v, s, 0)
// end of [read_split]
praxi
read_unsplit // HX: there is no need to check
  {v1:view}{v2:view}{s:int}{n1,n2:int} // if v1 and v2 match
  (pf1: READ (v1, s, n1), pf2: READ (v2, s, n2)): READ (v1, s, n1+n2-1)
// end of [read_unsplit]
*)
(* ****** ****** *)
//
castfn
stamp_t{a:t@ype}(x: a):<> stamped_t(a)
castfn
stamp_vt{a:vt@ype}(x: a):<> stamped_vt(a)
//
(* ****** ****** *)

castfn
unstamp_t
  {a:t@ype}{x:int} (x: stamped_t (INV(a), x)):<> a
// end of [unstamp_t]
castfn
unstamp_vt
  {a:vt@ype}{x:int} (x: stamped_vt (INV(a), x)):<> a
// end of [unstamp_vt]

(* ****** ****** *)
//
castfn
stamped_t2vt
  {a:t@ype}{x:int}
  (x: stamped_t(INV(a), x)):<> stamped_vt (a, x)
// end of [stamped_t2vt]
//
castfn
stamped_vt2t
  {a:t@ype}{x:int}
  (x: stamped_vt(INV(a), x)):<> stamped_t (a, x)
// end of [stamped_vt2t]
//
fun{a:t@ype}
stamped_vt2t_ref{x:int}
  (x: &stamped_vt(INV(a), x)):<> stamped_t (a, x)
//
(* ****** ****** *)
//
praxi
vcopyenv_v_decode{v:view} (x: vcopyenv_v (v)): vtakeout0 (v)
castfn
vcopyenv_vt_decode{vt:vt0p} (x: vcopyenv_vt (vt)): vttakeout0 (vt)
//
overload decode with vcopyenv_v_decode
overload decode with vcopyenv_vt_decode
//
(* ****** ****** *)
//
// HX: the_null_ptr = (void*)0
//
val
the_null_ptr : ptr (null) = "mac#atsptr_null"
//
(* ****** ****** *)

praxi
lemma_addr_param{l:addr} (): [l >= null] void

(* ****** ****** *)

praxi
lemma_string_param
  {n:int} (x: string(n)): [n >= 0] void
// end of [lemma_string_param]
praxi
lemma_stropt_param
  {n:int} (x: stropt(n)): [n >= ~1] void
// end of [lemma_stropt_param]

(* ****** ****** *)

dataprop SGN (int, int) =
  | SGNzero (0, 0) | {i:neg} SGNneg (i, ~1) | {i:pos} SGNpos (i,  1)
// end of [SGN] // end of [dataprop]

(* ****** ****** *)
//
// HX-2012-06:
// indication of the failure of
exception AssertExn of () // an assertion
//
(* ****** ****** *)
//
// HX-2012-06:
// indication of something expected
exception NotFoundExn of () // to be found but not
//
(* ****** ****** *)
//
exception GenerallyExn of (string) // for unspecified causes
(*
exception GenerallyExn2 of (string, ptr(*data*)) // for unspecified causes
*)
//
(* ****** ****** *)
//
// HX-2012-07:
// indication of a function argument being
exception IllegalArgExn of (string) // out of its domain
//
(* ****** ****** *)

praxi __vfree_exn (x: exn):<> void // for freeing nullary exception-con

(* ****** ****** *)
//
datatype unit = unit of ()
dataprop unit_p = unit_p of ()
dataview unit_v = unit_v of ()
prfun unit_v_elim (pf: unit_v): void
//
(* ****** ****** *)
//
abstype
boxed_t0ype_type(a:t@ype+) = unit
absvtype
boxed_vt0ype_vtype(a:vt@ype+) = unit
//
vtypedef
boxed(a:vt@ype) = boxed_vt0ype_vtype(a)
vtypedef
boxed_vt(a:vt@ype) = boxed_vt0ype_vtype(a)
//
typedef boxed(a:t@ype) = boxed_t0ype_type(a)
typedef boxed_t(a:t@ype) = boxed_t0ype_type(a)
//
fun{a:type} box: (INV(a)) -> boxed_t(a)
fun{a:type} unbox: boxed_t(INV(a)) -> (a)
fun{a:vtype} box_vt: (INV(a)) -> boxed_vt(a)
fun{a:vtype} unbox_vt: boxed_vt(INV(a)) -> (a)
//
(* ****** ****** *)
//
typedef
array (a, n) = @[a][n]
viewdef
array_v
  (a:vt@ype, l:addr, n:int) = @[a][n] @ l
//
absvtype
arrayptr_vt0ype_addr_int_vtype
  (a:vt0ype+, l:addr, n:int(*size*)) = ptr (l)
stadef
arrayptr = arrayptr_vt0ype_addr_int_vtype
vtypedef
arrayptr
  (a:vt0p, n:int) = [l:addr] arrayptr (a, l, n)
//
abstype
arrayref_vt0ype_int_type
  (a:vt@ype(*elt*), n:int(*size*)) = ptr
stadef arrayref = arrayref_vt0ype_int_type
//
abstype
arrszref_vt0ype_type (a: vt@ype) = ptr
stadef arrszref = arrszref_vt0ype_type
//
(* ****** ****** *)
//
datatype
// t@ype+: covariant
list_t0ype_int_type
  (a:t@ype+, int) =
  | list_nil(a, 0) of ()
  | {n:int | n >= 0}
    list_cons(a, n+1) of (a, list_t0ype_int_type (a, n))
// end of [datatype]
stadef list = list_t0ype_int_type
typedef
List (a:t0p) = [n:int] list (a, n)
typedef
List0 (a:t0p) = [n:int | n >= 0] list (a, n)
typedef
List1 (a:t0p) = [n:int | n >= 1] list (a, n)
typedef listLt
  (a:t0p, n:int) = [k:nat | k < n] list (a, k)
typedef listLte
  (a:t0p, n:int) = [k:nat | k <= n] list (a, k)
typedef listGt
  (a:t0p, n:int) = [k:int | k > n] list (a, k)
typedef listGte
  (a:t0p, n:int) = [k:int | k >= n] list (a, k)
typedef listBtw
  (a:t0p, m:int, n:int) = [k:int | m <= k; k < n] list (a, k)
typedef listBtwe
  (a:t0p, m:int, n:int) = [k:int | m <= k; k <= n] list (a, k)
//
(* ****** ****** *)
//
datavtype
// vt@ype+: covariant
list_vt0ype_int_vtype
  (a:vt@ype+, int) =
  | list_vt_nil (a, 0) of ()
  | {n:int | n >= 0}
    list_vt_cons (a, n+1) of (a, list_vt0ype_int_vtype (a, n))
// end of [list_vt0ype_int_vtype]
stadef list_vt = list_vt0ype_int_vtype
vtypedef
List_vt (a:vt0p) = [n:int] list_vt (a, n)
vtypedef
List0_vt (a:vt0p) = [n:int | n >= 0] list_vt (a, n)
vtypedef
List1_vt (a:vt0p) = [n:int | n >= 1] list_vt (a, n)
vtypedef listLt_vt
  (a:vt0p, n:int) = [k:nat | k < n] list_vt (a, k)
vtypedef listLte_vt
  (a:vt0p, n:int) = [k:nat | k <= n] list_vt (a, k)
vtypedef listGt_vt
  (a:vt0p, n:int) = [k:int | k > n] list_vt (a, k)
vtypedef listGte_vt
  (a:vt0p, n:int) = [k:int | k >= n] list_vt (a, k)
vtypedef listBtw_vt
  (a:vt0p, m:int, n:int) = [k:int | m <= k; k < n] list_vt (a, k)
vtypedef listBtwe_vt
  (a:vt0p, m:int, n:int) = [k:int | m <= k; k <= n] list_vt (a, k)
//
(* ****** ****** *)
//
datatype
// t@ype+: covariant
option_t0ype_bool_type
  (a:t@ype+, bool) = Some(a, true) of (a) | None(a, false)
// end of [datatype]
stadef option = option_t0ype_bool_type
typedef Option (a:t0p) = [b:bool] option (a, b)
//
datavtype
// vt@ype+: covariant
option_vt0ype_bool_vtype
  (a:vt@ype+, bool) = Some_vt(a, true) of (a) | None_vt(a, false)
// end of [option_vt0ype_bool_vtype]
stadef option_vt = option_vt0ype_bool_vtype
vtypedef Option_vt (a:vt0p) = [b:bool] option_vt (a, b)
//
(* ****** ****** *)
//
praxi
opt_some
  {a:vt0p}(x: !INV(a) >> opt(a, true)):<prf> void
praxi
opt_unsome
  {a:vt0p}(x: !opt(INV(a), true) >> a):<prf> void
//
fun{a:vt0p}
opt_unsome_get (x: &opt(INV(a), true) >> a?): (a)
//
praxi
opt_none
  {a:vt0p} (x: !(a?) >> opt(a, false)):<prf> void
praxi
opt_unnone
  {a:vt0p} (x: !opt(INV(a), false) >> a?):<prf> void
//
praxi
opt_clear
  {a:t0p}{b:bool}(x: !opt(INV(a), b) >> a?):<prf> void
//
(* ****** ****** *)
//
dataprop
or_prop_prop_int_prop
  (a0: prop+, a1: prop+, int) =
  PORleft(a0, a1, 0) of a0 | PORright(a0, a1, 1) of a1
stadef por = or_prop_prop_int_prop
//
dataview
or_view_view_int_view
  (a0: view+, a1: view+, int) =
  VORleft(a0, a1, 0) of a0 | VORright(a0, a1, 1) of a1
stadef vor = or_view_view_int_view
//
dataprop
option_prop_bool_prop
  (a:prop+, bool) = Some_p (a, true) of (a) | None_p (a, false)
// end of [option_prop_bool_prop]
stadef option_p = option_prop_bool_prop
//
dataview
option_view_bool_view
  (a:view+, bool) = Some_v (a, true) of (a) | None_v (a, false)
// end of [option_view_bool_view]
stadef option_v = option_view_bool_view
//
(* ****** ****** *)
//
absvt@ype
arrayopt (a:vt0p, n:int, b:bool) = array (a, n)
//
praxi
arrayopt_some
  {a:vt0p}{n:int} (A: &array(a, n) >> arrayopt(a, n, true)): void
praxi
arrayopt_none
  {a:vt0p}{n:int} (A: &array(a?, n) >> arrayopt(a, n, false)): void
praxi
arrayopt_unsome
  {a:vt0p}{n:int} (A: &arrayopt(a, n, true) >> array(a, n)): void
praxi
arrayopt_unnone
  {a:vt0p}{n:int} (A: &arrayopt(a, n, false) >> array(a?, n)): void
//
(* ****** ****** *)

absvtype
argv_int_vtype (n:int) = ptr
stadef argv = argv_int_vtype

(*
[argv_takeout_strarr] is declared in prelude/SATS/extern.sats
[argv_takeout_parrnull] is declared in prelude/SATS/extern.sats
*)

(* ****** ****** *)

praxi
lemma_argv_param {n:int} (argv: !argv(n)): [n >= 0] void
// end of [praxi]

(* ****** ****** *)
//
fun
argv_get_at{n:int}
  (argv: !argv (n), i: natLt n):<> string = "mac#%"
fun
argv_set_at{n:int}
  (argv: !argv (n), i: natLt n, x: string):<!wrt> void = "mac#%"
//
overload [] with argv_get_at
overload [] with argv_set_at
//
(* ****** ****** *)
//
symintr main0
//
fun main_void_0
  ((*void*)): void = "ext#mainats_void_0"
fun main_argc_argv_0
  {n:int | n >= 1}
  (argc: int n, argv: !argv(n)): void = "ext#mainats_argc_argv_0"
overload main0 with main_void_0
overload main0 with main_argc_argv_0
//
(* ****** ****** *)
//
symintr main
//
fun main_void_int
  ((*void*)): int = "ext#mainats_void_int"
fun main_argc_argv_int
  {n:int | n >= 1}
  (argc: int n, argv: !argv(n)): int = "ext#mainats_argc_argv_int"
fun main_argc_argv_envp_int
  {n:int | n >= 1}
  (argc: int n, argv: !argv n, envp: ptr): int = "ext#mainats_argc_argv_envp_int"
overload main with main_void_int
overload main with main_argc_argv_int
overload main with main_argc_argv_envp_int
//
(* ****** ****** *)

fun exit
  (ecode: int):<!exn> {a:t0p}(a) = "mac#%"
fun exit_errmsg
  (ecode: int, msg: string):<!exn> {a:t0p}(a) = "mac#%"
(*
fun exit_fprintf{ts:types}
(
  ecode: int, out: FILEref, fmt: printf_c ts, args: ts
) :<!exn> {a:vt0p}(a) = "mac#%" // end of [exit_fprintf]
*)

(* *****p* ****** *)
//
fun exit_void
  (ecode: int):<!exn> void = "mac#%"
fun exit_errmsg_void
  (ecode: int, msg: string):<!exn> void = "mac#%"
//
(* ****** ****** *)

fun assert_bool0
  (x: bool):<!exn> void = "mac#%"
fun assert_bool1
  {b:bool} (x: bool (b)):<!exn> [b] void = "mac#%"
//
overload assert with assert_bool0 of 0
overload assert with assert_bool1 of 10
//
(* ****** ****** *)

fun{}
assertexn_bool0 (x: bool):<!exn> void
fun{}
assertexn_bool1 {b:bool} (x: bool (b)):<!exn> [b] void
//
symintr assertexn
overload assertexn with assertexn_bool0 of 0
overload assertexn with assertexn_bool1 of 10
//
(* ****** ****** *)
//
symintr assert_errmsg
//
fun assert_errmsg_bool0
  (x: bool, msg: string):<!exn> void = "mac#%"
fun assert_errmsg_bool1
  {b:bool} (x: bool b, msg: string):<!exn> [b] void = "mac#%"
//
overload assert_errmsg with assert_errmsg_bool0 of 0
overload assert_errmsg with assert_errmsg_bool1 of 10
//
(* ****** ****** *)

fun assert_errmsg2_bool0
  (x: bool, msg1: string, msg2: string):<!exn> void = "mac#%"
fun assert_errmsg2_bool1{b:bool}
  (x: bool b, msg1: string, msg2: string):<!exn> [b] void = "mac#%"
//
symintr assert_errmsg2
overload assert_errmsg2 with assert_errmsg2_bool0 of 0
overload assert_errmsg2 with assert_errmsg2_bool1 of 10
//
(* ****** ****** *)

datasort
file_mode =
  | file_mode_r (* read *)
  | file_mode_w (* write *)
  | file_mode_rw (* read and write *)
// end of [file_mode]

(* ****** ****** *)

local
//
stadef r() = file_mode_r()
stadef w() = file_mode_w()
stadef rw() = file_mode_rw()
//
in (* in-of-local *)

(* ****** ****** *)

abstype
file_mode (file_mode) = string
typedef
file_mode = [fm:file_mode] file_mode (fm)

(* ****** ****** *)

sortdef fmode = file_mode
typedef fmode (fm:fmode) = file_mode (fm)
typedef fmode = file_mode

(* ****** ****** *)

dataprop
file_mode_lte
  (fmode, fmode) =
  | {m:fmode} file_mode_lte_refl (m, m)
  | {m1,m2,m3:fmode}
    file_mode_lte_tran (m1, m3) of
      (file_mode_lte (m1, m2), file_mode_lte (m2, m3))
  | {m:fmode} file_mode_lte_rw_r (rw(), r()) of ()
  | {m:fmode} file_mode_lte_rw_w (rw(), w()) of ()
// end of [file_mode_lte]

(* ****** ****** *)
//
prval
file_mode_lte_r_r
  : file_mode_lte (r(), r()) // impled in [filebas_prf.dats]
prval
file_mode_lte_w_w
  : file_mode_lte (w(), w()) // impled in [filebas_prf.dats]
prval
file_mode_lte_rw_rw
  : file_mode_lte (rw(), rw()) // impled in [filebas_prf.dats]
//
(* ****** ****** *)

end // end of [local]

(* ****** ****** *)

abstype FILEref_type = ptr
typedef FILEref = FILEref_type

(* ****** ****** *)
//
typedef
fprint_type(a: t0p) = (FILEref, a) -> void
typedef
fprint_vtype(a: vt0p) = (FILEref, !a) -> void
//
(* ****** ****** *)

fun print_newline (): void = "mac#%"
fun prerr_newline (): void = "mac#%"
fun fprint_newline (out: FILEref): void = "mac#%"

(* ****** ****** *)

#if VERBOSE_PRELUDE #then
#print "Loading [basics_dyn.sats] finishes!\n"
#endif // end of [VERBOSE_PRELUDE]

(* ****** ****** *)

(* end of [basics_dyn.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/unsafe.atxt
** Time of generation: Sat Oct 17 15:19:54 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: April, 2012 *)

(* ****** ****** *)

staload "prelude/SATS/unsafe.sats"

(* ****** ****** *)

implement{
} int2ptr (i) = cast{ptr}(cast{intptr}(i))
implement{
} ptr2int (p) = cast{int}(cast{intptr}(p))

(* ****** ****** *)

implement
{a}(*tmp*)
ptr0_get
  (p) = x where {
  val [l:addr]
    p = g1ofg0_ptr(p)
  prval (pf, fpf) = __assert () where {
    extern praxi __assert (): (a @ l, a? @ l -<lin,prf> void)
  } // end of [prval]
  val x = !p
  prval () = fpf (pf)
} // end of [ptr0_get]

implement{a} ptr1_get = ptr0_get<a>

(* ****** ****** *)

implement
{a}(*tmp*)
ptr0_set
  (p, x) = () where {
  val [l:addr]
    p = g1ofg0_ptr(p)
  prval (pf, fpf) = __assert () where {
    extern praxi __assert (): (a? @ l, a @ l -<lin,prf> void)
  } // end of [prval]
  val () = !p := x
  prval () = fpf (pf)
} // end of [ptr0_set]

implement{a} ptr1_set = ptr0_set<a>

(* ****** ****** *)

implement
{a}(*tmp*)
ptr0_exch
  (p, x) = () where {
  val p = g1ofg0_ptr(p)
  val (pf, fpf | p) = ptr_vtake{a}(p)
  val tmp = !p
  val ( ) = !p := x
  val ( ) = x := tmp
  prval () = fpf (pf)
} // end of [ptr0_exch]

implement{a} ptr1_exch = ptr0_exch<a>

(* ****** ****** *)

implement
{a}(*tmp*)
ptr0_intch
  (p1, p2) = () where {
  val p1 = g1ofg0_ptr(p1)
  val p2 = g1ofg0_ptr(p2)
  val (pf1, fpf1 | p1) = ptr_vtake{a}(p1)
  val (pf2, fpf2 | p2) = ptr_vtake{a}(p2)
  val tmp = !p1
  val ( ) = !p1 := !p2
  val ( ) = !p2 := tmp
  prval () = fpf1 (pf1)
  prval () = fpf2 (pf2)
} (* end of [ptr0_intch] *)

implement{a} ptr1_intch = ptr0_intch<a>

(* ****** ****** *)
//
implement
{a}(*tmp*)
ptr0_get_at_int (p, i) =
  ptr0_get<a> (ptr0_add_gint<a> (p, i))
implement
{a}(*tmp*)
ptr0_set_at_int (p, i, x) =
  ptr0_set<a> (ptr0_add_gint<a> (p, i), x)
//
implement
{a}(*tmp*)
ptr0_get_at_size (p, i) =
  ptr0_get<a> (ptr0_add_guint<a> (p, i))
implement
{a}(*tmp*)
ptr0_set_at_size (p, i, x) =
  ptr0_set<a> (ptr0_add_guint<a> (p, i), x)
//
(* ****** ****** *)

implement{a}
cptr_get (p) = ptr1_get<a> (cptr2ptr(p))

implement{a}
cptr_set (p, x) = ptr1_set<a> (cptr2ptr(p), x)

implement{a}
cptr_exch (p, x) = ptr1_exch<a> (cptr2ptr(p), x)

(* ****** ****** *)

implement{a}
ptr0_addby (p, x) = let
  val x0 = ptr0_get<a> (p) in ptr0_set<a> (p, gadd_val_val<a> (x0, x))
end // end of [ptr0_addby]
implement{a} ptr1_addby = ptr0_addby<a>

implement{a}
ptr0_subby (p, x) = let
  val x0 = ptr0_get<a> (p) in ptr0_set<a> (p, gsub_val_val<a> (x0, x))
end // end of [ptr0_subby]
implement{a} ptr1_subby = ptr0_subby<a>

implement{a}
ptr0_mulby (p, x) = let
  val x0 = ptr0_get<a> (p) in ptr0_set<a> (p, gmul_val_val<a> (x0, x))
end // end of [ptr0_mulby]
implement{a} ptr1_mulby = ptr0_mulby<a>

implement{a}
ptr0_divby (p, x) = let
  val x0 = ptr0_get<a> (p) in ptr0_set<a> (p, gdiv_val_val<a> (x0, x))
end // end of [ptr0_divby]
implement{a} ptr1_divby = ptr0_divby<a>

implement{a}
ptr0_modby (p, x) = let
  val x0 = ptr0_get<a> (p) in ptr0_set<a> (p, gmod_val_val<a> (x0, x))
end // end of [ptr0_modby]
implement{a} ptr1_modby = ptr0_modby<a>

(* ****** ****** *)

implement{a}
ptr1_list_next
  (p) = p_next where
{
  val xs =
  castvwtp1{list_vt(a,1)}(p)
  val+@list_vt_cons(_, xs_next) = xs
  val p_next = addr@(xs_next)
  prval ((*void*)) = fold@ (xs)
  prval ((*void*)) = cast2void (xs)
} (* end of [ptr1_list_next] *)

(* ****** ****** *)

(* end of [unsafe.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/option.atxt
** Time of generation: Sat Oct 17 15:19:56 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: Feburary, 2012 *)

(* ****** ****** *)

implement{a} option_some (x) = Some (x)
implement{a} option_none ( ) = None ( )

(* ****** ****** *)

implement
{}(*tmp*)
option_is_some (opt) =
  case+ opt of Some _ => true | None _ => false
// end of [option_is_some]

implement
{}(*tmp*)
option_is_none (opt) =
  case+ opt of Some _ => false | None _ => true
// end of [option_is_none]

(* ****** ****** *)

implement
{a}(*tmp*)
option_unsome
  (opt) = x where { val+Some (x) = opt }
// end of [option_unsome]

implement
{a}(*tmp*)
option_unsome_exn
  (opt) = (
  case+ opt of
  | Some x => x | None _ => $raise NotSomeExn()
) // end of [option_unsome_exn]

(* ****** ****** *)

implement
{a}(*tmp*)
option_equal
  (opt1, opt2) =
(
//
case+ opt1 of
| None () =>
  (
    case+ opt1 of None () => true | Some _ => false
  )
| Some x1 =>
  (
    case+ opt2 of None () => false | Some x2 => option_equal$eqfn(x1, x2)
  )
//
) (* end of [option_equal] *)

(* ****** ****** *)

implement
{a}(*tmp*)
fprint_option
  (out, opt) = let
in
//
case+ opt of
| Some (x) => {
    val (
    ) = fprint_string (out, "Some(")
    val () = fprint_val<a> (out, x)
    val () = fprint_string (out, ")")
  } (* end of [Some] *)
| None () => fprint_string (out, "None()")
//
end // end of [fprint_option]

(* ****** ****** *)

(* end of [option.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/matrixptr.atxt
** Time of generation: Sat Oct 17 15:19:57 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: Feburary, 2012 *)

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

implement{}
arrayptr2matrixptr_int (A, m, n) = $UN.castvwtp0 (A)
implement{}
arrayptr2matrixptr_size (A, m, n) = $UN.castvwtp0 (A)

(* ****** ****** *)

implement{a}
matrixptr_make_elt
  {m, n} (m, n, x0) = let
  val mn = $UN.cast{Size}(m * n)
in
  $UN.castvwtp0{matrixptr(a,m,n)}(arrayptr_make_elt<a> (mn, x0))
end // end of [matrixptr_make_elt]

(* ****** ****** *)

implement{a}
matrixptr_get_at_int
  (A, i, n, j) = let
  val ij = $UN.cast{Size}(i * n + j)
in
  $UN.ptr0_get<a> (ptr_add<a> (ptrcast(A), ij))
end // end of [matrixptr_get_at_int]

implement{a}
matrixptr_get_at_size
  (A, i, n, j) = let
  val ij = $UN.cast{Size}(i * n + j)
in
  $UN.ptr0_get<a> (ptr_add<a> (ptrcast(A), ij))
end // end of [matrixptr_get_at_size]

(* ****** ****** *)

implement{a}
matrixptr_set_at_int
  (A, i, n, j, x) = let
  val ij = $UN.cast{Size}(i * n + j)
in
  $UN.ptr0_set<a> (ptr_add<a> (ptrcast(A), ij), x)
end // end of [matrixptr_set_at_int]

implement{a}
matrixptr_set_at_size
  (A, i, n, j, x) = let
  val ij = $UN.cast{Size}(i * n + j)
in
  $UN.ptr0_set<a> (ptr_add<a> (ptrcast(A), ij), x)
end // end of [matrixptr_set_at_size]

(* ****** ****** *)

implement{a}
matrixptr_exch_at_int
  (A, i, n, j, x) = let
  val ij = $UN.cast{Size}(i * n + j)
in
  $UN.ptr0_exch<a> (ptr_add<a> (ptrcast(A), ij), x)
end // end of [matrixptr_exch_at_int]

implement{a}
matrixptr_exch_at_size
  (A, i, n, j, x) = let
  val ij = $UN.cast{Size}(i * n + j)
in
  $UN.ptr0_exch<a> (ptr_add<a> (ptrcast(A), ij), x)
end // end of [matrixptr_exch_at_size]

(* ****** ****** *)

implement{a}
fprint_matrixptr
  {m,n} (out, M, m, n) = let
//
val p0 = ptrcast (M)
//
val (
  pf, fpf | p0
) = $UN.ptr_vtake {matrix(a,m,n)} (p0)
val () = fprint_matrix<a> (out, !p0, m, n)
prval () = fpf (pf)
//
in
  // nothing
end // end of [fprint_matrixptr]

(* ****** ****** *)

implement{a}
fprint_matrixptr_sep
(
  out, M, m, n, sep1, sep2
) = let
//
implement
fprint_matrix$sep1<> (out) = fprint_string (out, sep1)
implement
fprint_matrix$sep2<> (out) = fprint_string (out, sep2)
//
in
  fprint_matrixptr<a> (out, M, m, n)
end // end of [fprint_matrixptr_sep]

(* ****** ****** *)

(*
implement matrixptr_free = ATS_MFREE
*)

(* ****** ****** *)

implement{a}
matrixptr_foreach
  (A, m, n) = let
  var env: void = () in
  matrixptr_foreach_env<a><void> (A, m, n, env)
end // end of [matrixptr_foreach]

implement
{a}{env}
matrixptr_foreach_env
  (A, m, n, env) = res where {
  val p = ptrcast (A)
  prval pfarr = matrixptr_takeout (A)
  val res = matrix_foreach_env<a><env> (!p, m, n, env)
  prval () = matrixptr_addback (pfarr | A)
} // end of [matrixptr_foreach_env]

(* ****** ****** *)

implement{a}
matrixptr_tabulate
  (nrow, ncol) =
(
  matrixptr_encode2(matrix_ptr_tabulate<a> (nrow, ncol))
) (* end of [matrixptr_tabulate] *)

(* ****** ****** *)

implement{a}
matrixptr_tabulate_cloref
  {m,n} (nrow, ncol, f) = let
//
implement(a2)
matrix_tabulate$fopr<a2> (i, j) =
  $UN.castvwtp0{a2}(f($UN.cast{sizeLt(m)}(i), $UN.cast{sizeLt(n)}(j)))
//
in
  matrixptr_tabulate<a> (nrow, ncol)
end // end of [matrixptr_tabulate_cloref]

(* ****** ****** *)

(* end of [matrixptr.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: May, 2012
//
(* ****** ****** *)
//
// HX-2012-05: for array-based iterators
//
(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"
// end of [staload]

(* ****** ****** *)

staload "prelude/SATS/giterator.sats"

(* ****** ****** *)

sortdef t0p = t@ype
stadef itrknd = giter_array_kind
stadef itrkpm = giter_array_param

(* ****** ****** *)

dataviewtype
iterk (
  a:viewt@ype+, l:addr, int(*f*), int(*r*)
) = {f,r:int}
  ITR (a, l, f, r) of (
    array_v (a, l, f+r) | ptr l(*beg*), ptr(*end*), ptr(*cur*)
  ) // end of [ITR]

(* ****** ****** *)

extern
castfn iterk2giter
  {x:vt0p}{l:addr}{n:int}
  (xs: iterk (x, l, 0, n)):<> giter (itrknd, itrkpm(l), x, 0, n)
// end of [iterk2giter]

extern
castfn giter2iterk
  {x:vt0p}{l:addr}{f,r:int}
  (itr: giter (itrknd, itrkpm(l), x, f, r)):<> iterk (x, l, f, r)
// end of [giter2iterk]

(* ****** ****** *)

implement{x}
giter_make_array (pf | p, n) =
  iterk2giter (ITR (pf | p, ptr0_add_guint<x> (p, n), p))
// end of [giter_make_array]

implement
giter_free_array (itr) = let
  val+ ~ITR (pf | _, _, _) = giter2iterk (itr) in (pf | ())
end // end of [giter_free_array]

(* ****** ****** *)

extern
praxi encode
  {kpm:tk}{x:vt0p}{l:addr}{f,r:int}
  (xs: !iterk (x, l, f, r) >> giter (itrknd, kpm, x, f, r)): void
// end of [encode]

extern
praxi decode
  {kpm:tk}{x:vt0p}{l:addr}{f,r:int}
  (itr: !giter (itrknd, kpm, x, f, r) >> iterk (x, l, f, r)): void
// end of [decode]

(* ****** ****** *)

implement(x)
giter_is_atbeg<itrknd><x>
  {kpm}{f,r} (itr) = let
  prval () = decode (itr)
  val+ ITR (_ | p_beg, p_end, pi) = itr
  prval () = encode (itr)
  val res = g1ofg0_bool (p_beg = pi)
  extern praxi __assert {b:bool} (b: bool b): [b==(f==0)] void
  prval () = __assert (res)
in
  res
end // end of [giter_is_atbeg]

implement(x)
giter_isnot_atbeg<itrknd><x>
  {kpm}{f,r} (itr) = let
  prval () = decode (itr)
  val+ ITR (_ | p_beg, p_end, pi) = itr
  prval () = encode (itr)
  extern castfn __cast {b:bool} (b: bool b):<> [b==(f>0)] bool (b)
in
  if p_beg < pi then __cast(true) else __cast(false)
end // end of [giter_isnot_atbeg]

(* ****** ****** *)

implement(x)
giter_is_atend<itrknd><x>
  {kpm}{f,r} (itr) = let
  prval () = decode (itr)
  val+ ITR (_ | p_beg, p_end, pi) = itr
  prval () = encode (itr)
  val res = g1ofg0_bool (pi = p_end)
  extern praxi __assert {b:bool} (b: bool b): [b==(r==0)] void
  prval () = __assert (res)
in
  res
end // end of [giter_is_atend]

implement(x)
giter_isnot_atend<itrknd><x>
  {kpm}{f,r} (itr) = let
  prval () = decode (itr)
  val+ ITR (_ | p_beg, p_end, pi) = itr
  prval () = encode (itr)
  extern castfn __cast {b:bool} (b: bool b):<> [b==(r>0)] bool (b)
in
  if pi < p_end then __cast(true) else __cast(false)
end // end of [giter_isnot_atend]

(* ****** ****** *)

implement(x)
giter_getref<itrknd><x> (itr) = let
  prval () = decode (itr)
  val+ ITR (_ | _, _, pi) = itr
  prval () = encode (itr)
in
  $UN.cast2Ptr1 (pi)
end // end of [giter_getref]

(* ****** ****** *)

implement(x)
giter_inc<itrknd><x> (itr) = let
  prval () = decode (itr)
  val+ @ITR (_ | _, _, rpi) = itr
  val () = rpi := ptr0_succ<x> (rpi)
  prval () = fold@ (itr)
  prval () = encode (itr)
in
  // nothing
end // end of [giter_inc]

implement(x)
giter_dec<itrknd><x> (itr) = let
  prval () = decode (itr)
  val+ @ITR (_ | _, _, rpi) = itr
  val () = rpi := ptr0_pred<x> (rpi)
  prval () = fold@ (itr)
  prval () = encode (itr)
in
  // nothing
end // end of [giter_dec]

(* ****** ****** *)

implement(x)
giter_getref_inc<itrknd><x> (itr) = let
  prval () = decode (itr)
  val+ @ITR (_ | _, _, rpi) = itr
  val pi = rpi
  val () = rpi := ptr0_succ<x> (pi)
  prval () = fold@ (itr)
  prval () = encode (itr)
in
  $UN.cast2Ptr1 (pi)
end // end of [giter_getref_inc]

implement(x)
giter_dec_getref<itrknd><x> (itr) = let
  prval () = decode (itr)
  val+ @ITR (_ | _, _, rpi) = itr
  val pi = ptr0_pred<x> (rpi)
  val () = rpi := pi
  prval () = fold@ (itr)
  prval () = encode (itr)
in
  $UN.cast2Ptr1 (pi)
end // end of [giter_getref_dec]

(* ****** ****** *)

implement(x)
giter_fjmp<itrknd><x>
  (itr, i) = let
  prval () = decode (itr)
  val+ @ITR (_ | _, _, rpi) = itr
  val () = rpi := ptr0_add_guint<x> (rpi, i)
  prval () = fold@ (itr)
  prval () = encode (itr)
in
  // nothing
end // end of [giter_fjmp]

(* ****** ****** *)

implement(x)
giter_fgetref_at<itrknd><x>
  (itr, i) = let
  prval () = decode (itr)
  val+ ITR (_ | _, _, pi) = itr
  prval () = encode (itr)
in
  $UN.cast2Ptr1 (ptr0_add_guint<x> (pi, i))
end // end of [giter_fgetref_at]

(* ****** ****** *)

implement(x)
giter_fbjmp<itrknd><x> (itr, i) = let
  prval () = decode (itr)
  val+ @ITR (_ | _, _, rpi) = itr
  val () = rpi := ptr0_add_gint<x> (rpi, i)
  prval () = fold@ (itr)
  prval () = encode (itr)
in
  // nothing
end // end of [giter_fbjmp]

implement(x)
giter_fbgetref_at<itrknd><x>
  (itr, i) = let
  prval () = decode (itr)
  val+ ITR (_ | _, _, pi) = itr
  prval () = encode (itr)
in
  $UN.cast2Ptr1 (ptr0_add_gint<x> (pi, i))
end // end of [giter_fbget_at]

(* ****** ****** *)

(* end of [giter_array.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/string.atxt
** Time of generation: Sat Oct 17 15:19:52 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: April, 2012 *)

(* ****** ****** *)

#define ATS_DYNLOADFLAG 0 // no dynloading at run-time

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

#define CNUL '\000'

(* ****** ****** *)

overload + with add_ptr_bsz

(* ****** ****** *)

macdef castvwtp_trans = $UN.castvwtp0 // former name

(* ****** ****** *)

extern
fun memcpy
  (d:ptr, s:ptr, n:size_t):<!wrt> ptr = "mac#atspre_string_memcpy"
// end of [memcpy]

(* ****** ****** *)

implement
{}(*tmp*)
string_sing (c) = let
  val (pfat, pfgc | p) = malloc_gc(i2sz(2))
  val ((*void*)) = $UN.ptr0_set<char> (p, c)
  val ((*void*)) = $UN.ptr0_set_at<char> (p, 1, '\000')
in
  $UN.castvwtp0{strnptr(1)}((pfat, pfgc | p))
end // end of [string_sing]

(* ****** ****** *)

implement{}
string_is_empty
  {n} (str) = let
  val p = string2ptr(str)
in
  $UN.cast{bool(n==0)}($UN.ptr1_get<char>(p) = CNUL)
end // end of [string_is_empty]
implement{}
string_isnot_empty
  {n} (str) = let
  val p = string2ptr(str)
in
  $UN.cast{bool(n > 0)}($UN.ptr1_get<char>(p) != CNUL)
end // end of [string_isnot_empty]

(* ****** ****** *)

implement{}
string_is_atend_size{n}{i}
  (str, i) = let
  val p_i = add_ptr_bsz (string2ptr(str), i)
in
  $UN.cast{bool(n==i)}($UN.ptr1_get<char>(p_i) = CNUL)
end // end of [string_is_atend_size]

implement{tk}
string_is_atend_gint (str, i) =
  string_is_atend_size (str, g1int2uint(i))
// end of [string_is_atend_gint]
implement{tk}
string_is_atend_guint (str, i) =
  string_is_atend_size (str, g1uint2uint(i))
// end of [string_is_atend_guint]

(* ****** ****** *)

implement{}
string_get_at_size (str, i) =
  $UN.ptr1_get<charNZ>(string2ptr(str) + i)
// end of [string_get_at_size]

implement{tk}
string_get_at_gint (str, i) =
  string_get_at_size (str, g1int2uint (i))
// end of [string_get_at_gint]
implement{tk}
string_get_at_guint (str, i) =
  string_get_at_size (str, g1uint2uint (i))
// end of [string_get_at_guint]

(* ****** ****** *)

implement{}
string_test_at_size
  {n}{i} (str, i) = let
//
extern
castfn
__cast (c: char):<>
  [c:int] (string_index_p (n, i, c) | char (c))
//
in
  __cast ($UN.ptr1_get<char>(string2ptr(str) + i))
end // end of [string_test_at_size]

implement{tk}
string_test_at_gint (str, i) =
  string_test_at_size (str, g1int2uint (i))
// end of [string_test_at_gint]
implement{tk}
string_test_at_guint (str, i) =
  string_test_at_size (str, g1uint2uint (i))
// end of [string_test_at_guint]

(* ****** ****** *)

implement{
} strintcmp
  {n1,n2} (x1, n2) = let
//
prval () = lemma_string_param (x1)
//
fun loop
  {n2:nat} .<n2>.
  (p1: ptr, n2: int n2):<> int = let
  val c = $UN.ptr0_get<char>(p1)
in
  if c != CNUL then (
    if n2 > 0 then loop (ptr_succ<char>(p1), n2-1) else 1(*gt*)
  ) else (
    if n2 > 0 then ~1(*lt*) else 0(*eq*)
  ) // end of [if]
end // end of [loop]
//
in
  $UN.cast{int(sgn(n1-n2))}(loop (string2ptr(x1), n2))
end // end of [strintcmp]

(* ****** ****** *)

implement{
} strlencmp
  {n1,n2} (x1, x2) = let
//
prval () = lemma_string_param (x1)
prval () = lemma_string_param (x2)
//
//
fun loop
  {n1:nat} .<n1>. (
  p1: ptr, p2: ptr
) :<> int = let
  val c1 = $UN.ptr0_get<char>(p1)
  val c2 = $UN.ptr0_get<char>(p2)
in
//
if c1 != CNUL then let
  prval () =
    __assert () where {
      extern praxi __assert (): [n1 > 0] void
  } // end of [prval]
in
  if c2 != CNUL then
    loop {n1-1} (ptr_succ<char>(p1), ptr_succ<char>(p2))
  else 1(*gt*) // end of [if]
end else (
  if c2 != CNUL then ~1(*lt*) else 0(*eq*)
) (* end of [if] *)
//
end // end of [loop]
//
in
  $UN.cast{int(sgn(n1-n2))}(loop{n1}(string2ptr(x1), string2ptr(x2)))
end // end of [strlencmp]

(* ****** ****** *)

implement{
} string_make_list (cs) =
  string_make_listlen (cs, list_length (cs))
// end of [string_make_list]

implement{
} string_make_listlen
  {n} (cs, n) = let
//
prval () = lemma_list_param (cs)
//
fun loop
  {n:nat} .<n>.
(
  cs: list (char, n), n: int n, p: ptr
) :<!wrt> ptr = let
in
  if n > 0 then let
    val+list_cons (c, cs) = cs
    val () = $UN.ptr0_set<char>(p, c)
  in
    loop (cs, n-1, ptr_succ<char>(p))
  end else p // end of [if]
end // end of [loop]
//
val n1 = n + 1
val (pf, pfgc | p0) =
  $effmask_wrt (malloc_gc(i2sz(n1)))
val p1 = $effmask_wrt (loop (cs, n, p0))
val () =
  $effmask_wrt ($UN.ptr0_set<char>(p1, CNUL))
//
in
  castvwtp_trans{strnptr(n)}((pf, pfgc | p0))
end // end of [string_make_listlen]

(* ****** ****** *)

implement{
} string_make_rlist (cs) =
  string_make_rlistlen (cs, list_length (cs))
// end of [string_make_rlist]

implement{
} string_make_rlistlen
  {n} (cs, n) = let
//
prval () = lemma_list_param (cs)
//
fun loop
  {n:nat} .<n>.
(
  cs: list (char, n), n: int n, p: ptr
) :<!wrt> ptr = let
in
  if n > 0 then let
    val p1 = ptr_pred<char>(p)
    val+list_cons (c, cs) = cs
    val () = $UN.ptr0_set<char>(p1, c)
  in
    loop (cs, n-1, p1)
  end else p // end of [if]
end // end of [loop]
//
val n1 = n + 1
val (pf, pfgc | p0) =
  $effmask_wrt (malloc_gc(i2sz(n1)))
val p1 = ptr_add<char>(p0, n)
val () =
  $effmask_wrt ($UN.ptr0_set<char>(p1, CNUL))
val p0 = $effmask_wrt (loop (cs, n, p1))
//
in
  castvwtp_trans{strnptr(n)}((pf, pfgc | p0))
end // end of [string_make_rlistlen]

(* ****** ****** *)

implement{
} string_make_substring
  {n}{st,ln}
  (str, st, ln) = $effmask_wrt let
//
val ln1 = succ(ln)
val (pf, pfgc | p_dst) = malloc_gc (ln1)
val p_src = string2ptr(str)
val p_dst = memcpy (p_dst, p_src + st, ln)
//
val () = $UN.ptr0_set<char>(p_dst + ln, CNUL)
//
in
  castvwtp_trans{strnptr(ln)}((pf, pfgc | p_dst))
end // end of [string_make_substring]

(* ****** ****** *)
//
implement{}
string_head
  (str) = $UN.ptr0_get<charNZ> (string2ptr(str))
implement{}
string_tail{n}
  (str) = $UN.cast{string(n-1)}(ptr_succ<char> (string2ptr(str)))
//
(* ****** ****** *)

implement{}
string0_length
  (str) = string1_length<> (g1ofg0(str))
// end of [string0_length]

implement{}
string1_length
  {n} (str) =
  __strlen (str) where {
  extern fun __strlen (str: string n):<> size_t (n) = "mac#atspre_strlen"
} // end of [where] // end of [string1_length]

(* ****** ****** *)
//
implement{}
string0_nlength
  (str1, n2) =
  string1_nlength<> (g1ofg0(str1), g1ofg0(n2))
// end of [string0_nlength]
//
implement{}
string1_nlength
  (str1, n2) = let
//
fun
loop{n1,n2,r:nat} .<n1>.
(
  str1: string(n1), n2: size_t(n2), r: size_t(r)
) :<> size_t(min(n1,n2)+r) =
(
if
(n2 > 0)
then let
in
//
if
isneqz(str1)
  then loop (str1.tail(), pred(n2), succ(r)) else (r)
//
end // end of [then]
else (r) // end of [else]
)
//
prval () = lemma_string_param(str1) and () = lemma_g1uint_param(n2)
//
in
  loop (str1, n2, i2sz(0))
end // end of [string1_nlength]
//
(* ****** ****** *)

implement{}
string0_copy
  (str) = let
//
val str = g1ofg0(str)
val str2 = string1_copy (str)
prval () = lemma_strnptr_param (str2)
//
in
  strnptr2strptr (str2)
end // end of [string0_copy]

implement{}
string1_copy
  {n} (str) = let
//
val n = string1_length (str)
val n1 = succ(n)
val (pf, pfgc | p) = malloc_gc (n1)
val _(*p*) = $effmask_wrt (memcpy (p, string2ptr(str), n1))
//
in
  castvwtp_trans{strnptr(n)}((pf, pfgc | p))
end // end of [string1_copy]

(* ****** ****** *)

implement{
} strchr {n} (str, c0) = let
//
prval () = lemma_string_param (str)
extern fun __strchr (string, int):<> ptr = "mac#atspre_strchr"
extern fun __sub (ptr, ptr):<> ssizeBtw (0, n) = "mac#atspre_sub_ptr_ptr"
val p0 = string2ptr(str)
val p1 = __strchr (str, (char2int0)c0)
//
in
  if p1 > the_null_ptr then __sub (p1, p0) else i2ssz(~1)
end // end of [strchr]

implement{
} strrchr {n} (str, c0) = let
//
prval () = lemma_string_param (str)
extern fun __strrchr (string, int):<> ptr = "mac#atspre_strrchr"
extern fun __sub (ptr, ptr):<> ssizeBtw (0, n) = "mac#atspre_sub_ptr_ptr"
val p0 = string2ptr(str)
val p1 = __strrchr (str, (char2int0)c0)
//
in
  if p1 > the_null_ptr then __sub (p1, p0) else i2ssz(~1)
end // end of [strrchr]

(* ****** ****** *)

implement{
} strstr {n}
  (haystack, needle) = let
//
prval () = lemma_string_param (haystack)
extern fun __strstr (string, string):<> ptr = "mac#atspre_strstr"
extern fun __sub (ptr, ptr):<> ssizeBtw (0, n) = "mac#atspre_sub_ptr_ptr"
val p0 = string2ptr(haystack)
val p1 = __strstr (haystack, needle)
//
in
  if p1 > the_null_ptr then __sub (p1, p0) else i2ssz(~1)
end // end of [strstr]

(* ****** ****** *)

implement{
} strspn {n}
  (str, accept) = let
//
prval () = lemma_string_param (str)
extern fun __strspn (string, string):<> sizeLte (n) = "mac#atspre_strspn"
//
in
  __strspn (str, accept)
end // end of [strspn]

implement{
} strcspn {n}
  (str, reject) = let
//
prval () = lemma_string_param (str)
extern fun __strcspn (string, string):<> sizeLte (n) = "mac#atspre_strcspn"
//
in
  __strcspn (str, reject)
end // end of [strcspn]

(* ****** ****** *)

implement{}
string_index {n}
  (str, c) = $UN.cast{ssizeBtw(~1,n)}(strchr (str, c))
// end of [string_index]

implement{}
string_rindex {n}
  (str, c) = $UN.cast{ssizeBtw(~1,n)}(strrchr (str, c))
// end of [string_rindex]

(* ****** ****** *)

implement{}
string0_append
  (x1, x2) = let
//
val x1 = g1ofg0(x1)
val x2 = g1ofg0(x2)
val x12 = string1_append (x1, x2)
prval () = lemma_strnptr_param (x12)
//
in
  strnptr2strptr (x12)
end // end of [string0_append]

implement{}
string1_append
  {n1,n2} (x1, x2) = let
//
val n1 = strlen (x1) and n2 = strlen (x2)
//
val n12 = n1 + n2
val (pf, fpf | p) = malloc_gc (succ(n12))
//
val p1 = memcpy (p, string2ptr(x1), n1)
val p2 = memcpy (p + n1, string2ptr(x2), succ(n2))
//
in
  castvwtp_trans{strnptr(n1+n2)}((pf, fpf | p))
end // end of [string1_append]

(* ****** ****** *)

implement{}
string0_append3
  (x1, x2, x3) = let
//
var xs = @[string](x1, x2, x3)
//
in
//
stringarr_concat<>
  ($UN.cast{arrayref(string,3)}(addr@xs), i2sz(3))
//
end // end of [string0_append3]

implement{}
string0_append4
  (x1, x2, x3, x4) = let
//
var xs = @[string](x1, x2, x3, x4)
//
in
//
stringarr_concat<>
  ($UN.cast{arrayref(string,4)}(addr@xs), i2sz(4))
//
end // end of [string0_append4]

implement{}
string0_append5
  (x1, x2, x3, x4, x5) = let
//
var xs = @[string](x1, x2, x3, x4, x5)
//
in
//
stringarr_concat<>
  ($UN.cast{arrayref(string,5)}(addr@xs), i2sz(5))
//
end // end of [string0_append5]

implement{}
string0_append6
  (x1, x2, x3, x4, x5, x6) = let
//
var xs = @[string](x1, x2, x3, x4, x5, x6)
//
in
//
stringarr_concat<>
  ($UN.cast{arrayref(string,6)}(addr@xs), i2sz(6))
//
end // end of [string0_append6]

(* ****** ****** *)

implement{}
stringarr_concat (xs, asz) = let
//
fun loop
(
  p1: ptr, p2: ptr, i: size_t, ntot: size_t
) : size_t = let
in
//
if i > 0 then let
  val x = $UN.ptr0_get<string> (p1)
  val nx: size_t = string_length (x)
  val () = $UN.ptr0_set<size_t> (p2, nx)
in
  loop (ptr_succ<string> (p1), ptr_succ<size_t> (p2), pred(i), ntot+nx)
end else ntot // end of [if]
//
end // end of [loop]
//
fun loop2
(
  p1: ptr, p2: ptr, i: size_t, pres: ptr
) : void = let
in
//
if i > 0 then let
  val x = $UN.ptr0_get<string> (p1)
  val nx = $UN.ptr0_get<size_t> (p2)
  val _(*ptr*) = memcpy (pres, $UN.cast{ptr}(x), nx)
in
  loop2 (ptr_succ<string> (p1), ptr_succ<size_t> (p2), pred(i), pres+nx)
end else $UN.ptr0_set<char> (pres, CNUL)
//
end // end of [loop2]
//
val p1 = $UN.cast{ptr}(xs)
val nxs = arrayptr_make_uninitized<size_t> (asz)
val p2 = arrayptr2ptr (nxs)
//
val ntot = $effmask_all (loop (p1, p2, asz, i2sz(0)))
val (pf, pfgc | pres) = malloc_gc (g1ofg0(succ(ntot)))
val ((*void*)) = $effmask_all (loop2 (p1, p2, asz, pres))
//
val () = arrayptr_free (nxs)
//
in
  castvwtp_trans{Strptr1}((pf, pfgc | pres))
end // end of [stringarr_concat]

(* ****** ****** *)

implement{}
stringlst_concat (xs) = let
//
val n = list_length (xs)
prval () = lemma_list_param (xs)
prval [n:int] EQINT() = eqint_make_gint (n)
val xs2 = arrayptr_make_list (n, xs)
val res = stringarr_concat ($UN.castvwtp1{arrayref(string,n)}(xs2), i2sz(n))
val () = arrayptr_free (xs2)
//
in
  res
end // end of [stringlst_concat]

(* ****** ****** *)

implement{}
string_explode
  {n} (x) = let
//
prval () = lemma_string_param (x)
//
viewtypedef res(n) = list_vt (charNZ, n)
//
fun loop
  {n:nat} .<n>.
(
  x: string n, res: &ptr? >> res(n)
) :<!wrt> void = let
  val p = string2ptr (x)
  val c = $UN.ptr1_get<Char> (p)
in
//
if c != CNUL then let
  prval () = __assert () where {
    extern praxi __assert (): [n > 0] void
  }
  val () = res :=
    list_vt_cons {charNZ}{0} (c, _)
  val+list_vt_cons (_, res1) = res
  val x = $UN.cast{string(n-1)}(ptr1_succ<char>(p))
  val () = loop (x, res1)
in
  fold@ (res)
end else let
  prval () = __assert () where {
    extern praxi __assert (): [n == 0] void
  } // end of [prval]
in
  res := list_vt_nil ()
end // end of [if]
//
end // end of [loop]
//
var res: ptr
val () = $effmask_wrt (loop (x, res))
//
in
  res
end // end of [string_explode]

(* ****** ****** *)

implement{}
string_tabulate {n} (n) = let
//
prval () = lemma_g1uint_param (n)
//
fun loop (
  p: ptr, n: size_t, i: size_t
) : void = let
in
//
if i < n then let
  val c = string_tabulate$fopr (i)
  val () = $UN.ptr0_set<char> (p, c)
in
  loop (ptr_succ<char> (p), n, succ (i))
end else
  $UN.ptr0_set<char> (p, CNUL)
// end of [if]
//
end // end of [loop]
//
val n1 = succ(n)
val (pf, fpf | p0) = malloc_gc (n1)
val () = loop (p0, n, g1int2uint (0))
//
in
  castvwtp_trans{strnptr(n)}((pf, fpf | p0))
end // end of [string_tabulate]

(* ****** ****** *)

implement
{}(*tmp*)
string_forall
  (str) = let
//
fun
loop
(
  p: ptr
) : bool = let
  val c0 = $UN.ptr0_get<char>(p)
in
//
if c0 = CNUL then true else
  (if string_forall$pred(c0) then loop(ptr0_succ<char>(p)) else false)
//
end // end of [loop]
//
in
  loop(string2ptr(str))
end // end of [string_forall]

(* ****** ****** *)

implement
{}(*tmp*)
string_iforall
  (str) = let
//
fun
loop
(
  i: int, p: ptr
) : bool = let
  val c0 = $UN.ptr0_get<char>(p)
in
//
if c0 = CNUL then true else
  (if string_iforall$pred(i, c0) then loop(i+1, ptr0_succ<char>(p)) else false)
//
end // end of [loop]
//
in
  loop(0, string2ptr(str))
end // end of [string_iforall]

(* ****** ****** *)

implement{env}
string_foreach$cont (c, env) = true
implement{env}
string_foreach$fwork (c, env) = ((*void*))

implement{}
string_foreach (str) = let
  var env: void = () in string_foreach_env (str, env)
end // end of [string_foreach]

implement{env}
string_foreach_env
  {n} (str, env) = let
//
fun loop (
  p: ptr, env: &env
) : ptr = let
  val c = $UN.ptr0_get<char> (p)
  val cont = (
    if c != CNUL then string_foreach$cont<env> (c, env) else false
  ) : bool // end of [val]
in
  if cont then let
    val () =
      string_foreach$fwork<env> (c, env) in loop (ptr_succ<char> (p), env)
    // end of [val]
  end else (p) // end of [if]
end // end of [fun]
//
val p0 =
  string2ptr (str)
val p1 = loop (p0, env)
//
in
  $UN.cast{sizeLte(n)}(p1 - p0)
end // end of [string_foreach_env]

(* ****** ****** *)

implement{env}
string_rforeach$cont (c, env) = true
implement{env}
string_rforeach$fwork (c, env) = ((*void*))

implement{}
string_rforeach (str) = let
  var env: void = () in string_rforeach_env (str, env)
end // end of [string_rforeach]

implement
{env}(*tmp*)
string_rforeach_env
  {n} (str, env) = let
//
fun loop
(
  p0: ptr, p1: ptr, env: &env >> _
) : ptr = let
in
//
if
(p1 > p0)
then let
  val p2 = ptr_pred<char> (p1)
  val c2 = $UN.ptr0_get<charNZ> (p2)
  val cont =
    string_rforeach$cont<env> (c2, env)
  // end of [val]
in
  if cont
    then let
      val () =
      string_rforeach$fwork<env> (c2, env)
    in
      loop (p0, p2, env)
    end // end of [then]
    else (p1) // end of [else]    
end // end of [then]
else (p1) // end of [else]
//
end // end of [loop]
//
val p0 = ptrcast(str)
val p1 = ptr_add<char> (p0, length(str))
//
in
  $UN.cast{sizeLte(n)}(p1 - loop (p0, p1, env))
end // end of [string_rforeach_env]

(* ****** ****** *)

(*
//
// HX-2013-03: it is now defined as a macro
//
implement
stropt_none () = $UN.cast{stropt(~1)} (the_null_ptr)
*)

(* ****** ****** *)

implement{
} stropt_is_none {n} (x) = (
  $UN.cast{bool(n < 0)} (ptr0_is_null ($UN.cast2ptr (x)))
) // end of [stropt_is_none]

implement{
} stropt_is_some {n} (x) =
(
  $UN.cast{bool(n>=0)} (ptr0_isnot_null ($UN.cast2ptr (x)))
) // end of [stropt_is_some]

(* ****** ****** *)

implement{
} stropt_length (x) = let
  prval () = lemma_stropt_param (x)
in
  if stropt_is_some (x) then
    g1uint2int (string1_length (stropt_unsome(x)))
  else i2ssz(~1) // end of [if]
end // end of [stropt_length]

(* ****** ****** *)

implement fprint_val<string> = fprint_string
implement fprint_val<stropt> = fprint_stropt

(* ****** ****** *)

%{$
//
atstype_string
atspre_string_make_snprintf
(
  atstype_string fmt, ...
) {
  char *res ;
  va_list ap0 ;
//
  va_start(ap0, fmt) ;
//
// HX: [8] is kind of random
//
  res =
  atspre_string_make_vsnprintf(8, fmt, ap0) ;
//
  va_end(ap0) ;
//
  return (res) ;
//
} // end of [atspre_string_make_snprintf]
//
atstype_string
atspre_string_make_vsnprintf
(
  atstype_size bsz
, atstype_string fmt, va_list ap0
) {
//
  int ntot ;
  char *res ;
  va_list ap1 ;
//
  res = atspre_malloc_gc(bsz) ;
//
  va_copy(ap1, ap0) ;
  ntot = vsnprintf(res, bsz, (char*)fmt, ap1) ;
  va_end(ap1) ;
//
  if (ntot >= bsz)
  {
    bsz = ntot + 1 ;
    res = atspre_realloc_gc(res, bsz) ;
    ntot = vsnprintf(res, bsz, (char*)fmt, ap0) ;
  }
//
  if (ntot < 0) {
    atspre_mfree_gc(res) ; return (char*)0 ;
  }
//
  return (res) ;
//
} // end of [atspre_string_make_vsnprintf]
//
%}

(* ****** ****** *)

(* end of [string.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: May, 2012
//
(* ****** ****** *)
//
// HX-2012-05-22:
// this code itself is not particularly useful; however, it sets a concrete
// example demonstrating how iterators can be created.
//
(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"
// end of [staload]

(* ****** ****** *)

staload "prelude/SATS/giterator.sats"

(* ****** ****** *)

sortdef t0p = t@ype
stadef itrknd = giter_list_kind
stadef itrkpm = giter_list_param

(* ****** ****** *)

dataviewtype
iterk (
  a:t@ype+, int(*f*), int(*r*)
) = {f,r:int} ITR (a, f, r) of list (a, r) // HX: [f] is spurious!

(* ****** ****** *)

extern
castfn iterk2giter
  {x:t0p}{n:int}
  (xs: iterk (x, 0, n)):<> giter (itrknd, itrkpm(), x, 0, n)
// end of [iterk2giter]

extern
castfn giter2iterk
  {x:t0p}{f,r:int}
  (itr: giter (itrknd, itrkpm(), x, f, r)):<> iterk (x, f, r)
// end of [giter2iterk]

(* ****** ****** *)

implement{x}
giter_make_list
  (xs) = iterk2giter (ITR (xs))
implement
giter_free_list (itr) = let
  val+ ~ITR (xs) = giter2iterk (itr) in xs
end // end of [giter_free_list]

(* ****** ****** *)

extern
praxi encode
  {kpm:tk}{x:t0p}{f,r:int}
  (xs: !iterk (x, f, r) >> giter (itrknd, kpm, x, f, r)): void
// end of [encode]

extern
praxi decode
  {kpm:tk}{x:t0p}{f,r:int}
  (itr: !giter (itrknd, kpm, x, f, r) >> iterk (x, f, r)): void
// end of [decode]

(* ****** ****** *)

implement(x:t0p)
giter_is_atend<itrknd><x>
  (itr) = let
  prval () = decode (itr)
  val+ ITR (xs) = itr
  prval () = encode (itr)
in
  list_is_nil (xs)
end // end of [giter_is_atend]

(* ****** ****** *)

implement(x:t0p)
giter_vttake<itrknd><x> (itr) = let
  prval () = decode (itr)
  val+ ITR (xs) = itr; val+ list_cons (x, _) = xs
  prval () = encode (itr)
  var x = x
in
  $UN.vttakeout_void (x)
end // end of [giter_vttake]

(* ****** ****** *)

implement(x:t0p)
giter_inc<itrknd><x> (itr) = let
  prval () = decode (itr)
  val+ @ITR (xs) = itr; val+ list_cons (_, xs1) = xs; val () = xs := xs1
  prval () = fold@ (itr)
  prval () = encode (itr)
in
  // nothing
end // end of [giter_inc]

(* ****** ****** *)

implement(x:t0p)
giter_vttake_inc<itrknd><x> (itr) = let
  prval () = decode (itr)
  val+ @ITR (xs) = itr; val+ list_cons (x, xs1) = xs; val () = xs := xs1
  prval () = fold@ (itr)
  prval () = encode (itr)
  var x = x
in
  $UN.vttakeout_void (x)
end // end of [giter_vttake_inc]

(* ****** ****** *)

(* end of [giter_list.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/gprint.atxt
** Time of generation: Sat Oct 17 15:19:58 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: August, 2012 *)

(* ****** ****** *)

implement
{}(*tmp*)
gprint$out () = stdout_ref

(* ****** ****** *)

implement
{}(*tmp*)
gprint_newline () = let
  val out = gprint$out () in fprint_newline (out)
end // end of [gprint_newline]

(* ****** ****** *)

implement
{a}(*tmp*)
gprint_val (x) = let
  val out = gprint$out () in fprint_val<a> (out, x)
end // end of [gprint_val]

(* ****** ****** *)

implement
{a}(*tmp*)
gprint_ref (x) = let
  val out = gprint$out () in fprint_ref<a> (out, x)
end // end of [gprint_ref]

(* ****** ****** *)
//
implement
{}(*tmp*)
gprint_int (x) =
  fprint_val<int> (gprint$out (), x)
implement
{}(*tmp*)
gprint_char (x) =
  fprint_val<char> (gprint$out (), x)
implement
{}(*tmp*)
gprint_float (x) =
  fprint_val<float> (gprint$out (), x)
implement
{}(*tmp*)
gprint_double (x) =
  fprint_val<double> (gprint$out (), x)
implement
{}(*tmp*)
gprint_string (x) =
  fprint_val<string> (gprint$out (), x)
//
implement gprint_val<int> (x) = gprint_int (x)
implement gprint_val<char> (x) = gprint_char (x)
implement gprint_val<float> (x) = gprint_float (x)
implement gprint_val<double> (x) = gprint_double (x)
implement gprint_val<string> (x) = gprint_string (x)
//
(* ****** ****** *)
//
implement{}
gprint_list$beg () = gprint_string "("
implement{}
gprint_list$end () = gprint_string ")"
implement{}
gprint_list$sep () = gprint_string ", "
//
(* ****** ****** *)

implement
{a}(*tmp*)
gprint_list (xs) = let
//
typedef tenv = int
//
implement
list_foreach$fwork<a><tenv>
  (x, env) = let
  val () =
    if env > 0 then gprint_list$sep ()
  val () = env := succ (env)
in
  gprint_val (x)
end // end of [list_foreach$fwork]
//
var env: tenv = 0
val () = gprint_list$beg ()
val () = list_foreach_env<a><tenv> (xs, env)
val () = gprint_list$end ()
//
in
  // nothing
end // end of [gprint_list]

implement
(a)(*tmp*)
gprint_val<List(a)> (xs) = gprint_list<a> (xs)

(* ****** ****** *)
//
implement{}
gprint_listlist$beg1 () = gprint_string "("
implement{}
gprint_listlist$end1 () = gprint_string ")"
implement{}
gprint_listlist$sep1 () = gprint_string ", "
//
implement{}
gprint_listlist$beg2 () = gprint_string "("
implement{}
gprint_listlist$end2 () = gprint_string ")"
implement{}
gprint_listlist$sep2 () = gprint_string ", "
//
(* ****** ****** *)
//
implement
{a}(*tmp*)
gprint_listlist
  (xss) = let
//
typedef xs = List (a)
//
implement
gprint_val<xs> (xs) = let
//
implement gprint_list$beg<> () = gprint_listlist$beg2 ()
implement gprint_list$end<> () = gprint_listlist$end2 ()
implement gprint_list$sep<> () = gprint_listlist$sep2 ()
//
in
  gprint_list<a> (xs)
end // end of [gprint_val]
//
implement gprint_list$beg<> () = gprint_listlist$beg1 ()
implement gprint_list$end<> () = gprint_listlist$end1 ()
implement gprint_list$sep<> () = gprint_listlist$sep1 ()
//
in
  gprint_list<xs> (xss)
end // end of [gprint_listlist]
//
(* ****** ****** *)
//
implement{}
gprint_array$beg () = gprint_string "("
implement{}
gprint_array$end () = gprint_string ")"
implement{}
gprint_array$sep () = gprint_string ", "
//
(* ****** ****** *)

implement
{a}(*tmp*)
gprint_array (A, n) = let
//
typedef tenv = size_t
//
implement
(env)(*tmp*)
array_iforeach$fwork<a><env>
  (i, x, env) = let
  val () = if i > 0 then gprint_array$sep ()
in
  gprint_ref<a> (x)
end // end of [array_iforeach$fwork]
//
var env: void = ()
val () = gprint_array$beg ()
val _(*n*) = array_iforeach<a> (A, n)
val () = gprint_array$end ()
//
in
  // nothing
end // end of [gprint_array]

(* ****** ****** *)

implement
{a}(*tmp*)
gprint_arrayptr
  (A, n) =
{
  val p = ptrcast (A)
  prval pf = arrayptr_takeout (A)
  val () = gprint_array<a> (!p, n)
  prval () = arrayptr_addback (pf | A)
} (* end of [gprint_arrayptr] *)

(* ****** ****** *)

implement
{a}(*tmp*)
gprint_arrayref
  (A, n) = let
//
val (vbox pf | p) =
  arrayref_get_viewptr (A)
//
in
  $effmask_ref (gprint_array<a> (!p, n))
end // end of [gprint_arrayref]

(* ****** ****** *)

implement
{a}(*tmp*)
gprint_arrszref
  (ASZ) = () where {
//
var n: size_t
val A =
  arrszref_get_refsize<> (ASZ, n)
//
val () = gprint_arrayref<a> (A, n)
//
} (* end of [gprint_arrszref] *)

(* ****** ****** *)

(* end of [gprint.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/reference.atxt
** Time of generation: Sat Oct 17 15:19:53 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: May, 2012 *)

(* ****** ****** *)

implement
{a}(*tmp*)
ref = ref_make_elt<a>

implement
{a}(*tmp*)
ref_make_elt (x0) = let
  val (pfat, pfgc | p) = ptr_alloc<a> ()
  prval () = mfree_gc_v_elim (pfgc)
  val () = !p := x0 // initialization
in
  ref_make_viewptr (pfat | p)
end // end of [ref_make_elt]

(* ****** ****** *)

implement
{a}(*tmp*)
ref_get_elt
  (r) = !p where {
  val (vbox _ | p) = ref_get_viewptr (r)
} // end of [ref_get_elt]

implement
{a}(*tmp*)
ref_set_elt
  (r, x) = let
  val (vbox _ | p) = ref_get_viewptr (r)
in
  !p := x // assignment
end // end of [ref_set_elt]

implement
{a}(*tmp*)
ref_exch_elt
  (r, x) = let
  val (vbox _ | p) = ref_get_viewptr (r)
in
  !p :=: x // exchanging
end // end of [ref_exch_elt]

(* ****** ****** *)

implement
{}(*tmp*)
ref_app_fun{a} (r, f) = let
  val (vbox _ | p) = ref_get_viewptr (r) in f (!p)
end // end of [ref_app_fun]

implement
{}(*tmp*)
ref_app_funenv{a}
  (pfv | r, f, env) = let
  val (vbox _ | p) = ref_get_viewptr (r) in f (pfv | !p, env)
end // end of [ref_app_funenv]

(* ****** ****** *)

implement
{}(*tmp*)
ref_vtakeout{a} (r) = let
//
val (
  vbox pf | p
) = ref_get_viewptr (r)
//
prval (pf, fpf) = __copy (pf) where
{
  extern praxi __copy {l:addr} (pf: !a @ l): (a @ l, a @ l -<lin,prf> void)
} (* end of [prval] *)
//
in
  (pf, fpf | p)
end // end of [ref_vtakeout]

(* ****** ****** *)

(* end of [reference.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/bool.atxt
** Time of generation: Sat Oct 17 15:19:52 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: Feburary, 2012 *)

(* ****** ****** *)

#define ATS_DYNLOADFLAG 0 // no dynloading at run-time

(* ****** ****** *)

(*
//
// HX: see CATS/bool.cats
//
implement
bool2string
  (b) = if b then "true" else "false"
// end of [bool2string]
*)

(* ****** ****** *)

(*
//
// HX: see CATS/bool.cats
//
implement
fprint_bool (out, x) =
  fprint_string (out, bool2string (x))
// end of [fprint_bool]
*)

implement fprint_val<bool> = fprint_bool

(* ****** ****** *)

(* end of [bool.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/list_vt.atxt
** Time of generation: Sat Oct 17 15:19:55 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: Feburary, 2012 *)

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)
//
implement
{a}(*tmp*)
list_vt_make_sing (x) =
  list_vt_cons{a}(x, list_vt_nil)
implement
{a}(*tmp*)
list_vt_make_pair (x1, x2) =
  list_vt_cons{a}(x1, list_vt_cons{a}(x2, list_vt_nil))
//
(* ****** ****** *)

implement
{a}(*tmp*)
print_list_vt (xs) = fprint_list_vt<a> (stdout_ref, xs)
implement
{a}(*tmp*)
prerr_list_vt (xs) = fprint_list_vt<a> (stderr_ref, xs)

(* ****** ****** *)

implement
{}(*tmp*)
fprint_list_vt$sep (out) = fprint_list$sep<> (out)

implement
{a}(*tmp*)
fprint_list_vt
  (out, xs) = let
//
implement(env)
list_vt_iforeach$fwork<a><env>
  (i, x, env) = let
  val () =
    if i > 0 then fprint_list_vt$sep<(*none*)> (out)
  // end of [val]
in
  fprint_ref<a> (out, x)
end // end of [list_iforeach$fwork]
//
val _(*n*) = list_vt_iforeach<a> (xs)
//
in
  // nothing
end // end of [fprint_list_vt]

implement
{a}(*tmp*)
fprint_list_vt_sep
  (out, xs, sep) = let
//
implement
fprint_list_vt$sep<(*none*)> (out) = fprint_string (out, sep)
//
in
  fprint_list_vt<a> (out, xs)
end // end of [fprint_list_vt_sep]

(* ****** ****** *)

implement
{x}(*tmp*)
list_vt_is_nil (xs) =
  case+ xs of list_vt_nil () => true | _ =>> false
// end of [list_vt_is_nil]

implement
{x}(*tmp*)
list_vt_is_cons (xs) =
  case+ xs of list_vt_cons _ => true | _ =>> false
// end of [list_vt_is_cons]

implement
{x}(*tmp*)
list_vt_is_sing (xs) =
  case+ xs of list_vt_sing (x) => true | _ =>> false
// end of [list_vt_is_sing]

implement
{x}(*tmp*)
list_vt_is_pair (xs) =
  case+ xs of list_vt_pair (x1, x2) => true | _ =>> false
// end of [list_vt_is_pair]

(* ****** ****** *)

implement
{}(*tmp*)
list_vt_unnil (xs) = let
  val+~list_vt_nil () = xs in (*nothing*)
end // end of [list_vt_unnil]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_uncons (xs) = let
  val+~list_vt_cons (x, xs1) = xs in xs := xs1; x
end // end of [list_vt_uncons]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_length (xs) = let
//
fun loop
  {i,j:nat} .<i>.
(
  xs: !list_vt (a, i), j: int j
) :<> int (i+j) = let
in
//
case+ xs of
| list_vt_cons
    (_, xs) => loop (xs, j + 1)
| list_vt_nil () => j
//
end // end of [loop]
//
prval () = lemma_list_vt_param (xs)
//
in
  loop (xs, 0)
end // end of [list_vt_length]

(* ****** ****** *)

implement
{x}(*tmp*)
list_vt_copy (xs) = let
//
implement
{x2}(*tmp*)
list_vt_copylin$copy
  (x) = $UN.ptr0_get<x2>(addr@x)
//
in
  $effmask_all (list_vt_copylin<x> (xs))
end // end of [list_vt_copy]

implement
{x}(*tmp*)
list_vt_copylin
  (xs) = let
//
prval () = lemma_list_vt_param (xs)
//
fun loop
  {n:nat} .<n>. (
  xs: !list_vt (x, n), res: &ptr? >> list_vt (x, n)
) : void = let
in
//
case+ xs of
| @list_vt_cons
    (x, xs1) => let
    val x =
      list_vt_copylin$copy<x> (x)
    val () =
      res := list_vt_cons{x}{0}(x, _)
    val+list_vt_cons (_, res1) = res
    val () = loop (xs1, res1)
    prval () = fold@ (xs)
    prval () = fold@ (res)
  in
    // nothing
  end // end of [list_vt_cons]
| list_vt_nil () => res := list_vt_nil ()
//
end // end of [loop]
//
var res: ptr
val () =
  $effmask_all(loop (xs, res))
//
in
  res
end // end of [list_vt_copylin]

(* ****** ****** *)

implement
{x}(*tmp*)
list_vt_copylin_fun
  (xs, f) = let
//
implement
{x2}(*tmp*)
list_vt_copylin$copy
  (x) = x2 where
{
//
val f2 =
  $UN.cast{(&RD(x2))->x2}(f)
//
val x2 = $effmask_all(f2(x))
//
} (* end of [copy] *)
//
in
  list_vt_copylin<x> (xs)
end // end of [list_vt_copylin_fun]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_getref_at
  {n}{i} (xs, i) = let
//
fun loop {
  n,i:nat | i <= n
} .<i>. (
  xs: &list_vt (a, n), i: int i
) :<> Ptr1 = let
in
  if i > 0 then let
    val+@list_vt_cons (_, xs1) = xs
    val res = loop{n-1,i-1}(xs1, pred(i))
  in
    fold@ (xs); res
  end else
    $UN.cast2Ptr1(addr@(xs))
  // end of [if]
end // end of [loop]
//
in
  $UN.ptr2cptr{list_vt(a,n-i)}(loop (xs, i))
end // end of [list_vt_getref_at]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_get_at
  {n} (xs, i) = x where
{
//
var xs = __ref (xs) where
{
  extern
  castfn __ref
    (xs: !list_vt (a, n)):<> list_vt (a, n)
} // end of [val]
//
val pi = list_vt_getref_at (xs, i)
val+list_cons (x, _) =
  $UN.ptr1_get<List1(a)> (cptr2ptr(pi))
//
prval () = __unref (xs) where
{
  extern praxi __unref (xs: list_vt (a, n)): void
} // end of [prval]
//
} // end of [list_vt_get_at]

implement
{a}(*tmp*)
list_vt_set_at
  {n} (xs, i, x0) = let
//
var xs = let
  extern
  castfn __ref
    (xs: !list_vt (a, n)):<> list_vt (a, n)
  // end of [__ref]
in
  __ref (xs)
end // end of [val]
//
val pi = list_vt_getref_at (xs, i)
val (pf, fpf | pi) = $UN.cptr_vtake (pi)
val+@list_vt_cons (x1, xs1) = !pi
val () = x1 := x0
prval () = fold@ (!pi)
prval () = fpf (pf)
//
prval () = let
  extern praxi __unref (xs: list_vt (a, n)): void
in
  __unref (xs)
end // end of [prval]
//
in
  // nothing
end // end of [list_vt_set_at]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_exch_at
  {n} (xs, i, x0) = let
//
var xs = __ref (xs) where
{
  extern
  castfn __ref
    (xs: !list_vt (a, n)):<> list_vt (a, n)
} // end of [val]
//
val pi = list_vt_getref_at (xs, i)
val (pf, fpf | pi) = $UN.cptr_vtake (pi)
val+@list_vt_cons (x1, xs1) = !pi
//
val t = x1
val () = x1 := x0
val () = x0 := t
//
prval () = fold@ (!pi)
prval () = fpf (pf)
//
prval () = __unref (xs) where
{
  extern praxi __unref (xs: list_vt (a, n)): void
} // end of [prval]
//
in
  // nothing
end // end of [list_vt_exch_at]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_insert_at
  {n} (xs, i, x) = let
//
val pi = list_vt_getref_at (xs, i)
val xs_i = $UN.cptr_get (pi)
val xs1_i = list_vt_cons (x, xs_i)
val () =
  $UN.ptr1_set<List1_vt(a)> (cptr2ptr(pi), xs1_i)
//
prval () = __assert (xs) where
{
  extern
  praxi __assert (xs: &list_vt (a, n) >> list_vt (a, n+1)): void
} // end of [prval]
in
  // nothing
end // end of [list_vt_insert_at]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_takeout_at
{n} (xs, i) = x1 where
{
//
val pi = list_vt_getref_at (xs, i)
val xs_i = $UN.cptr_get (pi)
val+~list_vt_cons (x1, xs1_i) = xs_i
val () =
  $UN.ptr1_set<List0_vt(a)> (cptr2ptr(pi), xs1_i)
//
prval () =
__assert (xs) where
{
  extern
  praxi __assert (xs: &list_vt (a, n) >> list_vt (a, n-1)): void
} (* end of [prval] *)
//
} // end of [list_vt_takeout_at]

(* ****** ****** *)
//
implement
{a}(*tmp*)
list_vt_copy (xs) =
  list_copy<a> ($UN.list_vt2t(xs))
//
(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_free (xs) = let
//
implement
(a2:t0p)
list_vt_freelin$clear<a2>
  (x) = let
  prval () = topize (x) in (*void*)
end // end of [list_vt_freelin$clear]
//
in
  list_vt_freelin<a> (xs)
end // end of [list_vt_free]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_freelin$clear (x) = gclear_ref (x)
implement
{a}(*tmp*)
list_vt_freelin (xs) = let
//
prval () = lemma_list_vt_param (xs)
//
fun loop
  {n:nat} .<n>. (
  xs: list_vt (a, n)
) :<!wrt> void =
(
  case+ xs of
  | @list_vt_cons
      (x, xs1) => let
      val () =
        list_vt_freelin$clear<a> (x)
      val xs1 = xs1
      val () = free@{a}{0}(xs)
    in
      loop (xs1)
    end // end of [list_vt_cons]
  | ~list_vt_nil () => ()
) (* end of [loop] *)
//
in
  loop (xs)
end // end of [list_vt_freelin]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_freelin_fun
  (xs, f) = let
//
implement
{a2}(*tmp*)
list_vt_freelin$clear
  (x) = () where
{
//
val f2 =
  $UN.cast{(&a2 >> _?) -> void}(f)
//
val ((*void*)) = $effmask_all(f2(x))
//
} (* end of [clear] *)
//
in
  list_vt_freelin<a> (xs)
end // end of [list_vt_freelin_fun]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_uninitize$clear (x) = gclear_ref (x)

implement
{a}(*tmp*)
list_vt_uninitize
  {n} (xs) = let
//
prval () = lemma_list_vt_param (xs)
//
fun loop
  {n:nat} .<n>. (
  xs: !list_vt (a, n) >> list_vt (a?, n)
) :<!wrt> void =
(
  case+ xs of
  | @list_vt_cons
      (x, xs1) => let
      val () =
        list_vt_uninitize$clear (x)
      val () = loop (xs1)
      prval () = fold@ {a?} (xs)
    in
      // nothing
    end // end of [list_vt_cons]
  | @list_vt_nil () => fold@ {a?} (xs)
) (* end of [loop] *)
//
in
  loop (xs)
end // end of [list_vt_uninitize]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_append
  {m,n} (xs, ys) = let
//
prval () = lemma_list_vt_param (xs)
prval () = lemma_list_vt_param (ys)
//
fun loop
  {m:nat} .<m>.
(
  xs: &list_vt (a, m) >> list_vt (a, m+n), ys: list_vt (a, n)
) :<!wrt> void = let
in
//
case+ xs of
| @list_vt_cons
    (x, xs1) => let
    val () = loop (xs1, ys); prval () = fold@ (xs) in (*none*)
  end // end of [list_vt_cons]
| ~list_vt_nil () => (xs := ys)
//
end (* end of [loop] *)
//
var res = xs
val () = loop (res, ys)
//
in
  res
end // end of [list_vt_append]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_extend
  (xs, y) = list_vt_append<a> (xs, cons_vt{a}(y, nil_vt()))
// end of [list_vt_extend]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_unextend
  (xs) = let
//
fun loop
  {n:pos} .<n>.
(
  xs: &list_vt (a, n) >> list_vt (a, n-1)
) :<!wrt> (a) = let
//
val+@list_vt_cons (x, xs1) = xs
//
in
//
case+ xs1 of
| list_vt_cons _ => let
    val x = loop (xs1)
    prval () = fold@ (xs)
  in
    x
  end // end of [list_vt_cons]
| list_vt_nil () => let
    val x = x
    val xs1 = xs1
    val () = free@{a}{0}(xs)
  in
    xs := xs1; x
  end // end of [list_vt_nil]
//
end // end of [loop]
//
in
  loop (xs)
end // end of [list_vt_unextend]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_reverse (xs) = list_vt_reverse_append<a> (xs, list_vt_nil)

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_reverse_append
  (xs, ys) = let
//
prval () = lemma_list_vt_param (xs)
prval () = lemma_list_vt_param (ys)
//
fun loop
  {m,n:nat} .<m>.
(
  xs: list_vt (a, m), ys: list_vt (a, n)
) :<!wrt> list_vt (a, m+n) =
  case+ xs of
  | @list_vt_cons
      (_, xs1) => let
      val xs1_ = xs1
      val () = xs1 := ys; prval () = fold@ (xs)
    in
      loop (xs1_, xs)
    end // end of [cons]
  | ~list_vt_nil () => ys
(* end of [loop] *)
//
in
  loop (xs, ys)
end // end of [list_vt_reverse_append]

(* ****** ****** *)

implement
{x}(*tmp*)
list_vt_split_at
  (xs, i) = let
//
fun loop
  {n:int}
  {i:nat | i <= n} .<n>.
(
  xs: &list_vt (x, n) >> list_vt (x, i), i: int i
) :<!wrt> list_vt (x, n-i) =
(
if i > 0 then let
//
val+@cons_vt (x, xs1) = xs
val res = loop (xs1, i-1)
prval ((*void*)) = fold@ (xs)
//
in
  res
end else let
  val res = xs
  val () = xs := list_vt_nil((*void*))
in
  res
end // end of [if]
) // end of [loop]
//
var xs = xs
val res = loop (xs, i)
//
in
  (xs, res)
end // end of [list_split_vt_at]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_concat
  (xss) = let
//
viewtypedef VT = List_vt (a)
viewtypedef VT0 = List0_vt (a)
//
fun loop
  {n:nat} .<n>.
(
  res: VT, xss: list_vt (VT, n)
) :<!wrt> VT0 = let
in
  case+ xss of
  | ~list_vt_cons
      (xs, xss) => let
      val res = list_vt_append<a> (xs, res)
    in
      loop (res, xss)
    end // end of [list_vt_cons]
  | ~list_vt_nil () => let
      prval () = lemma_list_vt_param (res) in res
    end // end of [list_vt_nil]
end (* end of [loop] *)
//
val xss = list_vt_reverse (xss)
//
prval () = lemma_list_vt_param (xss)
//
in
//
case+ xss of
| ~list_vt_cons
    (xs, xss) => loop (xs, xss)
| ~list_vt_nil () => list_vt_nil ()
//
end // end of [list_vt_concat]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_separate (xs) = let
//
prval () = lemma_list_vt_param (xs)
//
fun loop
  {n:nat} .<n>. (
  xs: list_vt (a, n)
, res1: &ptr? >> list_vt (a, n1)
, res2: &ptr? >> list_vt (a, n2)
) : #[n1,n2:nat | n1+n2==n] void = let
in
//
case+ xs of
| @list_vt_cons
    (x, xs_tl) => let
    val xs_tl_v = xs_tl
    val test = list_vt_separate$pred (x)
  in
    if test then let
      val () = res1 := xs
      val () = loop (xs_tl_v, xs_tl, res2)
    in
      fold@ (res1)
    end else let
      val () = res2 := xs
      val () = loop (xs_tl_v, res1, xs_tl)
    in
      fold@ (res2)
    end // end of [if]
  end // end of [list_vt_cons]
| ~list_vt_nil () => (
    res1 := list_vt_nil; res2 := list_vt_nil
  )
//
end // end of [loop]
//
var res1: ptr
var res2: ptr
val () = loop (xs, res1, res2)
val () = xs := res1
//
in
  res2
end // end of [list_vt_separate]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_filter (xs) = let
//
implement
list_vt_filterlin$pred<a>
  (x) = list_vt_filter$pred<a> (x)
implement
list_vt_filterlin$clear<a>
  (x) = let
  prval () = topize (x) in (*void*)
end // end of [list_vt_filterlin$clear]
//
in
  list_vt_filterlin<a> (xs)
end // end of [list_vt_filter]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_filterlin (xs) = let
//
prval () = lemma_list_vt_param (xs)
//
fun loop
  {n:nat} .<n>.
(
  xs: &list_vt (a, n) >> listLte_vt (a, n)
) :<!wrt> void = let
in
//
case+ xs of
| @list_vt_cons
    (x, xs1) => let
    val test =
      list_vt_filterlin$pred<a> (x)
  in
    if test then let
      val () = loop (xs1)
    in
      fold@ (xs)
    end else let
      val xs1 = xs1
      val () =
        list_vt_filterlin$clear<a> (x)
      val () = free@{a}{0}(xs)
      val () = xs := xs1
    in
      loop (xs)
    end // end of [if]
  end // end of [list_vt_cons]
| @list_vt_nil () => fold@ (xs)
//
end // end of [loop]
//
var xs = xs
//
in
  loop (xs); xs
end // end of [list_vt_filterlin]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_filterlin$clear (x) = gclear_ref (x)

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_app
  (xs) = let
in
//
case+ xs of
| @list_vt_cons
    (x, xs1) => let
    val () =
      list_vt_app$fwork<a> (x)
    val () = list_vt_app<a> (xs1)
    prval () = fold@ (xs)
  in
    // nothing
  end // end of [cons]
| list_vt_nil ((*void*)) => ()
//
end // end of [list_vt_app]

implement
{a}(*tmp*)
list_vt_appfree
  (xs) = let
in
//
case+ xs of
| @list_vt_cons
    (x, xs1) => let
    val xs1 = xs1
    val () = list_vt_appfree$fwork<a> (x)
    val () = free@ {a}{0} (xs)
  in
    list_vt_appfree<a> (xs1)
  end // end of [cons]
| ~list_vt_nil ((*void*)) => ()
//
end // end of [list_vt_appfree]

(* ****** ****** *)

implement
{a}{b}
list_vt_map
  (xs) = let
//
prval () = lemma_list_vt_param (xs)
//
fun loop
  {n:nat} .<n>. (
  xs: !list_vt (a, n)
, res: &ptr? >> list_vt (b, n)
) : void = let
in
  case+ xs of
  | @list_vt_cons
      (x, xs1) => let
      val y =
        list_vt_map$fopr<a><b> (x)
      // end of [val]
      val () = res := list_vt_cons{b}{0}(y, _)
      val+list_vt_cons (_, res1) = res
      val () = loop (xs1, res1)
      val () = fold@ (xs)
      prval () = fold@ (res)
    in
      // nothing
    end // end of [list_vt_cons]
  | list_vt_nil () => (res := list_vt_nil ())
end // end of [loop]
//
var res: ptr
val () = loop (xs, res)
//
in
  res
end // end of [list_vt_map]

(* ****** ****** *)

implement
{x}{y}(*tmp*)
list_vt_map_fun
  (xs, f) = let
//
implement
{x2}{y2}
list_vt_map$fopr (x2) = let
  val f = $UN.cast{(&x2)->y}(f) in $UN.castvwtp0{y2}(f(x2))
end // end of [list_vt_map$fopr]
//
in
  list_vt_map<x><y> (xs)
end // end of [list_vt_map_fun]

implement
{x}{y}(*tmp*)
list_vt_map_clo
  (xs, f) = let
//
val f = $UN.cast{(&x) -<cloref1> y}(addr@f)
//
implement
{x2}{y2}
list_vt_map$fopr (x2) = let
  val f = $UN.cast{(&x2)-<cloref1>y}(f) in $UN.castvwtp0{y2}(f(x2))
end // end of [list_vt_map$fopr]
//
in
  list_vt_map<x><y> (xs)
end // end of [list_vt_map_clo]

implement
{x}{y}(*tmp*)
list_vt_map_cloref
  (xs, f) = let
//
implement
{x2}{y2}
list_vt_map$fopr (x2) = let
  val f = $UN.cast{(&x2)-<cloref1>y}(f) in $UN.castvwtp0{y2}(f(x2))
end // end of [list_vt_map$fopr]
//
in
  list_vt_map<x><y> (xs)
end // end of [list_vt_map_cloref]

(* ****** ****** *)

implement
{a}{b}
list_vt_mapfree
  (xs) = let
//
prval () = lemma_list_vt_param (xs)
//
fun loop
  {n:nat} .<n>. (
  xs: list_vt (a, n)
, res: &ptr? >> list_vt (b, n)
) : void = let
in
  case+ xs of
  | @list_vt_cons
      (x, xs1) => let
      val y =
      list_vt_mapfree$fopr<a><b> (x)
      val xs1_val = xs1
      val ((*freed*)) = free@{a}{0}(xs)
      val () = res := list_vt_cons{b}{0}(y, _)
      val+list_vt_cons (_, res1) = res
      val () = loop (xs1_val, res1)
      prval ((*folded*)) = fold@(res)
    in
      // nothing
    end // end of [list_vt_cons]
  | ~list_vt_nil () => (res := list_vt_nil ())
end // end of [loop]
//
var res: ptr
val () = loop (xs, res)
//
in
  res
end // end of [list_vt_mapfree]

(* ****** ****** *)

implement
{x}{y}(*tmp*)
list_vt_mapfree_fun
  (xs, f) = let
//
implement
{x2}{y2}
list_vt_mapfree$fopr (x2) = let
  val f = $UN.cast{(&x2>>_?)->y}(f) in $UN.castvwtp0{y2}(f(x2))
end // end of [list_vt_mapfree$fopr]
//
in
  list_vt_mapfree<x><y> (xs)
end // end of [list_vt_mapfree_fun]

implement
{x}{y}(*tmp*)
list_vt_mapfree_clo
  (xs, f) = let
//
val f =
$UN.cast{(&x>>_?) -<cloref1> y}(addr@f)
//
implement
{x2}{y2}
list_vt_mapfree$fopr (x2) = let
  val f = $UN.cast{(&x2>>_?)-<cloref1>y}(f) in $UN.castvwtp0{y2}(f(x2))
end // end of [list_vt_mapfree$fopr]
//
in
  list_vt_mapfree<x><y> (xs)
end // end of [list_vt_mapfree_clo]

implement
{x}{y}(*tmp*)
list_vt_mapfree_cloref
  (xs, f) = let
//
implement
{x2}{y2}
list_vt_mapfree$fopr (x2) = let
  val f = $UN.cast{(&x2>>_?)-<cloref1>y}(f) in $UN.castvwtp0{y2}(f(x2))
end // end of [list_vt_mapfree$fopr]
//
in
  list_vt_mapfree<x><y> (xs)
end // end of [list_vt_mapfree_cloref]

(* ****** ****** *)

implement
{x}(*tmp*)
list_vt_foreach
  (xs) = let
  var env: void = ()
in
  list_vt_foreach_env<x><void> (xs, env)
end // end of [list_vt_foreach]

implement
{x}{env}
list_vt_foreach_env
  (xs, env) = let
//
prval () = lemma_list_vt_param (xs)
//
fun loop
  {n:nat} .<n>.
(
  xs: !list_vt (x, n), env: &env
) : void = let
in
//
case+ xs of
| @list_vt_cons
    (x, xs1) => let
    val test =
      list_vt_foreach$cont (x, env)
    // end of [val]
  in
    if test then let
      val () =
        list_vt_foreach$fwork<x><env> (x, env)
      val () = loop (xs1, env)
      prval ((*void*)) = fold@ (xs)
    in
      // nothing
    end else let
      prval ((*void*)) = fold@ (xs) in (*nothing*)
    end // end of [if]
  end // end of [cons]
| list_vt_nil ((*void*)) => ()
//
end // end of [loop]
//
in
  loop (xs, env)
end // end of [list_vt_foreach_env]

(* ****** ****** *)

implement
{x}{env}
list_vt_foreach$cont (x, env) = true

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_foreach_fun
  {fe} (xs, f) = let
//
prval () = lemma_list_vt_param (xs)
//
fun
loop
{n:nat} .<n>.
(
  xs: !list_vt (a, n), f: (&a) -<fe> void
) :<fe> void =
  case+ xs of
  | @list_vt_cons
      (x, xs1) => let
      val () = f (x)
      val () = loop (xs1, f)
    in
      fold@ (xs)
    end // end of [cons]
  | list_vt_nil ((*void*)) => ()
// end of [loop]
in
  loop (xs, f)
end // end of [list_vt_foreach_fun]

implement
{a}(*tmp*)
list_vt_foreach_funenv
  {v}{vt}{fe}
  (pf | xs, f, env) = let
//
prval () = lemma_list_vt_param (xs)
//
fun loop
  {n:nat} .<n>. (
  pf: !v
| xs: !list_vt (a, n)
, f: (!v | &a, !vt) -<fe> void
, env: !vt
) :<fe> void =
  case+ xs of
  | @list_vt_cons
      (x, xs1) => let
      val () = f (pf | x, env)
      val () = loop (pf | xs1, f, env)
    in
      fold@ (xs)
    end // end of [cons]
  | list_vt_nil ((*void*)) => ()
// end of [loop]
//
in
  loop (pf | xs, f, env)
end // end of [list_vt_foreach_funenv]

(* ****** ****** *)

implement
{x}(*tmp*)
list_vt_iforeach
  (xs) = let
  var env: void = ()
in
  list_vt_iforeach_env<x><void> (xs, env)
end // end of [list_vt_iforeach]

implement
{x}{env}
list_vt_iforeach_env
  (xs, env) = let
//
prval () = lemma_list_vt_param (xs)
//
fun loop
  {n:nat}{i:nat} .<n>. (
  i: int i, xs: !list_vt (x, n), env: &env
) : intBtwe(i, n+i) = let
in
  case+ xs of
  | @list_vt_cons
      (x, xs1) => let
      val test =
        list_vt_iforeach$cont<x><env> (i, x, env)
      // end of [val]
    in
      if test then let
        val () =
          list_vt_iforeach$fwork<x><env> (i, x, env)
        // end of [val]
        val i = loop (succ(i), xs1, env)
        prval () = fold@ (xs)
      in
        i // the number of processed elements
      end else let
        prval () = fold@ (xs)
      in
        i // the number of processed elements
      end // end of [if]
    end // end of [cons]
  | list_vt_nil ((*void*)) => (i) // |processed-elements|
end // end of [loop]
//
in
  loop (0, xs, env)
end // end of [list_vt_iforeach_env]

(* ****** ****** *)

implement
{x}{env}
list_vt_iforeach$cont (i, x, env) = true

(* ****** ****** *)

#include "./SHARE/list_vt_mergesort.dats"
#include "./SHARE/list_vt_quicksort.dats"

(* ****** ****** *)

(* end of [list_vt.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/float.atxt
** Time of generation: Sat Oct 17 15:19:52 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: Feburary, 2012 *)

(* ****** ****** *)

#define ATS_DYNLOADFLAG 0 // no dynloading at run-time

(* ****** ****** *)
//
(* ****** ****** *)
//
staload UN = "prelude/SATS/unsafe.sats"
//
(* ****** ****** *)


(* ****** ****** *)

implement
g0int2float<intknd,fltknd> = g0int2float_int_float
implement
g0int2float<intknd,dblknd> = g0int2float_int_double
implement
g0int2float<lintknd,dblknd> = g0int2float_lint_double

(* ****** ****** *)

implement
g0float2int<fltknd, intknd> = g0float2int_float_int
implement
g0float2int<fltknd, lintknd> = g0float2int_float_lint
implement
g0float2int<dblknd, intknd> = g0float2int_double_int
implement
g0float2int<dblknd, lintknd> = g0float2int_double_lint
implement
g0float2int<dblknd, llintknd> = g0float2int_double_llint

(* ****** ****** *)

implement
g0float2float<fltknd,fltknd> = g0float2float_float_float
implement
g0float2float<fltknd,dblknd> = g0float2float_float_double
implement
g0float2float<dblknd,fltknd> = g0float2float_double_float
implement
g0float2float<dblknd,dblknd> = g0float2float_double_double

(* ****** ****** *)

implement g0string2float<dblknd> = g0string2float_double

(* ****** ****** *)

implement g0float_neg<fltknd> = g0float_neg_float
implement g0float_abs<fltknd> = g0float_abs_float
implement g0float_succ<fltknd> = g0float_succ_float
implement g0float_pred<fltknd> = g0float_pred_float

implement g0float_add<fltknd> = g0float_add_float
implement g0float_sub<fltknd> = g0float_sub_float
implement g0float_mul<fltknd> = g0float_mul_float
implement g0float_div<fltknd> = g0float_div_float
implement g0float_mod<fltknd> = g0float_mod_float

implement g0float_lt<fltknd> = g0float_lt_float
implement g0float_lte<fltknd> = g0float_lte_float
implement g0float_gt<fltknd> = g0float_gt_float
implement g0float_gte<fltknd> = g0float_gte_float
implement g0float_eq<fltknd> = g0float_eq_float
implement g0float_neq<fltknd> = g0float_neq_float
implement g0float_compare<fltknd> = g0float_compare_float

implement g0float_max<fltknd> = g0float_max_float
implement g0float_min<fltknd> = g0float_min_float

(* ****** ****** *)

implement g0float_neg<dblknd> = g0float_neg_double
implement g0float_abs<dblknd> = g0float_abs_double
implement g0float_succ<dblknd> = g0float_succ_double
implement g0float_pred<dblknd> = g0float_pred_double

implement g0float_add<dblknd> = g0float_add_double
implement g0float_sub<dblknd> = g0float_sub_double
implement g0float_mul<dblknd> = g0float_mul_double
implement g0float_div<dblknd> = g0float_div_double
implement g0float_mod<dblknd> = g0float_mod_double

implement g0float_lt<dblknd> = g0float_lt_double
implement g0float_lte<dblknd> = g0float_lte_double
implement g0float_gt<dblknd> = g0float_gt_double
implement g0float_gte<dblknd> = g0float_gte_double
implement g0float_eq<dblknd> = g0float_eq_double
implement g0float_neq<dblknd> = g0float_neq_double
implement g0float_compare<dblknd> = g0float_compare_double

implement g0float_max<dblknd> = g0float_max_double
implement g0float_min<dblknd> = g0float_min_double

(* ****** ****** *)

implement g0float_neg<ldblknd> = g0float_neg_ldouble
implement g0float_abs<ldblknd> = g0float_abs_ldouble
implement g0float_succ<ldblknd> = g0float_succ_ldouble
implement g0float_pred<ldblknd> = g0float_pred_ldouble

implement g0float_add<ldblknd> = g0float_add_ldouble
implement g0float_sub<ldblknd> = g0float_sub_ldouble
implement g0float_mul<ldblknd> = g0float_mul_ldouble
implement g0float_div<ldblknd> = g0float_div_ldouble
implement g0float_mod<ldblknd> = g0float_mod_ldouble

implement g0float_lt<ldblknd> = g0float_lt_ldouble
implement g0float_lte<ldblknd> = g0float_lte_ldouble
implement g0float_gt<ldblknd> = g0float_gt_ldouble
implement g0float_gte<ldblknd> = g0float_gte_ldouble
implement g0float_eq<ldblknd> = g0float_eq_ldouble
implement g0float_neq<ldblknd> = g0float_neq_ldouble
implement g0float_compare<ldblknd> = g0float_compare_ldouble

implement g0float_max<ldblknd> = g0float_max_ldouble
implement g0float_min<ldblknd> = g0float_min_ldouble

(* ****** ****** *)
//
implement fprint_val<float> = fprint_float
implement fprint_val<double> = fprint_double
implement fprint_val<ldouble> = fprint_ldouble
//
(* ****** ****** *)

implement
{tk}(*tk*)
g0float_npow
  (x, n) = let
//
typedef gfloat = g0float(tk)
//
fun
loop
(
  x: gfloat, res: gfloat, n: int
) : gfloat = (
//
if
(n > 1)
then let
  val n2 = n >> 1
  val b0 = n - (n2 << 1)
  val xx = x * x
in
  if b0 = 0
    then loop(xx, res, n2) else loop(xx, x * res, n2)
  // end of [if]
end // end of [then]
else (
  if n > 0 then x * res else res
) (* end of [else] *)
//
) (* end of [loop] *)
//
val res = $UN.cast{gfloat}(1.0)
//
in
  $effmask_all(loop(x, res, n))
end // end of [g0float_npow]

(* ****** ****** *)

(* end of [float.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/pointer.atxt
** Time of generation: Sat Oct 17 15:19:51 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2012 *)

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

primplmnt
lemma_ptr_param
  {l} (p) = lemma_addr_param {l} ()
// end of [lemma_ptr_param]

(* ****** ****** *)

primplmnt
ptr_get_index {l} (p) = eqaddr_make {l, l} ()

(* ****** ****** *)

implement{a}
ptr0_succ (p) = add_ptr_bsz (p, sizeof<a>)
implement{a}
ptr0_pred (p) = sub_ptr_bsz (p, sizeof<a>)

(* ****** ****** *)
//
implement{a}{tk}
ptr0_add_gint (p, i) =
  add_ptr_bsz (p, g0int2uint(i) * sizeof<a>)
implement{a}{tk}
ptr0_sub_gint (p, i) =
  sub_ptr_bsz (p, g0int2uint(i) * sizeof<a>)
//
implement{a}{tk}
ptr0_add_guint (p, i) =
  add_ptr_bsz (p, g0uint2uint(i) * sizeof<a>)
implement{a}{tk}
ptr0_sub_guint (p, i) =
  sub_ptr_bsz (p, g0uint2uint(i) * sizeof<a>)
//
(* ****** ****** *)
//
implement{a}
ptr1_succ {l} (p) =
  $UN.cast{ptr(l+sizeof(a))}(ptr0_succ<a> (p))
implement{a}
ptr1_pred {l} (p) =
  $UN.cast{ptr(l-sizeof(a))}(ptr0_pred<a> (p))
//
(* ****** ****** *)
//
implement{a}{tk}
ptr1_add_gint {l}{i} (p, i) =
  $UN.cast{ptr(l+i*sizeof(a))}(ptr0_add_gint<a><tk> (p, i))
implement{a}{tk}
ptr1_sub_gint {l}{i} (p, i) =
  $UN.cast{ptr(l-i*sizeof(a))}(ptr0_sub_gint<a><tk> (p, i))
//
implement{a}{tk}
ptr1_add_guint {l}{i} (p, i) =
  $UN.cast{ptr(l+i*sizeof(a))}(ptr0_add_guint<a><tk> (p, i))
implement{a}{tk}
ptr1_sub_guint {l}{i} (p, i) =
  $UN.cast{ptr(l-i*sizeof(a))}(ptr0_sub_guint<a><tk> (p, i))
//
(* ****** ****** *)

implement{a} ptr_get (pf | p) = !p

implement{a} ptr_set (pf | p, x) = !p := x

implement{a}
ptr_exch (pf | p, x) =
{
  val tmp = x; val () = x := !p; val () = !p := tmp
} // end of [ptr_exch]

(* ****** ****** *)

implement
{a}(*tmp*)
ptr_nullize
  (pf | x) =
(
  ptr_nullize_tsz{a}(pf | x, sizeof<a>)
) (* ptr_nullize *)

(* ****** ****** *)

implement
{a}(*tmp*)
ptr_alloc () = ptr_alloc_tsz{a}(sizeof<a>)

(* ****** ****** *)

implement
{a}(*tmp*)
aptr_make_elt(x) = let
//
val (pf, fpf | p) = ptr_alloc()
//
in
  !p := x; $UN.castvwtp0{aPtr1(a)}((pf, fpf, p))
end // end of [aptr_make_elt]

(* ****** ****** *)
//
implement
{a}(*tmp*)
aptr_getfree_elt
  {l}(ap) = x where
{
  val p = aptr2ptr(ap)
  val x = $UN.ptr1_get<a>(p)
  prval
  pfat_ = $UN.castview0{(a?)@l}(0)
  prval
  pfgc_ = $UN.castview0{mfree_gc_v(l)}(0)
  val () = ptr_free{a?}{l}(pfgc_, pfat_ | p)
  prval () = $UN.cast2void(ap)
} (* end of [aptr_getfree_elt] *)
//
(* ****** ****** *)
//
implement
{a}(*tmp*)
aptr_get_elt(ap) = $UN.ptr1_get<a>(aptr2ptr(ap))
implement
{a}(*tmp*)
aptr_set_elt(ap, x) = $UN.ptr1_set<a>(aptr2ptr(ap), x)
//
(* ****** ****** *)

implement
fprint_val<ptr> (out, p) = fprint_ptr (out, p)

(* ****** ****** *)

(* end of [pointer.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/checkast.atxt
** Time of generation: Sat Oct 17 15:19:54 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: December, 2013 *)

(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

(*
staload "prelude/SATS/checkast.sats"
*)

(* ****** ****** *)

implement{tk}
checkast_gintLt
  (x, i, errmsg) = let
  val x = g1ofg0_int(x)
in
//
if x < i
  then (x)
  else let
    val () =
      fprint! (stderr_ref, "exit(ATS): ", errmsg) in exit(1)
    // end of [val]
  end // end of [else]
//
end // end of [checkast_gintLt]

(* ****** ****** *)

implement{tk}
checkast_gintLte
  (x, i, errmsg) = let
  val x = g1ofg0_int(x)
in
//
if x <= i
  then (x)
  else let
    val () =
      fprint! (stderr_ref, "exit(ATS): ", errmsg) in exit(1)
    // end of [val]
  end // end of [else]
//
end // end of [checkast_gintLte]

(* ****** ****** *)

implement{tk}
checkast_gintGt
  (x, i, errmsg) = let
  val x = g1ofg0_int(x)
in
//
if x > i
  then (x)
  else let
    val () =
      fprint! (stderr_ref, "exit(ATS): ", errmsg) in exit(1)
    // end of [val]
  end // end of [else]
//
end // end of [checkast_gintGt]

(* ****** ****** *)

implement{tk}
checkast_gintGte
  (x, i, errmsg) = let
  val x = g1ofg0_int(x)
in
//
if x >= i
  then (x)
  else let
    val () =
      fprint! (stderr_ref, "exit(ATS): ", errmsg) in exit(1)
    // end of [val]
  end // end of [else]
//
end // end of [checkast_gintGte]

(* ****** ****** *)

implement{tk}
checkast_gintBtw
  (x, i, j, errmsg) = let
  val x = g1ofg0_int(x)
in
//
if x >= i
  then
    if x < j then (x)
    else let
      val () =
      fprint! (stderr_ref, "exit(ATS): ", errmsg) in exit(1)
      // end of [val]
    end // end of [else]
  else let
    val () =
      fprint! (stderr_ref, "exit(ATS): ", errmsg) in exit(1)
    // end of [val]
  end // end of [else]
//
end // end of [checkast_gintBtw]

(* ****** ****** *)

implement{tk}
checkast_gintBtwe
  (x, i, j, errmsg) = let
  val x = g1ofg0_int(x)
in
//
if x >= i
  then
    if x <= j then (x)
    else let
      val () =
      fprint! (stderr_ref, "exit(ATS): ", errmsg) in exit(1)
      // end of [val]
    end // end of [else]
  else let
    val () =
      fprint! (stderr_ref, "exit(ATS): ", errmsg) in exit(1)
    // end of [val]
  end // end of [else]
//
end // end of [checkast_gintBtwe]

(* ****** ****** *)

implement{}
checkast_Ptr1
  (x, errmsg) = let
  val x = g1ofg0_ptr(x)
in
//
if x > 0
  then (x)
  else let
    val () =
      fprint! (stderr_ref, "exit(ATS): ", errmsg) in exit(1)
    // end of [val]
  end // end of [else]
// end of [if]
//
end // end of [checkast_Ptr1]

(* ****** ****** *)

implement{}
checkast_Strptr1
  (x, errmsg) = let
  val p = strptr2ptr(x)
in
//
if p > 0
  then (x)
  else let
    prval () =
      strptr_free_null (x)
    val ((*void*)) =
      fprint! (stderr_ref, "exit(ATS): ", errmsg)
    val ((*void*)) = exit_void(1)
  in
    $UN.castvwtp0{Strptr1}(0)
  end // end of [else]
// end of [if]
//
end // end of [checkast_Strptr1]

(* ****** ****** *)

(* end of [checkast.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/array_prf.atxt
** Time of generation: Sat Oct 17 15:19:56 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: Feburary, 2012 *)

(* ****** ****** *)

primplmnt
array_v_unnil_nil
  {a1,a2}(pf) = let
//
prval () =
  array_v_unnil{a1}(pf)
//
in
  array_v_nil{a2}((*void*))
//
end // end of [array_v_unnil]

(* ****** ****** *)

primplmnt
array_v_sing
  (pfat) =
(
//
array_v_cons(pfat, array_v_nil())
//
) (* end of [array_v_sing] *)

primplmnt
array_v_unsing
  (pfarr) = let
//
prval
(
  pf1at, pf2arr
) = array_v_uncons (pfarr)
//
prval () = array_v_unnil (pf2arr)
//
in
  pf1at
end // end of [array_v_unsing]

(* ****** ****** *)

primplmnt
array_v_split
  {a}(pf_arr) =
  split (pf_arr) where
{
//
prfun
split
  {l:addr} 
  {n,i:nat | i <= n} .<i>.
(
  pf_arr: array_v (a, l, n)
) : (
  array_v (a, l, i), array_v (a, l+i*sizeof(a), n-i)
) = (
//
sif
i > 0
then let
  prval (pf1elt, pf2arr) = array_v_uncons(pf_arr)
  prval (pf1arr_res, pf2arr_res) = split{..}{n-1,i-1}(pf2arr)
in
  (array_v_cons (pf1elt, pf1arr_res), pf2arr_res)
end // end of [then]
else let
  prval EQINT () =
    eqint_make{i,0}() in (array_v_nil{a}{l}((*void*)), pf_arr)
  // end of [prval]
end // end of [else]
//
) (* end of [split] *)
//
} (* end of [array_v_split] *)

(* ****** ****** *)

primplmnt
array_v_split_at
  {a}{l}{n}{i}(pf | i) = array_v_split{a}{l}{n}{i}(pf)
// end of [array_v_split_at]

(* ****** ****** *)

primplmnt
array_v_unsplit
  {a}(pf1arr, pf2arr) =
  unsplit (pf1arr, pf2arr) where
{
//
prval () = lemma_array_v_param (pf1arr)
prval () = lemma_array_v_param (pf2arr) 
//
prfun
unsplit
  {l:addr}
  {n1,n2:nat} .<n1>.
(
  pf1arr: array_v (a, l, n1)
, pf2arr: array_v (a, l+n1*sizeof(a), n2)
) : array_v (a, l, n1+n2) =
(
//
sif
n1 > 0
then let
  prval @(
    pf11elt, pf12arr
  ) = array_v_uncons (pf1arr)
  prval pf_arr_res = unsplit (pf12arr, pf2arr)
in
  array_v_cons (pf11elt, pf_arr_res)
end // end of [then]
else let
  prval
  EQINT () = eqint_make {n1,0} ()
  prval () = array_v_unnil (pf1arr) in pf2arr
end // end of [sif]
//
) (* end of [unsplit] *)
//
} (* end of [array_v_unsplit] *)

(* ****** ****** *)

primplmnt
array_v_extend
  {a}(pf1arr, pf2at) =
(
//
array_v_unsplit
(
  pf1arr, array_v_sing{a}(pf2at)
) // end of [array_v_unsplit]
//
) (* end of [array_v_extend] *)

primplmnt
array_v_unextend
  {a}{l}{n} (pfarr) = let
//
prval (pf1arr, pf2arr) =
  array_v_split{a}{l}{n}{n-1}(pfarr)
//
in
  (pf1arr, array_v_unsing{a}(pf2arr))
end // end of [array_v_unextend]

(* ****** ****** *)

primplmnt
array_v_takeout
  {a}{l}{n}{i} (pfarr) =
  takeout{..}{n}{i}(pfarr) where
{
//
prfun
takeout
  {l:addr}{n:int}
  {i:nat | i < n} .<i>.
(
  pfarr: array_v (a, l, n)
) : vtakeout (
  array_v (a, l, n), a@l+i*sizeof(a)
) = let
  prval @(pf1at, pf2arr) = array_v_uncons(pfarr)
in
  sif i > 0 then let
    prval (pfat, fpf) = takeout{..}{n-1}{i-1}(pf2arr)
  in
    (pfat, llam pfat =<prf> array_v_cons{a}(pf1at, fpf(pfat)))
  end else let
    prval EQINT () = eqint_make{i,0}((*void*))
  in
    (pf1at, llam pf1at =<prf> array_v_cons{a}(pf1at, pf2arr))
  end // end of [sif]
end // end of takeout]
//
} // end of [array_v_takeout]

(* ****** ****** *)

(* end of [array_prf.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/integer.atxt
** Time of generation: Sat Oct 17 15:19:51 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: May, 2012 *)

(* ****** ****** *)

#define ATS_DYNLOADFLAG 0 // no dynloading at run-time

(* ****** ****** *)
//
//
(* ****** ****** *)
//
staload UN = "prelude/SATS/unsafe.sats"
//
(* ****** ****** *)

implement
g0int2int<intknd,intknd> = g0int2int_int_int
implement
g0int2int<intknd,lintknd> = g0int2int_int_lint
implement
g0int2int<intknd,llintknd> = g0int2int_int_llint
implement
g0int2int<intknd,ssizeknd> = g0int2int_int_ssize

(* ****** ****** *)

implement g0int_neg<intknd> = g0int_neg_int
implement g0int_abs<intknd> = g0int_abs_int
implement g0int_succ<intknd> = g0int_succ_int
implement g0int_pred<intknd> = g0int_pred_int
implement g0int_half<intknd> = g0int_half_int
implement g0int_add<intknd> = g0int_add_int
implement g0int_sub<intknd> = g0int_sub_int
implement g0int_mul<intknd> = g0int_mul_int
implement g0int_div<intknd> = g0int_div_int
implement g0int_mod<intknd> = g0int_mod_int
implement g0int_asl<intknd> = g0int_asl_int
implement g0int_asr<intknd> = g0int_asr_int
implement g0int_isltz<intknd> = g0int_isltz_int
implement g0int_isltez<intknd> = g0int_isltez_int
implement g0int_isgtz<intknd> = g0int_isgtz_int
implement g0int_isgtez<intknd> = g0int_isgtez_int
implement g0int_iseqz<intknd> = g0int_iseqz_int
implement g0int_isneqz<intknd> = g0int_isneqz_int
implement g0int_lt<intknd> = g0int_lt_int
implement g0int_lte<intknd> = g0int_lte_int
implement g0int_gt<intknd> = g0int_gt_int
implement g0int_gte<intknd> = g0int_gte_int
implement g0int_eq<intknd> = g0int_eq_int
implement g0int_neq<intknd> = g0int_neq_int
implement g0int_compare<intknd> = g0int_compare_int
implement g0int_max<intknd> = g0int_max_int
implement g0int_min<intknd> = g0int_min_int
//
implement fprint_val<int> (out, x) = fprint_int (out, x)
//
implement g0int_neg<lintknd> = g0int_neg_lint
implement g0int_abs<lintknd> = g0int_abs_lint
implement g0int_succ<lintknd> = g0int_succ_lint
implement g0int_pred<lintknd> = g0int_pred_lint
implement g0int_half<lintknd> = g0int_half_lint
implement g0int_add<lintknd> = g0int_add_lint
implement g0int_sub<lintknd> = g0int_sub_lint
implement g0int_mul<lintknd> = g0int_mul_lint
implement g0int_div<lintknd> = g0int_div_lint
implement g0int_mod<lintknd> = g0int_mod_lint
implement g0int_asl<lintknd> = g0int_asl_lint
implement g0int_asr<lintknd> = g0int_asr_lint
implement g0int_isltz<lintknd> = g0int_isltz_lint
implement g0int_isltez<lintknd> = g0int_isltez_lint
implement g0int_isgtz<lintknd> = g0int_isgtz_lint
implement g0int_isgtez<lintknd> = g0int_isgtez_lint
implement g0int_iseqz<lintknd> = g0int_iseqz_lint
implement g0int_isneqz<lintknd> = g0int_isneqz_lint
implement g0int_lt<lintknd> = g0int_lt_lint
implement g0int_lte<lintknd> = g0int_lte_lint
implement g0int_gt<lintknd> = g0int_gt_lint
implement g0int_gte<lintknd> = g0int_gte_lint
implement g0int_eq<lintknd> = g0int_eq_lint
implement g0int_neq<lintknd> = g0int_neq_lint
implement g0int_compare<lintknd> = g0int_compare_lint
implement g0int_max<lintknd> = g0int_max_lint
implement g0int_min<lintknd> = g0int_min_lint
//
implement fprint_val<lint> (out, x) = fprint_lint (out, x)
//
implement g0int_neg<llintknd> = g0int_neg_llint
implement g0int_abs<llintknd> = g0int_abs_llint
implement g0int_succ<llintknd> = g0int_succ_llint
implement g0int_pred<llintknd> = g0int_pred_llint
implement g0int_half<llintknd> = g0int_half_llint
implement g0int_add<llintknd> = g0int_add_llint
implement g0int_sub<llintknd> = g0int_sub_llint
implement g0int_mul<llintknd> = g0int_mul_llint
implement g0int_div<llintknd> = g0int_div_llint
implement g0int_mod<llintknd> = g0int_mod_llint
implement g0int_asl<llintknd> = g0int_asl_llint
implement g0int_asr<llintknd> = g0int_asr_llint
implement g0int_isltz<llintknd> = g0int_isltz_llint
implement g0int_isltez<llintknd> = g0int_isltez_llint
implement g0int_isgtz<llintknd> = g0int_isgtz_llint
implement g0int_isgtez<llintknd> = g0int_isgtez_llint
implement g0int_iseqz<llintknd> = g0int_iseqz_llint
implement g0int_isneqz<llintknd> = g0int_isneqz_llint
implement g0int_lt<llintknd> = g0int_lt_llint
implement g0int_lte<llintknd> = g0int_lte_llint
implement g0int_gt<llintknd> = g0int_gt_llint
implement g0int_gte<llintknd> = g0int_gte_llint
implement g0int_eq<llintknd> = g0int_eq_llint
implement g0int_neq<llintknd> = g0int_neq_llint
implement g0int_compare<llintknd> = g0int_compare_llint
implement g0int_max<llintknd> = g0int_max_llint
implement g0int_min<llintknd> = g0int_min_llint
//
implement fprint_val<llint> (out, x) = fprint_llint (out, x)
//
implement g0int_neg<ssizeknd> = g0int_neg_ssize
implement g0int_abs<ssizeknd> = g0int_abs_ssize
implement g0int_succ<ssizeknd> = g0int_succ_ssize
implement g0int_pred<ssizeknd> = g0int_pred_ssize
implement g0int_half<ssizeknd> = g0int_half_ssize
implement g0int_add<ssizeknd> = g0int_add_ssize
implement g0int_sub<ssizeknd> = g0int_sub_ssize
implement g0int_mul<ssizeknd> = g0int_mul_ssize
implement g0int_div<ssizeknd> = g0int_div_ssize
implement g0int_mod<ssizeknd> = g0int_mod_ssize
implement g0int_asl<ssizeknd> = g0int_asl_ssize
implement g0int_asr<ssizeknd> = g0int_asr_ssize
implement g0int_isltz<ssizeknd> = g0int_isltz_ssize
implement g0int_isltez<ssizeknd> = g0int_isltez_ssize
implement g0int_isgtz<ssizeknd> = g0int_isgtz_ssize
implement g0int_isgtez<ssizeknd> = g0int_isgtez_ssize
implement g0int_iseqz<ssizeknd> = g0int_iseqz_ssize
implement g0int_isneqz<ssizeknd> = g0int_isneqz_ssize
implement g0int_lt<ssizeknd> = g0int_lt_ssize
implement g0int_lte<ssizeknd> = g0int_lte_ssize
implement g0int_gt<ssizeknd> = g0int_gt_ssize
implement g0int_gte<ssizeknd> = g0int_gte_ssize
implement g0int_eq<ssizeknd> = g0int_eq_ssize
implement g0int_neq<ssizeknd> = g0int_neq_ssize
implement g0int_compare<ssizeknd> = g0int_compare_ssize
implement g0int_max<ssizeknd> = g0int_max_ssize
implement g0int_min<ssizeknd> = g0int_min_ssize
//
implement fprint_val<ssize_t> (out, x) = fprint_ssize (out, x)
//
(* ****** ****** *)

implement{} mul_int1_size0 (i, j) = i2sz(i) * j
implement{} mul_size0_int1 (i, j) = i * i2sz(j)

(* ****** ****** *)

implement
{tk}(*tk*)
g0int_npow
  (x, n) = let
//
typedef gint = g0int(tk)
//
fun
loop
(
  x: gint, res: gint, n: int
) : gint = (
//
if
(n > 1)
then let
  val n2 = n >> 1
  val b0 = n - (n2 << 1)
  val xx = x * x
in
  if b0 = 0
    then loop(xx, res, n2) else loop(xx, x * res, n2)
  // end of [if]
end // end of [then]
else (
  if n > 0 then x * res else res
) (* end of [else] *)
//
) (* end of [loop] *)
//
val res = $UN.cast{gint}(1)
//
in
  $effmask_all(loop(x, res, n))
end // end of [g0int_npow]

(* ****** ****** *)

implement
g1int2int<intknd,intknd> = g1int2int_int_int
implement
g1int2int<intknd,lintknd> = g1int2int_int_lint
implement
g1int2int<intknd,llintknd> = g1int2int_int_llint
implement
g1int2int<intknd,ssizeknd> = g1int2int_int_ssize

(* ****** ****** *)

implement g1int_neg<intknd> = g1int_neg_int
implement g1int_abs<intknd> = g1int_abs_int
implement g1int_succ<intknd> = g1int_succ_int
implement g1int_pred<intknd> = g1int_pred_int
implement g1int_half<intknd> = g1int_half_int
implement g1int_add<intknd> = g1int_add_int
implement g1int_sub<intknd> = g1int_sub_int
implement g1int_mul<intknd> = g1int_mul_int
implement g1int_div<intknd> = g1int_div_int
implement g1int_nmod<intknd> = g1int_nmod_int
implement g1int_isltz<intknd> = g1int_isltz_int
implement g1int_isltez<intknd> = g1int_isltez_int
implement g1int_isgtz<intknd> = g1int_isgtz_int
implement g1int_isgtez<intknd> = g1int_isgtez_int
implement g1int_iseqz<intknd> = g1int_iseqz_int
implement g1int_isneqz<intknd> = g1int_isneqz_int
implement g1int_lt<intknd> = g1int_lt_int
implement g1int_lte<intknd> = g1int_lte_int
implement g1int_gt<intknd> = g1int_gt_int
implement g1int_gte<intknd> = g1int_gte_int
implement g1int_eq<intknd> = g1int_eq_int
implement g1int_neq<intknd> = g1int_neq_int
implement g1int_compare<intknd> = g1int_compare_int
implement g1int_max<intknd> = g1int_max_int
implement g1int_min<intknd> = g1int_min_int
//
implement g1int_neg<lintknd> = g1int_neg_lint
implement g1int_abs<lintknd> = g1int_abs_lint
implement g1int_succ<lintknd> = g1int_succ_lint
implement g1int_pred<lintknd> = g1int_pred_lint
implement g1int_half<lintknd> = g1int_half_lint
implement g1int_add<lintknd> = g1int_add_lint
implement g1int_sub<lintknd> = g1int_sub_lint
implement g1int_mul<lintknd> = g1int_mul_lint
implement g1int_div<lintknd> = g1int_div_lint
implement g1int_nmod<lintknd> = g1int_nmod_lint
implement g1int_isltz<lintknd> = g1int_isltz_lint
implement g1int_isltez<lintknd> = g1int_isltez_lint
implement g1int_isgtz<lintknd> = g1int_isgtz_lint
implement g1int_isgtez<lintknd> = g1int_isgtez_lint
implement g1int_iseqz<lintknd> = g1int_iseqz_lint
implement g1int_isneqz<lintknd> = g1int_isneqz_lint
implement g1int_lt<lintknd> = g1int_lt_lint
implement g1int_lte<lintknd> = g1int_lte_lint
implement g1int_gt<lintknd> = g1int_gt_lint
implement g1int_gte<lintknd> = g1int_gte_lint
implement g1int_eq<lintknd> = g1int_eq_lint
implement g1int_neq<lintknd> = g1int_neq_lint
implement g1int_compare<lintknd> = g1int_compare_lint
implement g1int_max<lintknd> = g1int_max_lint
implement g1int_min<lintknd> = g1int_min_lint
//
implement g1int_neg<llintknd> = g1int_neg_llint
implement g1int_abs<llintknd> = g1int_abs_llint
implement g1int_succ<llintknd> = g1int_succ_llint
implement g1int_pred<llintknd> = g1int_pred_llint
implement g1int_half<llintknd> = g1int_half_llint
implement g1int_add<llintknd> = g1int_add_llint
implement g1int_sub<llintknd> = g1int_sub_llint
implement g1int_mul<llintknd> = g1int_mul_llint
implement g1int_div<llintknd> = g1int_div_llint
implement g1int_nmod<llintknd> = g1int_nmod_llint
implement g1int_isltz<llintknd> = g1int_isltz_llint
implement g1int_isltez<llintknd> = g1int_isltez_llint
implement g1int_isgtz<llintknd> = g1int_isgtz_llint
implement g1int_isgtez<llintknd> = g1int_isgtez_llint
implement g1int_iseqz<llintknd> = g1int_iseqz_llint
implement g1int_isneqz<llintknd> = g1int_isneqz_llint
implement g1int_lt<llintknd> = g1int_lt_llint
implement g1int_lte<llintknd> = g1int_lte_llint
implement g1int_gt<llintknd> = g1int_gt_llint
implement g1int_gte<llintknd> = g1int_gte_llint
implement g1int_eq<llintknd> = g1int_eq_llint
implement g1int_neq<llintknd> = g1int_neq_llint
implement g1int_compare<llintknd> = g1int_compare_llint
implement g1int_max<llintknd> = g1int_max_llint
implement g1int_min<llintknd> = g1int_min_llint
//
implement g1int_neg<ssizeknd> = g1int_neg_ssize
implement g1int_abs<ssizeknd> = g1int_abs_ssize
implement g1int_succ<ssizeknd> = g1int_succ_ssize
implement g1int_pred<ssizeknd> = g1int_pred_ssize
implement g1int_half<ssizeknd> = g1int_half_ssize
implement g1int_add<ssizeknd> = g1int_add_ssize
implement g1int_sub<ssizeknd> = g1int_sub_ssize
implement g1int_mul<ssizeknd> = g1int_mul_ssize
implement g1int_div<ssizeknd> = g1int_div_ssize
implement g1int_nmod<ssizeknd> = g1int_nmod_ssize
implement g1int_isltz<ssizeknd> = g1int_isltz_ssize
implement g1int_isltez<ssizeknd> = g1int_isltez_ssize
implement g1int_isgtz<ssizeknd> = g1int_isgtz_ssize
implement g1int_isgtez<ssizeknd> = g1int_isgtez_ssize
implement g1int_iseqz<ssizeknd> = g1int_iseqz_ssize
implement g1int_isneqz<ssizeknd> = g1int_isneqz_ssize
implement g1int_lt<ssizeknd> = g1int_lt_ssize
implement g1int_lte<ssizeknd> = g1int_lte_ssize
implement g1int_gt<ssizeknd> = g1int_gt_ssize
implement g1int_gte<ssizeknd> = g1int_gte_ssize
implement g1int_eq<ssizeknd> = g1int_eq_ssize
implement g1int_neq<ssizeknd> = g1int_neq_ssize
implement g1int_compare<ssizeknd> = g1int_compare_ssize
implement g1int_max<ssizeknd> = g1int_max_ssize
implement g1int_min<ssizeknd> = g1int_min_ssize
//
(* ****** ****** *)

implement{tk}
g1int_sgn (x) = compare_g1int_int<tk> (x, 0)

(* ****** ****** *)
//
implement{
} add_size1_int1
  {i,j}(i, j) = $UN.cast{size_t(i+j)}(i+g0i2u(j))
implement{
} add_int1_size1
  {i,j}(i, j) = $UN.cast{size_t(i+j)}(g0i2u(i)+j)
//
implement{
} sub_size1_int1
  {i,j}(i, j) = $UN.cast{size_t(i-j)}(i-g0i2u(j))
//
(* ****** ****** *)

implement{tk}
g1int_mul2 {i,j} (x, y) = let
  prval pf = mul_make {i,j} () in (pf | g1int_mul<tk> (x, y))
end // end of [let] // end of [g1int_mul2]

(* ****** ****** *)
//
implement{
} mul_int1_size1
  {i,j}(i, j) = $UN.cast{size_t(i*j)}(g0i2u(i)*j)
implement{
} mul_size1_int1
  {i,j}(i, j) = $UN.cast{size_t(i*j)}(i*g0i2u(j))
//
(* ****** ****** *)

implement{tk}
g1int_ndiv {i,j} (x, y) = let
  val q = g1int_div (x, y) in $UN.cast{g1int(tk,ndiv(i,j))}(q)
end // end of [let] // end of [g1int_ndiv]

(* ****** ****** *)

implement{tk}
g1int_ndiv2 {i,j} (x, y) = let
  val [q:int] q = g1int_div (x, y)
  prval [q2:int,r:int] pf = divmod_istot{i,j}()
  prval EQINT() = $UN.castview0{EQINT(q,q2)}(0)
in
  (pf | q)
end // end of [let] // end of [g1int_ndiv2]

(* ****** ****** *)

implement{tk}
g1int_nmod2 {i,j} (x, y) = let
  val r = g1int_nmod (x, y)
  prval [q:int,r2:int] pf = divmod_istot{i,j}()
  prval EQINT() = $UN.castview0{EQINT(i%j,r2)}(0)
in
  (pf | r)
end // end of [let] // end of [g1int_nmod2]

(* ****** ****** *)

implement
nmod_g1int_int1<intknd> (x, y) = g1i2i(g1int_nmod (x, g1i2i(y)))
implement
nmod_g1int_int1<lintknd> (x, y) = g1i2i(g1int_nmod (x, g1i2i(y)))
implement
nmod_g1int_int1<llintknd> (x, y) = g1i2i(g1int_nmod (x, g1i2i(y)))

(* ****** ****** *)

implement{tk}
nmod2_g1int_int1{i,j}(x, y) = let
  val r = nmod_g1int_int1 (x, y)
  prval [q:int,r2:int] pf = divmod_istot{i,j}()
  prval EQINT() = $UN.castview0{EQINT(i%j,r2)}(0)
in
  (pf | r)
end // end of [let] // end of [nmod2_g1int_int1]

(* ****** ****** *)

implement{tk}
g1int_ngcd (x, y) = let
//
fun loop{i,j:nat} .<j>.
(
  x: g1int (tk, i), y: g1int (tk, j)
) :<> [r:nat] g1int (tk, r) = let
in
//
if y > 0 then loop (y, g1int_nmod (x, y)) else x
//
end // end of [loop]
//
in
  loop (x, y)
end // end of [g1int_ngcd]

(* ****** ****** *)
//
// HX: int -> uint
//
implement
g0int2uint<intknd,uintknd> = g0int2uint_int_uint
implement
g0int2uint<intknd,ulintknd> = g0int2uint_int_ulint
implement
g0int2uint<intknd,ullintknd> = g0int2uint_int_ullint
implement
g0int2uint<intknd,sizeknd> = g0int2uint_int_size
//
implement
g0int2uint<lintknd,ulintknd> = g0int2uint_lint_ulint
implement
g0int2uint<lintknd,ullintknd> = g0int2uint_lint_ullint
implement
g0int2uint<lintknd,sizeknd> = g0int2uint_lint_size
//
implement
g0int2uint<llintknd,ullintknd> = g0int2uint_llint_ullint
//
implement
g0int2uint<ssizeknd,sizeknd> = g0int2uint_ssize_size

(* ****** ****** *)
//
// HX: uint -> int
//
implement
g0uint2int<uintknd,intknd> = g0uint2int_uint_int
implement
g0uint2int<uintknd,lintknd> = g0uint2int_uint_lint
implement
g0uint2int<uintknd,llintknd> = g0uint2int_uint_llint
implement
g0uint2int<uintknd,ssizeknd> = g0uint2int_uint_ssize
//
implement
g0uint2int<sizeknd,intknd> = g0uint2int_size_int
implement
g0uint2int<sizeknd,lintknd> = g0uint2int_size_lint
implement
g0uint2int<sizeknd,llintknd> = g0uint2int_size_llint
implement
g0uint2int<sizeknd,ssizeknd> = g0uint2int_size_ssize
//
(* ****** ****** *)
//
// HX: uint -> uint
//
implement
g0uint2uint<uintknd,uintknd> = g0uint2uint_uint_uint
implement
g0uint2uint<uintknd,ulintknd> = g0uint2uint_uint_ulint
implement
g0uint2uint<uintknd,ullintknd> = g0uint2uint_uint_ullint
implement
g0uint2uint<uintknd,sizeknd> = g0uint2uint_uint_size

(* ****** ****** *)

implement
g0uint2uint<sizeknd,ulintknd> = g0uint2uint_size_ulint
implement
g0uint2uint<sizeknd,ullintknd> = g0uint2uint_size_ullint
implement
g0uint2uint<sizeknd,sizeknd> = g0uint2uint_size_size

(* ****** ****** *)

implement g0uint_succ<uintknd> = g0uint_succ_uint
implement g0uint_pred<uintknd> = g0uint_pred_uint
implement g0uint_half<uintknd> = g0uint_half_uint
implement g0uint_add<uintknd> = g0uint_add_uint
implement g0uint_sub<uintknd> = g0uint_sub_uint
implement g0uint_mul<uintknd> = g0uint_mul_uint
implement g0uint_div<uintknd> = g0uint_div_uint
implement g0uint_mod<uintknd> = g0uint_mod_uint
implement g0uint_lsl<uintknd> = g0uint_lsl_uint
implement g0uint_lsr<uintknd> = g0uint_lsr_uint
implement g0uint_lnot<uintknd> = g0uint_lnot_uint
implement g0uint_lor<uintknd> = g0uint_lor_uint
implement g0uint_lxor<uintknd> = g0uint_lxor_uint
implement g0uint_land<uintknd> = g0uint_land_uint
implement g0uint_isgtz<uintknd> = g0uint_isgtz_uint
implement g0uint_iseqz<uintknd> = g0uint_iseqz_uint
implement g0uint_isneqz<uintknd> = g0uint_isneqz_uint
implement g0uint_lt<uintknd> = g0uint_lt_uint
implement g0uint_lte<uintknd> = g0uint_lte_uint
implement g0uint_gt<uintknd> = g0uint_gt_uint
implement g0uint_gte<uintknd> = g0uint_gte_uint
implement g0uint_eq<uintknd> = g0uint_eq_uint
implement g0uint_neq<uintknd> = g0uint_neq_uint
implement g0uint_compare<uintknd> = g0uint_compare_uint
implement g0uint_max<uintknd> = g0uint_max_uint
implement g0uint_min<uintknd> = g0uint_min_uint
//
implement fprint_val<uint> (out, x) = fprint_uint (out, x)
//
implement g0uint_succ<ulintknd> = g0uint_succ_ulint
implement g0uint_pred<ulintknd> = g0uint_pred_ulint
implement g0uint_half<ulintknd> = g0uint_half_ulint
implement g0uint_add<ulintknd> = g0uint_add_ulint
implement g0uint_sub<ulintknd> = g0uint_sub_ulint
implement g0uint_mul<ulintknd> = g0uint_mul_ulint
implement g0uint_div<ulintknd> = g0uint_div_ulint
implement g0uint_mod<ulintknd> = g0uint_mod_ulint
implement g0uint_lsl<ulintknd> = g0uint_lsl_ulint
implement g0uint_lsr<ulintknd> = g0uint_lsr_ulint
implement g0uint_lnot<ulintknd> = g0uint_lnot_ulint
implement g0uint_lor<ulintknd> = g0uint_lor_ulint
implement g0uint_lxor<ulintknd> = g0uint_lxor_ulint
implement g0uint_land<ulintknd> = g0uint_land_ulint
implement g0uint_isgtz<ulintknd> = g0uint_isgtz_ulint
implement g0uint_iseqz<ulintknd> = g0uint_iseqz_ulint
implement g0uint_isneqz<ulintknd> = g0uint_isneqz_ulint
implement g0uint_lt<ulintknd> = g0uint_lt_ulint
implement g0uint_lte<ulintknd> = g0uint_lte_ulint
implement g0uint_gt<ulintknd> = g0uint_gt_ulint
implement g0uint_gte<ulintknd> = g0uint_gte_ulint
implement g0uint_eq<ulintknd> = g0uint_eq_ulint
implement g0uint_neq<ulintknd> = g0uint_neq_ulint
implement g0uint_compare<ulintknd> = g0uint_compare_ulint
implement g0uint_max<ulintknd> = g0uint_max_ulint
implement g0uint_min<ulintknd> = g0uint_min_ulint
//
implement fprint_val<ulint> (out, x) = fprint_ulint (out, x)
//
implement g0uint_succ<ullintknd> = g0uint_succ_ullint
implement g0uint_pred<ullintknd> = g0uint_pred_ullint
implement g0uint_half<ullintknd> = g0uint_half_ullint
implement g0uint_add<ullintknd> = g0uint_add_ullint
implement g0uint_sub<ullintknd> = g0uint_sub_ullint
implement g0uint_mul<ullintknd> = g0uint_mul_ullint
implement g0uint_div<ullintknd> = g0uint_div_ullint
implement g0uint_mod<ullintknd> = g0uint_mod_ullint
implement g0uint_lsl<ullintknd> = g0uint_lsl_ullint
implement g0uint_lsr<ullintknd> = g0uint_lsr_ullint
implement g0uint_lnot<ullintknd> = g0uint_lnot_ullint
implement g0uint_lor<ullintknd> = g0uint_lor_ullint
implement g0uint_lxor<ullintknd> = g0uint_lxor_ullint
implement g0uint_land<ullintknd> = g0uint_land_ullint
implement g0uint_isgtz<ullintknd> = g0uint_isgtz_ullint
implement g0uint_iseqz<ullintknd> = g0uint_iseqz_ullint
implement g0uint_isneqz<ullintknd> = g0uint_isneqz_ullint
implement g0uint_lt<ullintknd> = g0uint_lt_ullint
implement g0uint_lte<ullintknd> = g0uint_lte_ullint
implement g0uint_gt<ullintknd> = g0uint_gt_ullint
implement g0uint_gte<ullintknd> = g0uint_gte_ullint
implement g0uint_eq<ullintknd> = g0uint_eq_ullint
implement g0uint_neq<ullintknd> = g0uint_neq_ullint
implement g0uint_compare<ullintknd> = g0uint_compare_ullint
implement g0uint_max<ullintknd> = g0uint_max_ullint
implement g0uint_min<ullintknd> = g0uint_min_ullint
//
implement fprint_val<ullint> (out, x) = fprint_ullint (out, x)
//
implement g0uint_succ<sizeknd> = g0uint_succ_size
implement g0uint_pred<sizeknd> = g0uint_pred_size
implement g0uint_half<sizeknd> = g0uint_half_size
implement g0uint_add<sizeknd> = g0uint_add_size
implement g0uint_sub<sizeknd> = g0uint_sub_size
implement g0uint_mul<sizeknd> = g0uint_mul_size
implement g0uint_div<sizeknd> = g0uint_div_size
implement g0uint_mod<sizeknd> = g0uint_mod_size
implement g0uint_lsl<sizeknd> = g0uint_lsl_size
implement g0uint_lsr<sizeknd> = g0uint_lsr_size
implement g0uint_lnot<sizeknd> = g0uint_lnot_size
implement g0uint_lor<sizeknd> = g0uint_lor_size
implement g0uint_lxor<sizeknd> = g0uint_lxor_size
implement g0uint_land<sizeknd> = g0uint_land_size
implement g0uint_isgtz<sizeknd> = g0uint_isgtz_size
implement g0uint_iseqz<sizeknd> = g0uint_iseqz_size
implement g0uint_isneqz<sizeknd> = g0uint_isneqz_size
implement g0uint_lt<sizeknd> = g0uint_lt_size
implement g0uint_lte<sizeknd> = g0uint_lte_size
implement g0uint_gt<sizeknd> = g0uint_gt_size
implement g0uint_gte<sizeknd> = g0uint_gte_size
implement g0uint_eq<sizeknd> = g0uint_eq_size
implement g0uint_neq<sizeknd> = g0uint_neq_size
implement g0uint_compare<sizeknd> = g0uint_compare_size
implement g0uint_max<sizeknd> = g0uint_max_size
implement g0uint_min<sizeknd> = g0uint_min_size
//
implement fprint_val<size_t> (out, x) = fprint_size (out, x)
//
(* ****** ****** *)
//
// HX: int -> uint
//
implement
g1int2uint<intknd,uintknd> = g1int2uint_int_uint
implement
g1int2uint<intknd,ulintknd> = g1int2uint_int_ulint
implement
g1int2uint<intknd,ullintknd> = g1int2uint_int_ullint
implement
g1int2uint<intknd,sizeknd> = g1int2uint_int_size
//
implement
g1int2uint<ssizeknd,sizeknd> = g1int2uint_ssize_size

(* ****** ****** *)
//
// HX: uint -> int
//
implement
g1uint2int<uintknd,intknd> = g1uint2int_uint_int
implement
g1uint2int<uintknd,lintknd> = g1uint2int_uint_lint
implement
g1uint2int<uintknd,llintknd> = g1uint2int_uint_llint
implement
g1uint2int<uintknd,ssizeknd> = g1uint2int_uint_ssize
//
implement
g1uint2int<sizeknd,intknd> = g1uint2int_size_int
implement
g1uint2int<sizeknd,lintknd> = g1uint2int_size_lint
implement
g1uint2int<sizeknd,llintknd> = g1uint2int_size_llint
implement
g1uint2int<sizeknd,ssizeknd> = g1uint2int_size_ssize

(* ****** ****** *)
//
// HX: uint -> uint
//
implement
g1uint2uint<uintknd,uintknd> = g1uint2uint_uint_uint
implement
g1uint2uint<uintknd,ulintknd> = g1uint2uint_uint_ulint
implement
g1uint2uint<uintknd,ullintknd> = g1uint2uint_uint_ullint
implement
g1uint2uint<uintknd,sizeknd> = g1uint2uint_uint_size
//
implement
g1uint2uint<sizeknd,uintknd> = g1uint2uint_size_uint
implement
g1uint2uint<sizeknd,ulintknd> = g1uint2uint_size_ulint
implement
g1uint2uint<sizeknd,ullintknd> = g1uint2uint_size_ullint
implement
g1uint2uint<sizeknd,sizeknd> = g1uint2uint_size_size

(* ****** ****** *)

implement g1uint_succ<uintknd> = g1uint_succ_uint
implement g1uint_pred<uintknd> = g1uint_pred_uint
implement g1uint_half<uintknd> = g1uint_half_uint
implement g1uint_add<uintknd> = g1uint_add_uint
implement g1uint_sub<uintknd> = g1uint_sub_uint
implement g1uint_mul<uintknd> = g1uint_mul_uint
implement g1uint_div<uintknd> = g1uint_div_uint
implement g1uint_mod<uintknd> = g1uint_mod_uint
implement g1uint_isgtz<uintknd> = g1uint_isgtz_uint
implement g1uint_iseqz<uintknd> = g1uint_iseqz_uint
implement g1uint_isneqz<uintknd> = g1uint_isneqz_uint
implement g1uint_lt<uintknd> = g1uint_lt_uint
implement g1uint_lte<uintknd> = g1uint_lte_uint
implement g1uint_gt<uintknd> = g1uint_gt_uint
implement g1uint_gte<uintknd> = g1uint_gte_uint
implement g1uint_eq<uintknd> = g1uint_eq_uint
implement g1uint_neq<uintknd> = g1uint_neq_uint
implement g1uint_compare<uintknd> = g1uint_compare_uint
implement g1uint_max<uintknd> = g1uint_max_uint
implement g1uint_min<uintknd> = g1uint_min_uint
//
implement g1uint_succ<ulintknd> = g1uint_succ_ulint
implement g1uint_pred<ulintknd> = g1uint_pred_ulint
implement g1uint_half<ulintknd> = g1uint_half_ulint
implement g1uint_add<ulintknd> = g1uint_add_ulint
implement g1uint_sub<ulintknd> = g1uint_sub_ulint
implement g1uint_mul<ulintknd> = g1uint_mul_ulint
implement g1uint_div<ulintknd> = g1uint_div_ulint
implement g1uint_mod<ulintknd> = g1uint_mod_ulint
implement g1uint_isgtz<ulintknd> = g1uint_isgtz_ulint
implement g1uint_iseqz<ulintknd> = g1uint_iseqz_ulint
implement g1uint_isneqz<ulintknd> = g1uint_isneqz_ulint
implement g1uint_lt<ulintknd> = g1uint_lt_ulint
implement g1uint_lte<ulintknd> = g1uint_lte_ulint
implement g1uint_gt<ulintknd> = g1uint_gt_ulint
implement g1uint_gte<ulintknd> = g1uint_gte_ulint
implement g1uint_eq<ulintknd> = g1uint_eq_ulint
implement g1uint_neq<ulintknd> = g1uint_neq_ulint
implement g1uint_compare<ulintknd> = g1uint_compare_ulint
implement g1uint_max<ulintknd> = g1uint_max_ulint
implement g1uint_min<ulintknd> = g1uint_min_ulint
//
implement g1uint_succ<ullintknd> = g1uint_succ_ullint
implement g1uint_pred<ullintknd> = g1uint_pred_ullint
implement g1uint_half<ullintknd> = g1uint_half_ullint
implement g1uint_add<ullintknd> = g1uint_add_ullint
implement g1uint_sub<ullintknd> = g1uint_sub_ullint
implement g1uint_mul<ullintknd> = g1uint_mul_ullint
implement g1uint_div<ullintknd> = g1uint_div_ullint
implement g1uint_mod<ullintknd> = g1uint_mod_ullint
implement g1uint_isgtz<ullintknd> = g1uint_isgtz_ullint
implement g1uint_iseqz<ullintknd> = g1uint_iseqz_ullint
implement g1uint_isneqz<ullintknd> = g1uint_isneqz_ullint
implement g1uint_lt<ullintknd> = g1uint_lt_ullint
implement g1uint_lte<ullintknd> = g1uint_lte_ullint
implement g1uint_gt<ullintknd> = g1uint_gt_ullint
implement g1uint_gte<ullintknd> = g1uint_gte_ullint
implement g1uint_eq<ullintknd> = g1uint_eq_ullint
implement g1uint_neq<ullintknd> = g1uint_neq_ullint
implement g1uint_compare<ullintknd> = g1uint_compare_ullint
implement g1uint_max<ullintknd> = g1uint_max_ullint
implement g1uint_min<ullintknd> = g1uint_min_ullint
//
implement g1uint_succ<sizeknd> = g1uint_succ_size
implement g1uint_pred<sizeknd> = g1uint_pred_size
implement g1uint_half<sizeknd> = g1uint_half_size
implement g1uint_add<sizeknd> = g1uint_add_size
implement g1uint_sub<sizeknd> = g1uint_sub_size
implement g1uint_mul<sizeknd> = g1uint_mul_size
implement g1uint_div<sizeknd> = g1uint_div_size
implement g1uint_mod<sizeknd> = g1uint_mod_size
implement g1uint_isgtz<sizeknd> = g1uint_isgtz_size
implement g1uint_iseqz<sizeknd> = g1uint_iseqz_size
implement g1uint_isneqz<sizeknd> = g1uint_isneqz_size
implement g1uint_lt<sizeknd> = g1uint_lt_size
implement g1uint_lte<sizeknd> = g1uint_lte_size
implement g1uint_gt<sizeknd> = g1uint_gt_size
implement g1uint_gte<sizeknd> = g1uint_gte_size
implement g1uint_eq<sizeknd> = g1uint_eq_size
implement g1uint_neq<sizeknd> = g1uint_neq_size
implement g1uint_compare<sizeknd> = g1uint_compare_size
implement g1uint_max<sizeknd> = g1uint_max_size
implement g1uint_min<sizeknd> = g1uint_min_size
//
(* ****** ****** *)

implement
{tk}(*tmp*)
g1uint_div2 {i,j} (x, y) = let
//
  prval () = lemma_g1uint_param (x)
//
  val [q:int] q = g1uint_div (x, y)
  prval [q2:int,r:int] pf = divmod_istot{i,j}()
  prval EQINT() = $UN.castview0{EQINT(q,q2)}(0)
in
  (pf | q)
end // end of [let] // end of [g1uint_div2]

(* ****** ****** *)

implement
{tk}(*tmp*)
g1uint_mod2 {i,j} (x, y) = let
//
  prval () = lemma_g1uint_param (x)
//
  val [r:int] r = g1uint_mod (x, y)
  prval [q:int,r2:int] pf = divmod_istot{i,j}()
  prval EQINT() = $UN.castview0{EQINT(r,r2)}(0)
in
  (pf | r)
end // end of [let] // end of [g1uint_mod2]

(* ****** ****** *)
//
implement g0int2string<intknd> = g0int2string_int
implement g0int2string<lintknd> = g0int2string_lint
implement g0int2string<llintknd> = g0int2string_llint
(*
implement g0int2string<ssizeknd> = g0int2string_ssize
*)
//
(* ****** ****** *)
//
implement g0string2int<intknd> = g0string2int_int
implement g0string2int<lintknd> = g0string2int_lint
implement g0string2int<llintknd> = g0string2int_llint
implement g0string2int<ssizeknd> = g0string2int_ssize
//
implement g0string2uint<uintknd> = g0string2uint_uint
implement g0string2uint<ulintknd> = g0string2uint_ulint
implement g0string2uint<ullintknd> = g0string2uint_ullint
implement g0string2uint<sizeknd> = g0string2uint_size
//
(* ****** ****** *)

implement{tk}
g1string2int (str) = g1ofg0_int (g0string2int<tk> (str))
implement{tk}
g1string2uint (str) = g1ofg0_uint (g0string2uint<tk> (str))

(* ****** ****** *)

implement{tk}
lt_g0int_int (x, y) = g0int_lt<tk> (x, g0int2int (y))
implement{tk}
lte_g0int_int (x, y) = g0int_lte<tk> (x, g0int2int (y))
implement{tk}
gt_g0int_int (x, y) = g0int_gt<tk> (x, g0int2int (y))
implement{tk}
gte_g0int_int (x, y) = g0int_gte<tk> (x, g0int2int (y))
implement{tk}
eq_g0int_int (x, y) = g0int_eq<tk> (x, g0int2int (y))
implement{tk}
neq_g0int_int (x, y) = g0int_neq<tk> (x, g0int2int (y))

implement{tk}
compare_g0int_int (x, y) = g0int_compare<tk> (x, g0int2int (y))

(* ****** ****** *)

implement{tk}
lt_g1int_int (x, y) = g1int_lt<tk> (x, g1int2int (y))
implement{tk}
lte_g1int_int (x, y) = g1int_lte<tk> (x, g1int2int (y))
implement{tk}
gt_g1int_int (x, y) = g1int_gt<tk> (x, g1int2int (y))
implement{tk}
gte_g1int_int (x, y) = g1int_gte<tk> (x, g1int2int (y))
implement{tk}
eq_g1int_int (x, y) = g1int_eq<tk> (x, g1int2int (y))
implement{tk}
neq_g1int_int (x, y) = g1int_neq<tk> (x, g1int2int (y))

implement{tk}
compare_g1int_int (x, y) = g1int_compare<tk> (x, g1int2int (y))

(* ****** ****** *)

implement{tk}
lt_g0uint_int (x, y) = g0uint_lt<tk> (x, g0int2uint (y))
implement{tk}
lte_g0uint_int (x, y) = g0uint_lte<tk> (x, g0int2uint (y))
implement{tk}
gt_g0uint_int (x, y) = g0uint_gt<tk> (x, g0int2uint (y))
implement{tk}
gte_g0uint_int (x, y) = g0uint_gte<tk> (x, g0int2uint (y))
implement{tk}
eq_g0uint_int (x, y) = g0uint_eq<tk> (x, g0int2uint (y))
implement{tk}
neq_g0uint_int (x, y) = g0uint_neq<tk> (x, g0int2uint (y))

(* ****** ****** *)

implement{tk}
lt_g1uint_int (x, y) = g1uint_lt<tk> (x, g1int2uint (y))
implement{tk}
lte_g1uint_int (x, y) = g1uint_lte<tk> (x, g1int2uint (y))
implement{tk}
gt_g1uint_int (x, y) = g1uint_gt<tk> (x, g1int2uint (y))
implement{tk}
gte_g1uint_int (x, y) = g1uint_gte<tk> (x, g1int2uint (y))
implement{tk}
eq_g1uint_int (x, y) = g1uint_eq<tk> (x, g1int2uint (y))
implement{tk}
neq_g1uint_int (x, y) = g1uint_neq<tk> (x, g1int2uint (y))

(* ****** ****** *)

(* end of [integer.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/filebas_prf.atxt
** Time of generation: Sat Oct 17 15:19:54 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: Feburary, 2012 *)

(* ****** ****** *)
//
stadef r() = file_mode_r()
stadef w() = file_mode_w()
stadef rw() = file_mode_rw()
//
primplmnt file_mode_lte_r_r = file_mode_lte_refl{r()}()
primplmnt file_mode_lte_w_w = file_mode_lte_refl{w()}()
primplmnt file_mode_lte_rw_rw = file_mode_lte_refl{rw()}()
//
(* ****** ****** *)

(* end of [filebas_prf.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/option_vt.atxt
** Time of generation: Sat Oct 17 15:19:56 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: Feburary, 2012 *)

(* ****** ****** *)

implement{a} option_vt_some (x) = Some_vt (x)
implement{a} option_vt_none ( ) = None_vt ( )

(* ****** ****** *)

implement
{a}(*tmp*)
option_vt_make_opt
  (b, x) = (
  if b then let
    prval () = opt_unsome{a}(x) in Some_vt{a}(x)
  end else let
    prval () = opt_unnone{a}(x) in None_vt{a}( )
  end // end of [if]
) (* end of [option_vt_make_opt] *)

(* ****** ****** *)

implement
{}(*tmp*)
option_vt_is_some
  (opt) = case+ opt of
  | Some_vt _ => true | None_vt _ => false
// end of [option_is_some]

implement{}
option_vt_is_none
  (opt) = case+ opt of
  | Some_vt _ => false | None_vt _ => true
// end of [option_is_none]

(* ****** ****** *)

implement
{a}(*tmp*)
option_vt_unsome
  (opt) = x where { val+ ~Some_vt (x) = opt }
// end of [option_unsome]

implement
{a}(*tmp*)
option_vt_unnone
  (opt) = () where { val+ ~None_vt () = opt }
// end of [option_unnone]

(* ****** ****** *)

implement
{a}(*tmp*)
option_vt_free (opt) =
(
case+ opt of ~Some_vt _ => () | ~None_vt () => ()
) // end of [option_vt_free]

(* ****** ****** *)

implement
{a}(*tmp*)
fprint_option_vt
  (out, opt) = let
in
//
case+ opt of
| @Some_vt (x) => {
    val (
    ) = fprint_string (out, "Some_vt(")
    val () = fprint_ref<a> (out, x)
    val () = fprint_string (out, ")")
    prval () = fold@ (opt)
  } (* end of [Some_vt] *)
| None_vt () => {
    val () = fprint_string (out, "None_vt()")
  } (* end of [None_vt] *)
//
end // end of [fprint_option_vt]

(* ****** ****** *)

(* end of [option_vt.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/tuple.atxt
** Time of generation: Sat Oct 17 15:19:53 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: December, 2012 *)

(* ****** ****** *)

implement
fprint_tup$beg<> (out) = fprint_string (out, "(")
implement
fprint_tup$end<> (out) = fprint_string (out, ")")
implement
fprint_tup$sep<> (out) = fprint_string (out, ", ")

(* ****** ****** *)

implement
{a0,a1}
fprint_tupval2
  (out, x) = let
  val () = fprint_tup$beg<> (out)
  val () = fprint_val<a0> (out, x.0)
  val () = fprint_tup$sep<> (out)
  val () = fprint_val<a1> (out, x.1)
  val () = fprint_tup$end<> (out)
in
  // nothing
end // end of [fprint_tupval2]

implement
(a0,a1)
fprint_val<tup(a0,a1)> (out, x) = fprint_tupval2<a0,a1> (out, x)

(* ****** ****** *)

implement
{a0,a1,a2}
fprint_tupval3
  (out, x) = let
  val () = fprint_tup$beg<> (out)
  val () = fprint_val<a0> (out, x.0)
  val () = fprint_tup$sep<> (out)
  val () = fprint_val<a1> (out, x.1)
  val () = fprint_tup$sep<> (out)
  val () = fprint_val<a2> (out, x.2)
  val () = fprint_tup$end<> (out)
in
  // nothing
end // end of [fprint_tupval3]

implement
(a0,a1,a2)
fprint_val<tup(a0,a1,a2)> (out, x) = fprint_tupval3<a0,a1,a2> (out, x)

(* ****** ****** *)

implement
{a0,a1,a2,a3}
fprint_tupval4
  (out, x) = let
  val () = fprint_tup$beg<> (out)
  val () = fprint_val<a0> (out, x.0)
  val () = fprint_tup$sep<> (out)
  val () = fprint_val<a1> (out, x.1)
  val () = fprint_tup$sep<> (out)
  val () = fprint_val<a2> (out, x.2)
  val () = fprint_tup$sep<> (out)
  val () = fprint_val<a3> (out, x.3)
  val () = fprint_tup$end<> (out)
in
  // nothing
end // end of [fprint_tupval4]

implement
(a0,a1,a2,a3)
fprint_val<tup(a0,a1,a2,a3)> (out, x) = fprint_tupval4<a0,a1,a2,a3> (out, x)

(* ****** ****** *)

implement
{a0,a1}
fprint_tupref2
  (out, x) = let
  val () = fprint_tup$beg<> (out)
  val () = fprint_ref<a0> (out, x.0)
  val () = fprint_tup$sep<> (out)
  val () = fprint_ref<a1> (out, x.1)
  val () = fprint_tup$end<> (out)
in
  // nothing
end // end of [fprint_tupref2]

implement
(a0,a1)
fprint_ref<tup(a0,a1)> (out, x) = fprint_tupref2<a0,a1> (out, x)

(* ****** ****** *)

implement
{a0,a1,a2}
fprint_tupref3
  (out, x) = let
  val () = fprint_tup$beg<> (out)
  val () = fprint_ref<a0> (out, x.0)
  val () = fprint_tup$sep<> (out)
  val () = fprint_ref<a1> (out, x.1)
  val () = fprint_tup$sep<> (out)
  val () = fprint_ref<a2> (out, x.2)
  val () = fprint_tup$end<> (out)
in
  // nothing
end // end of [fprint_tupref3]

implement
(a0,a1,a2)
fprint_ref<tup(a0,a1,a2)> (out, x) = fprint_tupref3<a0,a1,a2> (out, x)

(* ****** ****** *)

implement
{a0,a1,a2,a3}
fprint_tupref4
  (out, x) = let
  val () = fprint_tup$beg<> (out)
  val () = fprint_ref<a0> (out, x.0)
  val () = fprint_tup$sep<> (out)
  val () = fprint_ref<a1> (out, x.1)
  val () = fprint_tup$sep<> (out)
  val () = fprint_ref<a2> (out, x.2)
  val () = fprint_tup$sep<> (out)
  val () = fprint_ref<a3> (out, x.3)
  val () = fprint_tup$end<> (out)
in
  // nothing
end // end of [fprint_tupref4]

implement
(a0,a1,a2,a3)
fprint_ref<tup(a0,a1,a2,a3)> (out, x) = fprint_tupref4<a0,a1,a2,a3> (out, x)

(* ****** ****** *)

implement
{a0,a1}
tupval2_compare (x, y) = let
  val sgn0 = gcompare_val_val<a0> (x.0, y.0)
in
  if sgn0 != 0 then sgn0 else gcompare_val_val<a1> (x.1, y.1)
end // end of [tupval2_compare]  

implement
(a0,a1)
gcompare_val_val<tup(a0,a1)> (x, y) = tupval2_compare<a0,a1> (x, y)

(* ****** ****** *)

implement
{a0,a1,a2}
tupval3_compare (x, y) = let
//
val sgn0 = gcompare_val_val<a0> (x.0, y.0)
//
in
//
if
sgn0 != 0
then sgn0
else let
  val sgn1 = gcompare_val_val<a1> (x.1, y.1)
in
  if sgn1 != 0 then sgn1 else gcompare_val_val<a2> (x.2, y.2)
end // end of [if]
//
end // end of [tupval3_compare]

implement
(a0,a1,a2)
gcompare_val_val<tup(a0,a1,a2)> (x, y) = tupval3_compare<a0,a1,a2> (x, y)

(* ****** ****** *)

implement
{a0,a1,a2,a3}
tupval4_compare (x, y) = let
//
val sgn0 = gcompare_val_val<a0> (x.0, y.0)
//
in
//
if
sgn0 != 0
then sgn0
else let
  val sgn1 = gcompare_val_val<a1> (x.1, y.1)
in
//
if sgn1 != 0 then sgn1
else let
  val sgn2 = gcompare_val_val<a2> (x.2, y.2)
in
  if sgn2 != 0 then sgn2 else gcompare_val_val<a3> (x.3, y.3)
end // end of [if]
//
end // end of [if]
//
end // end of [tupval4_compare]  

implement
(a0,a1,a2,a3)
gcompare_val_val<tup(a0,a1,a2,a3)> (x, y) = tupval4_compare<a0,a1,a2,a3> (x, y)

(* ****** ****** *)

(* end of [tuple.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/filebas.atxt
** Time of generation: Sat Oct 17 15:19:54 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: Feburary, 2012 *)

(* ****** ****** *)

#define ATS_DYNLOADFLAG 0 // no dynloading at run-time

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload _(*anon*) = "prelude/DATS/integer.dats"

(* ****** ****** *)

staload STDIO = "libc/SATS/stdio.sats"
vtypedef FILEptr1 = $STDIO.FILEptr1 (*linear/nonnull*)

(* ****** ****** *)

staload STAT = "libc/sys/SATS/stat.sats"

(* ****** ****** *)

#define c2i char2int0
#define i2c int2char0

(* ****** ****** *)
//
// HX-2013-06:
// this is just Unix convention
//
implement{} dirsep_get () = '/'
implement{} dirname_self () = "."
implement{} dirname_parent () = ".."
//
(* ****** ****** *)

implement
{}(*tmp*)
filename_get_ext (name) = let
//
#define NUL '\000'
overload + with add_ptr_bsz
//
fun loop
(
  p1: ptr, p2: ptr, c0: char
) : ptr = let
  val c = $UN.ptr0_get<char> (p1)
in
  if c != NUL then let
    val p1 = p1 + i2sz(1)
  in
    if c != c0 then loop (p1, p2, c0) else loop (p1, p1, c0)
  end else p2 // end of [if]
end // end of [loop]
//
val p1 = string2ptr(name)
val p2 = $effmask_all (loop (p1, the_null_ptr, '.'))
//
in
  $UN.castvwtp0{vStrptr0}(p2)
end // end of [filename_get_ext]

(* ****** ****** *)

implement
{}(*tmp*)
filename_test_ext
  (name, ext0) = let
//
val (fpf | ext) = filename_get_ext (name)
//
val ans =
(
  if strptr2ptr(ext) > 0
    then eq_string_string (ext0, $UN.strptr2string(ext))
    else false
  // end of [if]
) : bool // end of [val]
//
prval () = fpf (ext)
//
in
  ans
end // end of [filename_test_ext]

(* ****** ****** *)

implement
{}(*tmp*)
filename_get_base (name) = let
//
#define NUL '\000'
overload + with add_ptr_bsz
//
fun loop
(
  p1: ptr, p2: ptr, c0: char
) : ptr = let
  val c = $UN.ptr0_get<char> (p1)
in
  if c != NUL then let
    val p1 = p1 + i2sz(1)
  in
    if c != c0 then loop (p1, p2, c0) else loop (p1, p1, c0)
  end else p2 // end of [if]
end // end of [loop]
//
val c0 = dirsep_get<> ()
val p1 = string2ptr(name)
val p2 = $effmask_all (loop (p1, p1, c0))
//
in
  $UN.castvwtp0{vStrptr1}(p2)
end // end of [filename_get_base]

(* ****** ****** *)

implement
{}(*tmp*)
filename_test_base
  (name, base0) = let
//
val (fpf | base) = filename_get_base (name)
//
val ans = eq_string_string (base0, $UN.strptr2string(base))
//
prval () = fpf (base)
//
in
  ans
end // end of [filename_test_base]

(* ****** ****** *)

(*
//
// HX-2013-04:
// this is now implemented in [filebas.cats].
//
local

extern
castfn file_mode
  {fm:file_mode} (x: string):<> file_mode (fm)
// end of [extern]

in (* in of [local] *)

implement file_mode_r = file_mode ("r")
implement file_mode_rr = file_mode ("r+")
implement file_mode_w = file_mode ("w")
implement file_mode_ww = file_mode ("w+")
implement file_mode_a = file_mode ("a")
implement file_mode_aa = file_mode ("a+")

end // end of [local]
*)

(* ****** ****** *)

extern
castfn
__cast_filp (r: FILEref): FILEptr1

(* ****** ****** *)

implement
{}(*tmp*)
test_file_mode
  (path) = let
//
typedef stat = $STAT.stat
//
var st: stat?
val err = $STAT.stat (path, st)
//
in
//
if err >= 0
then let
  prval () = opt_unsome{stat}(st)
  val test =
  test_file_mode$pred<> ($UN.cast{uint}(st.st_mode))
in
  if test then 1(*true*) else 0(*false*)
end // end of [then]
else let
  prval () = opt_unnone{stat}(st) in ~1(*failure*)
end // end of [else]
//
end // end of [test_file_mode]

(* ****** ****** *)

implement
{}(*tmp*)
fileref_open_opt
  (path, fm) = let
//
val
filp = $STDIO.fopen (path, fm)
val
isnot = $STDIO.FILEptr2ptr(filp) > 0
//
in
//
if
isnot
then let
//
val filr =
  $STDIO.FILEptr_refize(filp)
//
in
  Some_vt{FILEref}(filr) // success
end // end of [then]
else let
//
prval () =
  $STDIO.FILEptr_free_null(filp)
//
in
  None_vt{FILEref}((*void*)) // failure
end // end of [else]
//
end // end of [fileref_open_opt]

(* ****** ****** *)

(*
//
// HX: atspre_fileref_close
//
implement
fileref_close (fil) = $STDIO.fclose0_exn (fil)
*)

(* ****** ****** *)

(*
//
// HX: atspre_fileref_flush
//
implement
fileref_flush (fil) = $STDIO.fflush0_exn (fil)
*)

(* ****** ****** *)

(*
//
// HX: atspre_fileref_getc
//
implement fileref_getc (inp) = $STDIO.fgetc0 (inp)
*)

(* ****** ****** *)

(*
//
// HX: atspre_fileref_putc_int
// HX: atspre_fileref_putc_char
//
implement
fileref_putc_int (out, c) = let
  val _(*ignored*) = $STDIO.fputc0 (c, out) in (*nothing*)
end // end of [fileref_putc_int]
implement
fileref_putc_char (out, c) = fileref_putc_int (out, (c2i)c)
*)

(* ****** ****** *)

(*
//
// HX: atspre_fileref_puts
//
implement
fileref_puts (out, s) = let
  val _(*ignored*) = $STDIO.fputs0 (s, out) in (*nothing*)
end // end of [fileref_puts]
*)

(* ****** ****** *)

(*
//
// HX: atspre_fileref_is_eof
//
implement
fileref_is_eof (fil) =
  if $STDIO.feof0 (fil) != 0 true else false
// end of [fileref_is_eof]
*)

(* ****** ****** *)
//
implement fileref_load<int> = fileref_load_int
implement fileref_load<lint> = fileref_load_lint
implement fileref_load<uint> = fileref_load_uint
implement fileref_load<ulint> = fileref_load_ulint
//
implement fileref_load<float> = fileref_load_float
implement fileref_load<double> = fileref_load_double
//
(* ****** ****** *)

implement{a}
fileref_get_optval (r) = let
  var x: a?
  val yn = fileref_load<a> (r, x)
in
  option_vt_make_opt<a> (yn, x)
end // end of [fileref_get_optval]

(* ****** ****** *)

implement{a}
fileref_get_exnmsg
  (r, msg) = let
  var x: a?
  val yn = fileref_load<a> (r, x)
in
  if yn then let
    prval () = opt_unsome (x) in x
  end else let
    prval () = opt_unnone (x) in exit_errmsg (1, msg)
  end (* end of [if] *)
end // end of [fileref_get_exnmsg]

(* ****** ****** *)

implement
fileref_get_line_charlst
  (inp) = let
//
val EOL = '\n'
//
fun loop
(
  inp: FILEref, res: &ptr? >> charlst_vt
) : void = let
  val i = fileref_getc (inp)
in
//
if i >= 0 then let
  val c = int2char0(i)
in
//
if (c != EOL) then let
  val () =
  (
    res :=
    list_vt_cons{char}{0}(c, _)
  )
  val+list_vt_cons (_, res1) = res
  val () = loop (inp, res1)
  prval () = fold@ (res)
in
  // nothing
end else (res := list_vt_nil)
//
end else (res := list_vt_nil)
//
end // end of [loop]
//
var res: ptr
val () = loop (inp, res)
//
in
  res
end // end of [fileref_get_line_charlst]

(* ****** ****** *)

implement
fileref_get_lines_charlstlst
  (inp) = let
//
vtypedef line = charlst_vt
vtypedef lines = List0_vt (line)
//
fun loop
(
  inp: FILEref
, res: &lines? >> lines
) : void = let
  val iseof = fileref_is_eof (inp)
in
//
if iseof then let
  val () = (res := list_vt_nil ())
in
  // nothing
end else let
  val line =
    fileref_get_line_charlst (inp)
  val () =
  (
    res := list_vt_cons{line}{0}(line, _)
  )
  val+list_vt_cons (_, res1) = res
  val () = loop (inp, res1)
  prval () = fold@ (res)
in
  // nothing
end // end of [if]
//
end // end of [loop]
//
var res: lines
val () = loop (inp, res)
//
in
  res
end // end of [fileref_get_lines_charlstlst]

(* ****** ****** *)
//
implement
fileref_get_file_charlst
  (inp) = fileref_get2_file_charlst (inp, ~1)
//
(* ****** ****** *)

local

fun loop
(
  inp: FILEref
, n: int, res: &ptr? >> charlst_vt
) : int = let
in
//
if n != 0 then let
  val i = fileref_getc (inp)
in
  if i >= 0 then let
    val () =
    (
      res :=
      list_vt_cons{char}{0}(i2c(i), _)
    )
    val+list_vt_cons (_, res1) = res
    val n = loop (inp, pred(n), res1)
    prval () = fold@ (res)
  in
    n
  end else let
    val () = res := list_vt_nil () in (n)
  end // end of [if]
end else let
  val () = res := list_vt_nil () in n(*=0*)
end // end of [if]
//
end // end of [loop]

in (* in of [local] *)

implement
fileref_get2_file_charlst
  (inp, n) = res where
{
  var res: ptr; val _(*nleft*) = loop (inp, n, res)
} // end of [fileref_nget_file_charlst]

end // end of [local]

(* ****** ****** *)

implement
fileref_put_charlst
  (out, cs) = let
//
fun loop
(
  out: FILEref, cs: List(char)
) : void = let
in
//
case+ cs of
| list_cons (c, cs) => let
    val () = fileref_putc (out, c) in loop (out, cs)
  end // end of [list_cons]
| list_nil ((*void*)) => ()
//
end // end of [loop]
//
in
  loop (out, cs)
end // end of [fileref_put_charlst]

(* ****** ****** *)
//
implement
{}(*tmp*)
fileref_get_line_string$bufsize () = 64
implement
{}(*tmp*)
fileref_get_file_string$bufsize () = 1024
//
(* ****** ****** *)

implement
{}(*tmp*)
fileref_get_line_string
  (inp) = let
//
var nlen: int // uninitialized
val line = fileref_get_line_string_main (inp, nlen)
prval () = lemma_strnptr_param (line)
//
in
  strnptr2strptr (line)
end // end of [fileref_get_line_string]

(* ****** ****** *)

implement
{}(*tmp*)
fileref_get_line_string_main
  (inp, nlen) = let
//
val bsz =
fileref_get_line_string$bufsize ()
//
val [l:addr,n:int] str = $extfcall
(
Strnptr0, "atspre_fileref_get_line_string_main2", bsz, inp, addr@(nlen)
)
//
prval () = lemma_strnptr_param (str)
//
extern
praxi
__assert {l:addr} (pf: !int? @ l >> int (n) @ l): void
prval () = __assert (view@(nlen)) 
//
val isnot = strnptr_isnot_null (str)
//
in
//
if isnot then str else let
  val (
  ) = exit_errmsg_void (1, "[fileref_get_line_string] failed.")
  val () = assert (nlen >= 0) // HX: for TC // deadcode at run-time
in
  str // HX: [str]=null is not returned
end (* end of [if] *)
//
end // end of [fileref_get_line_string_main]

(* ****** ****** *)

implement
{}(*tmp*)
fileref_get_lines_stringlst
  (inp) = let
//
vtypedef line = Strptr1
vtypedef lines = List0_vt (line)
//
fun loop
(
  inp: FILEref
, res: &lines? >> lines
) : void = let
  val iseof = fileref_is_eof (inp)
in
//
if iseof then let
  val () = (res := list_vt_nil ())
in
  // nothing
end else let
  val line =
    fileref_get_line_string (inp)
  val () =
  (
    res := list_vt_cons{line}{0}(line, _)
  )
  val+list_vt_cons (_, res1) = res
  val () = loop (inp, res1)
  prval () = fold@ (res)
in
  // nothing
end // end of [if]
//
end // end of [loop]
//
var res: lines
val () = loop (inp, res)
//
in
  res
end // end of [fileref_get_lines_stringlst]

(* ****** ****** *)

implement
{}(*tmp*)
fileref_get_file_string (inp) = let
//
#define CNUL '\000'
//
fun loop
(
  inp: FILEref
, p0: ptr, n0: size_t, p1: ptr, n1: size_t
) : Strptr1 = let
//
val nw = $extfcall (size_t, "atslib_fread", p1, 1, n1, inp)
//
in
//
if nw > 0
then let
  val n1 = n1 - nw
  val p1 = add_ptr_bsz (p1, nw)
in
  if n1 > 0 then
    loop (inp, p0, n0, p1, n1) else loop2 (inp, p0, n0)
  // end of [if]
end else let
  val () = $UN.ptr0_set<char> (p1, CNUL) in $UN.castvwtp0{Strptr1}(p0)
end // end of [if]
//
end // end of [loop]
//
and loop2
(
  inp: FILEref, p0: ptr, n0: size_t
) : Strptr1 = let
  val bsz = succ(n0)
  val bsz2 = g1ofg0(bsz + bsz)
  val (pf, pfgc | p0_) = malloc_gc (bsz2)
  val p0_ = $UN.castvwtp0{ptr}((pf, pfgc | p0_))
  val _(*ptr*) = $extfcall (ptr, "atslib_memcpy", p0_, p0, n0)
  val () = strptr_free ($UN.castvwtp0{Strptr1}(p0))
  val n0_ = pred(g0ofg1(bsz2))
  val p1_ = add_ptr_bsz (p0_, n0)
in
  loop (inp, p0_, n0_, p1_, bsz)
end // end of [loop2]
//
val bsz =
  fileref_get_file_string$bufsize ()
val bsz = i2sz(bsz)
val (pf, pfgc | p0_) = malloc_gc (bsz)
val p0_ = $UN.castvwtp0{ptr}((pf, pfgc | p0_))
val n0_ = pred(bsz)
//
in
  loop (inp, p0_, n0_, p0_, n0_)
end // end of [fileref_get_file_string]

(* ****** ****** *)

%{
extern
atstype_ptr
atspre_fileref_get_line_string_main2
(
  atstype_int bsz0
, atstype_ptr filp0
, atstype_ref nlen // int *nlen
)
{
//
  int bsz = bsz0 ;
  FILE *filp = (FILE*)filp0 ;
  int ofs = 0, ofs2 ;
  char *buf, *buf2, *pres ;
  buf = atspre_malloc_gc(bsz) ;
//
  while (1) {
    buf2 = buf+ofs ;
    pres = fgets(buf2, bsz-ofs, filp) ;
    if (!pres)
    {
      if (feof(filp))
      {
        *buf2 = '\000' ;
        *(int*)nlen = ofs ; return buf ;
      } else {
        atspre_mfree_gc(buf) ;
        *(int*)nlen = -1 ; return (char*)0 ;
      } // end of [if]
    }
    ofs2 = strlen(buf2) ;
    if (ofs2==0) return buf ;
    ofs += ofs2 ; // HX: ofs > 0
//
// HX: the newline symbol needs to be trimmed:
//
    if (buf[ofs-1]=='\n')
    {
      buf[ofs-1] = '\0'; *(int*)nlen = ofs-1 ; return buf ;
    }
//
// HX: there is room // so there are no more chars:
//
    if (ofs+1 < bsz) { *(int*)nlen = ofs ; return buf ; }
//
// HX: there is no room // so another call to [fgets] is needed:
//
    bsz *= 2 ;
    buf2 = buf ; buf = atspre_malloc_gc(bsz) ; memcpy(buf, buf2, ofs) ;
    atspre_mfree_gc(buf2) ;
  } // end of [while]
//
  return buf ; // HX: deadcode
//
} // end of [atspre_fileref_get_line_string_main2]
%}

(* ****** ****** *)

implement
{}(*tmp*)
fileref_get_word (inp) = let
//
vtypedef
res = List0_vt(charNZ)
//
fun
loop1 (): res = let
//
val c = $STDIO.fgetc0 (inp)
//
in
//
if
(c > 0)
then let
  val c = $UN.cast{charNZ}(c)
  val test = fileref_get_word$isalpha<> (c)
in
  if test then loop2 (c, list_vt_nil()) else loop1 ()
end // end of [then]
else list_vt_nil ((*void*))
//
end // end of [loop1]

and loop2
(
  c: charNZ, cs: res
) : res = let
//
val c2 = $STDIO.fgetc0 (inp)
//
in
//
if
(c2 > 0)
then let
  val c2 = $UN.cast{charNZ}(c2)
  val test = fileref_get_word$isalpha<> (c2)
in
  if test then loop2 (c2, list_vt_cons(c, cs)) else list_vt_cons(c, cs)
end // end of [then]
else list_vt_cons(c, cs)
//
end // end of [loop2]
//
val cs = loop1 ()
//
in
  case+ cs of
  | list_vt_cons _ => let
      val str =
        string_make_rlist ($UN.list_vt2t(cs))
      val () = list_vt_free (cs)
    in
      strnptr2strptr (str)
    end // end of [list_vt_cons]
  | ~list_vt_nil () => strptr_null ()
end // end of [fileref_get_word]

(* ****** ****** *)

implement
{}(*tmp*)
fileref_get_word$isalpha (charNZ) = isalpha (charNZ)

(* ****** ****** *)

implement
{}(*tmp*)
fileref_foreach
  (inp) = let
  var env: void = ()
in
  fileref_foreach_env (inp, env)
end // end of [fileref_foreach]

(* ****** ****** *)

local
//
staload "libc/SATS/stdio.sats"
//
extern
fun fread
  (ptr, size_t, size_t, FILEref): Size = "mac#atslib_fread"
//
in (* in of [local] *)

implement
{env}(*tmp*)
fileref_foreach_env
   (inp, env) = let
//
fun loop
  {l:addr}{n:int}
(
  pf: !b0ytes(n) @ l
| inp: FILEref, bufp: ptr(l), bsz: size_t(n), env: &env
) : void = let
//
val bsz2 = fread (bufp, i2sz(1), bsz, inp)
prval [n2:int] EQINT() = g1uint_get_index (bsz2)
//
in
//
if bsz2 > 0 then
{
  val A = $UN.cast{arrayref(char,n2)}(bufp)
  val () = fileref_foreach$fworkv<env> (A, bsz2, env)
  val ((*void*)) = loop (pf | inp, bufp, bsz, env)
} (* end of [if] *)
//
end // end of [loop]
//
val bsz = fileref_foreach$bufsize<> ()
val (pf1, pf2 | bufp) = memory$alloc<> (bsz)
val ((*void*)) = loop (pf1 | inp, bufp, bsz, env)
val ((*void*)) = memory$free<> (pf1, pf2 | bufp)
//
in
  // nothing
end // end of [fileref_foreach_env]

end // end of [local]

(* ****** ****** *)

implement
{}(*tmp*)
fileref_foreach$bufsize () = i2sz(4 * 1024)

(* ****** ****** *)

implement
{env}(*tmp*)
fileref_foreach$fworkv
  (A, n, env) = let
//
implement
{a}{env}
array_foreach$cont (x, env) = true
implement
array_foreach$fwork<char><env>
  (x, env) = fileref_foreach$fwork<env> (x, env)
//
in
  ignoret (arrayref_foreach_env<char><env> (A, n, env))
end // end of [fileref_foreach$fworkv]

(* ****** ****** *)

(* end of [filebas.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/list.atxt
** Time of generation: Sat Oct 17 15:19:55 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: Feburary, 2012 *)

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"
staload _(*anon*) = "prelude/DATS/unsafe.dats"

(* ****** ****** *)

abstype List0_(a:t@ype+) = List0(a)

(* ****** ****** *)

implement
{x}(*tmp*)
list_make_sing (x) = list_vt_cons{x}(x, list_vt_nil)
implement
{x}(*tmp*)
list_make_pair (x1, x2) = list_vt_cons{x}(x1, list_vt_cons{x}(x2, list_vt_nil))

(* ****** ****** *)

implement
{x}(*tmp*)
list_make_elt
  {n} (n, x) = let
  fun loop
    {i:nat | i <= n} .<i>.
  (
    i: int i, x: x, res: list_vt (x, n-i)
  ) :<> list_vt (x, n) = (
    if i > 0 then
      loop (pred(i), x, list_vt_cons (x, res)) else res
    // end of [if]
  ) // end of [loop]
in
  loop (n, x, list_vt_nil ())
end // end of [list_make_elt]

(* ****** ****** *)

implement
{}(*tmp*)
list_make_intrange
  {l0,r} (l0, r) = let
//
typedef elt = intBtw (l0, r)
vtypedef res (l:int) = list_vt (elt, r-l)
fun loop {
  l:int | l0 <= l; l <= r
} .<r-l>. (
  l: int l, r: int r, res: &ptr? >> res (l)
) :<!wrt> void =
  if l < r then let
    val () = res :=
      list_vt_cons{elt}{0}(l, _)
    val+list_vt_cons (_, res1) = res
    val () = loop (l+1, r, res1)
  in
    fold@ (res)
  end else (res := list_vt_nil)
// end of [loop]
//
var res: ptr
val () = $effmask_wrt (loop (l0, r, res))
//
in
  res
end // end of [list_make_intrange]

(* ****** ****** *)

implement
{a}(*tmp*)
list_make_array
  {n} (A, n) = let
//
prval () = lemma_array_param (A)
vtypedef res (n:int) = list_vt (a, n)
fun loop
  {l:addr}
  {n:nat} .<n>. (
  pf: !array_v (a, l, n) >> array_v (a?!, l, n)
| p: ptr l
, n: size_t n
, res: &ptr? >> res(n)
) :<!wrt> void =
  if n > 0 then let
    prval (
      pf1, pf2
    ) = array_v_uncons (pf)
    val () = res :=
      list_vt_cons{a}{0}(_, _)
    val+list_vt_cons (x, res1) = res
    val () = x := !p
    val () = loop (pf2 | ptr1_succ<a> (p), pred(n), res1)
    prval () = pf := array_v_cons (pf1, pf2)
    prval () = fold@ (res)
  in
    // nothing
  end else let
    prval () = array_v_unnil (pf)
    prval () = pf := array_v_nil ()
  in
    res := list_vt_nil ()
  end // end of [if]
// end of [loop]
var res: ptr // uninitialized
val () = loop (view@(A) | addr@(A), n, res)
//
in
  res
end // end of [list_make_array]

(* ****** ****** *)

implement
{a}(*tmp*)
list_make_arrpsz
  {n} (A0) = let
//
var asz: size_t
val A = arrpsz_get_ptrsize (A0, asz)
val p = arrayptr2ptr (A)
prval pfarr = arrayptr_takeout (A)
val res = list_make_array (!p, asz)
prval () = arrayptr_addback (pfarr | A)
val () = arrayptr_free (A)
//
in
  res
end // end of [list_make_arrpsz]

(* ****** ****** *)

implement
{a}(*tmp*)
print_list (xs) = fprint_list<a> (stdout_ref, xs)
implement
{a}(*tmp*)
prerr_list (xs) = fprint_list<a> (stderr_ref, xs)

(* ****** ****** *)

implement
{}(*tmp*)
fprint_list$sep
  (out) = fprint_string (out, ", ")
// end of [fprint_list$sep]

implement
{a}(*tmp*)
fprint_list (out, xs) = let
//
implement(env)
list_iforeach$fwork<a><env>
  (i, x, env) = let
  val () =
    if i > 0 then fprint_list$sep<(*none*)> (out)
  // end of [val]
in
  fprint_val<a> (out, x)
end // end of [list_iforeach$fwork]
//
val _(*len*) = list_iforeach<a> (xs)
//
in
  // nothing
end // end of [fprint_list]

implement
{a}(*tmp*)
fprint_list_sep
  (out, xs, sep) = let
//
implement
fprint_list$sep<(*none*)> (out) = fprint_string (out, sep)
//
in
  fprint_list<a> (out, xs)
end // end of [fprint_list_sep]

(* ****** ****** *)
(*
//
// HX-2012-05:
// Compiling this can be a great challenge!
//
*)
implement
{a}(*tmp*)
fprint_listlist_sep
  (out, xss, sep1, sep2) = let
//
implement
fprint_val<List0_(a)>
  (out, xs) = let
  val xs = $UN.cast{List0(a)}(xs)
in
  fprint_list_sep<a> (out, xs, sep2)
end // end of [fprint_val]
//
in
  fprint_list_sep<List0_(a)> (out, $UN.cast{List(List0_(a))}(xss), sep1)
end // end of [fprint_listlist_sep]

(* ****** ****** *)

implement
{}(*tmp*)
list_is_nil (xs) =
  case+ xs of list_nil () => true | _ =>> false
// end of [list_is_nil]

implement
{}(*tmp*)
list_is_cons (xs) =
  case+ xs of list_cons _ => true | _ =>> false
// end of [list_is_cons]

implement
{x}(*tmp*)
list_is_sing (xs) =
  case+ xs of list_sing (x) => true | _ =>> false
// end of [list_is_sing]

implement
{x}(*tmp*)
list_is_pair (xs) =
  case+ xs of list_pair (x1, x2) => true | _ =>> false
// end of [list_is_pair]

(* ****** ****** *)

implement
{x}(*tmp*)
list_head (xs) =
  let val+list_cons (x, _) = xs in x end
// end of [list_head]
implement
{x}(*tmp*)
list_tail (xs) =
  let val+list_cons (_, xs) = xs in xs end
// end of [list_tail]
implement
{x}(*tmp*)
list_last (xs) = let
//
fun loop
  (xs: List1 (x)): x = let
  val+list_cons (x, xs) = xs
in
  case+ xs of
  | list_cons _ => loop (xs) | list_nil _ => x
end // end of [loop]
//
in
  $effmask_all (loop (xs))
end // end of [list_last]

(* ****** ****** *)

implement
{x}(*tmp*)
list_head_exn (xs) =
(
case+ xs of
| list_cons (x, _) => x | _ => $raise ListSubscriptExn()
) (* end of [list_head_exn] *)

implement
{x}(*tmp*)
list_tail_exn (xs) =
(
case+ xs of
| list_cons (_, xs) => xs | _ => $raise ListSubscriptExn()
) (* end of [list_tail_exn] *)

implement
{x}(*tmp*)
list_last_exn (xs) =
(
case+ xs of
| list_cons _ => list_last (xs) | _ => $raise ListSubscriptExn()
) (* end of [list_last_exn] *)

(* ****** ****** *)

implement
{a}(*tmp*)
list_nth (xs, i) = let
//
fun loop
  {n,i:nat | i < n} .<i>. (
  xs: list (a, n), i: int i
) :<> a =
  if i > 0 then let
    val+list_cons (_, xs) = xs in loop (xs, pred(i))
  end else list_head<a> (xs)
//
in
  loop (xs, i)
end // end of [list_nth]

implement
{a}(*tmp*)
list_nth_opt (xs, i) = let
//
fun loop
  {n:nat} .<n>.
(
  xs: list (a, n), i: intGte(0)
) :<> Option_vt (a) =
(
case+ xs of
| list_nil () => None_vt ()
| list_cons (x, xs) =>
    if i = 0 then Some_vt(x) else loop (xs, pred(i))
  // end of [list_vt_cons]
) (* end of [loop] *)
//
prval () = lemma_list_param (xs)
//
in
  loop (xs, i)
end // end of [list_nth_opt]

(* ****** ****** *)

implement
{a}(*tmp*)
list_get_at (xs, i) = list_nth<a> (xs, i)
implement
{a}(*tmp*)
list_get_at_opt (xs, i) = list_nth_opt<a> (xs, i)

(* ****** ****** *)

implement
{a}(*tmp*)
list_set_at
  (xs, i, x_new) = let
  val (xs1, xs2) =
    $effmask_wrt (list_split_at<a> (xs, i))
  val+list_cons (x_old, xs2) = xs2
  val xs2 = list_cons{a}(x_new, xs2)
in
  $effmask_wrt (list_append1_vt<a> (xs1, xs2))
end // ed of [list_set_at]

(* ****** ****** *)

implement
{a}(*tmp*)
list_exch_at
  (xs, i, x_new) = let
  val (xs1, xs2) =
    $effmask_wrt (list_split_at<a> (xs, i))
  val+list_cons (x_old, xs2) = xs2
  val xs2 = list_cons{a}(x_new, xs2)
in
  ($effmask_wrt (list_append1_vt<a> (xs1, xs2)), x_old)
end // ed of [list_exch_at]

(* ****** ****** *)

implement
{a}(*tmp*)
list_insert_at
  (xs, i, x) = let
//
fun loop{n:int}
  {i:nat | i <= n} .<i>.
(
  xs: list (a, n)
, i: int i, x: a
, res: &ptr? >> list (a, n+1)
) :<!wrt> void =
  if i > 0 then let
    val+list_cons (x1, xs1) = xs
    val () = res :=
      list_cons{a}{0}(x1, _(*?*))
    val+list_cons
      (_, res1) = res // res1 = res.1
    val () = loop (xs1, i-1, x, res1)
    prval () = fold@ (res)
  in
    // nothing
  end else res := list_cons (x, xs)
//
var res: ptr
val () = $effmask_wrt (loop (xs, i, x, res))
//
in
  res
end // end of [list_insert_at]

(* ****** ****** *)

implement
{a}(*tmp*)
list_takeout_at
  (xs, i, x0) = let
//
fun loop{n:int}
  {i:nat | i < n} .<i>.
(
  xs: list (a, n)
, i: int i, x0: &a? >> a
, res: &ptr? >> list (a, n-1)
) :<!wrt> void = let
//
val+list_cons (x, xs) = xs
//
in
//
if i > 0 then let
  val () =
    res := list_cons{a}{0}(x, _(*?*))
  val+list_cons
    (_, res1) = res // res1 = res.1
  val () = loop (xs, i-1, x0, res1)
  prval () = fold@ (res)
in
  // nothing
end else let
  val () = x0 := x; val () = res := xs
in
  // nothing
end // end of [if]
//
end // end of [loop]
//
var res: ptr?
val () = loop (xs, i, x0, res)
//
in
  res
end // end of [list_takeout_at]

(* ****** ****** *)

implement
{x}(*tmp*)
list_length (xs) = let
//
prval () = lemma_list_param (xs)
//
fun loop
  {i,j:nat} .<i>. (
  xs: list (x, i), j: int j
) :<> int (i+j) = (
  case+ xs of
  | list_cons (_, xs) => loop (xs, j+1) | _ =>> j
) // end of [loop]
//
in
  loop (xs, 0)
end // end of [list_length]

(* ****** ****** *)

implement
{x}(*tmp*)
list_copy
  (xs) = res where {
//
vtypedef res = List0_vt (x)
prval () = lemma_list_param (xs)
//
fun loop
  {n:nat} .<n>.
(
  xs: list (x, n)
, res: &res? >> list_vt (x, n)
) :<!wrt> void = let
in
//
case+ xs of
| list_cons
    (x, xs) => let
    val () = res :=
      list_vt_cons{x}{0}(x, _(*?*))
    val+list_vt_cons
      (_, res1) = res // res1 = res.1
    val () = loop (xs, res1)
    prval () = fold@ (res)
  in
    // nothing
  end // end of [cons]
| list_nil () => res := list_vt_nil ()
//
end // end of [loop]
//
var res: res? ; val () = loop (xs, res)
//
} // end of [list_copy]

(* ****** ****** *)

implement
{a}(*tmp*)
list_append
  {m,n} (xs, ys) = let
  val ys = __cast (ys) where {
    extern castfn __cast (ys: list (a, n)):<> list_vt (a, n)
  } // end of [where] // end of [val]
in
$effmask_wrt
(
  list_of_list_vt (list_append2_vt (xs, ys))
) // end of [$effmask_wrt]
end // end of [list_append]

implement
{a}(*tmp*)
list_append1_vt
  {m,n} (xs, ys) = let
  val ys = __cast (ys) where {
    extern castfn __cast (ys: list (a, n)):<> list_vt (a, n)
  } // end of [val]
in
  list_of_list_vt (list_vt_append (xs, ys))
end // end of [list_append1_vt]

implement
{a}(*tmp*)
list_append2_vt
  {m,n} (xs, ys) = let
//
prval () = lemma_list_param (xs)
prval () = lemma_list_vt_param (ys)
//
fun loop
  {m:nat} .<m>. (
  xs: list (a, m)
, ys: list_vt (a, n)
, res: &ptr? >> list_vt (a, m+n)
) :<!wrt> void =
  case+ xs of
  | list_cons
      (x, xs) => let
      val () = res :=
        list_vt_cons{a}{0}(x, _(*?*))
      val+list_vt_cons
        (_, res1) = res // res1 = res.1
      val () = loop (xs, ys, res1)
      prval () = fold@ (res)
    in
      // nothing
    end // end of [list_cons]
  | list_nil () => res := ys
// end of [loop]
var res: ptr // uninitialized
val () = loop (xs, ys, res)
//
in
  res
end // end of [list_append2_vt]

(* ****** ****** *)

implement
{a}(*tmp*)
list_extend (xs, y) =
(
  list_append2_vt<a> (xs, list_vt_sing (y))
) // end of [list_extend]

(* ****** ****** *)

implement
{x}(*tmp*)
list_reverse (xs) = (
  list_reverse_append2_vt<x> (xs, list_vt_nil)
) // end of [list_reverse]

(* ****** ****** *)

implement
{a}(*tmp*)
list_reverse_append
  {m,n} (xs, ys) = let
//
val ys = __cast (ys) where
{
  extern castfn __cast (ys: list (a, n)):<> list_vt (a, n)
} // end of [where] // end of [val]
//
in
//
$effmask_wrt
(
  list_of_list_vt (list_reverse_append2_vt<a> (xs, ys))
) (* end of [$effmask_wrt] *)
//
end // end of [list_reverse_append]

implement
{a}(*tmp*)
list_reverse_append1_vt
  {m,n} (xs, ys) = let
//
prval (
) = lemma_list_vt_param (xs)
prval () = lemma_list_param (ys)
//
fun loop{m,n:nat} .<m>.
(
  xs: list_vt (a, m), ys: list (a, n)
) :<!wrt> list (a, m+n) = let
in
//
case+ xs of
| @list_vt_cons
    (x, xs1) => let
    val xs1_ = xs1
    val ys = __cast (ys) where {
      extern castfn __cast (ys: list (a, n)):<> list_vt (a, n)
    } // end of [val]
    val () = xs1 := ys
    prval () = fold@ (xs)
  in
    loop (xs1_, list_of_list_vt{a}(xs))
  end // end of [list_vt_cons]
| ~list_vt_nil () => ys
//
end // end of [loop]
//
in
  loop (xs, ys)
end // end of [list_reverse_append1_vt]

implement
{a}(*tmp*)
list_reverse_append2_vt
  (xs, ys) = let
//
prval () = lemma_list_param (xs)
prval () = lemma_list_vt_param (ys)
//
fun loop
  {m,n:nat} .<m>.
(
  xs: list (a, m), ys: list_vt (a, n)
) :<!wrt> list_vt (a, m+n) =
  case+ xs of
  | list_cons
      (x, xs) => loop (xs, list_vt_cons{a}(x, ys))
  | list_nil () => ys // end of [list_nil]
// end of [loop]
in
  loop (xs, ys)
end // end of [list_reverse_append2_vt]

(* ****** ****** *)

implement
{a}(*tmp*)
list_concat (xss) = let
//
prval () = lemma_list_param (xss)
//
typedef T = List (a)
fun aux {n:nat} .<n>.
(
  xs0: T
, xss: list (T, n)
) :<!wrt> List0_vt (a) = let
  prval () = lemma_list_param (xs0)
in
  case+ xss of
  | list_cons
      (xs, xss) => let
      val res = aux (xs, xss)
      val ys0 = list_copy (xs0)
    in
      list_vt_append<a> (ys0, res)
    end // end of [list_cons]
  | list_nil () => list_copy (xs0)
end // end of [aux]
//
in
//
case+ xss of
| list_cons
    (xs, xss) => aux (xs, xss)
| list_nil () => list_vt_nil ()
//
end // end of [list_concat]

(* ****** ****** *)

implement
{a}(*tmp*)
list_take (xs, i) = let
//
fun loop
  {n:int}
  {i:nat | i <= n} .<i>. (
  xs: list (a, n), i: int i
, res: &ptr? >> list_vt (a, i)
) :<!wrt> void =
  if i > 0 then let
    val+list_cons (x, xs) = xs
    val () = res :=
      list_vt_cons{a}{0}(x, _(*?*))
    val+list_vt_cons
      (_, res1) = res // res1 = res.1
    val () = loop (xs, i-1, res1)
    val () = fold@ (res)
  in
    // nothing
  end else (res := list_vt_nil ())
// end of [loop]
//
var res: ptr
val () = loop (xs, i, res)
//
in
  res
end // end of [list_take]

implement
{a}(*tmp*)
list_take_exn
  {n}{i} (xs, i) = let
//
prval () = lemma_list_param (xs)
//
fun loop
  {n:nat}
  {i:nat} .<i>. (
  xs: list (a, n), i: int i
, res: &ptr? >> list_vt (a, j)
) :<!wrt> #[
  j:nat | (i <= n && i == j) || (i > n && n == j)
] bool (i <= n) = let
//
in
//
if i > 0
then let
in
//
case+ xs of
| list_cons
    (x, xs1) => let
    val ((*void*)) =
    res := list_vt_cons{a}{0}(x, _)
    val+list_vt_cons (_, res1) = res
    val ans = loop (xs1, i-1, res1)
  in
    fold@ (res); ans
  end // end of [list_cons]
| list_nil () => let
    val ((*void*)) =
    res := list_vt_nil () in false(*fail*)
  end // end of [list_nil]
//
end // end of [then]
else let
  val () = res := list_vt_nil () in true(*succ*)
end // end of [else]
// end of [if]
//
end // end of [loop] 
//   
var res: ptr
val ans = loop{n}{i}(xs, i, res)
//
in
//
if ans
then res // i <= n && length (res) == i
else let
  val () = list_vt_free<a> (res) in $raise ListSubscriptExn()
end // end of [if]
//
end (* end of [list_take_exn] *)

(* ****** ****** *)

implement
{a}(*tmp*)
list_drop (xs, i) = let
//
fun loop
  {n:int}
  {i:nat | i <= n} .<i>.
  (xs: list (a, n), i: int i):<> list (a, n-i) =
  if i > 0 then let
    val+list_cons (_, xs) = xs in loop (xs, i-1)
  end else xs // end of [if]
//
in
  loop (xs, i)
end // end of [list_drop]

implement
{a}(*tmp*)
list_drop_exn
  (xs, i) = let
//
prval () = lemma_list_param (xs)
//
fun loop
  {n:nat}{i:nat} .<i>. (
  xs: list (a, n), i: int i
) :<!exn> [i <= n] list (a, n-i) =
  if i > 0 then (
    case+ xs of
    | list_cons (_, xs) => loop (xs, i-1)
    | list_nil () => $raise ListSubscriptExn()
  ) else (xs) // end of [if]
//
in
  loop (xs, i)
end // end of [list_drop_exn]

(* ****** ****** *)

implement
{x}(*tmp*)
list_split_at
  (xs, i) = let
//
fun loop
  {n:int}
  {i:nat | i <= n} .<n>.
(
  xs: list (x, n), i: int i
, res: &ptr? >> list_vt (x, i)
) :<!wrt> list (x, n-i) =
(
if i > 0
  then let
    val+list_cons (x, xs) = xs
    val () =
      res := list_vt_cons{x}{0}(x, _)
    // end of [val]
    val+list_vt_cons (_, res1) = res
    val xs2 = loop (xs, i-1, res1)
    prval () = fold@ (res)
  in
    xs2
  end // end of [then]
  else let
    val () = res := list_vt_nil () in xs
  end // end of [else]
// end of [if]
)
//
var res: ptr
val xs2 = loop (xs, i, res)
//
in
  (res, xs2)
end // end of [list_split_at]

(* ****** ****** *)

implement
{x}(*tmp*)
list_exists (xs) = let
in
//
case+ xs of
| list_cons (x, xs) =>
    if list_exists$pred<x> (x) then true else list_exists<x> (xs)
| list_nil () => false
//
end // end of [list_exists]

implement
{x}(*tmp*)
list_forall (xs) = let
in
//
case+ xs of
| list_cons (x, xs) =>
    if list_forall$pred<x> (x) then list_forall<x> (xs) else false
| list_nil () => true
//
end // end of [list_forall]

(* ****** ****** *)

implement
{a}(*tmp*)
list_equal$eqfn = gequal_val_val<a>

implement
{x}(*tmp*)
list_equal
  (xs1, xs2) = let
in
//
case+ xs1 of
| list_cons (x1, xs1) =>
  (
    case+ xs2 of
    | list_cons
        (x2, xs2) => let
        val iseq = list_equal$eqfn<x> (x1, x2)
      in
        if iseq then list_equal<x> (xs1, xs2) else false
      end
    | list_nil () => false
  ) // end of [list_cons]
| list_nil ((*void*)) =>
  (
    case+ xs2 of list_cons _ => false | list_nil () => true
  ) // end of [list_nil]
//
end // end of [list_equal]

(* ****** ****** *)

implement
{x}(*tmp*)
list_find_exn (xs) = let
in
//
case+ xs of
| list_cons (x, xs) =>
    if list_find$pred<x> (x) then x else list_find_exn<x> (xs)
| list_nil () => $raise NotFoundExn()
//
end // end of [list_find_exn]

implement
{x}(*tmp*)
list_find_opt (xs) = let
in
//
case+ xs of
| list_cons (x, xs) =>
    if list_find$pred<x> (x) then Some_vt{x}(x) else list_find_opt<x> (xs)
| list_nil () => None_vt(*void*)
//
end // end of [list_find_opt]

(* ****** ****** *)

implement
{key}(*tmp*)
list_assoc$eqfn = gequal_val_val<key>

implement
{key,itm}
list_assoc
  (kxs, k0, x0) = let
//
fun loop
(
  kxs: List @(key, itm)
, k0: key, x0: &itm? >> opt (itm, b)
) : #[b:bool] bool(b) =
(
  case+ kxs of
  | list_cons
      (kx, kxs) => let
      val iseq = list_assoc$eqfn<key> (k0, kx.0)
    in
      if iseq
        then let
          val () = x0 := kx.1
          prval () = opt_some{itm}(x0)
        in
          true
        end // end of [then]
        else loop (kxs, k0, x0)
      // end of [if]
    end // end of [list_cons]
  | list_nil ((*void*)) =>
      let prval () = opt_none{itm}(x0) in false end 
    // end of [list_nil]
) (* end of [loop] *)
//
in
  $effmask_all (loop (kxs, k0, x0))
end // end of [list_assoc]

(* ****** ****** *)

implement
{key,itm}
list_assoc_exn
  (kxs, k0) = let
  var x0: itm?
  val ans = list_assoc<key,itm> (kxs, k0, x0)
in
//
if ans
  then let
    prval () = opt_unsome{itm}(x0) in x0
  end // end of [then]
  else let
    prval () = opt_unnone{itm}(x0) in $raise NotFoundExn()
  end // end of [else]
//
end // end of [list_assoc_exn]

(* ****** ****** *)

implement
{key,itm}
list_assoc_opt
  (kxs, k0) = let
  var x0: itm?
  val ans = list_assoc<key,itm> (kxs, k0, x0)
in
//
if ans
  then let
    prval () = opt_unsome{itm}(x0) in Some_vt{itm}(x0)
  end // end of [then]
  else let
    prval () = opt_unnone{itm}(x0) in None_vt((*void*))
  end // end of [else]
//
end // end of [list_assoc_opt]

(* ****** ****** *)

implement
{x}(*tmp*)
list_filter {n} (xs) = let
//
prval () = lemma_list_param (xs)
//
fun loop
  {n:nat} .<n>. (
  xs: list (x, n)
, res: &ptr? >> listLte_vt (x, n)
) : void = (
  case+ xs of
  | list_cons (x, xs) => let
      val test = list_filter$pred<x> (x)
    in
      case+ test of
      | true => let
          val () = res :=
            list_vt_cons{x}{0}(x, _(*?*))
          val+list_vt_cons
            (_, res1) = res // res1 = res.1
          val () = loop (xs, res1)
          prval () = fold@ (res)
        in
          // nothing
        end // end of [true]
      | false => loop (xs, res)
    end // end of [list_cons]
  | list_nil () => (res := list_vt_nil)
) // end of [loop]
//
var res: ptr
val () = loop (xs, res)
//
in
  res (*listLte_vt(x, n)*)
end // end of [list_filter]

(* ****** ****** *)

implement
{x}(*tmp*)
list_labelize
  (xs) = res where {
//
typedef ix = @(int, x)
prval () = lemma_list_param (xs)
//
fun loop
  {n:nat} .<n>. (
  xs: list (x, n), i: int
, res: &ptr? >> list_vt (ix, n)
) :<!wrt> void = let
in
  case+ xs of
  | list_cons
      (x, xs) => let
      val () = res :=
        list_vt_cons{ix}{0}(_, _)
      val+list_vt_cons (ix, res1) = res
      val () = ix.0 := i and () = ix.1 := x
      val () = loop (xs, i+1, res1)
    in
      fold@ (res)
    end // end of [list_cons]
  | list_nil () => (res := list_vt_nil)
end // end of [loop]
//
var res: ptr ; val () = loop (xs, 0, res)
//
} // end of [list_labelize]

(* ****** ****** *)

implement
{x}(*tmp*)
list_app (xs) = let
//
prval () = lemma_list_param (xs)
//
fun
loop{n:nat} .<n>. (xs: list (x, n)): void =
(
case+ xs of
| list_nil () => ()
| list_cons (x, xs) => (list_app$fwork(x); loop (xs))
) (* end of [loop] *)
//
in
  loop (xs)
end // end of [list_app]

(* ****** ****** *)

implement
{x}(*tmp*)
list_app_fun(xs, f) = let
//
prval () = lemma_list_param (xs)
//
fun
loop{n:nat} .<n>.
(
  xs: list (x, n), f: (x) -<fun1> void
) : void = (
//
case+ xs of
| list_nil () => ()
| list_cons (x, xs) => (f(x); loop (xs, f))
//
) (* end of [loop] *)
//
in
  loop (xs, f)
end // end of [list_app_fun]

implement
{x}(*tmp*)
list_app_cloref(xs, f) = let
//
prval () = lemma_list_param (xs)
//
fun
loop{n:nat} .<n>.
(
  xs: list (x, n), f: (x) -<cloref1> void
) : void = (
//
case+ xs of
| list_nil () => ()
| list_cons (x, xs) => (f(x); loop (xs, f))
//
) (* end of [loop] *)
//
in
  loop (xs, f)
end // end of [list_app_cloref]

(* ****** ****** *)

implement
{x}{y}(*tmp*)
list_map{n}(xs) = let
//
prval () = lemma_list_param (xs)
//
fun loop
  {n:nat} .<n>. (
  xs: list (x, n)
, res: &ptr? >> list_vt (y, n)
) : void = (
  case+ xs of
  | list_cons (x, xs) => let
      val y =
        list_map$fopr<x><y> (x)
      val () = res :=
        list_vt_cons{y}{0}(y, _(*?*))
      val+list_vt_cons
        (_, res1) = res // res1 = res.1
      val () = loop (xs, res1)
      prval () = fold@ (res)
    in
      // nothing
    end // end of [list_cons]
  | list_nil () => (res := list_vt_nil)
) // end of [loop]
//
var res: ptr
val () = loop (xs, res)
//
in
  res (*list_vt (y, n)*)
end // end of [list_map]

(* ****** ****** *)

implement
{x}{y}(*tmp*)
list_map_fun
  (xs, f) = let
//
implement
{x2}{y2}
list_map$fopr (x2) = $UN.castvwtp0{y2}(f($UN.cast{x}(x2)))
//
in
  list_map<x><y> (xs)
end // end of [list_map_fun]

implement
{x}{y}(*tmp*)
list_map_clo
  (xs, f) = let
//
val f = $UN.cast{(x) -<cloref1> y}(addr@f)
//
implement
{x2}{y2}
list_map$fopr (x2) = $UN.castvwtp0{y2}(f($UN.cast{x}(x2)))
//
in
  list_map<x><y> (xs)
end // end of [list_map_clo]

implement
{x}{y}(*tmp*)
list_map_cloref
  (xs, f) = let
//
implement
{x2}{y2}
list_map$fopr (x2) = $UN.castvwtp0{y2}(f($UN.cast{x}(x2)))
//
in
  list_map<x><y> (xs)
end // end of [list_map_cloref]

(* ****** ****** *)

(*
implement
{x}{y}(*tmp*)
list_map_funenv
  {v}{vt}{n}{fe}
  (pfv | xs, f, env) = let
//
viewtypedef ys = List0_vt (y)
//
prval () =
  lemma_list_param (xs) // prove [n >= 0]
// end of [prval]
fun loop {n:nat} .<n>. (
  pfv: !v
| xs: list (x, n)
, f: (!v | x, !vt) -<fun,fe> y
, env: !vt
, res: &ys? >> list_vt (y, n)
) :<!wrt,fe> void = let
in
//
case+ xs of
| list_cons
    (x, xs) => let
    val y = f (pfv | x, env)
    val () = res :=
      list_vt_cons{y}{0}(y, _(*?*))
    val+list_vt_cons
      (_, res1) = res // res1 = res.1
    val () = loop (pfv | xs, f, env, res1)
    prval () = fold@ (res)
  in
    (*nothing*)
  end // end of [list_vt_cons]
| list_nil (
  ) => (res := list_vt_nil ())
//
end // end of [loop]
//
var res: ys // uninitialized
val () = loop (pfv | xs, f, env, res)
//
in
  res(*list_vt(y,n)*)
end // end of [list_map_funenv]
*)

(* ****** ****** *)

implement
{x}{y}
list_imap{n}(xs) = let
//
prval () = lemma_list_param (xs)
//
fun loop
  {n:nat}{i:nat} .<n>.
(
  xs: list (x, n), i: int(i)
, res: &ptr? >> list_vt (y, n)
) : void = (
  case+ xs of
  | list_cons
      (x, xs) => let
      val y =
        list_imap$fopr<x><y> (i, x)
      val () = res :=
        list_vt_cons{y}{0}(y, _(*?*))
      val+list_vt_cons
        (_, res1) = res // res1 = res.1
      val () = loop (xs, i+1, res1)
      prval ((*void*)) = fold@ (res)
    in
      // nothing
    end // end of [list_cons]
  | list_nil () => (res := list_vt_nil)
) // end of [loop]
//
var res: ptr
val () = loop (xs, 0, res)
//
in
  res (*list_vt (y, n)*)
end // end of [list_imap]

(* ****** ****** *)

implement
{x}{y}
list_mapopt{n}(xs) = let
//
prval () = lemma_list_param (xs)
//
fun loop
  {n:nat} .<n>. (
  xs: list (x, n)
, res: &ptr? >> listLte_vt (y, n)
) : void = let
in
//
case+ xs of
| list_cons (x, xs) => let
    val opt =
      list_mapopt$fopr<x><y> (x)
    // end of [val]
  in
    case+ opt of
    | ~Some_vt (y) => let
        val () = res :=
          list_vt_cons{y}{0}(y, _(*?*))
        val+list_vt_cons
          (_, res1) = res // res1 = res.1
        val () = loop (xs, res1)
        prval () = fold@ (res)
      in
        // nothing
      end // end of [Some_vt]
    | ~None_vt () => loop (xs, res)
  end // end of [list_cons]
| list_nil () => (res := list_vt_nil)
//
end // end of [loop]
//
var res: ptr
val () = loop (xs, res)
//
in
  res (*listLte_vt(y, n)*)
end // end of [list_mapopt]

(* ****** ****** *)

(*
implement
{x}{y}(*tmp*)
list_mapopt_funenv
  {v}{vt}{n}{fe}
  (pfv | xs, f, env) = let
//
viewtypedef ys = List0_vt (y)
//
prval () =
  lemma_list_param (xs) // prove [n >= 0]
// end of [prval]
fun loop {n:nat} .<n>. (
  pfv: !v
| xs: list (x, n)
, f: (!v | x, !vt) -<fun,fe> Option_vt (y)
, env: !vt
, res: &ys? >> listLte_vt (y, n)
) :<!wrt,fe> void = let
in
  case+ xs of
  | list_cons
      (x, xs) => let
      val opt = f (pfv | x, env)
    in
      case+ opt of
      | ~Some_vt (y) => let
          val () = res :=
            list_vt_cons{y}{0}(y, _(*?*))
          val+list_vt_cons
            (_, res1) = res // res1 = res.1
          val () = loop (pfv | xs, f, env, res1)
          prval () = fold@ (res)
        in
          (*nothing*)
        end // end of [Some_vt]
      | ~None_vt () => loop (pfv | xs, f, env, res)
    end // end of [list_vt_cons]
  | list_nil () => (res := list_vt_nil ())
    // end of [list_nil]
end // end of [loop]
//
var res: ys // uninitialized
val () = loop (pfv | xs, f, env, res)
//
in
  res(*listLte_vt(y,n)*)
end // end of [list_mapopt_funenv]
*)

(* ****** ****** *)

implement
{x1,x2}{y}(*tmp*)
list_map2{n1,n2}(xs1, xs2) = let
//
prval () = lemma_list_param (xs1)
prval () = lemma_list_param (xs2)
//
fun
loop{n1,n2:nat}
(
  xs1: list (x1, n1)
, xs2: list (x2, n2)
, res: &ptr? >> list_vt (y, min(n1,n2))
) : void = let
in
//
case+ (xs1, xs2) of
| (list_cons (x1, xs1),
   list_cons (x2, xs2)) =>
  {
    val y = list_map2$fopr (x1, x2)
    val () =
      res := list_vt_cons{y}{0}(y, _)
    val+list_vt_cons (_, res1) = res
    val ((*void*)) = loop (xs1, xs2, res1)
    prval ((*folded*)) = fold@ (res)
  } (* end of [cons, cons] *)
| (_, _) =>> (res := list_vt_nil((*void*)))
//
end // end of [loop]
//
var res: ptr
val ((*void*)) = loop (xs1, xs2, res)
//
in
  res
end // end of [list_map2]

(* ****** ****** *)

implement
{x}(*tmp*)
list_tabulate
  (n) = res where {
//
fun loop
  {n:int}
  {i:nat | i <= n}
  .<n-i>. (
  n: int n, i: int i
, res: &ptr? >> list_vt (x, n-i)
) : void =
  if n > i then let
    val x =
      list_tabulate$fopr<x> (i)
    val () = res :=
      list_vt_cons{x}{0}(x, _(*?*))
    val+list_vt_cons
      (_, res1) = res // res1 = res.1
    val () = loop (n, succ(i), res1)
    prval () = fold@ (res)
  in
    // nothing
  end else (res := list_vt_nil)
//
var res: ptr
val () = loop (n, 0, res)
//
} // end of [list_tabulate]

(* ****** ****** *)

implement
{a}(*tmp*)
list_tabulate_fun (n, f) = let
//
val f = $UN.cast{int -> a}(f)
//
implement(a2)
list_tabulate$fopr<a2> (n) = $UN.castvwtp0{a2}(f(n))
//
in
  list_tabulate<a> (n)
end // end of [list_tabulate_fun]

implement
{a}(*tmp*)
list_tabulate_clo (n, f) = let
//
val f = $UN.cast{int -<cloref1> a}(addr@f)
//
implement(a2)
list_tabulate$fopr<a2> (n) = $UN.castvwtp0{a2}(f(n))
//
in
  list_tabulate<a> (n)
end // end of [list_tabulate_clo]

implement
{a}(*tmp*)
list_tabulate_cloref (n, f) = let
//
val f = $UN.cast{int -<cloref1> a}(f)
//
implement(a2)
list_tabulate$fopr<a2> (n) = $UN.castvwtp0{a2}(f(n))
//
in
  list_tabulate<a> (n)
end // end of [list_tabulate_cloref]

(* ****** ****** *)

implement
{x,y}
list_zip (xs, ys) = let
//
typedef xy = @(x, y)
//
implement
list_zipwith$fopr<x,y><xy> (x, y) = @(x, y)
//
in
  $effmask_all (list_zipwith<x,y><xy> (xs, ys))
end // end of [list_zip]

implement
{x,y}{xy}
list_zipwith
  (xs, ys) = let
//
prval () = lemma_list_param (xs)
prval () = lemma_list_param (ys)
//
fun loop
  {m,n:nat} .<m>. (
  xs: list (x, m)
, ys: list (y, n)
, res: &ptr? >> list_vt (xy, min(m,n))
) : void = let
in
//
case+ xs of
| list_cons (x, xs) => (
  case+ ys of
  | list_cons (y, ys) => let
      val xy =
        list_zipwith$fopr<x,y><xy> (x, y)
      // end of [val]
      val () = res :=
        list_vt_cons{xy}{0}(xy, _(*y*))
      val+list_vt_cons
        (xy, res1) = res // res1 = res.1
      val () = loop (xs, ys, res1)
    in
      fold@ (res)
    end // end of [list_cons]
  | list_nil () => (res := list_vt_nil)
  ) // end of [list_cons]
| list_nil () => (res := list_vt_nil)
//
end // end of [loop]
//
var res: ptr
val () = loop (xs, ys, res)
in
  res
end // end of [list_zipwith]

(* ****** ****** *)

implement
{x,y}
list_cross (xs, ys) = let
//
typedef xy = @(x, y)
//
implement
list_crosswith$fopr<x,y><xy> (x, y) = @(x, y)
//
in
  $effmask_all (list_crosswith<x,y><xy> (xs, ys))
end // end of [list_cross]

implement
{x,y}{xy}
list_crosswith (xs, ys) = let
//
prval () = lemma_list_param (xs)
prval () = lemma_list_param (ys)
//
fnx loop1
  {m,n:nat} .<m,0,0>.
(
  xs: list (x, m)
, ys: list (y, n)
, res: &ptr? >> list_vt (xy, m*n)
) : void = let
in
  case+ xs of
  | list_cons
      (x, xs) => loop2 (xs, ys, x, ys, res)
  | list_nil () => (res := list_vt_nil)
end // end of [loop1]

and loop2
  {m,n,n2:nat} .<m,n2,1>.
(
  xs: list (x, m)
, ys: list (y, n)
, x: x, ys2: list (y, n2)
, res: &ptr? >> list_vt (xy, m*n+n2)
) : void = let
in
//
case+ ys2 of
| list_cons
    (y, ys2) => let
    val xy = 
      list_crosswith$fopr<x,y><xy> (x, y)
    // end of [val]
    val () = res :=
      list_vt_cons{xy}{0}(xy, _(*?*))
    val+list_vt_cons (_, res1) = res
    val () = loop2 (xs, ys, x, ys2, res1)
    prval () = mul_gte_gte_gte {m,n} ()
  in
    fold@ (res)
  end // end of [list_cons]
| list_nil () => loop1 (xs, ys, res)
//
end // end of [loop2]
//
var res: ptr
val () = loop1 (xs, ys, res)
//
in
  res
end // end of [list_crosswith]

(* ****** ****** *)

implement
{x}(*tmp*)
list_foreach (xs) = let
  var env: void = () in list_foreach_env<x><void> (xs, env)
end // end of [list_foreach]

implement
{x}{env}
list_foreach_env
  (xs, env) = let
//
prval () = lemma_list_param (xs)
//
fun loop
  {n:nat} .<n>. (
  xs: list (x, n), env: &env
) : void = let
in
//
case+ xs of
| list_cons (x, xs) => let
    val test =
      list_foreach$cont<x><env> (x, env)
    // end of [val]
  in
    if test then let
      val () = list_foreach$fwork<x><env> (x, env)
    in
      loop (xs, env)
    end else () // end of [if]
  end // end of [list_cons]
| list_nil ((*void*)) => ()
//
end // end of [loop]
//
in
  loop (xs, env)
end // end of [list_foreach_env]

(* ****** ****** *)

implement
{x}{env}
list_foreach$cont (x, env) = true

(* ****** ****** *)

implement
{x}(*tmp*)
list_foreach_fun
  (xs, f) = let
//
fun loop (xs: List(x)): void =
//
case+ xs of
| list_nil () => ()
| list_cons (x, xs) => (f (x); loop (xs))
//
in
  $effmask_all (loop (xs))
end // end of [list_foreach_fun]

implement
{x}(*tmp*)
list_foreach_cloref
  (xs, f) = let
//
fun loop (xs: List(x)): void =
//
case+ xs of
| list_nil () => ()
| list_cons (x, xs) => (f (x); loop (xs))
//
in
  $effmask_all (loop (xs))
end // end of [list_foreach_cloref]

(* ****** ****** *)

implement
{x}(*tmp*)
list_foreach_funenv
  {v}{vt}{fe}
  (pfv | xs, f, env) = let
//
prval () = lemma_list_param (xs)
//
fun loop {n:nat} .<n>. (
  pfv: !v
| xs: list (x, n)
, f: (!v | x, !vt) -<fun,fe> void
, env: !vt
) :<fe> void =
  case+ xs of
  | list_cons (x, xs) => let
      val () = f (pfv | x, env) in loop (pfv | xs, f, env)
    end // end of [list_cons]
  | list_nil ((*void*)) => ()
// end of [loop]
in
  loop (pfv | xs, f, env)
end // end of [list_foreach_funenv]

(* ****** ****** *)

implement
{x,y}(*tmp*)
list_foreach2 (xs, ys) = let
  var env: void = () in list_foreach2_env<x,y><void> (xs, ys, env)
end // end of [list_foreach2]

implement
{x,y}{env}
list_foreach2_env
  (xs, ys, env) = let
//
prval () = lemma_list_param (xs)
prval () = lemma_list_param (ys)
//
fun loop
  {m,n:nat} .<m>. (
  xs: list (x, m), ys: list (y, n), env: &env
) : void = let
in
//
case+ xs of
| list_cons
    (x, xs) => (
  case+ ys of
  | list_cons (y, ys) => let
      val test =
        list_foreach2$cont<x,y><env> (x, y, env)
      // end of [val]
    in
      if test then let
        val () = list_foreach2$fwork<x,y><env> (x, y, env)
      in
        loop (xs, ys, env)
      end else () // end of [if]
    end // end of [list_cons]
  | list_nil () => ()
  ) // end of [list_cons]
| list_nil () => ()
//
end // end of [loop]
//
in
  loop (xs, ys, env)
end // end of [list_foreach2_env]

(* ****** ****** *)

implement
{x,y}{env}
list_foreach2$cont (x, y, env) = true

(* ****** ****** *)

implement
{x}(*tmp*)
list_iforeach (xs) = let
  var env: void = () in list_iforeach_env<x><void> (xs, env)
end // end of [list_iforeach]

implement
{x}{env}
list_iforeach_env
  (xs, env) = let
//
prval () = lemma_list_param (xs)
//
fun loop
  {n:nat}
  {i:nat} .<n>.
(
  i: int i, xs: list (x, n), env: &env
) : intBtwe(i,n+i) =
  case+ xs of
  | list_cons
      (x, xs) => let
      val test =
        list_iforeach$cont<x><env> (i, x, env)
      // end of [test]
    in
      if test then let
        val () = list_iforeach$fwork<x><env> (i, x, env)
      in
        loop (succ(i), xs, env)
      end else (i) // end of [if]
    end // end of [list_cons]
  | list_nil () => (i) // number of processed elements
// end of [loop]
//
in
  loop (0, xs, env)
end // end of [list_iforeach_env]

(* ****** ****** *)

implement
{x}{env}(*tmp*)
list_iforeach$cont (i, x, env) = true

(* ****** ****** *)

implement
{x}(*tmp*)
list_iforeach_funenv
  {v}{vt}{n}{fe}
  (pfv | xs, f, env) = let
//
prval () = lemma_list_param (xs)
//
fun loop
  {i:nat | i <= n} .<n-i>. (
  pfv: !v
| i: int i
, xs: list (x, n-i)
, f: (!v | natLt(n), x, !vt) -<fun,fe> void
, env: !vt
) :<fe> int n =
  case+ xs of
  | list_cons (x, xs) => let
      val () = f (pfv | i, x, env) in loop (pfv | i+1, xs, f, env)
    end // end of [list_cons]
  | list_nil () => i // = size(xs)
// end of [loop]
in
  loop (pfv | 0, xs, f, env)
end // end of [list_iforeach_funenv]

(* ****** ****** *)

implement
{x,y}(*tmp*)
list_iforeach2
  (xs, ys) = let
  var env: void = ()
in
  list_iforeach2_env<x,y><void> (xs, ys, env)
end // end of [list_iforeach2]

implement
{x,y}{env}
list_iforeach2_env
  (xs, ys, env) = let
//
prval () = lemma_list_param (xs)
prval () = lemma_list_param (ys)
//
fun loop
  {m,n:nat}{i:nat} .<m>.
(
  i: int i, xs: list (x, m), ys: list (y, n), env: &env
) : intBtwe(i, min(m,n)+i) = let
in
//
case+ xs of
| list_cons (x, xs) => (
  case+ ys of
  | list_cons (y, ys) => let
      val test =
        list_iforeach2$cont<x,y><env> (i, x, y, env)
      // end of [val]
    in
      if test then let
        val () = list_iforeach2$fwork<x,y><env> (i, x, y, env)
      in
        loop (succ(i), xs, ys, env)
      end else (i) // end of [if]
    end // end of [list_cons]
  | list_nil () => i // the number of processed elements
  ) // end of [list_cons]
| list_nil () => i // the number of processed elements
//
end // end of [loop]
//
in
  loop (0, xs, ys, env)
end // end of [list_iforeach2_env]

(* ****** ****** *)

implement
{x,y}{env}
list_iforeach2$cont (i, x, y, env) = true

(* ****** ****** *)

implement
{res}{x}
list_foldleft (xs, ini) = let
//
prval () = lemma_list_param (xs)
//
fun loop
  {n:nat} .<n>.
(
  xs: list (x, n), acc: res
) : res =
  case+ xs of
  | list_nil () => acc
  | list_cons (x, xs) => let
      val acc =
        list_foldleft$fopr<res><x> (acc, x)
      // end of [val]
    in
      loop (xs, acc)
    end // end of [list_cons]
// end of [loop]
//
in
  loop (xs, ini)
end // end of [list_foldleft]

(* ****** ****** *)

implement
{x}{res}
list_foldright (xs, snk) = let
//
prval () = lemma_list_param (xs)
//
fun aux
  {n:nat} .<n>.
(
  xs: list (x, n), acc: res
) : res =
  case+ xs of
  | list_nil () => acc
  | list_cons (x, xs) =>
      list_foldright$fopr<x><res> (x, aux (xs, acc))
    // end of [list_cons]
// end of [aux]
//
in
  aux (xs, snk)
end // end of [list_foldright]

(* ****** ****** *)

implement
{a}(*tmp*)
list_mergesort$cmp
  (x1, x2) = gcompare_val_val<a> (x1, x2)
// end of [list_mergesort$cmp]

implement
{a}(*tmp*)
list_mergesort
  (xs) = let
//
val xs = list_copy<a> (xs)
//
implement
list_vt_mergesort$cmp<a>
  (x1, x2) = list_mergesort$cmp<a> (x1, x2)
//
in
  list_vt_mergesort<a> (xs)
end // end of [list_mergesort]

(* ****** ****** *)

implement
{a}(*tmp*)
list_mergesort_fun
  (xs, cmp) = let
//
implement
{a2}(*tmp*)
list_mergesort$cmp
  (x1, x2) = let
//
typedef cmp2 = cmpval(a2)
//
val cmp2 = $UN.cast{cmp2}(cmp) in cmp2 (x1, x2)
//
end // end of [list_mergesort$cmp]
//
in
  list_mergesort<a> (xs)
end // end of [list_mergesort_fun]

implement
{a}(*tmp*)
list_mergesort_cloref
  (xs, cmp) = let
//
implement
{a2}(*tmp*)
list_mergesort$cmp
  (x1, x2) = let
//
typedef cmp2 = (a2, a2) -<cloref> int
//
val cmp2 = $UN.cast{cmp2}(cmp) in cmp2 (x1, x2)
//
end // end of [list_mergesort$cmp]
//
in
  list_mergesort<a> (xs)
end // end of [list_mergesort_cloref]

(* ****** ****** *)

implement
{a}(*tmp*)
list_quicksort$cmp
  (x1, x2) = gcompare_val_val<a> (x1, x2)
// end of [list_quicksort$cmp]

implement
{a}(*tmp*)
list_quicksort
  (xs) = let
//
val xs = list_copy<a> (xs)
//
implement
list_vt_quicksort$cmp<a>
  (x1, x2) = list_quicksort$cmp<a> (x1, x2)
//
in
  list_vt_quicksort<a> (xs)
end // end of [list_quicksort]

(* ****** ****** *)

implement
{a}(*tmp*)
list_quicksort_fun
  (xs, cmp) = let
//
implement
{a2}(*tmp*)
list_quicksort$cmp
  (x1, x2) = let
//
val cmp = $UN.cast{cmpval(a2)}(cmp) in cmp (x1, x2)
//
end // end of [list_quicksort$cmp]
//
in
  list_quicksort<a> (xs)
end // end of [list_quicksort_fun]

(* ****** ****** *)

(* end of [list.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/strptr.atxt
** Time of generation: Sat Oct 17 15:19:52 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: April, 2012 *)

(* ****** ****** *)

#define ATS_DYNLOADFLAG 0 // no dynloading at run-time

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload _(*anon*) = "prelude/DATS/integer.dats"

(* ****** ****** *)

#define CNUL '\000'
#define nullp the_null_ptr

(* ****** ****** *)

overload + with add_ptr_bsz

(* ****** ****** *)

implement{}
strptr_is_null (str) = (strptr2ptr (str) = nullp)
implement{}
strptr_isnot_null (str) = (strptr2ptr (str) > nullp)

(* ****** ****** *)

implement{}
strptr_is_empty (str) = let
  val p = strptr2ptr (str) in $UN.ptr1_get<char>(p) = CNUL
end // end of [strptr_is_empty]
implement{}
strptr_isnot_empty (str) = let
  val p = strptr2ptr (str) in $UN.ptr1_get<char>(p) != CNUL
end // end of [strptr_isnot_empty]

(* ****** ****** *)

implement{}
strnptr_get_at_size (str, i) =
  $UN.ptr0_get<charNZ>(strnptr2ptr(str) + i)
// end of [strnptr_get_at_size]

implement{tk}
strnptr_get_at_gint (str, i) =
  strnptr_get_at_size (str, g1int2uint (i))
// end of [strnptr_get_at_gint]
implement{tk}
strnptr_get_at_guint (str, i) =
  strnptr_get_at_size (str, g1uint2uint (i))
// end of [strnptr_get_at_guint]

(* ****** ****** *)

implement{}
strnptr_set_at_size (str, i, c) =
  $UN.ptr0_set<charNZ>(strnptr2ptr(str) + i, c)
// end of [strnptr_set_at_size]

implement{tk}
strnptr_set_at_gint (str, i, c) =
  strnptr_set_at_size (str, g1int2uint (i), c)
// end of [strnptr_set_at_gint]
implement{tk}
strnptr_set_at_guint (str, i, c) =
  strnptr_set_at_size (str, g1uint2uint (i), c)
// end of [strnptr_set_at_guint]

(* ****** ****** *)

implement
lt_strptr_strptr (x1, x2) = (compare_strptr_strptr (x1, x2) < 0)
implement
lte_strptr_strptr (x1, x2) = (compare_strptr_strptr (x1, x2) <= 0)
implement
gt_strptr_strptr (x1, x2) = (compare_strptr_strptr (x1, x2) > 0)
implement
gte_strptr_strptr (x1, x2) = (compare_strptr_strptr (x1, x2) >= 0)
implement
eq_strptr_strptr (x1, x2) = (compare_strptr_strptr (x1, x2) = 0)
implement
neq_strptr_strptr (x1, x2) = (compare_strptr_strptr (x1, x2) != 0)

(* ****** ****** *)

(*
//
// HX: implemented in [strptr.cats]
//
implement
print_strptr (x) = fprint_strptr (stdout_ref, x)
implement
prerr_strptr (x) = fprint_strptr (stderr_ref, x)
*)

(* ****** ****** *)

implement{}
strnptr_is_null (str) = (strnptr2ptr (str) = nullp)
implement{}
strnptr_isnot_null (str) = (strnptr2ptr (str) > nullp)

(* ****** ****** *)

implement{}
strptr_length(x) = let
  val isnot = ptr_isnot_null(strptr2ptr(x))
in
//
if isnot
  then g0u2i(string_length($UN.strptr2string(x)))
  else g0i2i(~1)
//
end // end of [strptr_length]

implement{}
strnptr_length(x) = let
  prval () = lemma_strnptr_param (x)
  val isnot = ptr_isnot_null(strnptr2ptr(x))
in
//
if isnot
  then g1u2i(string_length($UN.strnptr2string(x)))
  else g1i2i(~1)
//
end // end of [strnptr_length]

(* ****** ****** *)

implement{}
strptr0_copy(x) = let
  val isnot = ptr_isnot_null(strptr2ptr(x))
in
//
if isnot
  then string0_copy($UN.strptr2string(x)) else strptr_null()
//
end // end of [strptr0_copy]

implement{}
strptr1_copy(x) = string0_copy($UN.strptr2string(x))

(* ****** ****** *)

implement{}
strnptr_copy
  {n}(x) = x2 where
{
  val x = strnptr2ptr(x)
  val x = $UN.castvwtp0{Strptr0}(x)
  val x2 = $UN.castvwtp0{strnptr(n)}(strptr0_copy(x))
  prval ((*void*)) = $UN.cast2void(x)
} (* end of [strnptr_copy] *)

(* ****** ****** *)

implement{}
strptr_append
  (x1, x2) = let
//
val isnot1 = ptr_isnot_null (strptr2ptr(x1))
//
in
//
if isnot1 then let
//
val isnot2 = ptr_isnot_null (strptr2ptr(x2))
//
in
//
if
isnot2
then
  strnptr2strptr(string1_append ($UN.strptr2string(x1), $UN.strptr2string(x2)))
else
  strptr1_copy (x1)
// end of [if]
//
end else
  strptr0_copy (x2)
// end of [if]
//
end // end of [strptr_append]

(* ****** ****** *)

implement{}
strptrlst_free (xs) = let
//
fun loop
  (xs: List_vt(Strptr0)): void = let
in
//
case+ xs of
| ~list_vt_cons
    (x, xs) => (strptr_free (x); loop (xs))
| ~list_vt_nil () => ()
//
end // end of [loop]
//
in
  $effmask_all (loop (xs))
end // end of [strptrlst_free]

(* ****** ****** *)

implement{}
strptrlst_concat (xs) = let
//
prval () = lemma_list_vt_param (xs)
//
fun loop
  {n0:nat} .<n0>.
(
  xs: &list_vt(Strptr0, n0)>>list_vt(Strptr1, n1)
) :<!wrt> #[n1:nat | n1 <= n0] void = let
in
//
case+ xs of
| @list_vt_cons
    (x, xs1) => let
    val isnot = strptr_isnot_null (x)
  in
    if isnot then let
      val () = loop (xs1)
      prval () = fold@ (xs)
    in
      // nothing
    end else let
      prval () =
        strptr_free_null (x)
      val xs1 = xs1
      val () = free@{..}{0}(xs)
      val ((*void*)) = (xs := xs1)
    in
      loop (xs)
    end // end of [if]
  end // end of [list_vt_cons]
| @list_vt_nil () => fold@ (xs)
//
end // end of [loop]
//
var xs = xs
val () = loop (xs)
//
in
//
case+ xs of
| ~list_vt_nil () => strptr_null ()
| ~list_vt_cons (x, ~list_vt_nil ()) => x
| _ => let
    val res =
      stringlst_concat ($UN.castvwtp1{List(string)}(xs))
    val () =
    loop (xs) where {
      fun loop {n:nat} .<n>.
        (xs: list_vt (Strptr1, n)):<!wrt> void =
        case+ xs of
        | ~list_vt_cons (x, xs) => (strptr_free (x); loop (xs))
        | ~list_vt_nil ((*void*)) => ()
      // end of [loop]
    } // end of [where] // end of [val]
  in
    res
  end // end of [_]
//
end // end of [strptrlst_concat]

(* ****** ****** *)

implement
{env}(*tmp*)
strnptr_foreach$cont (c, env) = true

(* ****** ****** *)

implement
{}(*tmp*)
strnptr_foreach (str) = let
  var env: void = () in strnptr_foreach_env<void> (str, env)
end // end of [strnptr_foreach]

(* ****** ****** *)

implement
{env}(*tmp*)
strnptr_foreach_env
  {n} (str, env) = let
//
fun loop
(
  p: ptr, env: &env >> _
) : ptr = let
//
#define NUL '\000'
//
val c = $UN.ptr0_get<Char> (p)
//
in
//
if
(c != NUL)
then let
  val (pf, fpf | p) =
    $UN.ptr0_vtake{charNZ}(p)
  val cont =
    strnptr_foreach$cont<env> (!p, env)
  // end of [val]
in
  if cont
    then let
      val () =
      strnptr_foreach$fwork<env> (!p, env)
      prval ((*void*)) = fpf (pf)
    in
      loop (ptr_succ<char> (p), env)
    end // end of [then]
    else let
      prval ((*void*)) = fpf (pf) in (p)
    end // end of [else]    
end // end of [then]
else (p) // end of [else]
//
end // end of [loop]
//
val p0 = ptrcast(str)
//
in
  $UN.cast{sizeLte(n)}(loop (p0, env) - p0)
end // end of [strnptr_foreach_env]

(* ****** ****** *)

implement
{env}(*tmp*)
strnptr_rforeach$cont (c, env) = true

(* ****** ****** *)

implement
{}(*tmp*)
strnptr_rforeach (str) = let
  var env: void = () in strnptr_rforeach_env<void> (str, env)
end // end of [strnptr_rforeach]

(* ****** ****** *)

implement
{env}(*tmp*)
strnptr_rforeach_env
  {n} (str, env) = let
//
fun loop
(
  p0: ptr, p1: ptr, env: &env >> _
) : ptr = let
in
//
if
(p1 > p0)
then let
  val p2 = ptr_pred<char> (p1)
  val (pf, fpf | p2) =
    $UN.ptr0_vtake{charNZ}(p2)
  val cont =
    strnptr_rforeach$cont<env> (!p2, env)
  // end of [val]
in
  if cont
    then let
      val () =
      strnptr_rforeach$fwork<env> (!p2, env)
      prval ((*void*)) = fpf (pf)
    in
      loop (p0, p2, env)
    end // end of [then]
    else let
      prval ((*void*)) = fpf (pf) in (p1)
    end // end of [else]    
end // end of [then]
else (p1) // end of [else]
//
end // end of [loop]
//
val p0 = ptrcast(str)
val p1 = ptr_add<char> (p0, length(str))
//
in
  $UN.cast{sizeLte(n)}(p1 - loop (p0, p1, env))
end // end of [strnptr_rforeach_env]

(* ****** ****** *)

(* end of [strptr.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/basics.atxt
** Time of generation: Sat Oct 17 15:19:55 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2012 *)

(* ****** ****** *)
//
staload
UN = "prelude/SATS/unsafe.sats"
//
(* ****** ****** *)
//
primplmnt
false_elim() = case+ 0 of _ =/=> ()
//
(* ****** ****** *)

primplmnt prop_verify () = ()
primplmnt prop_verify_and_add () = ()

(* ****** ****** *)

primplmnt pridentity_v (x) = ()
primplmnt pridentity_vt (x) = ()

(* ****** ****** *)

primplmnt eqint_make () = EQINT ()
primplmnt eqint_make_gint (x) = EQINT ()
primplmnt eqint_make_guint (x) = EQINT ()

(* ****** ****** *)

primplmnt eqaddr_make () = EQADDR ()
primplmnt eqaddr_make_ptr (x) = EQADDR ()

(* ****** ****** *)

primplmnt eqbool_make () = EQBOOL ()
primplmnt eqbool_make_bool (x) = EQBOOL ()

(* ****** ****** *)

implement
{a}(*tmp*)
lazy_force (lazyval) = !lazyval
implement
{a}(*tmp*)
lazy_vt_force (lazyval) = !lazyval

(* ****** ****** *)
//
implement
{a}(*tmp*)
stamped_vt2t_ref{x}(x) =
  $UN.ptr0_get<stamped_t(a,x)>(addr@x)
//
(* ****** ****** *)

primplmnt
unit_v_elim (pf) = let
  prval unit_v () = pf in (*nothing*)
end // end of [unit_v_elim]

(* ****** ****** *)
//
implement{a} box(x) = $UN.cast(x)
implement{a} unbox(x) = $UN.cast(x)
//
implement{a} box_vt(x) = $UN.castvwtp0(x)
implement{a} unbox_vt(x) = $UN.castvwtp0(x)
//
(* ****** ****** *)
//
// HX:
// See prelude/basics_dyn.sats
//
implement
{a}(*tmp*)
opt_unsome_get (x) =
  let prval () = opt_unsome (x) in x end
//
(* ****** ****** *)

(*
//
// HX: [atspre_argv_at_at] in basics.cats
//
implement
argv_get_at
  (argv, i) = x where {
  val (pf, fpf | p) =
    argv_takeout_strarr (argv)
  val x = !p.[i]
  prval () = minus_addback (fpf, pf | argv)
} // end of [argv_get_at]
*)

(* ****** ****** *)

implement{}
assertexn_bool0 (b) = if not(b) then $raise AssertExn()
implement{}
assertexn_bool1 (b) = if not(b) then $raise AssertExn()

(* ****** ****** *)

implement{a} gidentity (x) = x
implement{a} gidentity_vt (x) = x

(* ****** ****** *)

implement
{a}(*tmp*)
gcopy_val (x) = (x)
implement
(a:t@ype)
gcopy_ref<a> (x) = (x)

(* ****** ****** *)
//
implement
gequal_val_val<int> (x, y) = (x = y)
implement
gequal_val_val<bool> (x, y) = (x = y)
implement
gequal_val_val<char> (x, y) = (x = y)
implement
gequal_val_val<double> (x, y) = (x = y)
implement
gequal_val_val<string> (x, y) = (x = y)
//
(* ****** ****** *)
//
implement
(a:t@ype)
gequal_ref_ref<a>
  (x, y) = gequal_val_val<a> (x, y)
//
(* ****** ****** *)
//
implement
{a}(*tmp*)
tostring_val(x) = let
//
val str =
  $effmask_wrt(tostrptr_val<a>(x))
in
  strptr2string(str)
end // end of [tostring_val]
//
implement
{a}(*tmp*)
tostring_ref(x) = let
//
val str =
  $effmask_wrt(tostrptr_ref<a>(x))
in
  strptr2string(str)
end // end of [tostring_ref]
//
(* ****** ****** *)

implement
(a:t@ype)
tostrptr_ref<a> (x) = tostrptr_val<a> (x)

(* ****** ****** *)

implement
{a}(*tmp*)
fprint_val (out, x) = let
  val str = tostrptr_val<a> (x)
  val ((*void*)) = fprint_strptr (out, str)
  val ((*void*)) = strptr_free (str)
in
  // nothing
end // end of [fprint_val]

(* ****** ****** *)

implement
(a:t@ype)
fprint_ref<a> (out, x) = fprint_val<a> (out, x)

(* ****** ****** *)

(*
//
// HX-2014-02-25: commented out
//
implement{a}
print_val (x) = fprint_val<a> (stdout_ref, x)
implement{a}
prerr_val (x) = fprint_val<a> (stderr_ref, x)
implement{a}
print_ref (x) = fprint_ref<a> (stdout_ref, x)
implement{a}
prerr_ref (x) = fprint_ref<a> (stderr_ref, x)
*)

(* ****** ****** *)

(* end of [basics.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/arrayptr.atxt
** Time of generation: Sat Oct 17 15:19:57 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: May, 2012 *)

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

implement
{a}(*tmp*)
arrayptr_make_elt
  (asz, elt) = let
//
val
(
  pf, pfgc | p
) = array_ptr_alloc<a> (asz)
//
val () = array_initize_elt<a> (!p, asz, elt)
//
in
  arrayptr_encode(pf, pfgc | p)
end // end of [arrayptr_make_elt]

(* ****** ****** *)

implement
{}(*tmp*)
arrayptr_make_intrange
  {l,r} (l, r) = let
//
val asz = g1int2uint (r-l)
val [A:addr] A =
  arrayptr_make_uninitized<int> (asz)
//
fun loop
  {n:nat} .<n>. (
  p: ptr, asz: size_t n, l: int
) :<!wrt> void = let
in
//
if asz > 0 then let
  val () = $UN.ptr0_set<int> (p, l)
in
  loop (ptr0_succ<int> (p), pred (asz), l+1)
end else () // end of [if]
//
end // end of [loop]
//
val () = loop (ptrcast (A), asz, l)
//
in
  $UN.castvwtp0{arrayptr(intBtw(l,r),A,r-l)}(A)
end // end of [arrayptr_make_intrange]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayptr_make_list
  (asz, xs) = let
//
prval () = lemma_list_param (xs)
//
val (
  pf, pfgc | p
) = array_ptr_alloc<a> (i2sz(asz))
//
val () = array_initize_list<a> (!p, asz, xs)
//
in
  arrayptr_encode(pf, pfgc | p)
end // end of [arrayptr_make_list]

implement
{a}(*tmp*)
arrayptr_make_rlist
  (asz, xs) = let
//
prval () = lemma_list_param (xs)
//
val (
  pf, pfgc | p
) = array_ptr_alloc<a> (i2sz(asz))
//
val () = array_initize_rlist<a> (!p, asz, xs)
//
in
  arrayptr_encode(pf, pfgc | p)
end // end of [arrayptr_make_rlist]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayptr_make_subarray
  {n}{st,ln}(A, st, ln) = let
//
val p1 =
ptr_add<a> ($UN.cast2ptr(A), st)
val (
  pf1, fpf | p1
) = $UN.ptr_vtake{array(a,ln)}(p1)
//
val A2 =
arrayptr_make_uninitized<a> (ln)
val p2 = ptrcast (A2)
prval pf2 = arrayptr_takeout (A2)
//
val () = array_copy<a> (!p2, !p1, ln)
//
prval () = fpf (pf1)
prval () = arrayptr_addback (pf2 | A2)
//
in
  A2
end // end of [arrayptr_make_subarray]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayptr_make_list_vt
  (asz, xs) = let
//
prval () = lemma_list_vt_param (xs)
//
val (
 pf, pfgc | p
) = array_ptr_alloc<a> (i2sz(asz))
val () = array_initize_list_vt<a> (!p, asz, xs)
//
in
  arrayptr_encode(pf, pfgc | p)
end // end of [arrayptr_make_list_vt]

implement
{a}(*tmp*)
arrayptr_make_rlist_vt
  (asz, xs) = let
//
prval () = lemma_list_vt_param (xs)
//
val (
 pf, pfgc | p
) = array_ptr_alloc<a> (i2sz(asz))
val () = array_initize_rlist_vt<a> (!p, asz, xs)
//
in
  arrayptr_encode(pf, pfgc | p)
end // end of [arrayptr_make_rlist_vt]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayptr_make_uninitized
  (asz) = let
in
  arrayptr_encode2(array_ptr_alloc<a> (asz))
end // end of [arrayptr_uninitize]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayptr_imake_list
  (A, asz) = res where
{
//
val p = ptrcast(A)
prval pf = arrayptr_takeout (A)
val res = list_make_array (!p, asz)
prval () = arrayptr_addback (pf | A)
} // end of [arrayptr_imake_list]

(* ****** ****** *)

(*
implement
arrayptr_free = ATS_MFREE // HX: in arrayptr.cats
*)

(* ****** ****** *)

implement
{a}(*tmp*)
fprint_arrayptr
  (out, A, n) = () where
{
//
val p = ptrcast(A)
prval pf = arrayptr_takeout (A)
val () = fprint_array<a> (out, !p, n)
prval () = arrayptr_addback (pf | A)
//
} // end of [fprint_arrayptr]

(* ****** ****** *)

implement
{a}(*tmp*)
fprint_arrayptr_sep
  (out, A, n, sep) = () where
{
//
val p = ptrcast (A)
prval pf = arrayptr_takeout (A)
val () = fprint_array_sep<a> (out, !p, n, sep)
prval () = arrayptr_addback (pf | A)
//
} // end of [fprint_arrayptr_sep]

(* ****** ****** *)

implement
{a}{tk}
arrayptr_get_at_gint
  (A, i) = let
  val p = ptrcast (A) in
  $UN.ptr0_get<a> (ptr1_add_gint<a><tk> (p, i))
end // end of [arrayptr_get_at_gint]

implement
{a}{tk}
arrayptr_get_at_guint
  (A, i) = let
  val p = ptrcast (A) in
  $UN.ptr0_get<a> (ptr1_add_guint<a><tk> (p, i))
end // end of [arrayptr_get_at_guint]

(* ****** ****** *)

implement
{a}{tk}
arrayptr_set_at_gint
  (A, i, x) = let
  val p = ptrcast (A) in
  $UN.ptr0_set<a> (ptr1_add_gint<a><tk> (p, i), x)
end // end of [arrayptr_set_at_gint]

implement
{a}{tk}
arrayptr_set_at_guint
  (A, i, x) = let
  val p = ptrcast (A) in
  $UN.ptr0_set<a> (ptr1_add_guint<a><tk> (p, i), x)
end // end of [arrayptr_set_at_guint]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayptr_interchange
  (A, i, j) = let
//
  val p = ptrcast (A)
  prval pfarr = arrayptr_takeout (A)
  val () = array_interchange (!p, i, j)
  prval () = arrayptr_addback (pfarr | A)
//
in
  // noting
end // end of [arrayptr_interchange]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayptr_foreach
  (A, asz) = let
  var env: void = () in
  arrayptr_foreach_env<a><void> (A, asz, env)
end // end of [arrayptr_foreach]

implement
{a}{env}
arrayptr_foreach_env
  (A, asz, env) = res where {
  val p = ptrcast (A)
  prval pfarr = arrayptr_takeout (A)
  val res = array_foreach_env<a><env> (!p, asz, env)
  prval () = arrayptr_addback (pfarr | A)
} // end of [arrayptr_foreach_env]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayptr_foreach_fun
  (A, asz, f) = let
  val p = ptrcast (A)
  prval pfarr = arrayptr_takeout (A)
  val () = array_foreach_fun<a> (!p, asz, f)
  prval () = arrayptr_addback (pfarr | A)
in
  // nothing
end // end of [arrayptr_foreach_fun]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayptr_foreach_funenv
  (pfv | A, asz, f, env) = let
//
val p = ptrcast (A)
prval pfarr = arrayptr_takeout (A)
val () =
  array_foreach_funenv<a> (pfv | !p, asz, f, env)
prval () = arrayptr_addback (pfarr | A)
//
in
  // nothing
end // end of [arrayptr_foreach_funenv]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayptr_iforeach
  (A, asz) = let
  var env: void = () in
  arrayptr_iforeach_env<a><void> (A, asz, env)
end // end of [arrayptr_iforeach]

implement
{a}{env}
arrayptr_iforeach_env
  (A, asz, env) = res where {
  val p = ptrcast (A)
  prval pfarr = arrayptr_takeout (A)
  val res = array_iforeach_env<a><env> (!p, asz, env)
  prval () = arrayptr_addback (pfarr | A)
} // end of [arrayptr_iforeach_env]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayptr_rforeach
  (A, asz) = let
  var env: void = () in
  arrayptr_rforeach_env<a><void> (A, asz, env)
end // end of [arrayptr_rforeach]

implement
{a}{env}
arrayptr_rforeach_env
  (A, asz, env) = res where {
  val p = ptrcast (A)
  prval pfarr = arrayptr_takeout (A)
  val res = array_rforeach_env<a><env> (!p, asz, env)
  prval () = arrayptr_addback (pfarr | A)
} // end of [arrayptr_rforeach_env]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayptr_initize
  (A, asz) = () where {
  val p = ptrcast (A)
  prval pfarr = arrayptr_takeout (A)
  val () = array_initize<a> (!p, asz)
  prval () = arrayptr_addback (pfarr | A)
} // end of [arrayptr_initize]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayptr_uninitize
  (A, asz) = () where {
  val p = ptrcast (A)
  prval pfarr = arrayptr_takeout (A)
  val () = array_uninitize<a> (!p, asz)
  prval () = arrayptr_addback (pfarr | A)
} // end of [arrayptr_uninitize]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayptr_freelin
  (A, asz) = let
//
val () = arrayptr_uninitize<a> (A, asz)
//
in
  arrayptr_free{a?}(A)
end // end of [arrayptr_freelin]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayptr_tabulate
  (asz) = arrayptr_encode2(array_ptr_tabulate<a> (asz))
// end of [arrayptr_tabulate]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayptr_tabulate_cloref
  {n} (asz, f) = let
//
implement(a2)
array_tabulate$fopr<a2> (i) = $UN.castvwtp0{a2}(f($UN.cast{sizeLt(n)}(i)))
//
in
  arrayptr_tabulate<a> (asz)
end // end of [arrayptr_tabulate_cloref]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayptr_quicksort
  (A, asz) = () where
{
  val p = ptrcast (A)
  prval pfarr = arrayptr_takeout (A)
  val () = array_quicksort<a> (!p, asz)
  prval () = arrayptr_addback (pfarr | A)
} (* end of [arrayptr_quicksort] *)

(* ****** ****** *)

(* end of [arrayptr.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/integer_fixed.atxt
** Time of generation: Sat Oct 17 15:19:53 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: February, 2014 *)

(* ****** ****** *)

#define ATS_DYNLOADFLAG 0 // no dynloading at run-time

(* ****** ****** *)
//
//
(* ****** ****** *)
//
staload UN = "prelude/SATS/unsafe.sats"
//
(* ****** ****** *)

implement
g0int2int<int8knd,intknd> = g0int2int_int8_int
implement
g0int2int<int16knd,intknd> = g0int2int_int16_int
implement
g0int2int<int32knd,intknd> = g0int2int_int32_int
implement
g0int2int<int64knd,intknd> = g0int2int_int64_int

(* ****** ****** *)

implement g0int_neg<int8knd> = g0int_neg_int8
implement g0int_abs<int8knd> = g0int_abs_int8
implement g0int_succ<int8knd> = g0int_succ_int8
implement g0int_pred<int8knd> = g0int_pred_int8
implement g0int_half<int8knd> = g0int_half_int8
implement g0int_add<int8knd> = g0int_add_int8
implement g0int_sub<int8knd> = g0int_sub_int8
implement g0int_mul<int8knd> = g0int_mul_int8
implement g0int_div<int8knd> = g0int_div_int8
implement g0int_mod<int8knd> = g0int_mod_int8
implement g0int_asl<int8knd> = g0int_asl_int8
implement g0int_asr<int8knd> = g0int_asr_int8
implement g0int_isltz<int8knd> = g0int_isltz_int8
implement g0int_isltez<int8knd> = g0int_isltez_int8
implement g0int_isgtz<int8knd> = g0int_isgtz_int8
implement g0int_isgtez<int8knd> = g0int_isgtez_int8
implement g0int_iseqz<int8knd> = g0int_iseqz_int8
implement g0int_isneqz<int8knd> = g0int_isneqz_int8
implement g0int_lt<int8knd> = g0int_lt_int8
implement g0int_lte<int8knd> = g0int_lte_int8
implement g0int_gt<int8knd> = g0int_gt_int8
implement g0int_gte<int8knd> = g0int_gte_int8
implement g0int_eq<int8knd> = g0int_eq_int8
implement g0int_neq<int8knd> = g0int_neq_int8
implement g0int_compare<int8knd> = g0int_compare_int8
implement g0int_max<int8knd> = g0int_max_int8
implement g0int_min<int8knd> = g0int_min_int8
//
implement fprint_val<int8> (out, x) = fprint_int8 (out, x)
//
implement g0int_neg<int16knd> = g0int_neg_int16
implement g0int_abs<int16knd> = g0int_abs_int16
implement g0int_succ<int16knd> = g0int_succ_int16
implement g0int_pred<int16knd> = g0int_pred_int16
implement g0int_half<int16knd> = g0int_half_int16
implement g0int_add<int16knd> = g0int_add_int16
implement g0int_sub<int16knd> = g0int_sub_int16
implement g0int_mul<int16knd> = g0int_mul_int16
implement g0int_div<int16knd> = g0int_div_int16
implement g0int_mod<int16knd> = g0int_mod_int16
implement g0int_asl<int16knd> = g0int_asl_int16
implement g0int_asr<int16knd> = g0int_asr_int16
implement g0int_isltz<int16knd> = g0int_isltz_int16
implement g0int_isltez<int16knd> = g0int_isltez_int16
implement g0int_isgtz<int16knd> = g0int_isgtz_int16
implement g0int_isgtez<int16knd> = g0int_isgtez_int16
implement g0int_iseqz<int16knd> = g0int_iseqz_int16
implement g0int_isneqz<int16knd> = g0int_isneqz_int16
implement g0int_lt<int16knd> = g0int_lt_int16
implement g0int_lte<int16knd> = g0int_lte_int16
implement g0int_gt<int16knd> = g0int_gt_int16
implement g0int_gte<int16knd> = g0int_gte_int16
implement g0int_eq<int16knd> = g0int_eq_int16
implement g0int_neq<int16knd> = g0int_neq_int16
implement g0int_compare<int16knd> = g0int_compare_int16
implement g0int_max<int16knd> = g0int_max_int16
implement g0int_min<int16knd> = g0int_min_int16
//
implement fprint_val<int16> (out, x) = fprint_int16 (out, x)
//
implement g0int_neg<int32knd> = g0int_neg_int32
implement g0int_abs<int32knd> = g0int_abs_int32
implement g0int_succ<int32knd> = g0int_succ_int32
implement g0int_pred<int32knd> = g0int_pred_int32
implement g0int_half<int32knd> = g0int_half_int32
implement g0int_add<int32knd> = g0int_add_int32
implement g0int_sub<int32knd> = g0int_sub_int32
implement g0int_mul<int32knd> = g0int_mul_int32
implement g0int_div<int32knd> = g0int_div_int32
implement g0int_mod<int32knd> = g0int_mod_int32
implement g0int_asl<int32knd> = g0int_asl_int32
implement g0int_asr<int32knd> = g0int_asr_int32
implement g0int_isltz<int32knd> = g0int_isltz_int32
implement g0int_isltez<int32knd> = g0int_isltez_int32
implement g0int_isgtz<int32knd> = g0int_isgtz_int32
implement g0int_isgtez<int32knd> = g0int_isgtez_int32
implement g0int_iseqz<int32knd> = g0int_iseqz_int32
implement g0int_isneqz<int32knd> = g0int_isneqz_int32
implement g0int_lt<int32knd> = g0int_lt_int32
implement g0int_lte<int32knd> = g0int_lte_int32
implement g0int_gt<int32knd> = g0int_gt_int32
implement g0int_gte<int32knd> = g0int_gte_int32
implement g0int_eq<int32knd> = g0int_eq_int32
implement g0int_neq<int32knd> = g0int_neq_int32
implement g0int_compare<int32knd> = g0int_compare_int32
implement g0int_max<int32knd> = g0int_max_int32
implement g0int_min<int32knd> = g0int_min_int32
//
implement fprint_val<int32> (out, x) = fprint_int32 (out, x)
//
implement g0int_neg<int64knd> = g0int_neg_int64
implement g0int_abs<int64knd> = g0int_abs_int64
implement g0int_succ<int64knd> = g0int_succ_int64
implement g0int_pred<int64knd> = g0int_pred_int64
implement g0int_half<int64knd> = g0int_half_int64
implement g0int_add<int64knd> = g0int_add_int64
implement g0int_sub<int64knd> = g0int_sub_int64
implement g0int_mul<int64knd> = g0int_mul_int64
implement g0int_div<int64knd> = g0int_div_int64
implement g0int_mod<int64knd> = g0int_mod_int64
implement g0int_asl<int64knd> = g0int_asl_int64
implement g0int_asr<int64knd> = g0int_asr_int64
implement g0int_isltz<int64knd> = g0int_isltz_int64
implement g0int_isltez<int64knd> = g0int_isltez_int64
implement g0int_isgtz<int64knd> = g0int_isgtz_int64
implement g0int_isgtez<int64knd> = g0int_isgtez_int64
implement g0int_iseqz<int64knd> = g0int_iseqz_int64
implement g0int_isneqz<int64knd> = g0int_isneqz_int64
implement g0int_lt<int64knd> = g0int_lt_int64
implement g0int_lte<int64knd> = g0int_lte_int64
implement g0int_gt<int64knd> = g0int_gt_int64
implement g0int_gte<int64knd> = g0int_gte_int64
implement g0int_eq<int64knd> = g0int_eq_int64
implement g0int_neq<int64knd> = g0int_neq_int64
implement g0int_compare<int64knd> = g0int_compare_int64
implement g0int_max<int64knd> = g0int_max_int64
implement g0int_min<int64knd> = g0int_min_int64
//
implement fprint_val<int64> (out, x) = fprint_int64 (out, x)
//
(* ****** ****** *)
//
implement
g0int2uint<int8knd,uintknd> = g0int2uint_int8_uint
implement
g0int2uint<int16knd,uintknd> = g0int2uint_int16_uint
implement
g0int2uint<int32knd,uintknd> = g0int2uint_int32_uint
implement
g0int2uint<int64knd,uintknd> = g0int2uint_int64_uint
//
implement
g0uint2int<uint8knd,intknd> = g0uint2int_uint8_int
implement
g0uint2int<uint16knd,intknd> = g0uint2int_uint16_int
implement
g0uint2int<uint32knd,intknd> = g0uint2int_uint32_int
implement
g0uint2int<uint64knd,intknd> = g0uint2int_uint64_int
//
implement
g0uint2uint<uint8knd,uintknd> = g0uint2uint_uint8_uint
implement
g0uint2uint<uint16knd,uintknd> = g0uint2uint_uint16_uint
implement
g0uint2uint<uint32knd,uintknd> = g0uint2uint_uint32_uint
implement
g0uint2uint<uint64knd,uintknd> = g0uint2uint_uint64_uint
//
(* ****** ****** *)

implement g0uint_succ<uint8knd> = g0uint_succ_uint8
implement g0uint_pred<uint8knd> = g0uint_pred_uint8
implement g0uint_half<uint8knd> = g0uint_half_uint8
implement g0uint_add<uint8knd> = g0uint_add_uint8
implement g0uint_sub<uint8knd> = g0uint_sub_uint8
implement g0uint_mul<uint8knd> = g0uint_mul_uint8
implement g0uint_div<uint8knd> = g0uint_div_uint8
implement g0uint_mod<uint8knd> = g0uint_mod_uint8
implement g0uint_lsl<uint8knd> = g0uint_lsl_uint8
implement g0uint_lsr<uint8knd> = g0uint_lsr_uint8
implement g0uint_lnot<uint8knd> = g0uint_lnot_uint8
implement g0uint_lor<uint8knd> = g0uint_lor_uint8
implement g0uint_lxor<uint8knd> = g0uint_lxor_uint8
implement g0uint_land<uint8knd> = g0uint_land_uint8
implement g0uint_isgtz<uint8knd> = g0uint_isgtz_uint8
implement g0uint_iseqz<uint8knd> = g0uint_iseqz_uint8
implement g0uint_isneqz<uint8knd> = g0uint_isneqz_uint8
implement g0uint_lt<uint8knd> = g0uint_lt_uint8
implement g0uint_lte<uint8knd> = g0uint_lte_uint8
implement g0uint_gt<uint8knd> = g0uint_gt_uint8
implement g0uint_gte<uint8knd> = g0uint_gte_uint8
implement g0uint_eq<uint8knd> = g0uint_eq_uint8
implement g0uint_neq<uint8knd> = g0uint_neq_uint8
implement g0uint_compare<uint8knd> = g0uint_compare_uint8
implement g0uint_max<uint8knd> = g0uint_max_uint8
implement g0uint_min<uint8knd> = g0uint_min_uint8
//
implement fprint_val<uint8> (out, x) = fprint_uint8 (out, x)
//
implement g0uint_succ<uint16knd> = g0uint_succ_uint16
implement g0uint_pred<uint16knd> = g0uint_pred_uint16
implement g0uint_half<uint16knd> = g0uint_half_uint16
implement g0uint_add<uint16knd> = g0uint_add_uint16
implement g0uint_sub<uint16knd> = g0uint_sub_uint16
implement g0uint_mul<uint16knd> = g0uint_mul_uint16
implement g0uint_div<uint16knd> = g0uint_div_uint16
implement g0uint_mod<uint16knd> = g0uint_mod_uint16
implement g0uint_lsl<uint16knd> = g0uint_lsl_uint16
implement g0uint_lsr<uint16knd> = g0uint_lsr_uint16
implement g0uint_lnot<uint16knd> = g0uint_lnot_uint16
implement g0uint_lor<uint16knd> = g0uint_lor_uint16
implement g0uint_lxor<uint16knd> = g0uint_lxor_uint16
implement g0uint_land<uint16knd> = g0uint_land_uint16
implement g0uint_isgtz<uint16knd> = g0uint_isgtz_uint16
implement g0uint_iseqz<uint16knd> = g0uint_iseqz_uint16
implement g0uint_isneqz<uint16knd> = g0uint_isneqz_uint16
implement g0uint_lt<uint16knd> = g0uint_lt_uint16
implement g0uint_lte<uint16knd> = g0uint_lte_uint16
implement g0uint_gt<uint16knd> = g0uint_gt_uint16
implement g0uint_gte<uint16knd> = g0uint_gte_uint16
implement g0uint_eq<uint16knd> = g0uint_eq_uint16
implement g0uint_neq<uint16knd> = g0uint_neq_uint16
implement g0uint_compare<uint16knd> = g0uint_compare_uint16
implement g0uint_max<uint16knd> = g0uint_max_uint16
implement g0uint_min<uint16knd> = g0uint_min_uint16
//
implement fprint_val<uint16> (out, x) = fprint_uint16 (out, x)
//
implement g0uint_succ<uint32knd> = g0uint_succ_uint32
implement g0uint_pred<uint32knd> = g0uint_pred_uint32
implement g0uint_half<uint32knd> = g0uint_half_uint32
implement g0uint_add<uint32knd> = g0uint_add_uint32
implement g0uint_sub<uint32knd> = g0uint_sub_uint32
implement g0uint_mul<uint32knd> = g0uint_mul_uint32
implement g0uint_div<uint32knd> = g0uint_div_uint32
implement g0uint_mod<uint32knd> = g0uint_mod_uint32
implement g0uint_lsl<uint32knd> = g0uint_lsl_uint32
implement g0uint_lsr<uint32knd> = g0uint_lsr_uint32
implement g0uint_lnot<uint32knd> = g0uint_lnot_uint32
implement g0uint_lor<uint32knd> = g0uint_lor_uint32
implement g0uint_lxor<uint32knd> = g0uint_lxor_uint32
implement g0uint_land<uint32knd> = g0uint_land_uint32
implement g0uint_isgtz<uint32knd> = g0uint_isgtz_uint32
implement g0uint_iseqz<uint32knd> = g0uint_iseqz_uint32
implement g0uint_isneqz<uint32knd> = g0uint_isneqz_uint32
implement g0uint_lt<uint32knd> = g0uint_lt_uint32
implement g0uint_lte<uint32knd> = g0uint_lte_uint32
implement g0uint_gt<uint32knd> = g0uint_gt_uint32
implement g0uint_gte<uint32knd> = g0uint_gte_uint32
implement g0uint_eq<uint32knd> = g0uint_eq_uint32
implement g0uint_neq<uint32knd> = g0uint_neq_uint32
implement g0uint_compare<uint32knd> = g0uint_compare_uint32
implement g0uint_max<uint32knd> = g0uint_max_uint32
implement g0uint_min<uint32knd> = g0uint_min_uint32
//
implement fprint_val<uint32> (out, x) = fprint_uint32 (out, x)
//
implement g0uint_succ<uint64knd> = g0uint_succ_uint64
implement g0uint_pred<uint64knd> = g0uint_pred_uint64
implement g0uint_half<uint64knd> = g0uint_half_uint64
implement g0uint_add<uint64knd> = g0uint_add_uint64
implement g0uint_sub<uint64knd> = g0uint_sub_uint64
implement g0uint_mul<uint64knd> = g0uint_mul_uint64
implement g0uint_div<uint64knd> = g0uint_div_uint64
implement g0uint_mod<uint64knd> = g0uint_mod_uint64
implement g0uint_lsl<uint64knd> = g0uint_lsl_uint64
implement g0uint_lsr<uint64knd> = g0uint_lsr_uint64
implement g0uint_lnot<uint64knd> = g0uint_lnot_uint64
implement g0uint_lor<uint64knd> = g0uint_lor_uint64
implement g0uint_lxor<uint64knd> = g0uint_lxor_uint64
implement g0uint_land<uint64knd> = g0uint_land_uint64
implement g0uint_isgtz<uint64knd> = g0uint_isgtz_uint64
implement g0uint_iseqz<uint64knd> = g0uint_iseqz_uint64
implement g0uint_isneqz<uint64knd> = g0uint_isneqz_uint64
implement g0uint_lt<uint64knd> = g0uint_lt_uint64
implement g0uint_lte<uint64knd> = g0uint_lte_uint64
implement g0uint_gt<uint64knd> = g0uint_gt_uint64
implement g0uint_gte<uint64knd> = g0uint_gte_uint64
implement g0uint_eq<uint64knd> = g0uint_eq_uint64
implement g0uint_neq<uint64knd> = g0uint_neq_uint64
implement g0uint_compare<uint64knd> = g0uint_compare_uint64
implement g0uint_max<uint64knd> = g0uint_max_uint64
implement g0uint_min<uint64knd> = g0uint_min_uint64
//
implement fprint_val<uint64> (out, x) = fprint_uint64 (out, x)
//
(* ****** ****** *)

(* end of [integer_fixed.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/intrange.atxt
** Time of generation: Sat Oct 17 15:19:54 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: June, 2012 *)

(* ****** ****** *)

implement{}
intrange_foreach
  (l, r) = let
  var env: void = ()
in
  intrange_foreach_env<void> (l, r, env)
end // end of [intrange_foreach]

implement{tenv}
intrange_foreach_env
  (l, r, env) = let
//
fun loop
(
  l: int, r: int, env: &tenv
) : int =
(
//
if
l < r
then let
  val cont = intrange_foreach$cont<tenv> (l, env)
in
//
if
cont
then (
  intrange_foreach$fwork<tenv> (l, env); loop (succ(l), r, env)
) else l // end of [if]
//
end // end of [then]
else l // end of [else]
//
) // end of [loop]
//
in
  loop (l, r, env)
end // end of [intrange_foreach_env]

(* ****** ****** *)

implement{env}
intrange_foreach$cont (i, env) = true
(*
implement{env}
intrange_foreach$fwork (i, env) = ((*void*))
*)

(* ****** ****** *)

implement
{}(*tmp*)
int_foreach_cloref
  (n, fwork) = (
//
intrange_foreach_cloref<> (0, n, fwork)
//
) (* end of [int_foreach_cloref] *)

(* ****** ****** *)

implement
{}(*tmp*)
intrange_foreach_cloref
  (l, r, fwork) = let
//
implement
(env)(*tmp*)
intrange_foreach$cont<env> (i, env) = true
implement
(env)(*tmp*)
intrange_foreach$fwork<env>(i, env) = fwork(i)
//
var env: void = ()
//
in
  intrange_foreach_env<void> (l, r, env)
end // end of [intrange_foreach_cloref]

(* ****** ****** *)

implement{}
intrange_rforeach
  (l, r) = let
  var env: void = ()
in
  intrange_rforeach_env<void> (l, r, env)
end // end of [intrange_rforeach]

implement{tenv}
intrange_rforeach_env
  (l, r, env) = let
//
fun loop
(
  l: int, r: int, env: &tenv
) : int =
(
//
if
l < r
then let
  val r1 = pred (r)
  val cont = intrange_rforeach$cont<tenv> (r1, env)
in
//
if
cont
then (
  intrange_rforeach$fwork<tenv> (r1, env); loop (l, r1, env)
) else r // end of [if]
//
end // end of [then]
else r // end of [else]
//
) // end of [loop]
//
in
  loop (l, r, env)
end // end of [intrange_rforeach_env]

(* ****** ****** *)

implement{env}
intrange_rforeach$cont (i, env) = true
(*
implement{env}
intrange_rforeach$fwork (i, env) = ((*void*))
*)

(* ****** ****** *)

implement
{}(*tmp*)
int_rforeach_cloref
  (n, fwork) = (
//
intrange_rforeach_cloref<> (0, n, fwork)
//
) (* end of [int_rforeach_cloref] *)

(* ****** ****** *)

implement
{}(*tmp*)
intrange_rforeach_cloref
  (l, r, fwork) = let
//
implement
(env)(*tmp*)
intrange_rforeach$cont<env> (i, env) = true
implement
(env)(*tmp*)
intrange_rforeach$fwork<env>(i, env) = fwork(i)
//
var env: void = ()
//
in
  intrange_rforeach_env<void> (l, r, env)
end // end of [intrange_rforeach_cloref]

(* ****** ****** *)

implement{}
intrange2_foreach
  (l1, r1, l2, r2) = let
  var env: void = () in
  intrange2_foreach_env<void> (l1, r1, l2, r2, env)
end // end of [intrange2_foreach]

(* ****** ****** *)

implement{tenv}
intrange2_foreach_env
  (l1, r1, l2, r2, env) = let
//
fnx
loop1
(
  i: int, env: &(tenv) >> _
) : void =
(
if i < r1 then loop2 (i, l2, env) else ()
)
//
and
loop2
(
  i: int, j: int, env: &(tenv) >> _
) : void =
(
if
j < r2
then (
  intrange2_foreach$fwork(i, j, env); loop2 (i, j+1, env)
) else loop1 (i+1, env)
)
//
in
  loop1 (l1, env)
end // end of [intrange2_foreach]

(* ****** ****** *)

(* end of [intrange.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/gnumber.atxt
** Time of generation: Sat Oct 17 15:19:55 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2013 *)

(* ****** ****** *)

(* Author: Brandon Barker *)
(* Authoremail: brandon.barker AT gmail DOT com *)
(* Start time: July, 2013 *)

(* ****** ****** *)

implement
{a}(*tmp*)
gadd_val_int(x, y) = gadd_val_val<a> (x, gnumber_int<a> (y))
implement
{a}(*tmp*)
gsub_val_int(x, y) = gsub_val_val<a> (x, gnumber_int<a> (y))
  
(* ****** ****** *)

implement
{a}(*tmp*)
gmul_int_val(x, y) = gmul_val_val<a> (gnumber_int<a> (x), y)
implement
{a}(*tmp*)
gmul_val_int(x, y) = gmul_val_val<a> (x, gnumber_int<a> (y))

(* ****** ****** *)

implement
{a}(*tmp*)
gdiv_int_val(x, y) = gdiv_val_val<a> (gnumber_int<a> (x), y)
implement
{a}(*tmp*)
gdiv_val_int(x, y) = gdiv_val_val<a> (x, gnumber_int<a> (y))
implement
{a}(*tmp*)
gmod_val_int(x, y) = gmod_val_val<a> (x, gnumber_int<a> (y))

(* ****** ****** *)

implement
{a}(*tmp*)
gpow_int_val
  (n, x) = let
//
fun
loop
{n:pos} .<n>.
(
  n: int(n), x: a, res: a
) :<> (a) =
(
//
if
n >= 2
then let
  val n2 = half(n)
  val r2 = n - (n2 + n2)
in
  if r2 = 0
    then loop (n2, gmul_val_val<a> (x, x), res)
    else loop (n2, gmul_val_val<a> (x, x), gmul_val_val<a> (x, res))
  // end of [if]
end else gmul_val_val<a> (x, res)
//
) (* end of [loop] *)
//
in
//
if
n >= 2
then loop (n-1, x, x)
else (
  if n >= 1 then x else gnumber_int<a> (1)
) (* end of [else] *)
//
end // end of [gpow_int_val]

(* ****** ****** *)

#include "./SHARE/gnumber_int.dats"
#include "./SHARE/gnumber_uint.dats"

(* ****** ****** *)

#include "./SHARE/gnumber_float.dats"

(* ****** ****** *)

(* end of [gnumber.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/arrayref.atxt
** Time of generation: Sat Oct 17 15:19:57 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: May, 2012 *)

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

implement
{a}(*tmp*)
arrayref_make_elt (asz, x) =
  arrayptr_refize(arrayptr_make_elt<a> (asz, x))
// end of [arrayref_make_elt]

(* ****** ****** *)

implement
{}(*tmp*)
arrayref_make_intrange (l, r) =
  arrayptr_refize{int}(arrayptr_make_intrange (l, r))
// end of [arrayref_make_intrange]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayref_make_list (asz, xs) =
  arrayptr_refize(arrayptr_make_list<a> (asz, xs))
// end of [arrayref_make_list]

implement
{a}(*tmp*)
arrayref_make_rlist (asz, xs) =
  arrayptr_refize(arrayptr_make_rlist<a> (asz, xs))
// end of [arrayref_make_rlist]

(* ****** ****** *)
//
implement
{a}(*tmp*)
arrayref_head(A) = $UN.ptr0_get<a> (arrayref2ptr(A))
implement
{a}(*tmp*)
arrayref_tail{n}(A) =
  $UN.cast{arrayref(a,n-1)}(ptr_succ<a>(arrayref2ptr(A)))
//
(* ****** ****** *)

implement
{a}{tk}(*tmp*)
arrayref_get_at_gint
  (A, i) = let
//
val (vbox pf | p) =
  arrayref_get_viewptr (A) in array_get_at_gint (!p, i)
end // end of [arrayref_get_at_gint]
implement
{a}{tk}(*tmp*)
arrayref_get_at_guint
  (A, i) = let
//
val (vbox pf | p) =
  arrayref_get_viewptr (A) in array_get_at_guint (!p, i)
end // end of [arrayref_get_at_guint]

(* ****** ****** *)

implement
{a}{tk}(*tmp*)
arrayref_set_at_gint
  (A, i, x) = let
//
val (vbox pf | p) =
  arrayref_get_viewptr (A) in array_set_at_gint (!p, i, x)
//
end // end of [arrayref_set_at_gint]
implement
{a}{tk}(*tmp*)
arrayref_set_at_guint
  (A, i, x) = let
//
val (vbox pf | p) =
  arrayref_get_viewptr (A) in array_set_at_guint (!p, i, x)
//
end // end of [arrayref_set_at_guint]

(* ****** ****** *)

implement
{a}{tk}(*tmp*)
arrayref_exch_at_gint
  (A, i, x) = let
//
val (vbox pf | p) =
  arrayref_get_viewptr (A) in array_exch_at_gint (!p, i, x)
//
end // end of [arrayref_exch_at_gint]
implement
{a}{tk}(*tmp*)
arrayref_exch_at_guint
  (A, i, x) = let
//
val (vbox pf | p) =
  arrayref_get_viewptr (A) in array_exch_at_guint (!p, i, x)
//
end // end of [arrayref_exch_at_guint]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayref_interchange
  (A, i, j) = let
//
val (vbox pf | p) =
  arrayref_get_viewptr (A) in array_interchange<a> (!p, i, j)
//
end // end of [arrayref_interchange]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayref_subcirculate
  (A, i, j) = let
//
val (vbox pf | p) =
  arrayref_get_viewptr (A) in array_subcirculate<a> (!p, i, j)
//
end // end of [arrayref_subcirculate]

(* ****** ****** *)

implement
{a}(*tmp*)
fprint_arrayref
  (out, A, n) = let
//
val (vbox pf | p) = arrayref_get_viewptr (A)
//
in
  $effmask_ref (fprint_array<a> (out, !p, n))
end // end of [fprint_arrayref]

implement
{a}(*tmp*)
fprint_arrayref_sep
  (out, A, n, sep) = let
//
val (vbox pf | p) = arrayref_get_viewptr (A)
//
in
  $effmask_ref (fprint_array_sep<a> (out, !p, n, sep))
end // end of [fprint_arrayref_sep]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayref_copy
  {n} (A, n) = let
//
val (pf, fpf | p) =
  $UN.ptr0_vtake{array(a,n)}(ptrcast(A))
//
val (pf2, pf2gc | p2) = array_ptr_alloc<a> (n)
val ((*void*)) = array_copy<a> (!p2, !p, n)
//
prval ((*void*)) = fpf (pf)
//
in
  $UN.castvwtp0{arrayptr(a,n)}((pf2, pf2gc | p2))
end // end of [arrayref_copy]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayref_tabulate
  (asz) = arrayptr_refize (arrayptr_tabulate<a> (asz))
// end of [arrayref_tabulate]

implement
{a}(*tmp*)
arrayref_tabulate_cloref
  (asz, f) = arrayptr_refize (arrayptr_tabulate_cloref<a> (asz, f))
// end of [arrayref_tabulate_cloref]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayref_foreach
  (A, asz) = let
  var env: void = ()
  in arrayref_foreach_env<a><void> (A, asz, env)
end // end of [arrayref_foreach]

implement
{a}{env}
arrayref_foreach_env
  (A, asz, env) = let
//
val (vbox pf | p) = arrayref_get_viewptr (A)
//
in
  $effmask_ref (array_foreach_env<a><env> (!p, asz, env))
end // end of [arrayref_foreach_env]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayref_iforeach
  (A, asz) = let
  var env: void = () in
  arrayref_iforeach_env<a><void> (A, asz, env)
end // end of [arrayref_iforeach]

implement
{a}{env}
arrayref_iforeach_env
  (A, asz, env) = let
//
val (vbox pf | p) = arrayref_get_viewptr (A)
//
in
  $effmask_ref (array_iforeach_env<a><env> (!p, asz, env))
end // end of [arrayref_iforeach_env]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayref_rforeach
  (A, asz) = let
  var env: void = () in
  arrayref_rforeach_env<a><void> (A, asz, env)
end // end of [arrayref_rforeach]

implement
{a}{env}
arrayref_rforeach_env
  (A, asz, env) = let
//
val (vbox pf | p) = arrayref_get_viewptr (A)
//
in
  $effmask_ref (array_rforeach_env<a><env> (!p, asz, env))
end // end of [arrayref_rforeach_env]

(* ****** ****** *)

implement
{a}(*tmp*)
arrayref_quicksort
  (A, asz) = let
//
val (vbox pf | p) = arrayref_get_viewptr (A)
//
in
  $effmask_ref (array_quicksort<a> (!p, asz))
end // end of [arrayref_quicksort]

(* ****** ****** *)

local

datatype
arrszref
(
  a:viewt@ype
) =
  {n:int}
  ARRSZREF of (arrayref (a, n), size_t (n))
// end of [arrszref]

assume
arrszref_vt0ype_type = arrszref

in (* in of [local] *)

implement
{}(*tmp*)
arrszref_make_arrpsz
  (psz) = let
//
var asz: size_t
val A = arrpsz_get_ptrsize (psz, asz)
val A = arrayptr_refize (A)
//
in
  ARRSZREF(A, asz)
end // end of [arrszref_make_arrpsz]

(* ****** ****** *)
//
implement
{}(*tmp*)
arrszref_make_arrayref
  (A, asz) = ARRSZREF(A, asz)
//
(* ****** ****** *)

implement
{}(*tmp*)
arrszref_get_ref
  (ASZ) = let
//
val+
ARRSZREF(A, _) = ASZ in $UN.cast2Ptr1(A)
//
end // end of [arrszref_get_size]

(* ****** ****** *)

implement
{}(*tmp*)
arrszref_get_size
  (ASZ) = let
//
val+ARRSZREF(_, n) = ASZ in (n)
//
end // end of [arrszref_get_size]

(* ****** ****** *)

implement
{}(*tmp*)
arrszref_get_refsize
  (ASZ, nref) = let
//
val+ARRSZREF(A, n) = ASZ
//
prval () = lemma_arrayref_param (A)
//
in
  nref := n; A(*arrayref*)
end // end of [arrszref_get_refsize]

end // end of [local]

(* ****** ****** *)

implement
{a}(*tmp*)
arrszref_make_elt
  (n, x) = let
//
val n = g1ofg0_uint (n)
val A = arrayref_make_elt<a> (n, x)
//
in
  arrszref_make_arrayref (A, n)
end // end of [arrszref_make_elt]

(* ****** ****** *)

implement
{a}(*tmp*)
arrszref_make_list
  (xs) = let
//
val n = list_length<a> (xs)
val A = arrayref_make_list (n, xs)
//
prval () = lemma_list_param (xs)
//
in
  arrszref_make_arrayref (A, i2sz(n))
end // end of [arrszref_make_list]

implement
{a}(*tmp*)
arrszref_make_rlist
  (xs) = let
//
prval () = lemma_list_param (xs)
//
val n = list_length<a> (xs)
val A = arrayref_make_rlist (n, xs)
//
in
  arrszref_make_arrayref (A, i2sz(n))
end // end of [arrszref_make_rlist]

(* ****** ****** *)

implement
{a}(*tmp*)
arrszref_get_at_size
  (ASZ, i) = $effmask_wrt let
//
var n: size_t
val A = arrszref_get_refsize (ASZ, n)
val i = g1ofg0_uint (i)
//
in
//
if n > i
then arrayref_get_at_guint (A, i)
else $raise ArraySubscriptExn((*void*))
//
end // end of [arrszref_get_at_size]

implement
{a}{tk}
arrszref_get_at_gint
  (ASZ, i) = let
in
//
if (
i >= 0
) then (
  arrszref_get_at_size (ASZ, g0i2u(i))
) else (
  $raise ArraySubscriptExn((* i < 0 *))
) // end of [if]
end // end of [arrszref_get_at_gint]

implement
{a}{tk}
arrszref_get_at_guint
  (ASZ, i) = let
in
  arrszref_get_at_size (ASZ, g0u2u(i))
end // end of [arrszref_get_at_guint]

(* ****** ****** *)

implement
{a}(*tmp*)
arrszref_set_at_size
  (ASZ, i, x) = $effmask_wrt let
//
var n: size_t
val A = arrszref_get_refsize (ASZ, n)
val i = g1ofg0_uint (i)
//
in
//
if n > i
then arrayref_set_at_guint (A, i, x)
else $raise ArraySubscriptExn((*void*))
//
end // end of [arrszref_set_at_size]

implement
{a}{tk}
arrszref_set_at_gint
  (ASZ, i, x) = let
in
//
if (
i >= 0
) then (
  arrszref_set_at_size (ASZ, g0i2u(i), x)
) else $raise ArraySubscriptExn((*i < 0*))
//
end // end of [arrszref_set_at_gint]

implement
{a}{tk}
arrszref_set_at_guint
  (ASZ, i, x) = let
in
  arrszref_set_at_size (ASZ, g0u2u(i), x)
end // end of [arrszref_set_at_guint]

(* ****** ****** *)

implement
{a}(*tmp*)
arrszref_exch_at_size
  (ASZ, i, x) = $effmask_wrt let
//
var n: size_t
val A = arrszref_get_refsize (ASZ, n)
val i = g1ofg0_uint (i)
//
in
//
if n > i
then arrayref_exch_at_guint (A, i, x)
else $raise ArraySubscriptExn((*void*))
// end of [if]
//
end // end of [arrszref_exch_at_size]

implement
{a}{tk}
arrszref_exch_at_gint
  (ASZ, i, x) = let
in
//
if (
i >= 0
) then (
  arrszref_exch_at_size (ASZ, g0i2u(i), x)
) else $raise ArraySubscriptExn((*i < 0*))
//
end // end of [arrszref_exch_at_gint]

implement
{a}{tk}
arrszref_exch_at_guint
  (ASZ, i, x) = let
in
  arrszref_exch_at_size (ASZ, g0u2u(i), x)
end // end of [arrszref_exch_at_guint]

(* ****** ****** *)

implement
{a}(*tmp*)
arrszref_interchange
(
  ASZ, i, j
) = $effmask_wrt let
//
var n: size_t
val A = arrszref_get_refsize (ASZ, n)
val i = g1ofg0_uint (i)
val j = g1ofg0_uint (j)
//
in
//
if n > i
then (
  if n > j
  then arrayref_interchange (A, i, j)
  else $raise ArraySubscriptExn((*void*))
) else $raise ArraySubscriptExn((*void*))
//
end // end of [arrszref_interchange]

(* ****** ****** *)

implement
{a}(*tmp*)
arrszref_subcirculate
(
  ASZ, i, j
) = $effmask_wrt let
//
var n: size_t
val A = arrszref_get_refsize (ASZ, n)
val i = g1ofg0_uint (i)
val j = g1ofg0_uint (j)
//
in
//
if n > i
then (
  if n > j
  then arrayref_subcirculate (A, i, j)
  else $raise ArraySubscriptExn((*void*))
) else $raise ArraySubscriptExn((*void*))
//
end // end of [arrszref_subcirculate]

(* ****** ****** *)

implement
{a}(*tmp*)
fprint_arrszref
  (out, ASZ) = let
//
var asz: size_t
val A = arrszref_get_refsize (ASZ, asz)
//
in
  fprint_arrayref (out, A, asz)
end // end of [fprint_arrszref]

implement
{a}(*tmp*)
fprint_arrszref_sep
  (out, ASZ, sep) = let
//
var asz: size_t
val A = arrszref_get_refsize (ASZ, asz)
//
in
  fprint_arrayref_sep (out, A, asz, sep)
end // end of [fprint_arrszref_sep]

(* ****** ****** *)
//
implement
{a}(*tmp*)
arrszref_tabulate (asz) = let
  val asz = g1ofg0_uint (asz)
  val A = arrayref_tabulate<a> (asz) in arrszref_make_arrayref(A, asz)
end // end of [arrszref_tabulate]
//
implement
{a}(*tmp*)
arrszref_tabulate_cloref (asz, f) = let
  val A = arrayref_tabulate_cloref<a> (asz, f) in arrszref_make_arrayref(A, asz)
end // end of [arrszref_tabulate_cloref]
//
(* ****** ****** *)

(* end of [arrayref.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/matrix.atxt
** Time of generation: Sat Oct 17 15:19:57 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: Feburary, 2012 *)

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

implement{a}
matrix_getref_at_int
  (M, i, n, j) =
  $UN.cast{cPtr1(a)}(ptr_add<a> (addr@(M), i*n+j))
// end of [matrix_getref_at_int]

implement{a}
matrix_getref_at_size
  (M, i, n, j) =
  $UN.cast{cPtr1(a)}(ptr_add<a> (addr@(M), i*n+j))
// end of [matrix_getref_at_size]

(* ****** ****** *)

implement{a}
matrix_get_at_int
  (M, i, n, j) = $UN.cptr_get (matrix_getref_at_int (M, i, n, j))
// end of [matrix_get_at_int]

implement{a}
matrix_set_at_int
  (M, i, n, j, x) = $UN.cptr_set (matrix_getref_at_int (M, i, n, j), x)
// end of [matrix_set_at_int]

implement{a}
matrix_exch_at_int
  (M, i, n, j, x) = $UN.cptr_exch (matrix_getref_at_int (M, i, n, j), x)
// end of [matrix_exch_at_int]

(* ****** ****** *)

implement{a}
matrix_get_at_size
  (M, i, n, j) = $UN.cptr_get (matrix_getref_at_size (M, i, n, j))
// end of [matrix_get_at_size]

implement{a}
matrix_set_at_size
  (M, i, n, j, x) = $UN.cptr_set (matrix_getref_at_size (M, i, n, j), x)
// end of [matrix_set_at_size]

implement{a}
matrix_exch_at_size
  (M, i, n, j, x) = $UN.cptr_exch (matrix_getref_at_size (M, i, n, j), x)
// end of [matrix_exch_at_size]

(* ****** ****** *)

implement{a}
matrix_ptr_alloc
  (row, col) = let
//
val
(
  pfarr, pfgc | p
) = array_ptr_alloc<a> (row*col)
//
prval pfmat = array2matrix_v(pfarr)
//
in
  @(pfmat, pfgc | p)
end // end of [matrix_ptr_alloc]

(* ****** ****** *)

implement{}
matrix_ptr_free
  {a} (pfmat, pfgc | p) = let
//
prval pfarr = matrix2array_v (pfmat)
//
in
  array_ptr_free (pfarr, pfgc | p)
end // end of [matrix_ptr_free]

(* ****** ****** *)

implement{a}
matrix_ptr_tabulate
  (row, col) = let
//
val (pf, pfgc | p) = matrix_ptr_alloc<a> (row, col)
//
implement
matrix_initize$init<a> (i, j, x) = x := matrix_tabulate$fopr<a> (i, j)
//
val () = matrix_initize<a> (!p, row, col)
//
in
  @(pf, pfgc | p)
end // end of [matrix_ptr_tabulate]

(* ****** ****** *)

implement{}
fprint_matrix$sep1 (out) = fprint (out, ", ")
implement{}
fprint_matrix$sep2 (out) = fprint (out, "; ")

implement{a}
fprint_matrix_int
  (out, M, m, n) = let
//
prval () = lemma_matrix_param (M)
//
in
  fprint_matrix_size (out, M, i2sz(m), i2sz(n))
end // end of [fprint_matrix_int]

implement{a}
fprint_matrix_size
  {m,n} (out, M, m, n) = let
//
implement
fprint_array$sep<> (out) = fprint_matrix$sep1 (out)
//
fun loop {l:addr}
(
  out: FILEref, p0: ptr l, m: size_t m, n: size_t n, i: size_t
) : void = let
in
//
if i < m then let
  val () =
  (
    if i > 0 then fprint_matrix$sep2 (out)
  ) : void // end of [val]
  val (
    pf, fpf | p0
  ) = $UN.ptr_vtake{array(a,n)}(p0)
  val () = fprint_array (out, !p0, n)
  prval () = fpf (pf)
in
  loop (out, ptr_add<a> (p0, n), m, n, succ(i))
end else () // end of [if]
//
end // end of [loop]
//
in
  loop (out, addr@ (M), m, n, i2sz(0))
end // end of [fprint_matrix_size]

(* ****** ****** *)

implement{a}
fprint_matrix_sep
(
  out, M, m, n, sep1, sep2
) = let
//
implement
fprint_matrix$sep1<> (out) = fprint (out, sep1)
implement
fprint_matrix$sep2<> (out) = fprint (out, sep2)
//
in
  fprint_matrix_size (out, M, m, n)
end // end of [fprint_matrix_sep]

(* ****** ****** *)

implement{a}
matrix_foreach (A, m, n) = let
  var env: void = () in matrix_foreach_env<a><void> (A, m, n, env)
end // end of [matrix_foreach]

implement
{a}{env}
matrix_foreach_env
  (A, m, n, env) = let
//
implement
array_foreach$cont<a><env> (x, env) = true
implement
array_foreach$fwork<a><env> (x, env) = matrix_foreach$fwork<a><env> (x, env)
//
val p = addr@(A)
prval pf = matrix2array_v (view@(A))
val _(*mn*) = array_foreach_env<a> (!p, m*n, env)
prval () = view@(A) := array2matrix_v (pf)
//
in
  // nothing
end // end of [matrix_foreach_env]

(* ****** ****** *)

implement{a}
matrix_initize
  (M, m, n) = let
//
infixl (/) %
#define % g0uint_mod
//
implement
array_initize$init<a>
  (ij, x) = let
in
  matrix_initize$init<a> (ij/n, ij%n, x)
end // end of [array_initize$init]
//
val p = addr@(M)
prval pf = matrix2array_v (view@(M))
val () = array_initize<a> (!p, m * n)
prval () = view@(M) := array2matrix_v (pf)
//
in
  // nothing
end // end of [matrix_initize]

(* ****** ****** *)

implement
{a}{b}
matrix_mapto
  {m,n} (A, B, m, n) = let
//
val pA = addr@(A)
val pB = addr@(B)
//
prval pfA = matrix2array_v (view@(A))
prval pfB = matrix2array_v (view@(B))
//
local
//
implement
array_mapto$fwork<a><b>
  (x, y) = matrix_mapto$fwork<a><b> (x, y)
//
in (* in of [local] *)
//
val ((*void*)) = array_mapto<a><b> (!pA, !pB, m*n)
//
end // end of [local]
//
prval () = view@(A) := array2matrix_v {a}{..}{m,n} (pfA)
prval () = view@(B) := array2matrix_v {b}{..}{m,n} (pfB)
//
in
  // nothing
end (* end of [matrix_mapto] *)

(* ****** ****** *)

implement
{a,b}{c}
matrix_map2to
  {m,n} (A, B, C, m, n) = let
//
val pA = addr@(A)
val pB = addr@(B)
val pC = addr@(C)
//
prval pfA = matrix2array_v (view@(A))
prval pfB = matrix2array_v (view@(B))
prval pfC = matrix2array_v (view@(C))
//
local
//
implement
array_map2to$fwork<a,b><c>
  (x, y, z) = matrix_map2to$fwork<a,b><c> (x, y, z)
//
in (* in of [local] *)
//
val ((*void*)) = array_map2to<a,b><c> (!pA, !pB, !pC, m*n)
//
end // end of [local]
//
prval () = view@(A) := array2matrix_v {a}{..}{m,n} (pfA)
prval () = view@(B) := array2matrix_v {b}{..}{m,n} (pfB)
prval () = view@(C) := array2matrix_v {c}{..}{m,n} (pfC)
//
in
  // nothing
end (* end of [matrix_map2to] *)

(* ****** ****** *)

(* end of [matrix.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/char.atxt
** Time of generation: Sat Oct 17 15:19:52 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: Feburary, 2012 *)

(* ****** ****** *)

#define ATS_DYNLOADFLAG 0 // no dynloading at run-time

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

implement{tk}
g0int_of_char
  (c) = __cast (c) where {
  extern castfn __cast (c: char):<> g0int (tk)
} // end of [g0int_of_char]
implement{tk}
g0int_of_schar
  (c) = __cast (c) where {
  extern castfn __cast (c: schar):<> g0int (tk)
} // end of [g0int_of_schar]
implement{tk}
g0int_of_uchar
  (c) = __cast (c) where {
  extern castfn __cast (c: uchar):<> g0int (tk)
} // end of [g0int_of_uchar]

implement{tk}
g0uint_of_uchar
  (c) = __cast (c) where {
  extern castfn __cast (c: uchar):<> g0uint (tk)
} // end of [g0uint_of_uchar]

(* ****** ****** *)

implement{tk}
g1int_of_char1
  {c} (c) = __cast (c) where {
  extern castfn __cast (c: char c):<> g1int (tk, c)
} // end of [g1int_of_char1]
implement{tk}
g1int_of_schar1
  {c} (c) = __cast (c) where {
  extern castfn __cast (c: schar c):<> g1int (tk, c)
} // end of [g1int_of_schar1]
implement{tk}
g1int_of_uchar1
  {c} (c) = __cast (c) where {
  extern castfn __cast (c: uchar c):<> g1int (tk, c)
} // end of [g1int_of_uchar1]

implement{tk}
g1uint_of_uchar1
  {c} (c) = __cast (c) where {
  extern castfn __cast (c: uchar c):<> g1uint (tk, c)
} // end of [g1uint_of_uchar1]

(* ****** ****** *)

implement
{}(*tmp*)
char2string(c) =
$effmask_wrt
(
  $UN.castvwtp0{string}(char2strptr(c))
) (* end of [char2string] *)
implement
{}(*tmp*)
char2strptr(c) = let
//
#define BSZ 16
//
typedef
cstring = $extype"atstype_string"
//
var buf = @[byte][BSZ]()
val bufp = $UN.cast{cstring}(addr@buf)
//
val _(*int*) =
  $extfcall(ssize_t, "snprintf", bufp, BSZ, "%c", c)
//
in
  $UN.castvwtp0{Strptr1}(string0_copy($UN.cast{string}(bufp)))
end // end of [char2strptr]

(* ****** ****** *)
//
implement fprint_val<char> = fprint_char
implement fprint_val<uchar> = fprint_uchar
implement fprint_val<schar> = fprint_schar
//
(* ****** ****** *)

(* end of [char.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: February, 2012
//
(* ****** ****** *)

#include "prelude/params.hats"

(* ****** ****** *)

#if VERBOSE_PRELUDE #then
#print "Loading [fcontainer.dats] starts!\n"
#endif // end of [VERBOSE_PRELUDE]

(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"
// end of [staload]

(* ****** ****** *)

staload "prelude/SATS/fcontainer.sats"

(* ****** ****** *)

implement
{xs}{x}
iforeach (xs) = let
//
var i
  : size_t = g0int2uint (0)
val p_i = $UN.cast2Ptr1 (addr@ (i))
//
implement
foreach$fwork<x>
  (x) = () where {
  val i = $UN.ptr1_get<size_t> (p_i)
  val () = iforeach$fwork<x> (i, x)
  val () = $UN.ptr1_set<size_t> (p_i, succ(i))
} // [foreach$work]
//
in
  foreach<xs><x> (xs)
end // end of [iforeach]

(* ****** ****** *)

implement
{xs}{x}{init}
foldleft_funenv
  {v}{vt}{fe:eff}
  (pfv | xs, init, f, env) = let
//
var res: init = init
viewtypedef pvt = (ptr(res), vt)
//
val env1 = __cast (env) where {
  extern castfn __cast (env: !vt >> vt?):<> vt
} // end of [val]
//
val p_res = addr@ (res)
var penv: pvt = (p_res, env1)
viewdef v1 = (v, init@res, pvt @ penv)
fn f1 (
  pf: !v1 | x: x, penv: !ptr(penv)
) :<fe> void = let
  val p = penv->0
  val x = f (pf.0 | !p, x, penv->1)
in
  $effmask_wrt (!p := x)
end // end of [f1]
//
prval pfv1 = (pfv, view@(res), view@(penv))
val () = foreach_funenv{v1}{ptr(penv)} (pfv1 | xs, f1, addr@(penv))
prval () = pfv := pfv1.0
prval () = view@(res) := pfv1.1
prval () = view@(penv) := pfv1.2
//
prval () =
  __xfree (env, penv.1) where {
  extern praxi __xfree (env: !vt? >> vt, env1: vt): void
} // end of [where] // end of [prval]
//
in
  res
end // end of [foldleft_funenv]

implement
{xs}{x}{init}
foldleft_clo
  {fe:eff}(xs, init, f) = let
  typedef clo_t =
    (init, x) -<clo,fe> init
  // end of [typedef]
  val p_f = addr@ (f)
  prval [lf:addr]
    EQADDR () = ptr_get_index (p_f)
  viewdef v = clo_t @ lf
  fn app (
    pf: !v | init: init, x: x, p_f: !ptr(lf)
  ) :<fe> init = !p_f (init, x)
in
  foldleft_funenv<xs><x> {v}{ptr(lf)} (view@ f | xs, init, app, p_f)
end // end of [foldleft_clo]

implement
{xs}{x}{init}
foldleft_vclo
  {v} {fe:eff}
  (pfv | xs, init, f) = let
  typedef clo_t =
    (!v | init, x) -<clo,fe> init
  // end of [typedef]
  val p_f = addr@ (f)
  prval [lf:addr]
    EQADDR () = ptr_get_index (p_f)
  viewdef v2 = (v, clo_t @ lf)
  fn app (
    pf: !v2
  | init: init, x: x, p_f: !ptr lf
  ) :<fe> init = res where {
    prval (pf1, pf2) = pf
    val res = !p_f (pf1 | init, x)
    prval () = pf := (pf1, pf2)
  } // end of [val]
  prval pf = (pfv, view@ f)
  val res = foldleft_funenv<xs><x> {v2} {ptr(lf)} (pf | xs, init, app, p_f)
  prval () = pfv := pf.0 and () = view@ (f) := pf.1
in
  res(*init*)
end // end of [foldleft_vclo]

implement
{xs}{x}{init}
foldleft_cloref
  {fe:eff} (xs, init, f) = let
  typedef cloref_t = (init, x) -<cloref,fe> init
  fn app (
    pf: !unit_v | init: init, x: x, f: !cloref_t 
  ) :<fe> init = f (init, x)
  prval pfu = unit_v ()
  val res = foldleft_funenv<xs><x> {unit_v} {cloref_t} (pfu | xs, init, app, f)
  prval unit_v () = pfu
in
  res(*init*)
end // end of [foldleft_cloref]

(* ****** ****** *)

implement
{xs}{x}{sink}
foldright_funenv
  {v}{vt}{fe:eff}
  (pfv | xs, f, sink, env) = let
//
typedef tfun = (!v | x, sink, !vt) -<fun,fe> sink
//
fun loop {n:nat} .<n>. (
  pfv: !v
| xs: list_vt (x, n), f: tfun, sink: sink, env: !vt
) :<fe> sink = (
  case+ xs of
  | ~list_vt_cons (x, xs) =>
      loop (pfv | xs, f, f (pfv | x, sink, env), env)
  | ~list_vt_nil () => sink
) (* end of [loop] *)
//
val rxs = rlistize (xs)
//
in
  loop (pfv | rxs, f, sink, env)
end // end of [foldright_funenv]

implement
{xs}{x}{sink}
foldright_clo
  {fe:eff}(xs, f, sink) = let
  typedef clo_t =
    (x, sink) -<clo,fe> sink
  // end of [typedef]
  val p_f = addr@ (f)
  prval [lf:addr]
    EQADDR () = ptr_get_index (p_f)
  viewdef v = clo_t @ lf
  fn app (
    pf: !v | x: x, sink: sink, p_f: !ptr(lf)
  ) :<fe> sink = !p_f (x, sink)
in
  foldright_funenv<xs><x> {v}{ptr(lf)} (view@ f | xs, app, sink, p_f)
end // end of [foldright_clo]
implement
{xs}{x}{sink}
foldright_vclo
  {v} {fe:eff}
  (pfv | xs, f, sink) = let
  typedef clo_t =
    (!v | x, sink) -<clo,fe> sink
  // end of [typedef]
  val p_f = addr@ (f)
  prval [lf:addr]
    EQADDR () = ptr_get_index (p_f)
  viewdef v2 = (v, clo_t @ lf)
  fn app (
    pf: !v2 | x: x, sink: sink, p_f: !ptr lf
  ) :<fe> sink = res where {
    prval (pf1, pf2) = pf
    val res = !p_f (pf1 | x, sink)
    prval () = pf := (pf1, pf2)
  } // end of [val]
  prval pf = (pfv, view@ f)
  val res = foldright_funenv<xs><x> {v2} {ptr(lf)} (pf | xs, app, sink, p_f)
  prval () = pfv := pf.0 and () = view@ (f) := pf.1
in
  res(*sink*)
end // end of [foldright_vclo]

implement
{xs}{x}{sink}
foldright_cloref
  {fe:eff} (xs, f, sink) = let
  typedef cloref_t = (x, sink) -<cloref,fe> sink
  fn app (
    pf: !unit_v | x: x, sink: sink, f: !cloref_t 
  ) :<fe> sink = f (x, sink)
  prval pfu = unit_v ()
  val res = foldright_funenv<xs><x> {unit_v} {cloref_t} (pfu | xs, app, sink, f)
  prval unit_v () = pfu
in
  res(*sink*)
end // end of [foldright_cloref]

(* ****** ****** *)
//
// HX-2012-02:
// this implementation makes use
// of the (local) exception mechanism
//
implement
{xs}{x}
exists_funenv
  {v}{vt}{fe:eff}
  (pfv | xs, p, env) = let
  exception Found of ()
  fn f (
    pfv: !v | x: x, env: !vt
  ) :<fe,!exn> void =
    if p (pfv | x, env) then $raise (Found) else ()
  // end of [f]
  val ptr = __cast (env) where {
    extern castfn __cast (env: !vt):<> ptr
  } // end of [val]
in try let
  val env = __encode (ptr) where {
    extern castfn __encode (x: ptr):<> vt
  } // end of [val]
  prval (pfv, fpfv) = __assert () where {
    extern praxi __assert (): (v, v -<lin,prf> void)
  } // end of [prval]
  val () = $effmask_exn (foreach_funenv<xs><x> (pfv | xs, f, env))
  prval () = fpfv (pfv)
  val ptr = __decode (env) where {
    extern castfn __decode (x: vt):<> ptr
  } // end of [val]
in
  true (* element satifying [p] is found *)
end with
  ~Found () => false
// end of [try]
end // end of [exists_funenv]

(* ****** ****** *)

implement
{xs}{x}
forall_funenv
  {v}{vt}{fe:eff}
  (pfv | xs, p, env) = let
  fn np (pfv: !v | x: x, env: !vt):<fe> bool = ~p (pfv | x, env)
in
  ~(exists_funenv<xs><x> (pfv | xs, np, env))
end // end of [forall_funenv]

(* ****** ****** *)

implement
{xs}{x}
ismember_fun
  {fe} (xs, x0, eq) = let
  var p_clo =
    lam@ (x: x) =<fe> eq (x0, x) in exists_clo<xs><x> (xs, p_clo)
  // end of [var]
end // end of [ismemer_fun]

(* ****** ****** *)

implement
{xs}{x}
rlistize (xs) = res where {
  var res
    : List0_vt (x) = list_vt_nil ()
  viewdef v = List0_vt (x) @ res
  var p_clo = lam@ (
    pf: !v >> v | x: x
  ) : void =<clo> $effmask_wrt (res := list_vt_cons (x, res))
  val () = foreach_vclo {v}{effnil} (view@ (res) | xs, p_clo)
} // end of [rlistize]

implement
{xs}{x}{y}
rlistize_funenv
  {v}{vt}{fe}
  (pfv | xs, f, env) = let
  var res
    : List0_vt (y) = list_vt_nil ()
  viewdef v2 = @(v, List0_vt (y) @ res)
  val ptr =
    $UN.castvwtp1 {ptr}{vt} (env)
  // end of [val]
  var p_clo = lam@
    (pf: !v2 >> v2 | x: x): void =<clo,fe> let
    extern castfn __encode (x: ptr):<> vt
    extern castfn __decode (x: vt):<> ptr
    val env = __encode (ptr)
    val y = f (pf.0 | x, env)
    val ptr = __decode (env)
    prval pfat = pf.1
    val () = $effmask_wrt (res := list_vt_cons (y, res))
    prval () = pf.1 := pfat
  in
    (*nothing*)
  end // end of [var]
  prval pf = (pfv, view@ (res))
  val () = foreach_vclo {v2} (pf | xs, p_clo)
  prval () = pfv := pf.0
  prval () = view@ (res) := pf.1
in
  res
end // end of [rlistize_funenv]

(* ****** ****** *)

#if VERBOSE_PRELUDE #then
#print "Loading [fcontainer.dats] finishes!\n"
#endif // end of [VERBOSE_PRELUDE]

(* ****** ****** *)

(* end of [fcontainer.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: February, 2012
//
(* ****** ****** *)

#include "prelude/params.hats"

(* ****** ****** *)

#if VERBOSE_PRELUDE #then
#print "Loading [giterator.dats] starts!\n"
#endif // end of [VERBOSE_PRELUDE]

(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"
// end of [staload]

(* ****** ****** *)

staload "prelude/SATS/giterator.sats"

(* ****** ****** *)

implement
{knd}{x}
fprint_giter_sep
  {kpm}{f,r}
  (out, itr, sep) = let
//
val () = lemma_giter_param (itr)
//
stadef giter
  (f:int, r:int) = giter (knd, kpm, x, f, r)
//
fun loop
  {f,r:int | r >= 0} .<r>. (
  out: FILEref
, itr: !giter (f, r) >> giter (f+r, 0)
, sep: string
, notbeg: bool
) : void = let
  val test = giter_isnot_atend (itr)
in
  if test then let
    val p = giter_getref_inc<knd><x> (itr)
    val (pf, fpf | p) = $UN.ptr_vtake{x}(p)
    val () = if notbeg then fprint_string (out, sep)
    val () = fprint_ref<x> (out, !p)
    prval () = fpf (pf)
  in
    loop (out, itr, sep, true)
  end else () // end of [if]
end // end of [loop]
//
in
  loop (out, itr, sep, false(*notbeg*))
end // end of [fprint_giter_sep]

(* ****** ****** *)

implement
{knd}{x}
giter_isnot_atbeg (itr) = let
  prval () = lemma_giter_param (itr) in ~giter_is_atbeg (itr)
end // end of [giter_isnot_atbeg]

implement
{knd}{x}
giter_isnot_atend (itr) = let
  prval () = lemma_giter_param (itr) in ~giter_is_atend (itr)
end // end of [giter_isnot_atend]

(* ****** ****** *)

implement
{knd}{x}
giter_vttake (itr) = let
  val p =
    giter_getref<knd><x> (itr)
  val (
    pf, fpf | p
  ) = $UN.ptr_vtake{x}(p)
  val res = $UN.vttakeout_void{x}(!p)
  prval () = fpf (pf)
in
  res
end // end of [giter_vttake]

implement
{knd}{x}
giter_get (itr) = x where {
  val (fpf | x) = giter_vttake<knd><x> (itr); prval () = fpf (x)
} // end of [giter_get]

implement
{knd}{x}
giter_set (itr, x) =
  $UN.ptr1_set<x> (giter_getref<knd><x> (itr), x)
// end of [giter_set]

(* ****** ****** *)

implement
{knd}{x}
giter_getref_inc (itr) = let
  val p = giter_getref<knd><x> (itr) in giter_inc<knd><x> (itr); p
end // end of [giter_getref_inc]

implement
{knd}{x}
giter_vttake_inc (itr) = let
  val p =
    giter_getref_inc<knd><x> (itr)
  val (
    pf, fpf | p
  ) = $UN.ptr_vtake{x}(p)
  val res = $UN.vttakeout_void{x}(!p)
  prval () = fpf (pf)
in
  res
end // end of [giter_vttake_inc]

implement
{knd}{x}
giter_get_inc
  (itr) = x where {
  val (fpf | x) =
    giter_vttake_inc<knd><x> (itr)
  prval () = fpf (x)
} // end of [giter_get_inc]
implement
{knd}{x}
giter_set_inc (itr, x) =
  $UN.ptr1_set<x> (giter_getref_inc<knd><x> (itr), x)
// end of [giter_set_inc]
implement
{knd}{x}
giter_exch_inc (itr, x) =
  $UN.ptr1_exch<x> (giter_getref_inc<knd><x> (itr), x)
// end of [giter_exch_inc]

(* ****** ****** *)

implement
{knd}{x}
giter_dec_getref (itr) = let
  prval () =
    lemma_giter_param (itr)
  val () = giter_dec<knd><x> (itr)
in
  giter_getref<knd><x> (itr)
end // end of [giter_dec_getref]

implement
{knd}{x}
giter_dec_vttake (itr) = let
  val p =
    giter_dec_getref<knd><x> (itr)
  val (
    pf, fpf | p
  ) = $UN.ptr_vtake{x}(p)
  val res = $UN.vttakeout_void{x}(!p)
  prval () = fpf (pf)
in
  res
end // end of [giter_dec_vttake]

implement
{knd}{x}
giter_dec_get
  (itr) = x where {
  val (fpf | x) =
    giter_dec_vttake<knd><x> (itr)
  prval () = fpf (x)
} // end of [giter_dec_get]
implement
{knd}{x}
giter_dec_set (itr, x) =
  $UN.ptr1_set<x> (giter_dec_getref<knd><x> (itr), x)
// end of [giter_dec_set]
implement
{knd}{x}
giter_dec_exch (itr, x) =
  $UN.ptr1_exch<x> (giter_dec_getref<knd><x> (itr), x)
// end of [giter_dec_exch]

(* ****** ****** *)
(*
** HX: forward-get, set and exchange
*)
implement
{knd}{x}
giter_fget_at (itr, i) =
  $UN.ptr1_get<x> (giter_fgetref_at<knd><x> (itr, i))
// end of [giter_fget_at]
implement
{knd}{x}
giter_fset_at (itr, i, x) =
  $UN.ptr1_set<x> (giter_fgetref_at<knd><x> (itr, i), x)
// end of [giter_fset_at]
implement
{knd}{x}
giter_fexch_at (itr, i, x) =
  $UN.ptr1_exch<x> (giter_fgetref_at<knd><x> (itr, i), x)
// end of [giter_fexch_at]

(* ****** ****** *)
(*
** HX: forward/backward-get, set and exchange
*)
implement
{knd}{x}
giter_fbget_at (itr, i) =
  $UN.ptr1_get<x> (giter_fbgetref_at<knd><x> (itr, i))
// end of [giter_fbget_at]
implement
{knd}{x}
giter_fbset_at (itr, i, x) =
  $UN.ptr1_set<x> (giter_fbgetref_at<knd><x> (itr, i), x)
// end of [giter_fbset_at]
implement
{knd}{x}
giter_fbexch_at (itr, i, x) =
  $UN.ptr1_exch<x> (giter_fbgetref_at<knd><x> (itr, i), x)
// end of [giter_fbexch_at]

(* ****** ****** *)

implement
{knd}{x}
giter_fgetlst {kpm} (itr, i) = let
//
prval () = lemma_giter_param (itr)
//
stadef giter
  (f:int, r:int) = giter (knd, kpm, x, f, r)
//
fun loop
  {f,r:int | r >= 0} {i:nat} .<r>. (
  itr: !giter (f, r) >> giter (f+i1, r-i1)
, i: &int(i) >> int(i-i1)
, res: &ptr? >> list_vt (x, i1)
) : #[i1:int | i1 == min(i,r)] void = let
in
//
if i > 0 then let
  val test = giter_isnot_atend (itr)
in
  if test then let
    val () = i := i - 1
    val x = giter_get_inc (itr)
    val () = res :=
      list_vt_cons {x}{0} (x, _)
    val+ list_vt_cons (x, res1) = res
    val () = loop (itr, i, res1)
    prval () = fold@ (res)
  in
    // nothing
  end else (res := list_vt_nil)
end else (res := list_vt_nil) // endif
//
end // end of [loop]
//
var res: ptr
val () = loop (itr, i, res)
//
in
  res
end // end of [giter_fgetlst]

(* ****** ****** *)

implement
{knd}{x}
giter_bgetlst {kpm} (itr, i) = let
//
prval () = lemma_giter_param (itr)
//
stadef giter
  (f:int, r:int) = giter (knd, kpm, x, f, r)
//
fun loop
  {f,r:int | f >= 0} {i:nat} .<f>. (
  itr: !giter (f, r) >> giter (f-i1, r+i1)
, i: &int(i) >> int(i-i1)
, res: &ptr? >> list_vt (x, i1)
) : #[i1:int | i1 == min(i,f)] void = let
in
//
if i > 0 then let
  val test = giter_isnot_atbeg (itr)
in
  if test then let
    val () = i := i - 1
    val x = giter_dec_get (itr)
    val () = res :=
      list_vt_cons {x}{0} (x, _)
    val+ list_vt_cons (x, res1) = res
    val () = loop (itr, i, res1)
    prval () = fold@ (res)
  in
    // nothing
  end else (res := list_vt_nil)
end else (res := list_vt_nil) // endif
//
end // end of [loop]
//
var res: ptr
val () = loop (itr, i, res)
//
in
  res
end // end of [giter_bgetlst]

(* ****** ****** *)

implement
{knd}{x}
giter_ins_inc (itr, x) = let
  prval () = lemma_giter_param (itr)
  val () = giter_ins (itr, x) in giter_inc (itr)
end // end of [giter_ins_inc]

implement
{knd}{x}
giter_dec_rmv (itr) = let
  prval () = lemma_giter_param (itr)
  val () = giter_dec (itr) in giter_rmv (itr)
end // end of [giter_dec_rmv]

(* ****** ****** *)
//
// HX: some common generic functions on giterators
//
(* ****** ****** *)

implement
{knd}{x}
giter_listize_cpy {kpm} (itr) = let
//
prval () = lemma_giter_param (itr)
//
stadef giter (f:int, r:int) = giter (knd, kpm, x, f, r)
//
fun loop
  {f,r:int | r >= 0} .<r>. (
  itr: !giter (f, r) >> giter (f+r, 0), res: &ptr? >> list_vt (x, r)
) : void = let
  val test = giter_isnot_atend (itr)
in
  if test then let
    val x = giter_get_inc (itr)
    val () = res :=
      list_vt_cons {x}{0} (x, _)
    val+ list_vt_cons (x, res1) = res
    val () = loop (itr, res1)
    prval () = fold@ (res)
  in
    // nothing
  end else (res := list_vt_nil)
end // end of [loop]
//
var res: ptr
val () = loop (itr, res)
//
in
  res
end // end of [giter_listize_cpy]

implement
{knd}{x}
giter_rlistize_cpy
  {kpm} (itr) = let
//
prval () = lemma_giter_param (itr)
//
stadef giter (f:int, r:int) = giter (knd, kpm, x, f, r)
//
fun loop
  {f,r:int | r >= 0}{r2:nat} .<r>. (
  itr: !giter (f, r) >> giter (f+r, 0), res: list_vt (x, r2)
) : list_vt (x, r+r2) = let
  val test = giter_isnot_atend (itr)
in
  if test then let
    val x = giter_get_inc (itr)
  in
    loop (itr, list_vt_cons (x, res))
  end else res // end of [if]
end // end of [loop]
//
in
  loop (itr, list_vt_nil)
end // end of [giter_listize_cpy]

(* ****** ****** *)

implement
{knd}{x}
giter_foreach (itr) = let
  var env: void = () in giter_foreach_env<knd><x><void> (itr, env)
end // end of [giter_foreach]

implement
{knd}{x}{env}
giter_foreach_env
  {kpm}{f,r} (itr, env) = let
//
prval () = lemma_giter_param (itr)
//
stadef giter (f:int, r:int) = giter (knd, kpm, x, f, r)
//
fun loop
  {f,r:int | r >= 0} .<r>. (
  itr: !giter (f, r) >> giter (f1, r1), env: &env
) : #[f1,r1:int | f <= f1 | f+r==f1+r1] void = let
  val isnotend =
    giter_isnot_atend<knd><x> (itr) 
  // end of [val]
in
  if isnotend then let
    val p =
      giter_getref_inc<knd><x> (itr)
    val (pf, fpf | p) = $UN.ptr_vtake{x}(p)
    val cont = giter_foreach$cont (!p, env)
  in
    if cont then let
      val () = giter_foreach$fwork (!p, env)
      prval () = fpf (pf)
    in
      loop (itr, env)
    end else let
      prval () = fpf (pf)
    in
      (*nothing*)
    end // end of [if]
  end else ((*void*)) // end of [if]
end // end of [loop]
//
in
  loop (itr, env)
end // end of [giter_foreach_env]

(* ****** ****** *)
(*
** HX-2012-05-23:
** this is a very exiciting example for myself :)
*)
implement
{knd}{x}
giter_bsearch
  {kpm} (itr, ra) = let
//
prval () = lemma_giter_param (itr)
prval () = lemma_g1uint_param (ra)
//
stadef giter
  (f:int, r:int) = giter (knd, kpm, x, f, r)
//
fun loop
  {f,r:nat}
  {ra:nat | ra <= r} .<ra>. (
  itr: !giter (f, r) >> giter (f1, r1)
, ra: size_t (ra)
) : #[
  f1,r1:int | f1>=f;f+ra>=f1;f+r==f1+r1
] void = (
  if ra > 0 then let
    val ra2 = half (ra)
    val p =
      giter_fgetref_at (itr, ra2)
    val (
      pf, fpf | p
    ) = $UN.ptr_vtake{x}(p)
    val sgn = giter_bsearch$ford (!p)
    prval () = fpf (pf)
  in
    if sgn <= 0 then
      loop (itr, ra2)
    else let
      val ra21 = succ(ra2)
      val () = giter_fjmp (itr, ra21)
    in
      loop (itr, ra-ra21)
    end // end of [if]
  end else () // end of [if]
) (* end of [loop] *)
//
in
  loop (itr, ra)
end // end of [giter_bsearch]

(* ****** ****** *)

#if VERBOSE_PRELUDE #then
#print "Loading [giterator.dats] finishes!\n"
#endif // end of [VERBOSE_PRELUDE]

(* ****** ****** *)

(* end of [giterator.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/list.atxt
** Time of generation: Sun Oct 18 08:38:09 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: July, 2012 *)

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)
//
// HX-2014-04-07:
// This is a wild implementation!
//
implement
{a}(*tmp*)
stream_vt2t(xs) = let
//
fun
aux (
  xs: stream_vt(a)
) :<!laz> stream(a) = let
//
val xs = $UN.castvwtp0{ptr}(xs)
//
in
//
$delay
(
let
  val xs =
    $UN.castvwtp0{stream_vt(a)}(xs)
  val xs_con = !xs
in
  case+ xs_con of
  | ~stream_vt_nil
      ((*void*)) => stream_nil ()
    // end of [stream_vt_nil]
  | @stream_vt_cons
      (x, xs1) => let
      val xs1_val = xs1
      val () = xs1 := aux (xs1_val)
    in
      $UN.castvwtp0{stream_con(a)}((view@x, view@xs1 | xs_con))
    end // end of [stream_cons]
end
)
end // end of [aux]
//
in
  aux (xs)
end // end of [stream_vt2t]

(* ****** ****** *)

local
//
// HX-2012: casting stream_vt_cons to list_cons
//
extern
castfn
stream2list_vt_cons
  {l0,l1,l2:addr}
(
  stream_vt_cons_unfold (l0, l1, l2)
) :<> list_vt_cons_unfold (l0, l1, l2)

in (* in-of-local *)

implement
{a}(*tmp*)
stream2list_vt(xs) = let
//
fun
loop (
  xs: stream_vt a
) :<!laz> List0_vt (a) = let
  val xs_con = !xs
in
  case+ xs_con of
  | ~stream_vt_nil
      ((*void*)) => list_vt_nil()
    // end of [stream_vt_nil]
  | @stream_vt_cons
      (x, xs1) => let
      val xs1_val = xs1
      val () = xs1 := loop (xs1_val)
      val xs_con = stream2list_vt_cons (xs_con)
    in
      fold@ (xs_con); xs_con
    end // end of [stream_vt_cons]
end // end of [loop]
//
in
  loop (xs)
end // end of [stream2list_vt]

end // end of [local]

(* ****** ****** *)

implement
{a}(*tmp*)
stream_vt_free (xs) = ~(xs)

(* ****** ****** *)
//
implement
{a}(*tmp*)
stream_vt_drop_exn
  (xs, n) = let
//
fun aux
  : $d2ctype(stream_vt_drop_exn<a>) =
lam (xs, n) =>
(
//
if
n > 0
then (
//
case+ !xs of
| ~stream_vt_cons
    (_, xs) => aux(xs, n-1)
  // end of [stream_vt_cons]
| ~stream_vt_nil
    ((*void*)) => $raise StreamSubscriptExn()
  // end of [stream_vt_nil]
//
) (* end of [then] *)
else (xs) // end of [else]
//
) (* end of [lam] *)
//
in
  aux (xs, n)
end // end of [stream_vt_drop_exn]
//
implement
{a}(*tmp*)
stream_vt_drop_opt
  (xs, n) = let
//
fun aux
  : $d2ctype(stream_vt_drop_opt<a>) =
lam (xs, n) =>
(
//
if
n > 0
then (
//
case+ !xs of
| ~stream_vt_cons
    (_, xs) => aux(xs, n-1)
| ~stream_vt_nil
    ((*void*)) => None_vt((*void*))
//
) (* end of [then] *)
else Some_vt{stream_vt(a)}(xs) // [else]
//
) (* end of [lam] *)
//
in
  aux (xs, n)
end // end of [stream_vt_drop_opt]
//
(* ****** ****** *)
//
implement
{a}(*tmp*)
stream_vt_head(xs) =
(
case+ !xs of
| ~stream_vt_cons (x, xs) =>
    let val () = stream_vt_free (xs) in x end
| ~stream_vt_nil ((*void*)) => $raise StreamSubscriptExn()
) (* end of [stream_vt_head] *)
//
implement
{a}(*tmp*)
stream_vt_tail(xs) =
(
case+ !xs of
| ~stream_vt_cons (x, xs) => (xs)
| ~stream_vt_nil ((*void*)) => $raise StreamSubscriptExn()
) (* end of [stream_vt_tail] *)
//
(* ****** ****** *)

implement
{a}(*tmp*)
stream_vt_uncons(xs0) =
(
case+ !xs0 of
| ~stream_vt_cons
    (x, xs) => (xs0 := xs; x)
| ~stream_vt_nil () => let
    val () =
      xs0 := $ldelay (stream_vt_nil)
    // end of [val]
  in
    $raise StreamSubscriptExn((*void*))
  end // end of [stream_vt_nil]
) (* end of [stream_vt_uncons] *)

(* ****** ****** *)

implement
{a}(*tmp*)
stream_vt_foreach
  (xs) = let
  var env: void = ()
in
  stream_vt_foreach_env<a><void> (xs, env)
end // end of [stream_vt_foreach]

implement
{a}(*tmp*){env}
stream_vt_foreach_env
  (xs, env) = let
  val xs_con = !xs
in
//
case+ xs_con of
| @stream_vt_cons
    (x, xs1) => let
    val xs1 = xs1
    val () = stream_vt_foreach$fwork<a> (x, env)
    val () = free@ {a} (xs_con)
  in
    stream_vt_foreach<a> (xs1)
  end // end of [stream_vt_cons]
| ~stream_vt_nil () => ()
//
end // end of [stream_vt_foreach_env]

(* ****** ****** *)

local

fun{a:t0p}
stream_vt_filter_con
(
  xs: stream_vt (a)
) : stream_vt_con (a) = let
  val xs = !xs
in
//
case+ xs of
| @stream_vt_cons
    (x, xs1) => let
    val test =
      stream_vt_filter$pred<a> (x)
    // end of [val]
  in
    if test then let
      val () =
      xs1 := stream_vt_filter (xs1)
    in
      fold@{a}(xs); xs
    end else let
      val xs1 = xs1
      val ((*void*)) = free@{a}(xs)
    in
      stream_vt_filter_con<a> (xs1)
    end // end of [if]
  end // end of [cons]
| ~stream_vt_nil((*void*)) => stream_vt_nil()
//
end (* end of [stream_vt_filter_con] *)

in (* in of [local] *)

implement
{a}(*tmp*)
stream_vt_filter (xs) =
  $ldelay (stream_vt_filter_con<a> (xs), ~xs)
// end of [stream_vt_filter]

implement
{a}(*tmp*)
stream_vt_filter_fun
  (xs, pred) = let
//
implement{a2}
stream_vt_filter$pred (x) = let
//
val p = addr@(x)
val (pf, fpf | p) = $UN.ptr0_vtake{a}(p)
val test = pred (!p)
prval ((*void*)) = fpf (pf)
//
in
  test
end // end of [stream_vt_filter$pred]
//
in
  stream_vt_filter (xs)
end // end of [stream_vt_filter_fun]

end // end of [local]

(* ****** ****** *)

local

fun{}
auxfree
  {a:t0p}
(
  pred: (&a) -<cloptr> bool
) : void =
  cloptr_free ($UN.castvwtp0{cloptr0}(pred))

fun{a:t0p}
stream_vt_filter_cloptr_con
(
  xs: stream_vt (a), pred: (&a) -<cloptr> bool
) : stream_vt_con (a) = let
  val xs = !xs
in
//
case+ xs of
| @stream_vt_cons
    (x, xs1) => let
    val test = pred (x)
  in
    if test then let
      val () = xs1 :=
      stream_vt_filter_cloptr (xs1, pred)
    in
      fold@{a}(xs); xs
    end else let
      val xs1 = xs1
      val ((*void*)) = free@{a}(xs)
    in
      stream_vt_filter_cloptr_con<a> (xs1, pred)
    end // end of [if]
  end // end of [cons]
| ~stream_vt_nil () =>
    let val () = auxfree(pred) in stream_vt_nil(*void*) end
//
end (* end of [stream_vt_filter_cloptr_con] *)

in (* in of [local] *)

implement
{a}(*tmp*)
stream_vt_filter_cloptr
  (xs, pred) = $ldelay
(
  stream_vt_filter_cloptr_con<a> (xs, pred), (~xs; auxfree(pred))
) (* end of [stream_vt_filter_cloptr] *)

end // end of [local]

(* ****** ****** *)

local

fun{
a:vt0p}{b:vt0p
} stream_vt_map_con
(
  xs: stream_vt (a)
) : stream_vt_con (b) = let
  val xs_con = !xs
in
//
case+ xs_con of
| @stream_vt_cons(x, xs) => let
    val y = stream_vt_map$fopr<a><b> (x)
    val xs = xs
    val ((*void*)) = free@ (xs_con)
  in
    stream_vt_cons{b}(y, stream_vt_map<a><b> (xs))
  end (* end of [stream_vt_con] *)
| ~stream_vt_nil((*void*)) => stream_vt_nil()
//
end // end of [stream_vt_map_con]

in (* in of [local] *)

implement
{a}{b}(*tmp*)
stream_vt_map (xs) = $ldelay (stream_vt_map_con<a><b> (xs), ~xs)

end // end of [local]

(* ****** ****** *)

implement
{a}{b}(*tmp*)
stream_vt_map_fun
  (xs, f) = let
//
implement
{a2}{b2}
stream_vt_map$fopr (x) = let
  prval () = __assert (x) where
  {
    extern praxi __assert (x: &a2 >> a2?!): void
  }
  val (
    pf, fpf | p_x
  ) = $UN.ptr0_vtake{a}(addr@x)
  val res = $UN.castvwtp0{b2}(f(!p_x))
  prval () = $UN.castview0{void}(@(fpf, pf))
in
  res
end (* end of [stream_vt_map$fopr] *)
//
in
  stream_vt_map<a><b> (xs)
end // end of [stream_vt_map_fun]

(* ****** ****** *)

local

fun{
a1,a2:t0p}{b:vt0p
} stream_vt_map2_con
(
  xs1: stream_vt (a1)
, xs2: stream_vt (a2)
) : stream_vt_con (b) = let
  val xs1_con = !xs1
in
//
case+ xs1_con of
| @stream_vt_cons
    (x1, xs1) => let
    val xs2_con = !xs2
  in
    case+ xs2_con of
    | @stream_vt_cons
        (x2, xs2) => let
        val y = stream_vt_map2$fopr<a1,a2><b> (x1, x2)
        val xs1 = xs1
        and xs2 = xs2
        val () = free@ (xs1_con)
        and () = free@ (xs2_con)
      in
        stream_vt_cons{b}(y, stream_vt_map2<a1,a2><b> (xs1, xs2))
      end // end of [stream_vt_cons]
    | ~stream_vt_nil() => let
        val xs1 = xs1
        val () = free@ (xs1_con)
      in
        ~xs1; stream_vt_nil ()
      end // end of [stream_vt_nil]
  end // end of [stream_vt_cons]
| ~stream_vt_nil((*void*)) => (~xs2; stream_vt_nil())
//
end // end of [stream_vt_map_con]

in (* in of [local] *)

implement
{a1,a2}{b}
stream_vt_map2
  (xs1, xs2) = $ldelay
  (stream_vt_map2_con<a1,a2><b> (xs1, xs2), (~xs1; ~xs2))
// end of [stream_vt_map2]

implement
{a1,a2}{b}
stream_vt_map2_fun
  (xs1, xs2, f) = let
//
implement
{a12,a22}{b2}
stream_vt_map2$fopr
  (x1, x2) = let
  val (
    pf1, fpf1 | p_x1
  ) = $UN.ptr0_vtake{a1}(addr@x1)
  and (
    pf2, fpf2 | p_x2
  ) = $UN.ptr0_vtake{a2}(addr@x2)
  val res =
    $UN.castvwtp0{b2}(f(!p_x1, !p_x2))
  prval () = fpf1 (pf1) and () = fpf2 (pf2)
in
  res
end (* end of [stream_vt_map2$fopr] *)
//
in
  stream_vt_map2<a1,a2><b> (xs1, xs2)
end // end of [stream_vt_map2_fun]

end // end of [local]

(* ****** ****** *)

implement
{a}(*tmp*)
stream_vt_tabulate
(
// argumentless
) = aux (0) where
{
//
fun aux (i: intGte(0)): stream_vt (a) =
  $ldelay (stream_vt_cons{a}(stream_vt_tabulate$fopr<a> (i), aux (i+1)))
//
} (* end of [stream_vt_tabulate] *)

(* ****** ****** *)

local
//
datavtype streamer
  (a:vt@ype+) = STREAMER of (stream_vt(a))
//
assume streamer_vtype (a:vt0p) = streamer (a)
//
in (* in-of-local *)

implement
{}(*tmp*)
streamer_vt_make (xs) = STREAMER (xs)

implement
{}(*tmp*)
streamer_vt_free
  (xser) = let val+~STREAMER(xs) = xser in ~xs end
// end of [streamer_free]

implement
{a}(*tmp*)
streamer_vt_eval_exn
  (xser) = let
//
val+@STREAMER(xs) = xser
//
in
//
case+ !xs of
| ~stream_vt_cons
    (x, xs2) =>
  (
    xs := xs2; fold@(xser); x
  ) (* end of [stream_vt_cons] *)
| ~stream_vt_nil
    ((*void*)) => let
    prval () =
     __assert (view@xs) where
    {
      extern
      praxi __assert{l:addr}(!ptr@l >> stream_vt(a)@l): void
    } (* end of [prval] *)
    prval () = fold@(xser)
  in
    $raise StreamSubscriptExn()
  end (* end of [stream_vt_nil] *)
//
end // end of [stream_eval_exn]

end // end of [local]

(* ****** ****** *)

(* end of [stream_vt.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: February, 2012
//
(* ****** ****** *)

#include "prelude/params.hats"

(* ****** ****** *)

#if VERBOSE_PRELUDE #then
#print "Loading [fcontainer_foreach.dats] starts!\n"
#endif // end of [VERBOSE_PRELUDE]

(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"
// end of [staload]

(* ****** ****** *)

staload "prelude/SATS/fcontainer.sats"

(* ****** ****** *)

implement
{xs}{x}
foreach_fun
  {fe:eff} (xs, f) = let
  val f = coerce (f) where { extern castfn
    coerce (f: (x) -<fe> void):<> (!unit_v | x, !ptr) -<fe> void
  } // end of [val] // HX: this is a safe cast
  prval pfu = unit_v ()
  val () = foreach_funenv<xs><x> {unit_v} {ptr} (pfu | xs, f, the_null_ptr)
  prval unit_v () = pfu
in
  // empty
end // end of [foreach_fun]

implement
{xs}{x}
foreach_clo
  {fe:eff}
  (xs, f) = let
  typedef clo_t = (x) -<clo,fe> void
  val p_f = addr@(f)
  prval [f:addr] EQADDR () = ptr_get_index (p_f)  
  viewdef v = clo_t @ f
  fn app (pf: !v | x: x, p_f: !ptr f):<fe> void = !p_f (x)
in
  foreach_funenv<xs><x> {v}{ptr(f)} (view@ f | xs, app, p_f)
end // end of [foreach_clo]

implement
{xs}{x}
foreach_vclo
  {v} {fe:eff}
  (pfv | xs, f) = let
  typedef clo_t = (!v | x) -<clo,fe> void
  val p_f = addr@(f)
  prval [f:addr] EQADDR () = ptr_get_index (p_f)  
  viewdef v2 = (v, clo_t @ f)
  fn app (pf: !v2 | x: x, p_f: !ptr f):<fe> void = () where {
    val () = !p_f (pf.0 | x)
  } // end of [val]
  prval pf = (pfv, view@ f)
  val () = foreach_funenv<xs><x> {v2} {ptr(f)} (pf | xs, app, p_f)
  prval () = pfv := pf.0 and () = view@ (f) := pf.1
in
  (*nothing*)
end // end of [foreach_vclo]

implement
{xs}{x}
foreach_cloptr
  {fe:eff}
  (xs, f) = let
  viewdef uv = unit_v
  viewtypedef cloptr0_t = (x) -<cloptr,fe> void
  viewtypedef cloptr1_t = (!uv>>uv | x) -<cloptr,fe> void
  prval () = __assert(f) where {
    extern prfun __assert (f: !cloptr0_t >> cloptr1_t): void
  } // end of [val] // HX: this is a safe cast
  prval pfu = unit_v ()
  val () = foreach_vcloptr<xs><x> {uv} (pfu | xs, f)
  prval unit_v () = pfu
  prval () = __assert(f) where {
    extern prfun __assert (f: !cloptr1_t >> cloptr0_t): void
  } // end of [val] // HX: this is a safe cast
in
  (*nothing*)
end // end of [foreach_cloptr]
implement
{xs}{x}
foreach_vcloptr
  {v} {fe:eff} (pf | xs, f) = let
  viewtypedef cloptr_t = (!v | x) -<cloptr,fe> void
  fn app (pf: !v | x: x, f: !cloptr_t):<fe> void = f (pf | x)
in
  foreach_funenv<xs><x> {v} {cloptr_t} (pf | xs, app, f)
end // end of [foreach_vcloptr]

implement
{xs}{x}
foreach_cloref
  {fe:eff}
  (xs, f) = let
  viewdef uv = unit_v
  typedef cloref_t = (x) -<cloref,fe> void
  fn app (pf: !uv | x: x, f: !cloref_t):<fe> void = f (x)
  prval pfu = unit_v ()
  val () = foreach_funenv<xs><x> {uv} {cloref_t} (pfu | xs, app, f)
  prval unit_v () = pfu
in
  (*empty*)
end // end of [foreach_cloref]

(* ****** ****** *)

implement
{xs}{x}
iforeach_funenv
  {v}{vt}{fe} (
  pfv | xs, f, env
) = let
var i: int = 0
val p_i = addr@(i)
viewtypedef ivt = (ptr(i), vt)
//
val env1 = __cast (env) where {
  extern castfn __cast (env: !vt >> vt?):<> vt
} // end of [val]
//
var ienv
  : ivt = (p_i, env1)
val p_ienv = addr@(ienv)
viewdef v1 = (v, int@i, ivt@ienv)
fn f1 (
  pf: !v1 | x: x, p: !ptr(ienv)
) :<fe> void = let
  val i = !(p->0)
  val () = f (pf.0 | i, x, p->1)
in
  $effmask_wrt (!(p->0) := i + 1)
end // end of [f1]
//
prval pfv1 = (pfv, view@(i), view@(ienv))
val () = foreach_funenv{v1}{ptr(ienv)} (pfv1 | xs, f1, p_ienv)
prval () = pfv := pfv1.0
prval () = view@(i) := pfv1.1
prval () = view@(ienv) := pfv1.2
//
prval () =
  __xfree (env, ienv.1) where {
  extern praxi __xfree (env: !vt? >> vt, env1: vt): void
} // end of [where] // end of [prval]
//
in
  i // = the size of [xs]
end // end of [iforeach_funenv]

(* ****** ****** *)

implement
{xs}{x}
iforeach_clo
  {fe:eff}
  (xs, f) = let
  typedef clo_t = (int, x) -<clo,fe> void
  val p_f = addr@(f)
  prval [f:addr] EQADDR () = ptr_get_index (p_f)  
  viewdef v = clo_t @ f
  fn app (pf: !v | i: int, x: x, p_f: !ptr f):<fe> void = !p_f (i, x)
in
  iforeach_funenv<xs><x> {v}{ptr(f)} (view@ f | xs, app, p_f)
end // end of [iforeach_clo]

implement
{xs}{x}
iforeach_vclo
  {v} {fe:eff}
  (pfv | xs, f) = let
  typedef clo_t = (!v | int, x) -<clo,fe> void
  val p_f = addr@(f)
  prval [f:addr] EQADDR () = ptr_get_index (p_f)  
  viewdef v2 = (v, clo_t @ f)
  fn app (
    pf: !v2 | i: int, x: x, p_f: !ptr f
  ) :<fe> void = () where {
    val () = !p_f (pf.0 | i, x)
  } // end of [val]
  prval pf = (pfv, view@ f)
  val nxs = iforeach_funenv<xs><x> {v2} {ptr(f)} (pf | xs, app, p_f)
  prval () = pfv := pf.0 and () = view@ (f) := pf.1
in
  nxs
end // end of [iforeach_vclo]

(* ****** ****** *)

implement
{xs}{x}
iforeach_cloptr
  {fe:eff}
  (xs, f) = let
  viewdef uv = unit_v
  viewtypedef cloptr0_t = (int, x) -<cloptr,fe> void
  viewtypedef cloptr1_t = (!uv >> uv | int, x) -<cloptr,fe> void
  prval () = __assert(f) where {
    extern prfun __assert (f: !cloptr0_t >> cloptr1_t): void
  } // end of [val] // HX: this is a safe cast
  prval pfu = unit_v ()
  val nxs = iforeach_vcloptr<xs><x> {uv} (pfu | xs, f)
  prval unit_v () = pfu
  prval () = __assert(f) where {
    extern prfun __assert (f: !cloptr1_t >> cloptr0_t): void
  } // end of [val] // HX: this is a safe cast
in
  nxs
end // end of [iforeach_cloptr]
implement
{xs}{x}
iforeach_vcloptr
  {v} {fe:eff} (pf | xs, f) = let
  viewtypedef cloptr_t = (!v | int, x) -<cloptr,fe> void
  fn app (pf: !v | i: int, x: x, f: !cloptr_t):<fe> void = f (pf | i, x)
in
  iforeach_funenv<xs><x> {v} {cloptr_t} (pf | xs, app, f)
end // end of [iforeach_vcloptr]

(* ****** ****** *)

implement
{xs}{x}
iforeach_cloref
  {fe:eff}
  (xs, f) = let
  viewdef uv = unit_v
  typedef cloref_t = (int, x) -<cloref,fe> void
  fn app (pf: !uv | i: int, x: x, f: !cloref_t):<fe> void = f (i, x)
  prval pfu = unit_v ()
  val nxs = iforeach_funenv<xs><x> {uv} {cloref_t} (pfu | xs, app, f)
  prval unit_v () = pfu
in
  nxs
end // end of [foreach_cloref]

(* ****** ****** *)

#if VERBOSE_PRELUDE #then
#print "Loading [fcontainer_foreach.dats] finishes!\n"
#endif // end of [VERBOSE_PRELUDE]

(* ****** ****** *)

(* end of [fcontainer_foreach.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/matrixref.atxt
** Time of generation: Sat Oct 17 15:19:58 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: Feburary, 2012 *)

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

implement{a}
matrixref_make_elt
  (nrow, ncol, x) =
  matrixptr_refize(matrixptr_make_elt<a> (nrow, ncol, x))
// end of [matrixref_make_elt]

(* ****** ****** *)

implement{a}
matrixref_get_at_size
  (A, i, n, j) = let
//
val
(
vbox pf | p
) = matrixref_get_viewptr (A)
//
in
  matrix_get_at_size (!p, i, n, j)
end // end of [matrixref_get_at_size]

(* ****** ****** *)
//
implement
{a}(*tmp*)
matrixref_get_at_int
  (M, i, n, j) =
  matrixref_get_at_size (M, i2sz(i), i2sz(n), i2sz(j))
//
(* ****** ****** *)

implement{a}
matrixref_set_at_size
  (A, i, n, j, x) = let
//
val
(
vbox pf | p
) = matrixref_get_viewptr (A)
//
in
  matrix_set_at_size (!p, i, n, j, x)
end // end of [matrixref_set_at_size]

(* ****** ****** *)
//
implement
{a}(*tmp*)
matrixref_set_at_int
  (M, i, n, j, x) =
  matrixref_set_at_size (M, i2sz(i), i2sz(n), i2sz(j), x)
//
(* ****** ****** *)

implement{a}
fprint_matrixref
  {m,n}
(
  out, M, nrow, ncol
) = {
//
val M =
$UN.castvwtp1{matrixptr(a, m, n)}(M)
//
val () = fprint_matrixptr<a> (out, M, nrow, ncol)
//
prval ((*void*)) = $UN.cast2void (M)
//
} (* end of [fprint_matrixref] *)

implement{a}
fprint_matrixref_sep
  {m,n}
(
  out, M, nrow, ncol, sep1, sep2
) = {
//
val M =
$UN.castvwtp1{matrixptr(a, m, n)}(M)
//
val () =
fprint_matrixptr_sep<a> (out, M, nrow, ncol, sep1, sep2)
//
prval ((*void*)) = $UN.cast2void (M)
//
} (* end of [fprint_matrixref_sep] *)

(* ****** ****** *)

implement
{a}(*tmp*)
matrixref_copy
  {m,n} (M, m, n) = let
//
val A = $UN.cast{arrayref(a,m*n)}(M)
//
in
  $UN.castvwtp0{matrixptr(a,m,n)}(arrayref_copy<a> (A, m*n))
end // end of [matrixref_copy]

(* ****** ****** *)

implement{a}
matrixref_tabulate
  (nrow, ncol) =
(
  matrixptr_refize (matrixptr_tabulate<a> (nrow, ncol))
) (* end of [matrixref_tabulate] *)

implement{a}
matrixref_tabulate_cloref
  (nrow, ncol, f) =
  matrixptr_refize (matrixptr_tabulate_cloref<a> (nrow, ncol, f))
// end of [matrixref_tabulate_cloref]

(* ****** ****** *)

implement{a}
matrixref_foreach
  (A, m, n) = let
//
var env: void = ()
//
in
  matrixref_foreach_env<a><void> (A, m, n, env)
end // end of [matrixref_foreach]

implement
{a}{env}
matrixref_foreach_env
  (A, m, n, env) = let
  val (vbox pf | p) = matrixref_get_viewptr (A)
in
  $effmask_ref (matrix_foreach_env<a><env> (!p, m, n, env))
end // end of [matrixref_foreach_env]

(* ****** ****** *)

local
//
datatype
mtrxszref
(
  a:viewt@ype
) =
{m,n:int}
MTRXSZREF of
(
  matrixref(a, m, n)
, size_t(m), size_t(n)
) // end of [mtrxszref]
//
assume mtrxszref_vt0ype_type = mtrxszref
//
in (* in of [local] *)

implement{}
mtrxszref_make_matrixref
  (M, nrow, ncol) = MTRXSZREF (M, nrow, ncol)
// end of [mtrxszref_make_matrixref]

(* ****** ****** *)

implement{}
mtrxszref_get_ref (MSZ) = let
  val+MTRXSZREF (M, nrow, ncol) = MSZ in $UN.cast2Ptr1(M)
end // end of [mtrxszref_get_ref]

(* ****** ****** *)

implement{}
mtrxszref_get_nrow (MSZ) = let
  val+MTRXSZREF (M, nrow, ncol) = MSZ in nrow
end // end of [mtrxszref_get_nrow]

implement{}
mtrxszref_get_ncol (MSZ) = let
  val+MTRXSZREF (M, nrow, ncol) = MSZ in ncol
end // end of [mtrxszref_get_ncol]

(* ****** ****** *)

implement{}
mtrxszref_get_refsize
   (MSZ, nrow_r, ncol_r) = let
//
val+MTRXSZREF (M, nrow, ncol) = MSZ
//
prval ((*void*)) = lemma_matrixref_param (M)
//
in
  nrow_r := nrow; ncol_r := ncol; M(*matrixref*)
end // end of [mtrxszref_get_nrow]

end // end of [local]

(* ****** ****** *)

implement{a}
mtrxszref_make_elt
  (nrow, ncol, x) = let
//
val nrow = g1ofg0_uint (nrow)
val ncol = g1ofg0_uint (ncol)
val M =
  matrixref_make_elt<a> (nrow, ncol, x)
//
in
  mtrxszref_make_matrixref (M, nrow, ncol)
end // end of [mtrxszref_make_elt]

(* ****** ****** *)

implement{a}
mtrxszref_get_at_int
  (MSZ, i, j) = let
//
val i = g1ofg0_int(i)
and j = g1ofg0_int(j)
//
in
//
if
i >= 0
then (
//
if
j >= 0
then (
  mtrxszref_get_at_size(MSZ,i2sz(i),i2sz(j))
) else $raise MatrixSubscriptExn((* j < 0 *))
//
) else $raise MatrixSubscriptExn((* i < 0 *))
//
end // end of [mtrxszref_get_at_gint]

implement{a}
mtrxszref_get_at_size
  (MSZ, i, j) = let
//
var nrow: size_t
and ncol: size_t
//
val M =
$effmask_wrt (
  mtrxszref_get_refsize (MSZ, nrow, ncol)
) (* end of [val] *)
//
val i = g1ofg0_uint(i)
and j = g1ofg0_uint(j)
//
in
//
if
nrow > i
then (
//
if
ncol > j
then (
  matrixref_get_at_size (M, i, ncol, j)
) else $raise MatrixSubscriptExn((*void*))
//
) else $raise MatrixSubscriptExn((*void*))
//
end // end of [mtrxszref_get_at_size]

(* ****** ****** *)

implement{a}
mtrxszref_set_at_int
  (MSZ, i, j, x) = let
//
val i = g1ofg0_int(i)
and j = g1ofg0_int(j)
//
in
//
if
i >= 0
then (
//
if
j >= 0
then (
  mtrxszref_set_at_size(MSZ,i2sz(i),i2sz(j),x)
) else $raise MatrixSubscriptExn( (* j < 0 *) )
//
) else $raise MatrixSubscriptExn( (* i < 0 *) )
//
end // end of [mtrxszref_set_at_int]

implement{a}
mtrxszref_set_at_size
  (MSZ, i, j, x) = let
//
var nrow: size_t
and ncol: size_t
//
val M =
(
  mtrxszref_get_refsize (MSZ, nrow, ncol)
) (* end of [val] *)
//
val i = g1ofg0_uint (i)
and j = g1ofg0_uint (j)
//
in
//
if
nrow > i
then (
//
if
ncol > j
then (
  matrixref_set_at_size(M, i, ncol, j, x)
) else $raise MatrixSubscriptExn((*void*))
//
) else $raise MatrixSubscriptExn((*void*))
//
end // end of [mtrxszref_set_at_size]

(* ****** ****** *)

implement{a}
fprint_mtrxszref
  (out, MSZ) = let
//
var nrow: size_t
and ncol: size_t
val A =
  mtrxszref_get_refsize (MSZ, nrow, ncol)
//
in
  fprint_matrixref<a> (out, A, nrow, ncol)
end // end of [fprint_mtrxszref]

implement{a}
fprint_mtrxszref_sep
  (out, MSZ, sep1, sep2) = let
//
var nrow: size_t
and ncol: size_t
val A =
  mtrxszref_get_refsize (MSZ, nrow, ncol)
//
in
  fprint_matrixref_sep<a> (out, A, nrow, ncol, sep1, sep2)
end // end of [fprint_mtrxszref_sep]

(* ****** ****** *)

implement{a}
mtrxszref_foreach
  (A) = let
//
var env: void = ()
//
in
  mtrxszref_foreach_env<a><void> (A, env)
end // end of [mtrxszref_foreach]

implement
{a}{env}
mtrxszref_foreach_env
  (MSZ, env) = let
//
var nrow: size_t and ncol: size_t
//
val MAT = mtrxszref_get_refsize(MSZ, nrow, ncol)
//
in
  matrixref_foreach_env<a><env> (MAT, nrow, ncol, env)
end // end of [mtrxszref_foreach_env]

(* ****** ****** *)

implement
{a}(*tmp*)
mtrxszref_foreach_cloref
  (MSZ, fwork) = let
//
implement
{a2}{env}
matrix_foreach$fwork
  (x, env) = let
  val (pf, fpf | p) = $UN.ptr_vtake{a}(addr@x)
  val ((*void*)) = fwork(!p)
  prval ((*void*)) = fpf(pf)
in
  // nothing
end // end of [matrix_foreach$work]
//
in
  mtrxszref_foreach(MSZ)
end // end of [mtrxszref_foreach_cloref]

(* ****** ****** *)

implement{a}
mtrxszref_tabulate
  (nrow, ncol) = let
//
val nrow = g1ofg0_uint (nrow)
val ncol = g1ofg0_uint (ncol)
val M =
  matrixref_tabulate<a> (nrow, ncol)
//
in 
  mtrxszref_make_matrixref (M, nrow, ncol)
end // end of [mtrxszref_tabulate]

(* ****** ****** *)

implement{a}
mtrxszref_tabulate_cloref
(
  nrow, ncol, fclo
) = let
//
val M =
matrixref_tabulate_cloref<a>
(
  nrow, ncol, fclo
) (* end of [val] *)
//
in
//
mtrxszref_make_matrixref (M, nrow, ncol)
//
end // end of [mtrxszref_tabulate_cloref]

(* ****** ****** *)

(* end of [matrixref.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmhwxiATgmailDOTcom
// Start Time: May, 2012
//
(* ****** ****** *)
//
// HX-2012-05-25:
//
// for iterators based on singly-linked lists
//
(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"
// end of [staload]

(* ****** ****** *)

staload "prelude/SATS/giterator.sats"

(* ****** ****** *)

sortdef t0p = t@ype
sortdef vt0p = viewt@ype
stadef itrknd = giter_list_vt_kind
stadef itrkpm = giter_list_vt_param

(* ****** ****** *)

dataviewtype
iterk (
  a:viewt@ype+, int(*f*), int(*r*)
) = {f,r:int} ITR (a, f, r) of (list_vt (a, f+r), Ptr1)

(* ****** ****** *)

extern
castfn iterk2giter
  {x:vt0p}{n:int}
  (xs: iterk (x, 0, n)):<> giter (itrknd, itrkpm(), x, 0, n)
// end of [iterk2giter]

extern
castfn giter2iterk
  {x:vt0p}{f,r:int}
  (itr: giter (itrknd, itrkpm(), x, f, r)):<> iterk (x, f, r)
// end of [giter2iterk]

(* ****** ****** *)

implement{x}
giter_make_list_vt
  {n} (xs) = let
  val itr = ITR {x}{0,n} (xs, _)
  val+ ITR (xs, p) = itr
  val () = p := $UN.cast2Ptr1 (addr@ (xs))
  prval () = fold@ (itr)
in
  iterk2giter (itr)
end // end of [giter_make_list_vt]

implement
giter_free_list_vt (itr) = let
  val+ ~ITR (xs, _) = giter2iterk (itr) in xs
end // end of [giter_free_list_vt]

(* ****** ****** *)

extern
praxi encode
  {kpm:tk}{x:vt0p}{f,r:int}
  (xs: !iterk (x, f, r) >> giter (itrknd, kpm, x, f, r)): void
// end of [encode]

extern
praxi decode
  {kpm:tk}{x:vt0p}{f,r:int}
  (itr: !giter (itrknd, kpm, x, f, r) >> iterk (x, f, r)): void
// end of [decode]

(* ****** ****** *)

implement(x)
giter_is_atbeg<itrknd><x>
  {kpm}{f,r} (itr) = let
//
  prval () = decode (itr)
  val+ @ITR (xs0, p) = itr
  val p_xs0 = addr@ (xs0)
  val p = p
  prval () = fold@ (itr)
  prval () = encode (itr)
//
  extern castfn
    __cast {b:bool} (bool(b)):<> [b==(f==0)] bool (b)
  // end of [extern]
in
  if p_xs0 = p then __cast(true) else __cast(false)
end // end of [giter_is_atbeg]

(* ****** ****** *)

implement(x)
giter_is_atend<itrknd><x>
  {kpm}{f,r} (itr) = let
//
  viewtypedef vt = list_vt (x, r)
//
  prval () = decode (itr)
  val+ ITR (_, p) = itr
  prval () = encode (itr)
  val xs = $UN.ptr1_get<vt> (p)
  val isnil = list_vt_is_nil (xs)
  prval () = __vfree (xs) where {
    extern praxi __vfree (xs: vt): void // returned back to [!p]
  } // end of [prval]
in
  isnil
end // end of [giter_is_atend]

(* ****** ****** *)

implement(x)
giter_getref<itrknd><x>
  {kpm}{f,r} (itr) = let
//
  viewtypedef vt = list_vt (x, r)
//
  prval () = decode (itr)
  val+ ITR (_, p) = itr
  prval () = encode (itr)
//
  val xs = $UN.ptr1_get<vt> (p)
  val @list_vt_cons (x, _) = xs
  val p_x = addr@ (x)
  prval () = fold@ (xs)
  prval () = __vfree (xs) where {
    extern praxi __vfree (xs: vt): void // returned back to [!p]
  } // end of [prval]
in
  $UN.cast2Ptr1 (p_x)
end // end of [giter_getref]

(* ****** ****** *)

implement(x)
giter_inc<itrknd><x>
  {kpm}{f,r} (itr) = let
//
  viewtypedef vt = list_vt (x, r)
//
  prval () = decode (itr)
  val+ @ITR (_, p) = itr
  val xs = $UN.ptr1_get<vt> (p)
  val+ @list_vt_cons (_, xs1) = xs
  val () = p := $UN.cast2Ptr1 (addr@ (xs1))
  val () = fold@ (itr)
  prval () = encode (itr)
//
  prval () = fold@ (xs)
  prval () = __vfree (xs) where {
    extern praxi __vfree (xs: vt): void // returned back to [!p]
  } // end of [prval]
in
  // nothing
end // end of [giter_inc]

(* ****** ****** *)

implement(x)
giter_getref_inc<itrknd><x>
  {kpm}{f,r} (itr) = let
//
  viewtypedef vt = list_vt (x, r)
//
  prval () = decode (itr)
  val+ @ITR (_, p) = itr
  val xs = $UN.ptr1_get<vt> (p)
  val+ @list_vt_cons (x, xs1) = xs
  val p_x = addr@ (x)
  val () = p := $UN.cast2Ptr1 (addr@ (xs1))
  val () = fold@ (itr)
  prval () = encode (itr)
//
  prval () = fold@ (xs)
  prval () = __vfree (xs) where {
    extern praxi __vfree (xs: vt): void // returned back to [!p]
  } // end of [prval]
in
  $UN.cast2Ptr1 (p_x)
end // end of [giter_getref_inc]

(* ****** ****** *)

implement(x)
giter_ins<itrknd><x>
  {kpm}{f,r} (itr, x) = let
//
  prval () =
    lemma_giter_param (itr)
  (* end of [prval] *)
//
  viewtypedef vt = list_vt (x, r)
  viewtypedef vt1 = list_vt (x, r+1)
  prval () = decode (itr)
  val+ @ITR (xs0, p) = itr
  val xs = $UN.ptr1_get<vt> (p)
  val () = $UN.ptr1_set<vt1> (p, list_vt_cons (x, xs))
  prval () = let
    extern praxi __assert
      (xs0: !list_vt (x, f+r) >> list_vt (x, f+r+1)): void
    // end of [extern]
  in
    __assert (xs0)
  end // end of [prval]
  prval () = fold@ (itr)
  prval () = encode (itr)
in
  // nothing
end // end of [giter_ins]

(* ****** ****** *)

implement(x)
giter_rmv<itrknd><x>
  {kpm}{f,r} (itr) = let
//
  viewtypedef vt = list_vt (x, r)
  viewtypedef vt1 = list_vt (x, r-1)
//
  prval () = decode (itr)
  val+ @ITR (xs0, p) = itr
  val xs = $UN.ptr1_get<vt> (p)
  val+ ~list_vt_cons (x, xs1) = xs
  val () = $UN.ptr1_set<vt1> (p, xs1)
  prval () = let
    extern praxi __assert
      (xs0: !list_vt (x, f+r) >> list_vt (x, f+r-1)): void
    // end of [extern]
  in
    __assert (xs0)
  end // end of [prval]
  prval () = fold@ (itr)
  prval () = encode (itr)
//
in
  x
end // end of [giter_rmv]

(* ****** ****** *)

(* end of [giter_list_vt.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/parray.atxt
** Time of generation: Sat Oct 17 15:19:57 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: April, 2012 *)

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

implement{a}
parray_is_empty
  {l}{n} (pf | p) = let
//
prval () =
  lemma_parray_v_params (pf)
//
val x = $UN.ptr0_get<ptr> (p)
val [lx:addr] x = g1ofg0_ptr (x)
//
prval () =
__assert () where {
  extern praxi __assert (): [(lx <= null && n == 0) || (lx > null && n > 0)] void
} (* end of [prval] *)
//
in
  lte_ptr1_ptr1 (x, the_null_ptr)
end // end of [parray_is_empty]

implement{a}
parray_isnot_empty
  {l}{n} (pf | p) = let
//
prval () =
  lemma_parray_v_params (pf)
//
val x = $UN.ptr0_get<ptr> (p)
val [lx:addr] x = g1ofg0_ptr (x)
//
prval () =
__assert () where {
  extern praxi __assert (): [(lx <= null && n == 0) || (lx > null && n > 0)] void
} (* end of [prval] *)
//
in
  gt_ptr1_ptr1 (x, the_null_ptr)
end // end of [parray_isnot_empty]

(* ****** ****** *)

implement
{a}(*tmp*)
parray_size
  (pf | p) = let
//
prval () = lemma_parray_v_params (pf)
//
fun
loop
{l:addr}
{i,j:nat} .<i>.
(
  pf: !parray_v (a, l, i) | p: ptr l, j: size_t j
) :<> size_t (i+j) = let
  val isnot = parray_isnot_empty<a> (pf | p)
in
  if isnot
    then let
      prval parray_v_cons(pf1, pf2) = pf
      val asz = loop (pf2 | ptr_succ<a> (p), j+1)
      prval () = pf := parray_v_cons{a}(pf1, pf2)
    in
      asz
    end // end of [then]
    else (j) // end of [else]
  // end if [if]
end (* end of [loop] *)
//
in
  loop (pf | p, i2sz(0))
end // end of [parray_size]

(* ****** ****** *)

(* end of [parray.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/arith_prf.atxt
** Time of generation: Sat Oct 17 15:19:53 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: Feburary, 2012 *)

(* ****** ****** *)

primplmnt eqint_make () = EQINT ()

(* ****** ****** *)

primplmnt
mul_gte_gte_gte {m,n} () = let
  prfun loop
    {m:nat}{p:int} .<m>.
    (pf: MUL (m, n, p)):<> [p >= 0] void =
    sif m > 0 then let
      prval MULind (pf1) = pf in loop (pf1)
    end else let
      prval MULbas () = pf in (*nothing*)
    end // end of [sif]
  // end of [loop]
  prval pf = mul_make {m,n} ()
in
  loop {m} (pf)
end // end of [mul_gte_gte_gte]

primplmnt
mul_gte_lte_lte {m,n} () = let
  prfun loop
    {m:nat}{p:int} .<m>.
    (pf: MUL (m, n, p)):<> [p <= 0] void =
    sif m > 0 then let
      prval MULind (pf1) = pf in loop (pf1)
    end else let
      prval MULbas () = pf in (*nothing*)
    end // end of [sif]
  // end of [loop]
  prval pf = mul_make {m,n} ()
in
  loop {m} (pf)
end // end of [mul_gte_lte_lte]

primplmnt
mul_lte_gte_lte {m,n} () = mul_gte_lte_lte {n,m} ()

primplmnt
mul_lte_lte_gte {m,n} () = mul_gte_gte_gte {~m,~n} ()

(* ****** ****** *)

primplmnt
mul_nat_nat_nat
  {m,n} (pf) = let
  prval () = mul_elim (pf)
  prval () = mul_gte_gte_gte {m,n} ()
in
  (*nothing*)
end // end of [mul_nat_nat_nat]

primplmnt
mul_pos_pos_pos
  {m,n} (pf) = let
  prval () = mul_elim (pf)
  prval () = mul_gte_gte_gte {m-1,n-1} ()
in
  (*nothing*)
end // end of [mul_pos_pos_pos]

(* ****** ****** *)

primplmnt
mul_negate {m,n} (pf) = let
  prval () = mul_elim (pf) in mul_make {~m,n} ()
end // end of [mul_negate]

primplmnt
mul_negate2 {m,n} (pf) = let
  prval () = mul_elim (pf) in mul_make {m,~n} ()
end // end of [mul_negate2]

(* ****** ****** *)

primplmnt
mul_commute {m,n} (pf) = let
  prval () = mul_elim (pf) in mul_make {n,m} ()
end // end of [mul_commute]

primplmnt
mul_is_commutative
  (pf1, pf2) = let
  prval () = mul_elim (pf1) and () = mul_elim (pf2)
in
  (*nothing*)
end // end of [mul_commute]

(* ****** ****** *)

primplmnt
mul_distribute
  {m}{n1,n2} (pf1, pf2) = let
  prval () = mul_elim (pf1) and () = mul_elim (pf2)
in
  mul_make {m,n1+n2} ()
end // end of [mul_distribute]

primplmnt
mul_distribute2
  {m1,m2}{n} (pf1, pf2) = let
  prval () = mul_elim (pf1) and () = mul_elim (pf2)
in
  mul_make {m1+m2,n} ()
end // end of [mul_distribute]

(* ****** ****** *)

primplmnt
mul_is_associative
  {x,y,z}{xy,yz}
  (pf1, pf2, pf3, pf4) = {
  prval pf1_alt = mul_make {x,y} ()
  prval EQINT () = mul_isfun2 (pf1, pf1_alt)
  prval pf2_alt = mul_make {y,z} ()
  prval EQINT () = mul_isfun2 (pf2, pf2_alt)
  prval pf3_alt = mul_make {xy,z} ()
  prval EQINT () = mul_isfun2 (pf3, pf3_alt)
  prval pf4_alt = mul_make {x,yz} ()
  prval EQINT () = mul_isfun2 (pf4, pf4_alt)
//
} // end of [mul_is_associative]

(* ****** ****** *)

primplmnt
lemma_exp2_param (pf) = let
  prfun aux
    {n:int}
    {p:int}
    .<max(n,0)>. (
    pf: EXP2 (n, p)
  ) : [n>=0;p>=1] void = case+ pf of
    | EXP2ind (pf1) => aux (pf1) | EXP2bas () => ()
  // end of [aux]
in
  aux (pf)
end // end of [lemma_exp2_param]  

(* ****** ****** *)

primplmnt
exp2_istot {n}
  () = istot {n} () where {
  prfun istot
    {n:nat} .<n>. (): [p:nat] EXP2 (n, p) =
    sif n > 0 then EXP2ind (istot {n-1} ()) else EXP2bas ()
} // end of [exp2_istot]

(* ****** ****** *)

primplmnt
exp2_isfun
  (pf1, pf2) =
  isfun (pf1, pf2) where {
  prfun isfun
    {n:nat} {p1,p2:int} .<n>. (
    pf1: EXP2 (n, p1), pf2: EXP2 (n, p2)
  ) : [p1==p2] void =
    case+ pf1 of
    | EXP2ind pf1 => let
        prval EXP2ind pf2 = pf2 in isfun (pf1, pf2)
      end // end of [EXP2ind]
    | EXP2bas () => let
        prval EXP2bas () = pf2 in (* nothing *)
      end // end of [EXP2bas]
  // end of [isfun]
} // end of [exp2_isfun]

(* ****** ****** *)

primplmnt
exp2_is_mono
  (pf1, pf2) =
  aux (pf1, pf2) where {
  prfun aux
    {n1:nat;n2:int | n1 <= n2}
    {p1,p2:int} .<n2>. (
    pf1: EXP2 (n1, p1), pf2: EXP2 (n2, p2)
  ) : [p1 <= p2] void =
    case+ pf2 of
    | EXP2ind (pf2) => (case+ pf1 of
      | EXP2ind (pf1) => aux (pf1, pf2) | EXP2bas () => aux (pf1, pf2)
      ) // end of [EXP2ind]
    | EXP2bas () => let prval EXP2bas () = pf1 in () end
  // end of [aux]
} // end of [exp2_is_mono]

(* ****** ****** *)

primplmnt
exp2_muladd
  (pf1, pf2, pf3) = let
  prfun aux
    {n1,n2:nat}
    {p1,p2:int}
    {p:int} .<n2>. (
    pf1: EXP2 (n1, p1)
  , pf2: EXP2 (n2, p2)
  , pf3: MUL (p1, p2, p)
  ) : [p>=0] EXP2 (n1+n2, p) = case+ pf2 of
    | EXP2ind {n21} {p21} (pf21) => let // n2 = n21+1; p2 = p21 + p21
        prval pf31 = mul_istot {p1,p21} ()
        prval pf32 = mul_distribute (pf31, pf31)
        prval () = mul_isfun (pf3, pf32)
        prval pf1_res = aux (pf1, pf21, pf31)
      in
        EXP2ind pf1_res
      end // end of [EXP2ind]
    | EXP2bas () => let
        prval () =
          lemma_exp2_param (pf1)
        prval () = mul_elim (pf3) in pf1
      end // end of [EXP2bas]
  // end of [aux]
in
  aux (pf1, pf2, pf3)
end // end of [exp2_muladd]

(* ****** ****** *)

(* end of [arith_prf.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/gorder.atxt
** Time of generation: Sat Oct 17 15:19:55 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2013 *)

(* ****** ****** *)

implement{a}
glt_val_val (x, y) = gcompare_val_val<a> (x, y) < 0
implement{a}
glte_val_val (x, y) = gcompare_val_val<a> (x, y) <= 0
implement{a}
ggt_val_val (x, y) = gcompare_val_val<a> (x, y) > 0
implement{a}
ggte_val_val (x, y) = gcompare_val_val<a> (x, y) >= 0

(* ****** ****** *)

implement{a}
glt_val_int (x, y) = glt_val_val<a> (x, gnumber_int<a>(y))
implement{a}
glte_val_int (x, y) = glte_val_val<a> (x, gnumber_int<a>(y))
implement{a}
ggt_val_int (x, y) = ggt_val_val<a> (x, gnumber_int<a>(y))
implement{a}
ggte_val_int (x, y) = ggte_val_val<a> (x, gnumber_int<a>(y))

(* ****** ****** *)

implement{a}
geq_val_val (x, y) = gcompare_val_val<a> (x, y) = 0
implement{a}
gneq_val_val (x, y) = gcompare_val_val<a> (x, y) != 0

(* ****** ****** *)

implement{a}
geq_val_int (x, y) = geq_val_val<a> (x, gnumber_int<a>(y))
implement{a}
gneq_val_int (x, y) = gneq_val_val<a> (x, gnumber_int<a>(y))

(* ****** ****** *)

implement{a}
gisltz_val (x) = glt_val_int<a> (x, 0)
implement{a}
gisltez_val (x) = glte_val_int<a> (x, 0)
implement{a}
gisgtz_val (x) = ggt_val_int<a> (x, 0)
implement{a}
gisgtez_val (x) = ggte_val_int<a> (x, 0)

(* ****** ****** *)

implement{a}
giseqz_val (x) = geq_val_int<a> (x, 0)
implement{a}
gisneqz_val (x) = gneq_val_int<a> (x, 0)

(* ****** ****** *)

implement{a}
glt_ref_ref (x, y) = gcompare_ref_ref<a> (x, y) < 0
implement{a}
glte_ref_ref (x, y) = gcompare_ref_ref<a> (x, y) <= 0
implement{a}
ggt_ref_ref (x, y) = gcompare_ref_ref<a> (x, y) > 0
implement{a}
ggte_ref_ref (x, y) = gcompare_ref_ref<a> (x, y) >= 0

(* ****** ****** *)

implement{a}
geq_ref_ref (x, y) = gcompare_ref_ref<a> (x, y) = 0
implement{a}
gneq_ref_ref (x, y) = gcompare_ref_ref<a> (x, y) != 0

(* ****** ****** *)

implement(a:t0p)
gcompare_ref_ref<a> (x, y) = gcompare_val_val<a> (x, y)

(* ****** ****** *)

implement{a}
gabs_val (x) =
  if gisgtez_val (x) then x else gneg_val<a> (x)
// end of [gabs_val]

(* ****** ****** *)

implement{a}
gmax_val_val (x, y) = if ggte_val_val (x, y) then x else y
implement{a}
gmin_val_val (x, y) = if glte_val_val (x, y) then x else y

(* ****** ****** *)

#include "./SHARE/gorder_int.dats"
#include "./SHARE/gorder_uint.dats"

(* ****** ****** *)

#include "./SHARE/gorder_bool.dats"
#include "./SHARE/gorder_char.dats"

(* ****** ****** *)

#include "./SHARE/gorder_float.dats"

(* ****** ****** *)

#include "./SHARE/gorder_string.dats"

(* ****** ****** *)

(* end of [gorder.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/grandom.atxt
** Time of generation: Sat Oct 17 15:19:55 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: June, 2015 *)

(* ****** ****** *)

implement{} grandom_int() = 0
implement{} grandom_uint() = 0u

(* ****** ****** *)

implement{} grandom_bool() = false

(* ****** ****** *)

implement{} grandom_float() = 0.0f
implement{} grandom_double() = 0.0

(* ****** ****** *)

implement
grandom_val<int> () = grandom_int<> ()
implement
grandom_val<uint> () = grandom_uint<> ()

(* ****** ****** *)

implement
grandom_val<bool> () = grandom_bool<> ()

(* ****** ****** *)

implement
grandom_val<double> () = grandom_double<> ()

(* ****** ****** *)

implement
{a}(*tmp*)
grandom_ref(x) = (x := grandom_val<a> ())

(* ****** ****** *)
//
implement
{a}(*tmp*)
grandom_list
  (n) = list_vt2t(grandom_list_vt<a>(n))
//
implement
{a}(*tmp*)
grandom_list_vt
  (n) = res where
{
//
fun loop
  {n:nat} .<n>.
(
  n: int n, res: &ptr? >> list_vt (a, n)
) : void = let
in
//
if n > 0 then let
//
val () =
  res := cons_vt{a}{0} (_, _)
// end of [val]
val+list_vt_cons (x, res1) = res
val () = grandom_ref<a> (x)
val () = loop (pred (n), res1)
//
in
  fold@ (res)
end else res := nil_vt((*void*))
//
end // end of [loop]
//
var res: ptr // uninitialized
val () = loop (n, res)
//
} (* end of [grandom_list_vt] *)
//
(* ****** ****** *)

implement
{a}(*tmp*)
grandom_arrayptr
  (n) = A where {
//
val A =
  arrayptr_make_uninitized<a> (n)
//
implement
array_initize$init<a> (_, x) = grandom_ref<a> (x)
//
prval pf = arrayptr_takeout (A)
val () = array_initize<a> (!(ptrcast(A)), n)
prval () = arrayptr_addback (pf | A)
//
} (* end of [grandom_arrayptr] *)

implement
{a}(*tmp*)
grandom_arrayref (n) =
  arrayptr_refize(grandom_arrayptr<a> (n))
// end of [grandom_arrayref]

implement
{a}(*tmp*)
grandom_arrszref (n) = let
  val n = g1ofg0_uint (n) in
  arrszref_make_arrayref (grandom_arrayref<a> (n), n)
end // end of [grandom_arrszref]

(* ****** ****** *)

(* end of [grandom.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/list.atxt
** Time of generation: Sun Oct 18 14:27:09 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: July, 2012 *)

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)
//
implement
{a}(*tmp*)
stream_sing(x) =
  stream_cons{a}(x, $delay(stream_nil))
//
(* ****** ****** *)

implement
{a}(*tmp*)
stream2list (xs) = let
//
fun loop
(
  xs: stream (a), res: &ptr? >> List0_vt (a)
) : void = let
in
  case+ !xs of
  | stream_cons
      (x, xs) => let
      val () =
      res := list_vt_cons{a}{0}(x, _)
      val+list_vt_cons (_, res1) = res
      val ((*void*)) = loop (xs, res1)
    in
      fold@ (res)
    end // end of [stream_cons]
  | stream_nil () => res := list_vt_nil ()
end // end of [loop]
var res: ptr // uninitialized
val () = $effmask_all (loop (xs, res))
//
in
  res
end // end of [stream2list]

(* ****** ****** *)

implement
{a}(*tmp*)
stream_nth_exn
  (xs, n) = let
in
  case+ !xs of
  | stream_cons
      (x, xs) =>
    (
      if n > 0
        then stream_nth_exn<a> (xs, pred(n)) else (x)
      // end of [if]
    )
  | stream_nil () => $raise StreamSubscriptExn()
end // end of [stream_nth_exn]

implement
{a}(*tmp*)
stream_nth_opt
  (xs, n) = let
in
  try Some_vt(stream_nth_exn<a> (xs, n)) with ~StreamSubscriptExn() => None_vt()
end // end of [stream_nth_opt]

(* ****** ****** *)

implement
{a}(*tmp*)
stream_take_exn
  (xs, n) = let
//
fun loop{n:nat}
(
  xs: stream a, res: &ptr? >> list_vt (a, n-k), n: int n
) : #[k:nat | k <= n] int k =
  if n > 0 then (
    case+ !xs of
    | stream_cons
        (x, xs) => let
        val () =
        res := list_vt_cons{a}{0}(x, _)
        val+list_vt_cons (_, res1) = res
        val k = loop (xs, res1, pred(n))
        prval () = fold@ (res)
      in
        k
      end // end of [stream_cons]
    | stream_nil () => let
        val () = res := list_vt_nil () in n
      end // end of [stream_nil]
  ) else let
    val () = res := list_vt_nil () in n
  end // end of [if]
//
var res: ptr // uninitialized
val k = $effmask_all (loop (xs, res, n))
//
in
//
$effmask_all (
if k = 0 then res else let
  val () = list_vt_free (res) in $raise StreamSubscriptExn()
end // end of [if]
) // end of [$effmask_all]
//
end // end of [stream_take_exn]

(* ****** ****** *)

implement
{a}(*tmp*)
stream_drop_exn
  (xs, n) = let
in
//
if n > 0 then
(
  case+ !xs of
  | stream_cons
      (_, xs) => stream_drop_exn (xs, pred(n))
  | stream_nil () => $raise StreamSubscriptExn()
) else (xs) // end of [if]
//
end // end of [stream_drop_exn]

(* ****** ****** *)

implement
{a}(*tmp*)
stream_append
  (xs, ys) = let
//
fun aux
(
  xs: stream(a)
, ys: stream(a)
) : stream_con(a) =
  case+ !xs of
  | stream_nil () => !ys
  | stream_cons (x, xs) => stream_cons (x, $delay (aux (xs, ys)))
//
in
//
  $delay (aux (xs, ys))
//
end // end of [stream_append]

(* ****** ****** *)

implement
{a}(*tmp*)
stream_concat (xss) = let
//
fun aux1
(
  xss: stream(stream(a))
) : stream_con(a) =
(
  case+ !xss of
  | stream_nil () => stream_nil ()
  | stream_cons (xs, xss) => aux2 (xs, xss)
)
and aux2
(
  xs: stream(a), xss: stream(stream(a))
) : stream_con(a) =
  case+ !xs of
  | stream_nil () => aux1 (xss)
  | stream_cons (x, xs) => stream_cons (x, $delay (aux2 (xs, xss)))
//
in
  $delay (aux1 (xss))
end // end of [stream_concat]

(* ****** ****** *)

local

fun{a:t0p}
stream_filter_con
  (xs: stream a): stream_con(a) = let
in
//
case+ !xs of
| stream_cons
    (x, xs) =>
  (
    if stream_filter$pred<a> (x)
      then stream_cons{a}(x, stream_filter<a> (xs)) else stream_filter_con<a> (xs)
    // end of [if]
  ) // end of [stream_cons]
| stream_nil () => stream_nil ()
//
end // end of [stream_filter_con]

in (* in of [local] *)

implement
{a}(*tmp*)
stream_filter (xs) =
  $delay (stream_filter_con<a> (xs))
// end of [stream_filter]

implement
{a}(*tmp*)
stream_filter_fun
  (xs, p) = let
//
implement{a2}
stream_filter$pred (x) = p($UN.cast{a}(x))
//
in
  stream_filter (xs)
end // end of [stream_filter_fun]

implement
{a}(*tmp*)
stream_filter_cloref (xs, p) = let
//
implement{a2}
stream_filter$pred (x) = p($UN.cast{a}(x))
//
in
  stream_filter (xs)
end // end of [stream_filter_cloref]

end // end of [local]

(* ****** ****** *)

implement
{a}{b}
stream_map
  (xs) = let
//
fun aux
(
  xs: stream (a)
) :<!laz> stream (b) = $delay
(
case+ !xs of
| stream_nil () => stream_nil ()
| stream_cons (x, xs) =>
    stream_cons{b}(stream_map$fopr<a><b> (x), aux (xs))
  // end of [stream_cons]
) : stream_con (b) // end of [$delay]
//
in
  aux (xs)
end // end of [stream_map]

implement
{a}{b}
stream_map_fun
  (xs, f) = let
//
implement
{a2}{b2}
stream_map$fopr (x) = $UN.cast{b2}(f($UN.cast{a}(x)))
//
in
  stream_map<a><b> (xs)
end // end of [stream_map_fun]

implement
{a}{b}
stream_map_cloref
  (xs, f) = let
//
implement
{a2}{b2}
stream_map$fopr (x) = $UN.cast{b2}(f($UN.cast{a}(x)))
//
in
  stream_map<a><b> (xs)
end // end of [stream_map_cloref]

(* ****** ****** *)

implement
{a}{b}
stream_imap
  (xs) = let
//
fun aux
(
  i: intGte(0), xs: stream (a)
) :<!laz> stream (b) = $delay
(
case+ !xs of
| stream_nil () => stream_nil ()
| stream_cons
    (x, xs) => let
    val y =
      stream_imap$fopr<a><b> (i, x)
    // end of [val]
  in
    stream_cons{b}(y, aux (succ (i), xs))
  end // end of [stream_cons]
) : stream_con (b) // end of [$delay]
//
in
  aux (0, xs)
end // end of [stream_imap]

implement
{a}{b}
stream_imap_fun
  (xs, f) = let
//
implement
{a2}{b2}
stream_imap$fopr
  (i, x) = $UN.cast{b2}(f(i, $UN.cast{a}(x)))
//
in
  stream_imap<a><b> (xs)
end // end of [stream_imap_fun]

implement
{a}{b}
stream_imap_cloref
  (xs, f) = let
//
implement
{a2}{b2}
stream_imap$fopr
  (i, x) = $UN.cast{b2}(f(i, $UN.cast{a}(x)))
//
in
  stream_imap<a><b> (xs)
end // end of [stream_imap_cloref]

(* ****** ****** *)

local

#define :: stream_cons

in (* in of [local] *)

implement
{a1,a2}{b}
stream_map2
(
  xs1, xs2
) = $delay (
(
case+ !xs1 of
| x1 :: xs1 => (
  case+ !xs2 of
  | x2 :: xs2 => let
      val y =
        stream_map2$fopr<a1,a2><b> (x1, x2)
      // end of [val]
    in
      stream_cons{b}(y, stream_map2<a1,a2><b> (xs1, xs2))
    end // end of [::]
  | stream_nil () => stream_nil ()
  ) // end of [::]
| stream_nil () => stream_nil ()
) : stream_con (b)
) // end of [stream_map2]

end // end of [local]

implement
{a1,a2}{b}
stream_map2_fun
  (xs1, xs2, f) = let
//
implement
{a12,a22}{b2}
stream_map2$fopr (x1, x2) =
  $UN.cast{b2}(f($UN.cast{a1}(x1), $UN.cast{a2}(x2)))
//
in
  stream_map2<a1,a2><b> (xs1, xs2)
end // end of [stream_map2_fun]

implement
{a1,a2}{b}
stream_map2_cloref
  (xs1, xs2, f) = let
//
implement
{a12,a22}{b2}
stream_map2$fopr (x1, x2) =
  $UN.cast{b2}(f($UN.cast{a1}(x1), $UN.cast{a2}(x2)))
//
in
  stream_map2<a1,a2><b> (xs1, xs2)
end // end of [stream_map2_cloref]

(* ****** ****** *)

implement
{res}{x}
stream_scan
  (xs, ini) = let
//
fun aux
(
  xs: stream(x), ini: res
) :<!laz> stream (res) = $delay
(
case+ !xs of
| stream_nil
    () => stream_nil ()
  // end of [stream_nil]
| stream_cons(x, xs) =>
  stream_cons{res}
    (stream_scan$fopr<res><x> (ini, x), aux (xs, ini))
  // end of [stream_cons]
) : stream_con(res) // end of [$delay]
//
in
  aux (xs, ini)
end // end of [stream_scan]

(* ****** ****** *)

implement
{res}{x}
stream_scan_fun
  (xs, ini, f) = let
//
implement
{res2}{x2}
stream_scan$fopr
  (ini, x) =
  $UN.cast{res2}(f($UN.cast{res}(ini), $UN.cast{x}(x)))
//
in
  stream_scan<res><x> (xs, ini)
end // end of [stream_scan_fun]

implement
{res}{x}
stream_scan_cloref
  (xs, ini, f) = let
//
implement
{res2}{x2}
stream_scan$fopr
  (ini, x) =
  $UN.cast{res2}(f($UN.cast{res}(ini), $UN.cast{x}(x)))
//
in
  stream_scan<res><x> (xs, ini)
end // end of [stream_scan_cloref]

(* ****** ****** *)

local

#define :: stream_cons

in (* in of [local] *)

implement
{a}(*tmp*)
stream_merge
  (xs10, xs20) = $delay
(
(
case+ !xs10 of
| x1 :: xs1 => (
  case+ !xs20 of
  | x2 :: xs2 => let
      val sgn =
        stream_merge$cmp<a> (x1, x2)
      // end of [val]
    in
      if sgn <= 0 then
        stream_cons{a}(x1, stream_merge (xs1, xs20))
      else
        stream_cons{a}(x2, stream_merge (xs10, xs2))
      // end of [if]
    end // end of [::]
  | stream_nil () => stream_cons{a}(x1, xs1)
  ) (* end of [::] *)
| stream_nil () => !xs20
) : stream_con (a)
) // end of [stream_merge]

end // end of [local]

implement
{a}(*tmp*)
stream_merge_fun
  (xs1, xs2, cmp) = let
//
implement{a2}
stream_merge$cmp (x1, x2) =
  cmp ($UN.cast{a}(x1), $UN.cast{a}(x2))
//
in
  stream_merge (xs1, xs2)
end // end of [stream_merge_fun]

implement
{a}(*tmp*)
stream_merge_cloref
  (xs1, xs2, cmp) = let
//
implement{a2}
stream_merge$cmp (x1, x2) =
  cmp ($UN.cast{a}(x1), $UN.cast{a}(x2))
//
in
  stream_merge (xs1, xs2)
end // end of [stream_merge_cloref]

(* ****** ****** *)
//
implement
{a}(*tmp*)
stream_merge$cmp
  (x1, x2) = gcompare_val_val<a> (x1, x2)
//
(* ****** ****** *)

local

#define :: stream_cons

in (* in of [local] *)

implement
{a}(*tmp*)
stream_mergeq
  (xs10, xs20) = $delay
(
(
case+ !xs10 of
| x1 :: xs1 => (
  case+ !xs20 of
  | x2 :: xs2 => let
      val sgn =
        stream_mergeq$cmp<a> (x1, x2)
      // end of [val]
    in
      if sgn < 0 then
        stream_cons{a}(x1, stream_mergeq (xs1, xs20))
      else if sgn > 0 then
        stream_cons{a}(x2, stream_mergeq (xs10, xs2))
      else
        stream_cons{a}(x1(*=x2*), stream_mergeq (xs1, xs2))
      // end of [if]
    end // end of [::]
  | stream_nil () => stream_cons{a}(x1, xs1)
  ) (* end of [::] *)
| stream_nil () => !xs20
) : stream_con (a)
) // end of [stream_mergeq]

end // end of [local]

implement
{a}(*tmp*)
stream_mergeq_fun
  (xs1, xs2, cmp) = let
//
implement{a2}
stream_mergeq$cmp (x1, x2) =
  cmp ($UN.cast{a}(x1), $UN.cast{a}(x2))
//
in
  stream_mergeq (xs1, xs2)
end // end of [stream_mergeq_fun]

implement
{a}(*tmp*)
stream_mergeq_cloref
  (xs1, xs2, cmp) = let
//
implement{a2}
stream_mergeq$cmp (x1, x2) =
  cmp ($UN.cast{a}(x1), $UN.cast{a}(x2))
//
in
  stream_mergeq (xs1, xs2)
end // end of [stream_mergeq_cloref]

(* ****** ****** *)
//
implement
{a}(*tmp*)
stream_mergeq$cmp
  (x1, x2) = gcompare_val_val<a> (x1, x2)
//
(* ****** ****** *)

implement
{a}(*tmp*)
stream_tabulate () = let
//
fun
aux{n:nat}
(
  n: int(n)
) : stream(a) = $delay
(
  stream_cons{a}(stream_tabulate$fopr<a> (n), aux (n+1))
)
//
in
  aux (0)
end // end of [stream_tabulate]

(* ****** ****** *)

implement
{a}(*tmp*)
stream_tabulate_fun (f) = let
//
implement
{a2}(*tmp*)
stream_tabulate$fopr (n) = $UN.cast{a2}(f(n))
//
in
  stream_tabulate ()
end // end of [stream_tabulate_fun]

implement
{a}(*tmp*)
stream_tabulate_cloref (f) = let
//
implement
{a2}(*tmp*)
stream_tabulate$fopr (n) = $UN.cast{a2}(f(n))
//
in
  stream_tabulate ()
end // end of [stream_tabulate_cloref]

(* ****** ****** *)

implement
{a}{env}
stream_foreach$cont (x, env) = true

implement
{a}(*tmp*)
stream_foreach (xs) = let
  var env: void = () in stream_foreach_env<a><void> (xs, env)
end // end of [stream_foreach]

implement
{a}{env}
stream_foreach_env
  (xs, env) = let
//
fun loop
(
  xs: stream(a), env: &env >> _
) : void =
(
//
case+ !xs of
| stream_nil () => ()
| stream_cons (x, xs) => let
    val test =
      stream_foreach$cont<a><env> (x, env)
    // end of [val]
  in
    if test
      then let
        val () =
          stream_foreach$fwork<a><env> (x, env)
        // end of [val]
      in
        loop (xs, env)
      end // end of [then]
      else () // end of [else]
    // end of [if]
  end // end of [stream_cons]
//
) (* end of [loop] *)
//
in
  loop (xs, env)
end (* end of [stream_foreach_env] *)

(* ****** ****** *)

implement
{a}(*tmp*)
fprint_stream
  (out, xs, n) = let
//
var env: int = 0
typedef tenv = int
//
implement
stream_foreach$cont<a><tenv>
  (x, env) =
  if n > env then true else false
implement
stream_foreach$fwork<a><tenv>
  (x, env) =
{
  val () =
  if env > 0
    then fprint_stream$sep<> (out)
  // end of [if]
  val () = env := env + 1
  val () = fprint_val<a> (out, x)
} (* end of [stream_foreach$fwork] *)
//
in
  stream_foreach_env<a><tenv> (xs, env)
end // end of [fprint_stream]

implement{}
fprint_stream$sep (out) = fprint_string (out, ", ")

(* ****** ****** *)

(* end of [stream.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/array.atxt
** Time of generation: Sat Oct 17 15:19:56 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: Feburary, 2012 *)

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"
staload IT = "prelude/SATS/giterator.sats"

(* ****** ****** *)

macdef castvwtp_trans = $UN.castvwtp0 // former name

(* ****** ****** *)

implement{a}
array_getref_at
  (A, i) = let
  val p = ptr0_add_guint<a> (addr@(A), i) in $UN.cast{cPtr1(a)}(p)
end // end of [array_getref_at]

(* ****** ****** *)

implement{a}{tk}
array_get_at_gint (A, i) = let
  val p = ptr0_add_gint<a> (addr@(A), i) in $UN.ptr0_get<a> (p)
end // end of [array_get_at_gint]
implement{a}{tk}
array_get_at_guint (A, i) = let
  val p = ptr0_add_guint<a> (addr@(A), i) in $UN.ptr0_get<a> (p)
end // end of [array_get_at_guint]

(* ****** ****** *)

implement{a}{tk}
array_set_at_gint (A, i, x) = let
  val p = ptr0_add_gint<a> (addr@(A), i) in $UN.ptr0_set<a> (p, x)
end // end of [array_set_at_uint]
implement{a}{tk}
array_set_at_guint (A, i, x) = let
  val p = ptr0_add_guint<a> (addr@(A), i) in $UN.ptr0_set<a> (p, x)
end // end of [array_set_at_guint]

(* ****** ****** *)

implement{a}{tk}
array_exch_at_gint (A, i, x) = let
  val p = ptr0_add_gint<a> (addr@(A), i) in $UN.ptr0_exch<a> (p, x)
end // end of [array_exch_at_gint]
implement{a}{tk}
array_exch_at_guint (A, i, x) = let
  val p = ptr0_add_guint<a> (addr@(A), i) in $UN.ptr0_exch<a> (p, x)
end // end of [array_exch_at_guint]

(* ****** ****** *)

implement{a}
array_subreverse
  (A, i, j) = let
//
fun
loop
(
  p1: ptr, p2: ptr
) : void =
(
if
p1 < p2
then let
  val x = $UN.ptr0_get<a> (p1)
  val () =
  $UN.ptr0_set<a> (p1, $UN.ptr0_get<a> (p2))
  val () = $UN.ptr0_set<a> (p2, x)
in
  loop (ptr0_succ<a> (p1), ptr0_pred<a> (p2))
end // end of [then]
else () // end of [else]
) (* end of [loop] *)
//
val pA = addr@A
val pi = ptr_add<a> (pA, i)
val pj = ptr_add<a> (pA, j)
//
in
  $effmask_all(loop (pi, ptr0_pred<a> (pj)))
end // end of [array_subreverse]

(* ****** ****** *)

implement{a}
array_interchange
  (A, i, j) = let
in
//
if i != j then let
  val p = addr@(A)
  val pi = ptr0_add_guint<a> (p, i)
  val pj = g1ofg0_ptr (ptr0_add_guint<a> (p, j))
  val (pf, fpf | pj) = $UN.ptr_vtake{a}(pj)
  val () = $UN.ptr0_exch<a> (pi, !pj)
  prval () = fpf (pf)
in
  // nothing
end else () // end of [if]
//
end // end of [array_interchange]

(* ****** ****** *)

implement{a}
array_subcirculate
  (A, i, j) = let
//
extern
fun memmove
(
  dst: ptr, src: ptr, bsz: size_t
) :<!wrt> ptr = "mac#atspre_array_memmove"
//
in
//
if i < j then
{
//
val p0 = ptr_add<a> (addr@(A), i)
val p1 = ptr_add<a> (addr@(A), j)
val A1 = $UN.ptr0_get<a> (p1)
val _(*ptr*) = memmove (ptr_succ<a>(p0), p0, (j-i)*sizeof<a>)
val () = $UN.ptr0_set<a> (p0, A1)
//
} else if i > j then
{
//
val p0 = ptr_add<a> (addr@(A), j)
val p1 = ptr_add<a> (addr@(A), i)
val A0 = $UN.ptr0_get<a> (p0)
val _(*ptr*) = memmove (p0, ptr_succ<a>(p0), (i-j)*sizeof<a>)
val () = $UN.ptr0_set<a> (p1, A0)
//
} else () // end of [if]
//
end // end of [array_subcirculate]

(* ****** ****** *)

implement{a}
array_ptr_takeout
  {l}{n}{i}(pf | p, i) = let
  prval (pf, fpf) =
    array_v_takeout {a}{l}{n}{i} (pf)
  // end of [prval]
in
  (pf, fpf | ptr1_add_guint<a> (p, i))
end // end of [array_ptr_takeout]

(* ****** ****** *)

implement{a}
array_ptr_alloc
  {n} (asz) = let
  val [l:addr] (
    pf, pfgc | p
  ) = malloc_gc (asz * sizeof<a>)
  prval pf =
    __assert (pf) where {
    extern praxi __assert
      (pf: b0ytes (n*sizeof(a)) @ l): array_v (a?, l, n)
    // end of [__assert]
  } // end of [where] // end of [prval]
in
  (pf, pfgc | p)
end // end of [array_ptr_alloc]

(* ****** ****** *)

implement{}
array_ptr_free
  {a}{l}{n}
  (pf, pfgc | p) = let
  prval pf =
    __assert (pf) where {
    extern praxi __assert
      (pf: array_v (a?, l, n)): b0ytes (n*sizeof(a)) @ l
    // end of [__assert]
  } // end of [where] // end of [prval]
in
  mfree_gc (pf, pfgc | p)
end // end of [array_ptr_free]

(* ****** ****** *)

implement{a}
array_ptr_tabulate (asz) = let
//
val
(
  pf, pfgc | p
) = array_ptr_alloc<a> (asz)
//
local
implement{a}
array_initize$init (i, x) = x := array_tabulate$fopr<a> (i)
in (*in of [local]*)
val () = array_initize<a> (!p, asz)
end // end of [local]
//
in
  @(pf, pfgc | p)
end // end of [array_ptr_tabulate]

(* ****** ****** *)

implement{a}
fprint_array_int
  (out, A, asz) = let
//
prval () = lemma_array_param (A)
//
in
  fprint_array_size (out, A, i2sz(asz))
end // end of [fprint_array_int]

implement{a}
fprint_array_size
  (out, A, asz) = let
//
typedef tenv = int
//
implement
array_foreach$fwork<a><tenv>
  (x, env) = let
  val n = env
  val () = if n > 0 then fprint_array$sep<> (out)
  val () = env := n + 1
in
  fprint_ref<a> (out, x)
end // end of [array_foreach$fwork]
//
var env: tenv = 0
val _(*n*) = array_foreach_env<a><tenv> (A, asz, env)
//
in
  // nothing
end // end of [fprint_array_size]

(* ****** ****** *)

implement{}
fprint_array$sep (out) = fprint (out, ", ")

(* ****** ****** *)

implement{a}
fprint_array_sep
  (out, A, asz, sep) = let
//
implement
fprint_array$sep<> (out) = fprint (out, sep)
//
in
  fprint_array<a> (out, A, asz)
end // end of [fprint_array_sep]

(* ****** ****** *)

implement
{a}(*tmp*)
array_copy
  {n} (to, from, n) = let
//
val p_to = addr@(to) and p_from = addr@(from)
//
val _ =
$extfcall
(
  ptr, "atspre_array_memcpy", p_to, p_from, n*sizeof<a>
) (* end of [val] *)
//
extern
praxi __assert {l1,l2:addr}
(
  pf1: !array_v (a?, l1, n) >> array_v (a  , l1, n)
, pf2: !array_v (a , l2, n) >> array_v (a?!, l2, n)
) : void // end of [__assert]
//
prval () = __assert (view@ (to), view@ (from))
//
in
  // nothing
end // end of [array_copy]

(* ****** ****** *)

implement{a}
array_copy_from_list
  (A, xs) = let
//
prval () = lemma_list_param (xs)
//
fun loop
  {l:addr}{n:nat} .<n>. (
  pf: !array_v (a?, l, n) >> array_v (a, l, n)
| p: ptr l, xs: list (a, n)
) :<!wrt> void = (
  case+ xs of
  | list_cons (x, xs) => let
      prval (pf1, pf2) = array_v_uncons (pf)
      val () = !p := x
      val () = loop (pf2 | ptr1_succ<a> (p), xs)
      prval () = pf := array_v_cons (pf1, pf2)
    in
      // nothing
    end // end of [list_cons]
  | list_nil () => let
      prval () = pf := array_v_unnil_nil (pf)
    in
      // nothing
    end // end of [list_nil]
) (* end of [loop] *)
//
in
  loop (view@(A) | addr@(A), xs)
end // end of [array_copy_from_list]

(* ****** ****** *)

implement{a}
array_copy_from_list_vt
  (A, xs) = let
//
prval () = lemma_list_vt_param (xs)
//
fun loop
  {l:addr}{n:nat} .<n>. (
  pf: !array_v (a?, l, n) >> array_v (a, l, n)
| p: ptr l, xs: list_vt (a, n)
) :<!wrt> void = (
  case+ xs of
  | ~list_vt_cons (x, xs) => let
      prval (pf1, pf2) = array_v_uncons (pf)
      val () = !p := x
      val () = loop (pf2 | ptr1_succ<a> (p), xs)
      prval () = pf := array_v_cons (pf1, pf2)
    in
      // nothing
    end // end of [list_vt_cons]
  | ~list_vt_nil () => let
      prval () = pf := array_v_unnil_nil (pf)
    in
      // nothing
    end // end of [list_vt_nil]
) (* end of [loop] *)
//
in
  loop (view@(A) | addr@(A), xs)
end // end of [array_copy_from_list_vt]

(* ****** ****** *)

implement{a}
array_copy_to_list_vt
  (A, n) = res where {
//
prval () = lemma_array_param (A)
//
fun loop
  {l:addr}{n:nat} .<n>. (
  pf: !array_v (a, l, n) >> array_v (a?!, l, n)
| p: ptr l, n: size_t n, res: &ptr? >> list_vt (a, n)
) :<!wrt> void = (
  if n > 0 then let
    prval (pf1, pf2) = array_v_uncons (pf)
    val () = res := list_vt_cons {a}{0} (!p, _)
    val+list_vt_cons (_, res1) = res
    val () = loop (pf2 | ptr1_succ<a> (p), pred(n), res1)
    prval () = pf := array_v_cons (pf1, pf2)
    prval () = fold@ (res)
  in
    // nothing
  end else let
    prval () = pf := array_v_unnil_nil (pf)
  in
    res := list_vt_nil ()
  end // end of [if]
) (* end of [loop] *)
//
var res: ptr
val () = loop (view@(A) | addr@(A), n, res)
//
} // end of [array_copy_to_list_vt]

(* ****** ****** *)

implement{a}
array_foreach
  (A, asz) = let
  var env: void = ()
in
  array_foreach_env<a><void> (A, asz, env)
end // end of [array_foreach]

implement
{a}{env}
array_foreach_env
  {n0} (A, asz, env) = let
//
prval () = lemma_array_param (A)
//
fun loop
  {l:addr}
  {n:nat | n <= n0} .<n>.
(
  pf: !array_v (a, l, n)
| p: ptr l, n: size_t n, env: &env
) : sizeLte (n0) = let
in
//
if n > 0 then let
  prval
  (
    pf1, pf2
  ) = array_v_uncons (pf)
  val cont = array_foreach$cont<a><env> (!p, env)
in
  if cont then let
    val () = array_foreach$fwork<a><env> (!p, env)
    val res = loop (pf2 | ptr1_succ<a> (p), pred(n), env)
    prval () = pf := array_v_cons (pf1, pf2)
  in
    res
  end else let
    prval () = pf := array_v_cons (pf1, pf2) in n
  end (* end of [if] *)
end else n(*0*)
//
end // end of [loop]
//
val p_beg = addr@(A)
val n = loop (view@(A) | p_beg, asz, env)
//
in
  asz - n
end // end of [array_foreach_env]

(* ****** ****** *)

implement{a}{env}
array_foreach$cont (x, env) = true
(*
implement{a}{env}
array_foreach$fwork (x, env) = ((*void*))
*)

(* ****** ****** *)

implement{a}
array_foreach_fun
  {n}{fe} (A, asz, f) = let
  typedef tfun = (!unit_v | &a, !ptr) -<fun,fe> void
  val f = $UN.cast{tfun} (f)
  prval pfu = unit_v ()
  var env: ptr = the_null_ptr
  val () = array_foreach_funenv<a> (pfu | A, asz, f, env)
  prval () = unit_v_elim (pfu)
in
  // nothing
end // end of [array_foreach_fun]

implement{a}
array_foreach_cloref
  {n}{fe} (A, asz, f) = let
//
  viewdef v = unit_v
  typedef vt = (&a) -<cloref,fe> void
//
  fun app .<>. (pf: !v | x: &a, env: !vt):<fe> void = env (x)
  prval pfu = unit_v ()
  var env = f
  val () = array_foreach_funenv<a> {v}{vt} (pfu | A, asz, app, env)
  prval () = unit_v_elim (pfu)
in
  // nothing
end // end of [array_foreach_cloref]

(* ****** ****** *)

implement{a}
array_foreach_funenv
  {v}{vt}
(
  pf | A, asz, f, env
) =
  array_foreach_funenv_tsz{a}{v}{vt} (pf | A, asz, sizeof<a>, f, env)
// end of [array_foreach_funenv]

(* ****** ****** *)

implement
{a1,a2}(*tmp*)
array_foreach2
  (A1, A2, asz) = let
  var env: void = ()
in
  array_foreach2_env<a1,a2><void> (A1, A2, asz, env)
end // end of [array_foreach2]

implement
{a1,a2}{env}
array_foreach2_env
  {n0} (A1, A2, asz, env) = let
//
prval () = lemma_array_param (A1)
//
fun loop
  {l1,l2:addr}
  {n:nat | n <= n0} .<n>. (
  pf1: !array_v (a1, l1, n)
, pf2: !array_v (a2, l2, n)
| p1: ptr l1, p2: ptr l2, n: size_t n, env: &env
) : sizeLte (n0) = let
in
  if n > 0 then let
    prval (pf11, pf12) = array_v_uncons (pf1)
    prval (pf21, pf22) = array_v_uncons (pf2)
    val cont = array_foreach2$cont<a1,a2><env> (!p1, !p2, env)
  in
    if cont then let
      val () = array_foreach2$fwork<a1,a2><env> (!p1, !p2, env)
      val res = loop (
        pf12, pf22 | ptr1_succ<a1> (p1), ptr1_succ<a2> (p2), pred(n), env
      ) // end of [val]
      prval () = pf1 := array_v_cons (pf11, pf12)
      prval () = pf2 := array_v_cons (pf21, pf22)
    in
      res
    end else let
      prval () = pf1 := array_v_cons (pf11, pf12)
      prval () = pf2 := array_v_cons (pf21, pf22) in n
    end (* end of [if] *)
  end else n(*0*)
end // end of [loop]
//
val p1_beg = addr@(A1)
val p2_beg = addr@(A2)
val n = loop (view@(A1), view@(A2) | p1_beg, p2_beg, asz, env)
//
in
  asz - n
end // end of [array_foreach2_env]

(* ****** ****** *)

implement
{a1,a2}{env}
array_foreach2$cont (x1, x2, env) = true
(*
implement
{a1,a2}{env}
array_foreach2$fwork (x1, x2, env) = ((*void*))
*)

(* ****** ****** *)

implement{a}
array_iforeach
  (A, asz) = let
  var env: void = ()
in
  array_iforeach_env<a><void> (A, asz, env)
end // end of [array_iforeach]

implement
{a}{env}
array_iforeach_env
  {n0} (A, asz, env) = let
//
prval () = lemma_array_param (A)
//
fun loop
  {l:addr}
  {n:nat | n <= n0} .<n>. (
  pf: !array_v (a, l, n)
| i: size_t, p: ptr l, n: size_t n, env: &env
) : sizeLte (n0) = let
in
//
if n > 0 then let
  prval (
    pf1, pf2
  ) = array_v_uncons (pf)
  val cont = array_iforeach$cont<a><env> (i, !p, env)
in
  if cont then let
    val () = array_iforeach$fwork<a><env> (i, !p, env)
    val res = loop (pf2 | succ(i), ptr1_succ<a> (p), pred(n), env)
    prval () = pf := array_v_cons (pf1, pf2)
  in
    res
  end else let
    prval () = pf := array_v_cons (pf1, pf2) in n
  end (* end of [if] *)
end else n(*0*)
//
end // end of [loop]
//
val p_beg = addr@(A)
val n = loop (view@(A) | g0int2uint(0), p_beg, asz, env)
//
in
  asz - n
end // end of [array_iforeach_env]

(* ****** ****** *)

implement{a}{env}
array_iforeach$cont (i, x, env) = true
(*
implement{a}{env}
array_iforeach$fwork (i, x, env) = ((*void*))
*)

(* ****** ****** *)

implement{a}
array_rforeach
  (A, asz) = let
  var env: void = ()
in
  array_rforeach_env<a><void> (A, asz, env)
end // end of [array_rforeach]

implement
{a}{env}
array_rforeach_env
  {n0} (A, asz, env) = let
//
prval () = lemma_array_param (A)
//
fun loop
  {l:addr}
  {n:nat | n <= n0} .<n>.
(
  pf: !array_v (a, l, n)
| p: ptr (l+n*sizeof(a)), n: size_t n, env: &env
) : sizeLte (n0) = let
in
//
if n > 0 then let
  prval
  (
    pf1, pf2
  ) = array_v_unextend (pf)
  val p1 = ptr1_pred<a> (p)
  val (pf2 | p1) = viewptr_match (pf2 | p1)
  val cont = array_rforeach$cont<a><env> (!p1, env)
in
  if cont then let
    val () = array_rforeach$fwork<a><env> (!p1, env)
    val res = loop (pf1 | p1, pred(n), env)
    prval () = pf := array_v_extend (pf1, pf2)
  in
    res
  end else let
    prval () = pf := array_v_extend (pf1, pf2) in n
  end (* end of [if] *)
end else n (*0*)
//
end // end of [loop]
//
val p_end =
  ptr1_add_guint<a> (addr@(A), asz)
val n = loop (view@(A) | p_end, asz, env)
//
in
  asz - n
end // end of [array_rforeach_env]

(* ****** ****** *)

implement{a}{env}
array_rforeach$cont (x, env) = true
(*
implement{a}{env}
array_rforeach$fwork (x, env) = ((*void*))
*)

(* ****** ****** *)

implement{a}
array_initize
  (A, asz) = let
//
stadef V = array_v
//
fun loop
  {l:addr}{n:nat} .<n>.
(
  pf: !V (a?, l, n) >> V (a, l, n)
| p: ptr l, n: size_t n, i: size_t
) : void =
(
if n > 0 then let
  prval (pf1, pf2) = array_v_uncons (pf)
  val () = array_initize$init<a> (i, !p)
  val () = loop (pf2 | ptr1_succ<a> (p), pred(n), succ(i))
  prval () = pf := array_v_cons{a}(pf1, pf2)
in
  // nothing
end else let
  prval () = pf := array_v_unnil_nil (pf)
in
  // nothing
end // end of [if]
) (* end of [loop] *)
//
prval () = lemma_g1uint_param (asz)
//
in
  loop (view@ (A) | addr@ (A), asz, g0int2uint(0))
end // end of [array_initize]

(* ****** ****** *)

implement{a}
array_initize_elt
  (A, asz, elt) = let
//
implement{a2}
array_initize$init
  (i, xi) = xi := $UN.castvwtp0{a2}(elt)
//
in
  $effmask_all (array_initize<a> (A, asz))
end // end of [array_initize_elt]

(* ****** ****** *)

implement{a}
array_initize_list
  {n} (A, asz, xs) = let
//
typedef list0 = listGte (a, 0)
typedef list1 = listGte (a, 1)
//
fun loop
(
  p: ptr, p1: ptr, xs: list0
) : void = let
in
//
if p < p1 then let
  val xs =
    $UN.cast{list1}(xs)
  val+list_cons (x, xs) = xs
  val () = $UN.ptr0_set<a> (p, x)
  val p = ptr_succ<a> (p)
in
  loop (p, p1, xs)
end else () // end of [if]
//
end // end of [loop]
//
prval () = lemma_list_param (xs)
//
val p = addr@(A)
val p1 = ptr_add<a> (p, asz)
val () = $effmask_all(loop (p, p1, xs))
//
prval (
) = __assert (A) where
{
extern praxi __assert (A: &array(a?, n) >> array(a, n)): void
} (* end of [prval] *)
//
in
  // nothing
end // end of [array_initize_list]

(* ****** ****** *)

implement{a}
array_initize_rlist
  {n} (A, asz, xs) = let
//
typedef list0 = listGte (a, 0)
typedef list1 = listGte (a, 1)
//
fun loop
(
  p: ptr, p0: ptr, xs: list0
) : void = let
in
//
if p > p0 then let
  val xs =
    $UN.cast{list1}(xs)
  val+list_cons (x, xs) = xs
  val p = ptr_pred<a> (p)
  val () = $UN.ptr0_set<a> (p, x)
in
  loop (p, p0, xs)
end else () // end of [if]
//
end // end of [loop]
//
prval () = lemma_list_param (xs)
//
val p0 = addr@(A)
val p = ptr_add<a> (p0, asz)
val () = $effmask_all(loop (p, p0, xs))
//
prval (
) = __assert (A) where
{
extern
praxi __assert (A: &array(a?, n) >> array(a, n)): void
} (* end of [prval] *)
//
in
  // nothing
end // end of [array_initize_rlist]

(* ****** ****** *)

implement{a}
array_initize_list_vt
  {n} (A, asz, xs) = let
//
vtypedef list0 = listGte_vt (a, 0)
vtypedef list1 = listGte_vt (a, 1)
//
fun loop
(
  p: ptr, p1: ptr, xs: list0
) : void = let
in
//
if p < p1 then let
  val xs =
    $UN.castvwtp0{list1}(xs)
  val+~list_vt_cons (x, xs) = xs
  val () = $UN.ptr0_set<a> (p, x)
  val p = ptr_succ<a> (p)
in
  loop (p, p1, xs)
end else let
  prval () = $UN.cast2void (xs) in (*nothing*)
end // end of [if]
//
end // end of [loop]
//
prval () = lemma_list_vt_param (xs)
//
val p = addr@(A)
val p1 = ptr_add<a> (p, asz)
val () = $effmask_all(loop (p, p1, xs))
//
prval (
) = __assert (A) where
{
extern
praxi __assert (A: &array(a?, n) >> array(a, n)): void
} (* end of [prval] *)
//
in
  // nothing
end // end of [array_initize_list_vt]

(* ****** ****** *)

implement{a}
array_initize_rlist_vt
  {n} (A, asz, xs) = let
//
vtypedef list0 = listGte_vt (a, 0)
vtypedef list1 = listGte_vt (a, 1)
//
fun loop
(
  p: ptr, p0: ptr, xs: list0
) : void = let
in
//
if p > p0 then let
  val xs =
    $UN.castvwtp0{list1}(xs)
  val+~list_vt_cons (x, xs) = xs
  val p = ptr_pred<a> (p)
  val () = $UN.ptr0_set<a> (p, x)
in
  loop (p, p0, xs)
end else let
  prval () = $UN.cast2void (xs) in (*nothing*)
end // end of [if]
//
end // end of [loop]
//
prval () = lemma_list_vt_param (xs)
//
val p0 = addr@(A)
val p = ptr_add<a> (p0, asz)
val () = $effmask_all(loop (p, p0, xs))
//
prval (
) = __assert (A) where
{
extern
praxi __assert (A: &array(a?, n) >> array(a, n)): void
} (* end of [prval] *)
//
in
  // nothing
end // end of [array_initize_rlist_vt]

(* ****** ****** *)

implement{a}
array_uninitize
  (A, asz) = let
//
fun loop
  {l:addr}{n:nat} .<n>.
(
  pf: !array_v (a, l, n) >> array_v (a?, l, n) | p: ptr l, n: size_t n, i: size_t
) : void = let
in
//
if n > 0 then let
  prval (pf1, pf2) = array_v_uncons (pf)
  val () = array_uninitize$clear<a> (i, !p)
  val () = loop (pf2 | ptr_succ<a> (p), pred (n), succ (i))
  prval () = pf := array_v_cons (pf1, pf2)
in
  // nothing
end else let
  prval () = pf := array_v_unnil_nil {a,a?} (pf)
in
  // nothing
end // end of [if]
//
end // end of [loop]
//
prval () = lemma_array_param (A)
//
prval pf = view@ (A)
val () = loop (pf | addr@ (A), asz, i2sz(0))
prval () = view@ (A) := pf
//
in
  // nothing  
end // end of [array_uninitize]

(* ****** ****** *)

implement
{a}{b}
array_mapto
  {n}(A, B, n) = let
//
val pa = addr@ (A)
val pa2 = ptr_add<a> (pa, n)
val pb = addr@ (B)
//
fun loop{la,lb:addr}
(
  pa: ptr la, pa2: ptr, pb: ptr lb
) : void =
(
if pa < pa2 then let
  val (pfa, fpfa | pa) = $UN.ptr_vtake{a}(pa)
  val (pfb, fpfb | pb) = $UN.ptr_vtake{b?}(pb)
  val () = array_mapto$fwork<a><b> (!pa, !pb)
  prval () = fpfa (pfa)
  prval () = fpfb ($UN.castview0{(b?)@lb}(pfb))
in
  loop (ptr_succ<a> (pa), pa2, ptr_succ<b> (pb))
end (* end of [if] *)
)
//
val () = loop (pa, pa2, pb)
prval [lb:addr] EQADDR () = ptr_get_index (pb)
prval () = view@(B) := $UN.castview0{array_v (b, lb, n)}(view@(B))
//
in
  // nothing
end (* end of [array_mapto] *)

(* ****** ****** *)

implement
{a,b}{c}
array_map2to
  {n}(A, B, C, n) = let
//
val pa = addr@ (A)
val pa2 = ptr_add<a> (pa, n)
val pb = addr@ (B)
val pc = addr@ (C)
//
fun loop{la,lb,lc:addr}
(
  pa: ptr la, pa2: ptr, pb: ptr lb, pc: ptr lc
) : void =
(
if pa < pa2 then let
  val (pfa, fpfa | pa) = $UN.ptr_vtake{a}(pa)
  val (pfb, fpfb | pb) = $UN.ptr_vtake{b}(pb)
  val (pfc, fpfc | pc) = $UN.ptr_vtake{c?}(pc)
  val () = array_map2to$fwork<a,b><c> (!pa, !pb, !pc)
  prval () = fpfa (pfa)
  prval () = fpfb (pfb)
  prval () = fpfc ($UN.castview0{(c?)@lc}(pfc))
in
  loop (ptr_succ<a> (pa), pa2, ptr_succ<b> (pb), ptr_succ<c> (pc))
end (* end of [if] *)
)
//
val () = loop (pa, pa2, pb, pc)
prval [lc:addr] EQADDR () = ptr_get_index (pc)
prval () = view@(C) := $UN.castview0{array_v (c, lc, n)}(view@(C))
//
in
  // nothing
end (* end of [array_map2to] *)

(* ****** ****** *)

(*
implement{a}
array_bsearch
  (A, n) = $effmask_all let
//
val itr =
  $IT.giter_make_array (view@(A) | addr@(A), n)
// end of [val]
implement
$IT.giter_bsearch$ford<a> (x) = array_bsearch$ford<a> (x)
val () = $IT.giter_bsearch (itr, n)
//
val ofs = $IT.giter_get_fofs (itr)
//
val (pf | ()) = $IT.giter_free_array (itr)
prval () = view@ (A) := pf
//
in
  ofs
end // end of [array_bsearch]
*)

(* ****** ****** *)

implement{a}
array_permute (A, asz) = let
//
prval () = lemma_array_param (A)
//
fun loop
  {l:addr}{n:nat} .<n>.
(
  pf: !array_v (a, l, n) | p: ptr l, n: size_t n
) : void = let
in
//
if n >= 2 then let
  val i = array_permute$randint<> (n)
  prval (pf1, pf2) = array_v_uncons (pf)
  val () = if i > 0 then $UN.ptr0_exch<a> (ptr0_add_guint<a> (p, i), !p)
  val () = loop (pf2 | ptr1_succ<a> (p), pred (n))
  prval () = pf := array_v_cons (pf1, pf2)
in
  // nothing
end else () // end of [if]
//
end // end of [loop]
//
in
  loop (view@ (A) | addr@ (A), asz)
end // end of [array_permute]

(* ****** ****** *)

#include "./SHARE/array_bsearch.dats"
#include "./SHARE/array_quicksort.dats"

(* ****** ****** *)

(* end of [array.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/tostring.atxt
** Time of generation: Sat Oct 17 15:19:58 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxiATgmailDOTcom *)
(* Start time: April, 2015 *)

(* ****** ****** *)
//
staload
UN = "prelude/SATS/unsafe.sats"
//
(* ****** ****** *)

implement
{}(*tmp*)
tostring_int(i) = 
$effmask_wrt
(
  strptr2string(tostrptr_int(i))
)
implement
{}(*tmp*)
tostrptr_int(i) = let
//
#define BSZ 32
//
typedef
cstring = $extype"atstype_string"
//
var buf = @[byte][BSZ]()
val bufp = $UN.cast{cstring}(addr@buf)
//
val _(*int*) =
  $extfcall(ssize_t, "snprintf", bufp, BSZ, "%i", i)
//
in
  $UN.castvwtp0{Strptr1}(string0_copy($UN.cast{string}(bufp)))
end // end of [tostrptr_int]
//
implement
tostring_val<int> = tostring_int
implement
tostrptr_val<int> = tostrptr_int
//
(* ****** ****** *)

implement
{}(*tmp*)
tostring_uint(u) = 
$effmask_wrt
(
  strptr2string(tostrptr_uint(u))
)
implement
{}(*tmp*)
tostrptr_uint(u) = let
//
#define BSZ 32
//
typedef
cstring = $extype"atstype_string"
//
var buf = @[byte][BSZ]()
val bufp = $UN.cast{cstring}(addr@buf)
//
val _(*int*) =
  $extfcall(ssize_t, "snprintf", bufp, BSZ, "%u", u)
//
in
  $UN.castvwtp0{Strptr1}(string0_copy($UN.cast{string}(bufp)))
end // end of [tostrptr_uint]
//
implement
tostring_val<uint> = tostring_uint
implement
tostrptr_val<uint> = tostrptr_uint
//
(* ****** ****** *)
//
implement
{}(*tmp*)
tostring_bool(b) = bool2string(b)
implement
{}(*tmp*)
tostrptr_bool(b) = string0_copy(bool2string(b))
//
implement
tostring_val<bool> = tostring_bool
implement
tostrptr_val<bool> = tostrptr_bool
//
(* ****** ****** *)
//
implement
{}(*tmp*)
tostring_char(c) =
$effmask_wrt
(
  strptr2string(char2strptr(c))
)
//
implement
{}(*tmp*)
tostrptr_char(c) = char2strptr(c)
//
implement
tostring_val<char> = tostring_char
implement
tostrptr_val<char> = tostrptr_char
//
(* ****** ****** *)

implement
tostrptr_val<int> = g0int2string_int
implement
tostrptr_val<lint> = g0int2string_lint
implement
tostrptr_val<llint> = g0int2string_llint

(* ****** ****** *)

implement
{a}(*tmp*)
tostrptr_list(xs) = let
//
fun
loop
(
  i: int
, xs: List(a)
, res: List0_vt(Strptr1)
) : List0_vt(Strptr1) =
(
case+ xs of
| list_nil
    ((*void*)) => res
| list_cons
    (x, xs) => let
    val res1 = 
    (
      if i > 0
        then let
          val sep =
            tostrptr_list$sep<> ()
          // end of [val]
          val sep = string0_copy (sep)
        in
          list_vt_cons (sep, res)
        end // end of [then]
        else res // end of [else]
    ) : List0_vt(Strptr1)
    val xrep = tostrptr_val<a> (x)
    val res2 = list_vt_cons (xrep, res1)
  in
    loop (i+1, xs, res2)
  end // end of [list_cons]
)
//
val res = list_vt_nil ()
//
val _beg =
  tostrptr_list$beg<> ()
val _beg = string0_copy(_beg)
val res = list_vt_cons (_beg, res)
//
val res = loop (0, xs, res)
//
val _end =
  tostrptr_list$end<> ()
val _end = string0_copy(_end)      
val res = list_vt_cons (_end, res)
//
val res = list_vt_reverse<Strptr1> (res)
//
in
//
$UN.castvwtp0{Strptr1}(strptrlst_concat(res))
//
end // end of [tostrptr_list]

(* ****** ****** *)
//
implement{} tostrptr_list$beg() = ""
implement{} tostrptr_list$end() = ""
implement{} tostrptr_list$sep() = ""
//
(* ****** ****** *)
//
implement(a)
tostrptr_val<List(a)>
  (xs0) = $effmask_all (tostrptr_list<a> (xs0))
//
(* ****** ****** *)

implement
{a}(*tmp*)
tostrptr_array
  (A, n) = let
//
fun
loop{n:int}
(
  i: int
, p: ptr, n: size_t(n)
, res: List0_vt(Strptr1)
) : List0_vt(Strptr1) =
(
if
(n > 0)
then let
//
  val res1 = 
  (
    if i > 0
      then let
        val sep =
          tostrptr_array$sep<> ()
        // end of [val]
        val sep = string0_copy (sep)
      in
        list_vt_cons (sep, res)
      end // end of [then]
      else res // end of [else]
  ) : List0_vt(Strptr1)
//
  val
  (pf, fpf | p) =
    $UN.ptr_vtake{a}(p)
  // end of [val]
  val xrep = tostrptr_ref<a> (!p)
  prval ((*returned*)) = fpf (pf)
//
  val res2 = list_vt_cons (xrep, res1)
//
in
  loop (i+1, ptr_succ<a>(p), pred(n), res2)
end // end of [then]
else res // end of [else]
//
) (* end of [loop] *)
//
val res = list_vt_nil ()
//
val _beg =
  tostrptr_array$beg<> ()
val _beg = string0_copy(_beg)
val res = list_vt_cons (_beg, res)
//
val res = loop (0, addr@A, n, res)
//
val _end =
  tostrptr_array$end<> ()
val _end = string0_copy(_end)      
val res = list_vt_cons (_end, res)
//
val res = list_vt_reverse<Strptr1> (res)
//
in
//
$UN.castvwtp0{Strptr1}(strptrlst_concat(res))
//
end // end of [tostrptr_array]

(* ****** ****** *)
//
implement{} tostrptr_array$beg() = ""
implement{} tostrptr_array$end() = ""
implement{} tostrptr_array$sep() = ""
//
(* ****** ****** *)

implement
{a}(*tmp*)
tostrptr_arrayref
  (A, n) = let
//
val (vbox pf | p) =
  arrayref_get_viewptr(A)
//
in
//
$effmask_ref(tostrptr_array<a> (!p, n))
//
end // end of [tostrptr_arrayref]

(* ****** ****** *)

implement
{a}(*tmp*)
tostrptr_arrszref
  (ASZ) = let
//
var n: size_t
val A = arrszref_get_refsize (ASZ, n)
//
in
  tostrptr_arrayref<a> (A, n)
end // end of [tostrptr_arrszref]

(* ****** ****** *)

(* end of [tostring.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/integer_ptr.atxt
** Time of generation: Sat Oct 17 15:19:53 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: February, 2014 *)

(* ****** ****** *)

#define ATS_DYNLOADFLAG 0 // no dynloading at run-time

(* ****** ****** *)
//
//
(* ****** ****** *)
//
staload UN = "prelude/SATS/unsafe.sats"
//
(* ****** ****** *)

implement
g0int2int<intknd,intptrknd> = g0int2int_int_intptr
implement
g0int2int<lintknd,intptrknd> = g0int2int_lint_intptr

(* ****** ****** *)

implement g0int_neg<intptrknd> = g0int_neg_intptr
implement g0int_abs<intptrknd> = g0int_abs_intptr
implement g0int_succ<intptrknd> = g0int_succ_intptr
implement g0int_pred<intptrknd> = g0int_pred_intptr
implement g0int_half<intptrknd> = g0int_half_intptr
implement g0int_add<intptrknd> = g0int_add_intptr
implement g0int_sub<intptrknd> = g0int_sub_intptr
implement g0int_mul<intptrknd> = g0int_mul_intptr
implement g0int_div<intptrknd> = g0int_div_intptr
implement g0int_mod<intptrknd> = g0int_mod_intptr
implement g0int_asl<intptrknd> = g0int_asl_intptr
implement g0int_asr<intptrknd> = g0int_asr_intptr
implement g0int_isltz<intptrknd> = g0int_isltz_intptr
implement g0int_isltez<intptrknd> = g0int_isltez_intptr
implement g0int_isgtz<intptrknd> = g0int_isgtz_intptr
implement g0int_isgtez<intptrknd> = g0int_isgtez_intptr
implement g0int_iseqz<intptrknd> = g0int_iseqz_intptr
implement g0int_isneqz<intptrknd> = g0int_isneqz_intptr
implement g0int_lt<intptrknd> = g0int_lt_intptr
implement g0int_lte<intptrknd> = g0int_lte_intptr
implement g0int_gt<intptrknd> = g0int_gt_intptr
implement g0int_gte<intptrknd> = g0int_gte_intptr
implement g0int_eq<intptrknd> = g0int_eq_intptr
implement g0int_neq<intptrknd> = g0int_neq_intptr
implement g0int_compare<intptrknd> = g0int_compare_intptr
implement g0int_max<intptrknd> = g0int_max_intptr
implement g0int_min<intptrknd> = g0int_min_intptr
//
implement fprint_val<intptr> (out, x) = fprint_intptr (out, x)
//
(* ****** ****** *)

implement
g0uint2uint<uintknd,uintptrknd> = g0uint2uint_uint_uintptr
implement
g0uint2uint<ulintknd,uintptrknd> = g0uint2uint_ulint_uintptr

(* ****** ****** *)

implement g0uint_succ<uintptrknd> = g0uint_succ_uintptr
implement g0uint_pred<uintptrknd> = g0uint_pred_uintptr
implement g0uint_half<uintptrknd> = g0uint_half_uintptr
implement g0uint_add<uintptrknd> = g0uint_add_uintptr
implement g0uint_sub<uintptrknd> = g0uint_sub_uintptr
implement g0uint_mul<uintptrknd> = g0uint_mul_uintptr
implement g0uint_div<uintptrknd> = g0uint_div_uintptr
implement g0uint_mod<uintptrknd> = g0uint_mod_uintptr
implement g0uint_lsl<uintptrknd> = g0uint_lsl_uintptr
implement g0uint_lsr<uintptrknd> = g0uint_lsr_uintptr
implement g0uint_lnot<uintptrknd> = g0uint_lnot_uintptr
implement g0uint_lor<uintptrknd> = g0uint_lor_uintptr
implement g0uint_lxor<uintptrknd> = g0uint_lxor_uintptr
implement g0uint_land<uintptrknd> = g0uint_land_uintptr
implement g0uint_isgtz<uintptrknd> = g0uint_isgtz_uintptr
implement g0uint_iseqz<uintptrknd> = g0uint_iseqz_uintptr
implement g0uint_isneqz<uintptrknd> = g0uint_isneqz_uintptr
implement g0uint_lt<uintptrknd> = g0uint_lt_uintptr
implement g0uint_lte<uintptrknd> = g0uint_lte_uintptr
implement g0uint_gt<uintptrknd> = g0uint_gt_uintptr
implement g0uint_gte<uintptrknd> = g0uint_gte_uintptr
implement g0uint_eq<uintptrknd> = g0uint_eq_uintptr
implement g0uint_neq<uintptrknd> = g0uint_neq_uintptr
implement g0uint_compare<uintptrknd> = g0uint_compare_uintptr
implement g0uint_max<uintptrknd> = g0uint_max_uintptr
implement g0uint_min<uintptrknd> = g0uint_min_uintptr
//
implement fprint_val<uintptr> (out, x) = fprint_uintptr (out, x)
//
(* ****** ****** *)

(* end of [integer_ptr.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/memory.atxt
** Time of generation: Sat Oct 17 15:19:52 2015
*)

(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

implement
{}(*tmp*)
memory$free{l}
  (pfat, pfmf | p) = let
//
prval pfgc = $UN.castview0{mfree_gc_v(l)}(pfmf)
//
in
  mfree_gc (pfat, pfgc | p)
end // end of [memory$free]

(* ****** ****** *)

implement
{}(*tmp*)
memory$alloc
  {n} (bsz) = let
//
val [l:addr]
  (pfat, pfgc | p) = malloc_gc (bsz)
prval pfmf = $UN.castview0{memory$free_v(l)}(pfgc)
//
in
  (pfat, pfmf | p)
end // end of [memory$alloc]

(* ****** ****** *)

(* end of [memory.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/gnumber_int.atxt
** Time of generation: Sat Oct 17 15:19:59 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2013 *)

(* ****** ****** *)

implement
gnumber_int<int> (x) = g0int2int_int_int (x)
implement
gnumber_int<lint> (x) = g0int2int_int_lint (x)
implement
gnumber_int<llint> (x) = g0int2int_int_llint (x)
implement
gnumber_int<ssize_t> (x) = g0int2int_int_ssize (x)

(* ****** ****** *)

implement
gneg_val<int> (x) = ~x
implement
gneg_val<lint> (x) = ~x
implement
gneg_val<llint> (x) = ~x

(* ****** ****** *)

implement
gsucc_val<int> (x) = succ (x)
implement
gsucc_val<lint> (x) = succ (x)
implement
gsucc_val<llint> (x) = succ (x)
implement
gsucc_val<ssize_t> (x) = succ (x)

(* ****** ****** *)

implement
gpred_val<int> (x) = pred (x)
implement
gpred_val<lint> (x) = pred (x)
implement
gpred_val<llint> (x) = pred (x)

(* ****** ****** *)

implement
gadd_val_val<int> (x, y) = x + y
implement
gadd_val_val<lint> (x, y) = x + y
implement
gadd_val_val<llint> (x, y) = x + y
implement
gadd_val_val<ssize_t> (x, y) = x + y

(* ****** ****** *)

implement
gsub_val_val<int> (x, y) = x - y
implement
gsub_val_val<lint> (x, y) = x - y
implement
gsub_val_val<llint> (x, y) = x - y

(* ****** ****** *)

implement
gmul_val_val<int> (x, y) = x * y
implement
gmul_val_val<lint> (x, y) = x * y
implement
gmul_val_val<llint> (x, y) = x * y
implement
gmul_val_val<ssize_t> (x, y) = x * y

(* ****** ****** *)

implement
gdiv_val_val<int> (x, y) = x / y
implement
gdiv_val_val<lint> (x, y) = x / y
implement
gdiv_val_val<llint> (x, y) = x / y
implement
gdiv_val_val<ssize_t> (x, y) = x / y

(* ****** ****** *)

implement
gmod_val_val<int> (x, y) = x mod y
implement
gmod_val_val<lint> (x, y) = x mod y
implement
gmod_val_val<llint> (x, y) = x mod y
implement
gmod_val_val<ssize_t> (x, y) = x mod y

(* ****** ****** *)

(*
implement
gconjugate_val<int> (x) = x
implement
gconjugate_val<lint> (x) = x
implement
gconjugate_val<llint> (x) = x
implement
gconjugate_val<ssize_t> (x) = x
*)

(* ****** ****** *)

(* end of [gnumber_int.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/gorder_uint.atxt
** Time of generation: Sat Oct 17 15:19:58 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2013 *)

(* ****** ****** *)
//
implement
gcompare_val_val<uint> = g0uint_compare_uint
implement
gcompare_val_val<ulint> = g0uint_compare_ulint
implement
gcompare_val_val<ullint> = g0uint_compare_ullint
implement
gcompare_val_val<size_t> = g0uint_compare_size
//
(* ****** ****** *)

(* end of [gorder_uint.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/gorder_string.atxt
** Time of generation: Sat Oct 17 15:19:59 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2013 *)

(* ****** ****** *)

implement
gcompare_val_val<string> = compare_string_string

(* ****** ****** *)

(* end of [gorder_string.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/gorder_int.atxt
** Time of generation: Sat Oct 17 15:19:58 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2013 *)

(* ****** ****** *)
//
implement
gcompare_val_val<int> = g0int_compare_int
implement
gcompare_val_val<lint> = g0int_compare_lint
implement
gcompare_val_val<llint> = g0int_compare_llint
implement
gcompare_val_val<ssize_t> = g0int_compare_ssize
//
(* ****** ****** *)

(* end of [gorder_int.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/gnumber.atxt
** Time of generation: Sat Oct 17 15:20:00 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2013 *)

(* ****** ****** *)

implement
gnumber_int<float> (x) = g0int2float_int_float (x)
implement
gnumber_int<double> (x) = g0int2float_int_double (x)
(*
implement
gnumber_int<ldouble> (x) = g0int2float_int_ldouble (x)
*)

(* ****** ****** *)

implement
gnumber_double<float> (x) = g0float2float_double_float (x)
implement
gnumber_double<double> (x) = g0float2float_double_double (x)
(*
implement
gnumber_double<ldouble> (x) = g0float2float_double_ldouble (x)
*)
(* ****** ****** *)

implement
gneg_val<float> (x) = ~x
implement
gneg_val<double> (x) = ~x
implement
gneg_val<ldouble> (x) = ~x

(* ****** ****** *)

implement
gsucc_val<float> (x) = succ (x)
implement
gsucc_val<double> (x) = succ (x)
implement
gsucc_val<ldouble> (x) = succ (x)

(* ****** ****** *)

implement
gpred_val<float> (x) = pred (x)
implement
gpred_val<double> (x) = pred (x)
implement
gpred_val<ldouble> (x) = pred (x)

(* ****** ****** *)

implement
grecip_val<float> (x) = 1.0f / x
implement
grecip_val<double> (x) = 1.0 / x
implement
grecip_val<ldouble> (x) = 1.0l / x

(* ****** ****** *)

implement
gadd_val_val<float> (x, y) = x + y
implement
gadd_val_val<double> (x, y) = x + y
implement
gadd_val_val<ldouble> (x, y) = x + y

(* ****** ****** *)

implement
gsub_val_val<float> (x, y) = x - y
implement
gsub_val_val<double> (x, y) = x - y
implement
gsub_val_val<ldouble> (x, y) = x - y

(* ****** ****** *)

implement
gmul_val_val<float> (x, y) = x * y
implement
gmul_val_val<double> (x, y) = x * y
implement
gmul_val_val<ldouble> (x, y) = x * y

(* ****** ****** *)

implement
gdiv_val_val<float> (x, y) = x / y
implement
gdiv_val_val<double> (x, y) = x / y
implement
gdiv_val_val<ldouble> (x, y) = x / y

(* ****** ****** *)

implement
gmod_val_val<float> (x, y) = x mod y
implement
gmod_val_val<double> (x, y) = x mod y
implement
gmod_val_val<ldouble> (x, y) = x mod y

(* ****** ****** *)

(*
implement
gconjugate_val<float> (x) = x
implement
gconjugate_val<double> (x) = x
implement
gconjugate_val<ldouble> (x) = x
*)

(* ****** ****** *)

(* end of [gnumber_float.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/list_vt_quicksort.atxt
** Time of generation: Sat Oct 17 15:20:00 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: Feburary, 2012 *)

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

implement{a}
list_vt_quicksort$cmp
  (x1, x2) =
(
  gcompare_ref_ref<a> (x1, x2)
) (* end of [list_vt_quicksort$cmp] *)

(* ****** ****** *)
(*
** HX-2012-05:
** (1) Copying a list into an array
** (2) Performing quicksort on the array
** (3) Copying it back into the list
*)
implement
{a}(*tmp*)
list_vt_quicksort
  {n} (xs) = let
//
fun copyout
  {n:nat} .<n>.
(
  xs: !list_vt (a, n), p: ptr
) :<!wrt> void = let
in
//
case+ xs of
| @list_vt_cons
    (x, xs1) => let
    val (
    ) = $UN.ptr0_set<a> (p, $UN.ptr0_get<a> (addr@(x)))
    val () = copyout (xs1, ptr0_succ<a> (p))
  in
    fold@ (xs)
  end // end of [list_vt_cons]
| list_vt_nil ((*void*)) => ()
//
end // end of [copyout]
//
fun copyinto
  {n:nat} .<n>.
(
  xs: !list_vt (a, n), p: ptr
) :<!wrt> void = let
in
//
case+ xs of
| @list_vt_cons
    (x, xs1) => let
    val (
    ) = $UN.ptr0_set<a> (addr@(x), $UN.ptr0_get<a> (p))
    val () = copyinto (xs1, ptr0_succ<a> (p))
  in
    fold@ (xs)
  end // end of [list_vt_cons]
| list_vt_nil ((*void*)) => ()
//
end // end of [copyinto]
//
implement
array_quicksort$cmp<a>
  (x1, x2) = list_vt_quicksort$cmp<a> (x1, x2)
// end of [array_quicksort$cmp]
//
prval () = lemma_list_vt_param (xs)
//
val n = list_vt_length (xs)
//
val [l:addr]
  (pfat, pfgc | p0) = array_ptr_alloc<a> (i2sz(n))
//
extern praxi
__out (pf: !array_v (a?, l, n) >> array_v (a, l, n)): void
extern praxi
__into (pf: !array_v (a, l, n) >> array_v (a?, l, n)): void
//
val () = copyout (xs, p0)
prval () = __out (pfat)
val () = array_quicksort<a> (!p0, i2sz(n))
prval () = __into (pfat)
val () = copyinto (xs, p0)
//
val () = array_ptr_free {a} (pfat, pfgc | p0)
//
in
  xs
end // end of [list_vt_quicksort]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_quicksort_fun
  (xs, cmp) = let
//
implement{a2}
list_vt_quicksort$cmp
  (x1, x2) = let
//
val cmp = $UN.cast{cmpref(a2)}(cmp) in cmp (x1, x2)
//
end (* end of [list_vt_quicksort$cmp] *)
//
in
  list_vt_quicksort<a> (xs)
end // end of [list_vt_quicksort_fun]

(* ****** ****** *)

(* end of [list_vt_quicksort.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/array.atxt
** Time of generation: Sat Oct 17 15:20:00 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: April, 2013 *)

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

implement
{a}(*tmp*)
array_bsearch
  {n} (A, asz) = let
//
fun loop
  {l,r:nat | l <= r; r <= n} .<r-l>.
(
  A: &array (a, n), l: size_t l, r: size_t r
) :<> sizeLte (n) =
(
if l < r then let
  val m = l + half (r-l)
  val pm = addr@ (A.[m])
  val (
    pf, fpf | pm
  ) = $UN.ptr_vtake{a}(pm)
  val sgn = array_bsearch$ford<a> (!pm)
  prval () = fpf (pf)
in
  if sgn <= 0 then loop (A, l, m) else loop (A, succ(m), r)
end else l (* end of [if] *)
)
//
prval () = lemma_array_param (A)
//
in
  loop (A, g1i2u(0), asz)
end (* end of [array_bsearch] *)

(* ****** ****** *)

implement
{a}(*tmp*)
array_bsearch_fun
  (A, asz, key, cmp) = let
//
val p0 = addr@(key)
//
implement
array_bsearch$ford<a>
  (x) = sgn where
{
//
val
(
  pf, fpf | p0
) = $UN.ptr_vtake (p0)
val sgn = cmp (!p0, x)
prval ((*void*)) = fpf (pf)
//
} (* endimp *)
//
in
  array_bsearch<a> (A, asz)
end (* end of [array_bsearch_fun] *)

(* ****** ****** *)

(*
//
// HX: [qsort] is in libc/stdlib
//
void *bsearch
(
  const void *key
, const void *base
, size_t nmemb, size_t size
, int (*compar)(const void *, const void *)
) ; // end of [bsearch]
*)
implement{a}
array_bsearch_stdlib
  (A, asz, key, cmp) = let
in
//
$extfcall (
  Ptr0, "atspre_array_bsearch", addr@(key), addr@(A), asz, sizeof<a>, cmp
) // end of [$extfcall]
//
end // end of [array_bsearch_stdlib]

(* ****** ****** *)

(* end of [array_bsearch.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/array.atxt
** Time of generation: Sat Oct 17 15:20:00 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: April, 2013 *)

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

(*
//
// HX-2013-04:
// Instead of employing advanced types, I happily
// ventured into the typeless territory of unsafe
// pointer arithmetic!
//
*)

(* ****** ****** *)

implement
{a}(*tmp*)
array_quicksort$cmp
  (x1, x2) =
(
  gcompare_ref_ref<a> (x1, x2)
) // end of [array_quicksort$cmp]

(* ****** ****** *)

implement
{a}(*tmp*)
array_quicksort
  (A, asz) = let
//
overload + with add_ptr0_bsz
overload - with sub_ptr0_bsz
//
(* ****** ****** *)
//
fun ptrcmp
(
  p1: ptr, p2: ptr
) : int = (sgn) where
{
//
val p1 = g1ofg0_ptr(p1)
val p2 = g1ofg0_ptr(p2)
//
val
(
  pf1, fpf1 | p1
) = $UN.ptr_vtake{a}(p1)
val
(
  pf2, fpf2 | p2
) = $UN.ptr_vtake{a}(p2)
//
val sgn = array_quicksort$cmp<a> (!p1, !p2)
//
prval () = fpf1 (pf1)
prval () = fpf2 (pf2)
//
} (* end of [ptrcmp] *)

(* ****** ****** *)
(*
//
// HX-2013-04:
// move min to the start
// HX-2013-04:
// this is not a safe approach
// in case [cmp] is not transitive!
//
fun auxmin
(
  pa: ptr, p: ptr, tsz: size_t
) : void = let
in
//
if pa < p then let
  val p1 = p - tsz
  val sgn = ptrcmp (p1, p)
  val () =
    if sgn > 0 then $UN.ptr0_intch<a> (p1, p)
  // end of [val]
in
  auxmin (pa, p1, tsz)
end (* end of [if] *)
//
end (* end of [auxmin] *)
*)
//
// HX: one round of insertion
//
fun auxins
(
  pa: ptr, p: ptr, tsz: size_t
) : void = let
in
//
if pa < p then let
  val p1 = p - tsz
  val sgn = ptrcmp (p1, p)
in
  if sgn > 0 then let
    val () = $UN.ptr0_intch<a> (p1, p) in auxins (pa, p1, tsz)
  end // end of [if]
end else () // end of [if]
//
end (* end of [auxins] *)
//
// HX: all rounds of insertion
//
fun auxinss
(
  pa: ptr, pz: ptr, p: ptr, tsz: size_t
) : void = let
in
//
if p < pz then let
  val () = auxins (pa, p, tsz)
in
  auxinss (pa, pz, p + tsz, tsz)
end // end of [if]
//
end (* end of [auxinss] *)

(* ****** ****** *)
//
// HX: insertion sorting
//
fun auxinsort
(
  pa: ptr, asz: size_t, tsz: size_t
) : void = let
  val pz = pa + asz * tsz
in
//
if pa < pz then let
  val () = auxinss (pa, pz, pa + tsz, tsz)
in
  (* nothing *)
end else () // end of [if]
//
end (* end of [auxinsort] *)

(* ****** ****** *)
//
// HX: locate the middle of 3
//
fun auxmid
(
  p1: ptr, p2: ptr, p3: ptr
) : ptr = let
  val sgn12 = ptrcmp (p1, p2)
in
//
if sgn12 <= 0 then (
  if ptrcmp (p2, p3) <= 0
    then p2 else (if ptrcmp (p1, p3) <= 0 then p3 else p1)
) else (
  if ptrcmp (p1, p3) <= 0
    then p1 else (if ptrcmp (p2, p3) <= 0 then p3 else p2)
) // end of [if]
end (* end of [auxmid] *)
//
// HX: pivot to the start
//
fun auxpivot
(
  pa: ptr, asz: size_t, tsz: size_t
) : void = let
//
val pm = auxmid
(
  pa, pa + half(asz) * tsz, pa + pred(asz) * tsz
) (* end of [val] *)
//
in
  $UN.ptr0_intch<a> (pa, pm)
end (* end of [auxpivot] *)

(* ****** ****** *)
//
// HX-2013-04:
// Invariants:
// 1. elements in [pa, pl) <= pivot
// 2. elements in (pr, pz) >= pivot
//
fun auxsplit_l
(
  pa: ptr, pl: ptr, pr: ptr, tsz: size_t
) : ptr =
(
if pl <= pr then let
  val sgn = ptrcmp (pl, pa)
in
//
if sgn <= 0 then auxsplit_l (pa, pl + tsz, pr, tsz) else pl
//
end else pl // end of [if]
) (* end of [auxsplit_l] *)

fun auxsplit_r
(
  pa: ptr, pl: ptr, pr: ptr, tsz: size_t
) : ptr =
(
if pl <= pr then let
  val sgn = ptrcmp (pa, pr)
in
//
if sgn <= 0 then auxsplit_r (pa, pl, pr - tsz, tsz) else pr
//
end else pr // end of [if]
) (* end of [auxsplit_r] *)

fun auxsplit_lr
(
  pa: ptr, pl: ptr, pr: ptr, tsz: size_t
) : ptr = let
  val pl = auxsplit_l (pa, pl, pr, tsz)
  val pr = auxsplit_r (pa, pl, pr, tsz)
in
//
if pl < pr then let
  val () = $UN.ptr0_intch<a> (pl, pr)
in
  auxsplit_lr (pa, pl + tsz, pr - tsz, tsz)
end else pl (* end of [if] *)
//
end (* end of [auxsplit_lr] *)

(* ****** ****** *)

#define CUTOFF 12

(* ****** ****** *)
//
// HX: quick-sorting
//
fun auxqsort
(
  pa: ptr, asz: size_t, tsz: size_t
) : void = let
in
//
if asz >= CUTOFF then let
  val () = auxpivot (pa, asz, tsz)
  val pz = pa + asz * tsz
  val pm = auxsplit_lr (pa, pa + tsz, pz - tsz, tsz)
  val pm1 = pm - tsz
  val () = $UN.ptr0_intch<a> (pa, pm1)
  val asz_f = $UN.cast2size(pm1-pa) / tsz
  val asz_r = pred (asz - asz_f)
in
  if asz_f <= asz_r then let
    val () = auxqsort (pa, asz_f, tsz)
    val () = auxqsort (pm, asz_r, tsz)
  in
    // nothing
  end else let
    val () = auxqsort (pm, asz_r, tsz)
    val () = auxqsort (pa, asz_f, tsz)
  in
    // nothing
  end (* end of [if] *)
end else
  auxinsort (pa, asz, tsz)
// end of [if]
//
end (* end of [auxqsort] *)

(* ****** ****** *)

in (* in of [let] *)
//
$effmask_all (auxqsort (addr@(A), asz, sizeof<a>))
//
end (* end of [array_quicksort] *)

(* ****** ****** *)

(*
//
// HX: [qsort] is in libc/stdlib
//
void qsort
(
  void *base, size_t nmemb, size_t size,
  int(*compar)(const void *, const void *)
) ; // end of [qsort]
*)
implement
{a}(*tmp*)
array_quicksort_stdlib
  (A, asz, cmp) = let
in
  $extfcall (void, "atspre_array_qsort", addr@(A), asz, sizeof<a>, cmp)
end (* end of [array_quicksort_stdlib] *)

(* ****** ****** *)

(* end of [array_quicksort.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/list_vt_mergesort.atxt
** Time of generation: Sat Oct 17 15:20:00 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: Feburary, 2012 *)

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_mergesort$cmp
  (x1, x2) =
(
  gcompare_ref_ref<a> (x1, x2)
) // end of [list_vt_mergesort$cmp]

(* ****** ****** *)
//
extern
fun{
a:vt0p
} list_vt_insort
  {n:int}(xs: list_vt (a, n)):<!wrt> list_vt (a, n)
//
(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_insort
  (xs) = let
//
fun
insord
{l0,l1,l2:addr}{n:nat} .<n>.
(
  pf1: a @ l1
, pf2: list_vt (a, 0)? @ l2
| xs0: &list_vt (a, n) >> list_vt (a, n+1)
, nx0: list_vt_cons_unfold (l0, l1, l2), p1: ptr (l1), p2: ptr (l2)
) :<!wrt> void = let
in
//
case+ xs0 of
| @list_vt_cons
    (x0, xs1) => let
    val sgn = list_vt_mergesort$cmp<a> (x0, !p1)
  in
    if sgn <= 0
      then let
        val () = insord (pf1, pf2 | xs1, nx0, p1, p2)
        prval () = fold@ (xs0)
      in
        // nothing
      end // end of [then]
      else let
        prval () = fold@ (xs0)
        val () = (!p2 := xs0; xs0 := nx0)
        prval () = fold@ (xs0)
      in
        // nothing
      end // end of [else]
    // end of [if]
  end // end of [list_vt_cons]
| ~list_vt_nil () =>
  {
    val () = xs0 := nx0
    val () = !p2 := list_vt_nil ()
    prval () = fold@ (xs0)
  }
//
end (* end of [insord] *)
//
fun
loop{m,n:nat} .<m>.
(
  xs: list_vt (a, m)
, ys: &list_vt (a, n) >> list_vt (a, m+n)
) :<!wrt> void = let
in
//
case+ xs of
| @list_vt_cons
    (x, xs1) => let
    val xs1_ = xs1
    val ((*void*)) =
      insord (view@x, view@xs1 | ys, xs, addr@x, addr@xs1)
    // end of [val]
  in
    loop (xs1_, ys)
  end // end of [list_vt_cons]
| ~list_vt_nil ((*void*)) => ()
//
end // end of [loop]
//
prval () =
lemma_list_vt_param (xs)
//
var ys = list_vt_nil{a}()
val ((*void*)) = loop (xs, ys)
//
in
  ys
end // end of [list_vt_insort]

(* ****** ****** *)

#define CUTOFF 12

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_mergesort
  {n} (xs) = let
//
fun
split
{n,n1:int |
 n >= n1; n1 >= 0} .<n1>.
(
  xs: &list_vt (a, n) >> list_vt (a, n1)
, n1: int n1, res: &List_vt a? >> list_vt (a, n-n1)
) :<!wrt> void = let
in
//
if n1 > 0 then let
  val+@list_vt_cons (_, xs1) = xs
  val () = split (xs1, n1-1, res)
in
  fold@ (xs)
end else let
  val () = res := xs
  val () = xs := list_vt_nil ()
in
  // nothing
end // end of [if]
//
end // end of [split]
//
fun
merge
{n1,n2:nat} .<n1+n2>.
(
  xs1: list_vt (a, n1)
, xs2: list_vt (a, n2)
, res: &List_vt a? >> list_vt (a, n1+n2)
) :<!wrt> void = let
in
//
case+ xs1 of
| @list_vt_cons
    (x1, xs11) => (
    case+ xs2 of
    | @list_vt_cons
        (x2, xs21) => let
        val sgn =
          list_vt_mergesort$cmp<a> (x1, x2)
        // end of [val]
      in
        if sgn <= 0 then let
          prval () = fold@{a}(xs2)
          val () = merge (xs11, xs2, xs11)
          prval () = fold@{a}(xs1)
        in
          res := xs1
        end else let
          prval () = fold@{a}(xs1)
          val () = merge (xs1, xs21, xs21)
          prval () = fold@{a}(xs2)
        in
          res := xs2
        end // end of [if]
      end // end of [list_vt_cons]
    | ~list_vt_nil () => (fold@ (xs1); res := xs1)
  ) // end of [list_vt_cons]
| ~list_vt_nil () => (res := xs2)
//
end // end of [merge]
//
fun
msort{n:nat} .<n>.
(
  xs: list_vt(a, n), n: int(n)
) :<!wrt> list_vt(a, n) =
(
if
n >= CUTOFF
then let
  val n1 = half(n+1)
  val+@list_vt_cons (_, xs1) = xs
  var res: List_vt a? // uninitialized
  val () = split (xs1, n1-1, res)
  prval () = fold@ (xs)
  val xs1 = msort (xs, n1)
  and xs2 = msort (res, n-n1)
  val () = merge (xs1, xs2, res)
in
  res
end // end of [then]
else list_vt_insort<a> (xs)
) (* end of [msort] *)
//
prval () = lemma_list_vt_param (xs)
//
in
  msort (xs, list_vt_length<a> (xs))
end // end of [list_vt_mergesort]

(* ****** ****** *)

implement
{a}(*tmp*)
list_vt_mergesort_fun
  (xs, cmp) = let
//
implement{a2}
list_vt_mergesort$cmp
  (x1, x2) = let
//
val cmp = $UN.cast{cmpref(a2)}(cmp) in cmp (x1, x2)
//
end (* end of [list_vt_mergesort$cmp] *)
//
in
  list_vt_mergesort<a> (xs)
end // end of [list_vt_mergesort_fun]

(* ****** ****** *)

(* end of [list_vt_mergesort.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/gorder_char.atxt
** Time of generation: Sat Oct 17 15:19:59 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2013 *)

(* ****** ****** *)

implement
gcompare_val_val<char> = compare_char0_char0

(* ****** ****** *)

(* end of [gorder_char.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/gorder_bool.atxt
** Time of generation: Sat Oct 17 15:19:59 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2013 *)

(* ****** ****** *)

implement
gcompare_val_val<bool> = compare_bool0_bool0

(* end of [gorder_bool.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/gorder_float.atxt
** Time of generation: Sat Oct 17 15:19:59 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2013 *)

(* ****** ****** *)

implement
gcompare_val_val<float> = g0float_compare_float
implement
gcompare_val_val<double> = g0float_compare_double
implement
gcompare_val_val<ldouble> = g0float_compare_ldouble

(* end of [gorder_float.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/DATS/CODEGEN/gnumber_uint.atxt
** Time of generation: Sat Oct 17 15:20:00 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2013 *)

(* ****** ****** *)

implement
gnumber_int<uint> (x) = g0int2uint_int_uint (x)
implement
gnumber_int<ulint> (x) = g0int2uint_int_ulint (x)
implement
gnumber_int<ullint> (x) = g0int2uint_int_ullint (x)

(* ****** ****** *)

implement
gsucc_val<uint> (x) = succ (x)
implement
gsucc_val<ulint> (x) = succ (x)
implement
gsucc_val<ullint> (x) = succ (x)
implement
gsucc_val<size_t> (x) = succ (x)

(* ****** ****** *)

implement
gpred_val<uint> (x) = pred (x)
implement
gpred_val<ulint> (x) = pred (x)
implement
gpred_val<ullint> (x) = pred (x)
implement
gpred_val<size_t> (x) = pred (x)

(* ****** ****** *)

implement
gadd_val_val<uint> (x, y) = x + y
implement
gadd_val_val<ulint> (x, y) = x + y
implement
gadd_val_val<ullint> (x, y) = x + y
implement
gadd_val_val<size_t> (x, y) = x + y

(* ****** ****** *)

implement
gsub_val_val<uint> (x, y) = x - y
implement
gsub_val_val<ulint> (x, y) = x - y
implement
gsub_val_val<ullint> (x, y) = x - y
implement
gsub_val_val<size_t> (x, y) = x - y

(* ****** ****** *)

implement
gmul_val_val<uint> (x, y) = x * y
implement
gmul_val_val<ulint> (x, y) = x * y
implement
gmul_val_val<ullint> (x, y) = x * y
implement
gmul_val_val<size_t> (x, y) = x * y

(* ****** ****** *)

implement
gdiv_val_val<uint> (x, y) = x / y
implement
gdiv_val_val<ulint> (x, y) = x / y
implement
gdiv_val_val<ullint> (x, y) = x / y
implement
gdiv_val_val<size_t> (x, y) = x / y

(* ****** ****** *)

implement
gmod_val_val<uint> (x, y) = x mod y
implement
gmod_val_val<ulint> (x, y) = x mod y
implement
gmod_val_val<ullint> (x, y) = x mod y
implement
gmod_val_val<size_t> (x, y) = x mod y

(* ****** ****** *)

(*
implement
gconjugate_val<uint> (x) = x
implement
gconjugate_val<ulint> (x) = x
implement
gconjugate_val<ullint> (x) = x
implement
gconjugate_val<size_t> (x) = x
*)

(* ****** ****** *)

(* end of [gnumber_uint.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/list.atxt
** Time of generation: Sat Oct 17 15:19:48 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2012 *)

(* ****** ****** *)

#define NSH (x) x // for commenting: no sharing
#define SHR (x) x // for commenting: it is shared

(* ****** ****** *)

#if(0)
//
// HX: these decls are available in [basic_dyn.sats]
//
datatype // t@ype+: covariant
list_t0ype_int_type (a:t@ype+, int) =
  | {n:int | n >= 0}
    list_cons (a, n+1) of (a, list_t0ype_int_type (a, n))
  | list_nil (a, 0) of ((*void*))
// end of [list_t0ype_int_type]
//
stadef list = list_t0ype_int_type
typedef
List (a:t0p) = [n:int] list (a, n)
typedef
List0 (a:t0p) = [n:int | n >= 0] list (a, n)
typedef
List1 (a:t0p) = [n:int | n >= 1] list (a, n)
typedef listLt
  (a:t0p, n:int) = [k:nat | k < n] list (a, k)
typedef listLte
  (a:t0p, n:int) = [k:nat | k <= n] list (a, k)
typedef listGt
  (a:t0p, n:int) = [k:int | k > n] list (a, k)
typedef listGte
  (a:t0p, n:int) = [k:int | k >= n] list (a, k)
typedef listBtw
  (a:t0p, m:int, n:int) = [k:int | m <= k; k < n] list (a, k)
typedef listBtwe
  (a:t0p, m:int, n:int) = [k:int | m <= k; k <= n] list (a, k)
//
#endif

(* ****** ****** *)

#define nil list_nil
#define cons list_cons

(* ****** ****** *)

exception
ListSubscriptExn of ()
(*
fun ListSubscriptExn ():<> exn = "mac#%ListSubscriptExn_make"
fun isListSubscriptExn (x: !exn):<> bool = "mac#%isListSubscriptExn"
macdef
ifListSubscriptExn
  {tres}(exn, body) =
(
let val x = ,(exn) in
(
if isListSubscriptExn(x)
  then
    let prval () = __vfree_exn (x) in ,(body) end
  else $raise (x)
) : tres // end of [if]
end (* end of [let] *)
) // end of [ifListSubscriptExn]
*)

(* ****** ****** *)

prfun
lemma_list_param
  {x:t0p}{n:int}
  (xs: list (INV(x), n)): [n >= 0] void
// end of [lemma_list_param]

(* ****** ****** *)

castfn
list_cast
  {x:t0p}{n:int}
  (xs: list (INV(x), n)):<> list (x, n)
// end of [list_cast]

(* ****** ****** *)
//
castfn
list_vt2t
  {x:t0p}{n:int}
  (xs: list_vt (INV(x), n)):<> list (x, n)
castfn
list_of_list_vt
  {x:t0p}{n:int}
  (xs: list_vt (INV(x), n)):<!wrt> list (x, n)
//
(* ****** ****** *)

#define list_sing(x)
  list_cons(x, list_nil())
#define list_pair(x1, x2)
  list_cons(x1, list_cons (x2, list_nil()))

(* ****** ****** *)

fun{x:t0p}
list_make_sing (x: x):<!wrt> list_vt (x, 1)
fun{x:t0p}
list_make_pair (x1: x, x2: x):<!wrt> list_vt (x, 2)

(* ****** ****** *)

fun{x:t0p}
list_make_elt
  {n:nat} (n: int n, x: x):<!wrt> list_vt (x, n)
// end of [list_make_elt]

(* ****** ****** *)

fun{
} list_make_intrange
  {l,r:int | l <= r}
  (l: int l, r: int r):<!wrt> list_vt (intBtw (l, r), r-l)
// end of [list_make_intrange]

(* ****** ****** *)

fun{a:vt0p}
list_make_array
  {n:int} (
  A: &(@[INV(a)][n]) >> @[a?!][n], n: size_t n
) :<!wrt> list_vt (a, n) // endfun

(* ****** ****** *)
//
symintr list
//
fun{a:vt0p}
list_make_arrpsz
  {n:int} (psz: arrpsz (INV(a), n)):<!wrt> list_vt (a, n)
overload list with list_make_arrpsz

(* ****** ****** *)
//
fun{x:t0p}
print_list (xs: List (INV(x))): void
fun{x:t0p}
prerr_list (xs: List (INV(x))): void
//
fun{x:t0p}
fprint_list (out: FILEref, xs: List (INV(x))): void
fun{x:t0p}
fprint_list_sep
  (out: FILEref, xs: List (INV(x)), sep: NSH(string)): void
// end of [fprint_list_sep]
//
fun{}
fprint_list$sep (out: FILEref): void
//
(* ****** ****** *)

fun{x:t0p}
fprint_listlist_sep
( out: FILEref
, xss: List (List (INV(x))), sep1: NSH(string), sep2: NSH(string)
) : void // end of [fprint_listlist_sep]

(* ****** ****** *)

(*
//
// HX: for testing macdef
//
macdef
fprintlst_mac
  {T:t@ype}(f, out, xs, sep) = let
//
val out = ,(out)
val xs  = ,(xs)
val sep = ,(sep)
//
fun loop (
  xs: List(T), i: int
) : void =
  case+ xs of
  | list_cons
      (x, xs) => let
      val () = if i > 0 then fprint_string (out, sep)
      val () = ,(f) (out, x)
    in
      loop (xs, i+1)
    end
  | list_nil () => ()
//
in
  loop (xs, 0)
end // end of [fprintlst_mac]
*)

(* ****** ****** *)
//
fun{
} list_is_nil
  {x:t0p}{n:int} (xs: list (x, n)):<> bool(n==0)
fun{
} list_is_cons
  {x:t0p}{n:int} (xs: list (x, n)):<> bool(n > 0)
//
fun{x:t0p}
list_is_sing{n:int} (xs: list (INV(x), n)):<> bool(n==1)
fun{x:t0p}
list_is_pair{n:int} (xs: list (INV(x), n)):<> bool(n==2)
//
(* ****** ****** *)

fun{x:t0p}
list_head{n:pos} (xs: list (INV(x), n)):<> (x)
fun{x:t0p}
list_head_exn{n:int} (xs: list (INV(x), n)):<!exn> (x)

(* ****** ****** *)

fun{x:t0p}
list_tail{n:pos}
  (xs: SHR(list (INV(x), n))):<> list (x, n-1)
fun{x:t0p}
list_tail_exn{n:int}
  (xs: SHR(list (INV(x), n))):<!exn> list (x, n-1)

(* ****** ****** *)

fun{x:t0p}
list_last{n:pos} (xs: list (INV(x), n)):<> (x)
fun{x:t0p}
list_last_exn{n:int} (xs: list (INV(x), n)):<!exn> (x)

(* ****** ****** *)
//
fun{
x:t0p
} list_nth{n:int}
  (xs: list (INV(x), n), i: natLt (n)):<> (x)
fun{x:t0p}
list_nth_opt
  (xs: List (INV(x)), i: intGte (0)):<> Option_vt (x)
//
fun{x:t0p}
list_get_at{n:int}
  (xs: list (INV(x), n), i: natLt (n)):<> (x)
fun{x:t0p}
list_get_at_opt
  (xs: List (INV(x)), i: intGte (0)):<> Option_vt (x)
//
(* ****** ****** *)
//
fun{x:t0p}
list_set_at{n:nat}
  (xs: list (INV(x), n), i: natLt (n), x: x):<> list (x, n)
fun{x:t0p}
list_exch_at{n:nat}
  (xs: list (INV(x), n), i: natLt (n), x: x):<> (list (x, n), x)
//
(* ****** ****** *)

fun{x:t0p}
list_insert_at
  {n:int} (
  xs: SHR(list (INV(x), n)), i: natLte (n), x: x
) :<> list (x, n+1) // end of [list_insert_at]

fun{x:t0p}
list_remove_at
  {n:int} (
  xs: SHR(list (INV(x), n)), i: natLt (n)
) :<> list (x, n-1) // end of [list_remove_at]

fun{x:t0p}
list_takeout_at
  {n:int} (
  xs: SHR(list (INV(x), n)), i: natLt (n), x: &(x)? >> x
) :<!wrt> list (x, n-1) // end of [list_takeout_at]

(* ****** ****** *)

fun{x:t0p}
list_length
  {n:int} (xs: list (INV(x), n)):<> int (n)
// end of [list_length]

(* ****** ****** *)

fun{
x:t0p
} list_copy
  {n:int} (xs: list (INV(x), n)):<!wrt> list_vt (x, n)
// end of [list_copy]

(* ****** ****** *)
//
fun{a:t0p}
list_append
  {m,n:int}
(
  xs: NSH(list (INV(a), m)), ys: SHR(list (a, n))
) :<> list (a, m+n) // end of [list_append]
//
(* ****** ****** *)

fun{
a:t0p
} list_append1_vt
  {i,j:int} (
  xs: list_vt (INV(a), i), ys: SHR(list (a, j))
) :<!wrt> list (a, i+j) // endfun
fun{
a:t0p
} list_append2_vt
  {i,j:int} (
  xs: NSH(list (INV(a), i)), ys: list_vt (a, j)
) :<!wrt> list_vt (a, i+j) // endfun

(* ****** ****** *)

fun{
x:t0p
} list_extend{n:int}
  (xs: list (INV(x), n), x: x):<!wrt> list_vt (x, n+1)
// end of [list_extend]

macdef list_snoc (xs, x) = list_extend (,(xs), ,(x))

(* ****** ****** *)

fun{x:t0p}
list_reverse
  {n:int} (xs: list (INV(x), n)):<!wrt> list_vt (x, n)
// end of [list_reverse]

(* ****** ****** *)
//
fun{a:t0p}
list_reverse_append{m,n:int}
  (xs: NSH(list (INV(a), m)), ys: SHR(list (a, n))):<> list (a, m+n)
// end of [list_reverse_append]
//
fun{a:t0p}
list_reverse_append1_vt{m,n:int}
  (xs: list_vt (INV(a), m), ys: SHR(list (a, n))):<!wrt> list (a, m+n)
// end of [list_reverse_append1_vt]
fun{a:t0p}
list_reverse_append2_vt{m,n:int}
  (xs: NSH(list (INV(a), m)), ys: list_vt (a, n)):<!wrt> list_vt (a, m+n)
// end of [list_reverse_append2_vt]
//
macdef list_revapp = list_reverse_append
macdef list_revapp1_vt = list_reverse_append1_vt
macdef list_revapp2_vt = list_reverse_append2_vt
//
(* ****** ****** *)

fun{x:t0p}
list_concat (xss: List (List (INV(x)))):<!wrt> List0_vt (x)

(* ****** ****** *)
//
fun{
x:t0p
} list_take
  {n:int}{i:nat | i <= n}
  (xs: list (INV(x), n), i: int i):<!wrt> list_vt (x, i)
fun{
x:t0p
} list_take_exn
  {n:int}{i:nat} // it may raise [ListSubscriptException]
  (xs: list (INV(x), n), i: int i):<!exnwrt> [i <= n] list_vt (x, i)
//
(* ****** ****** *)
//
fun{
x:t0p
} list_drop
  {n:int}{i:nat | i <= n}
  (xs: SHR(list (INV(x), n)), i: int i):<> list (x, n-i)
fun{
x:t0p
} list_drop_exn
  {n:int}{i:nat} // it may raise [ListSubscriptException]
  (xs: SHR(list (INV(x), n)), i: int i):<!exn> [i <= n] list (x, n-i)
//
(* ****** ****** *)

fun{
x:t0p
} list_split_at
  {n:int}{i:nat | i <= n}
  (xs: SHR(list (INV(x), n)), i: int i):<!wrt> (list_vt (x, i), list (x, n-i))
// end of [list_split_at]

(* ****** ****** *)

fun{x:t0p}
list_exists (xs: List (INV(x))):<> bool
fun{x:t0p} list_exists$pred (x):<> bool

(* ****** ****** *)

fun{x:t0p}
list_forall (xs: List (INV(x))):<> bool
fun{x:t0p} list_forall$pred (x):<> bool

(* ****** ****** *)

fun{x:t0p}
list_equal$eqfn (x, x):<> bool
fun{x:t0p}
list_equal (xs1: List (INV(x)), xs2: List(x)):<> bool

(* ****** ****** *)
//
fun{
x:t0p
} list_find
  (List (INV(x)), x: &(x)? >> opt(x, b)):<> #[b:bool] bool(b)
//
fun{x:t0p} list_find$pred (x):<> bool
//
fun{x:t0p} list_find_exn (xs: List (INV(x))):<!exn> x
fun{x:t0p} list_find_opt (xs: List (INV(x))):<> Option_vt (x)
//
(* ****** ****** *)
//
fun{
key,itm:t0p
} list_assoc
(
  List @(INV(key), itm), key, x: &itm? >> opt(itm, b)
) :<> #[b:bool] bool(b) // end of [list_assoc]
//
fun{key:t0p}
list_assoc$eqfn (k1: key, k2: key):<> bool
//
fun{
key,itm:t0p
} list_assoc_exn
  (kxs: List @(INV(key), itm), k: key):<!exn> itm
fun{
key,itm:t0p
} list_assoc_opt
  (kxs: List @(INV(key), itm), k: key):<> Option_vt(itm)
//
(* ****** ****** *)
//
fun{
x:t0p
} list_filter{n:int}
  (xs: list (INV(x), n)): listLte_vt (x, n)
//
fun{x:t0p} list_filter$pred (x): bool
//
(*
fun{
x:t0p
} list_filter_funenv
  {v:view}{vt:viewtype}{n:int}{fe:eff}
(
  pfv: !v |
  xs: list (INV(x), n)
, f: (!v | x, !vt) -<fun,fe> bool, env: !vt
) :<fe,!wrt> listLte_vt (x, n) // end-of-function
*)
//
(* ****** ****** *)

fun{
x:t0p
} list_labelize{n:int}
  (xs: list (INV(x), n)):<!wrt> list_vt (@(int, x), n)
// end of [list_labelize]

(* ****** ****** *)
//
fun{x:t0p}
list_app (xs: List (INV(x))): void
//
fun{x:t0p} list_app$fwork (x): void
//
(* ****** ****** *)
//
fun{x:t0p}
list_app_fun
  (xs: List (INV(x)), fwork: (x) -<fun1> void): void
fun{x:t0p}
list_app_clo
  (xs: List (INV(x)), fwork: (x) -<clo1> void): void
fun{x:t0p}
list_app_cloref
  (xs: List (INV(x)), fwork: (x) -<cloref1> void): void
//
(* ****** ****** *)
//
(*
fun{
x:t0p
} list_app_funenv
  {v:view}{vt:viewtype}{n:int}{fe:eff} (
  pfv: !v |
  xs: list (INV(x), n)
, f: (!v | x, !vt) -<fun,fe> void, env: !vt
) :<fe> void // end of [list_app_funenv]
*)
//
(* ****** ****** *)
//
fun{
x:t0p}{y:vt0p
} list_map{n:int}
  (xs: list (INV(x), n)): list_vt (y, n)
// end of [list_map]
//
fun{x:t0p}{y:vt0p} list_map$fopr (x: x): (y)
//
(* ****** ****** *)

fun{
x:t0p}{y:vt0p
} list_map_fun{n:int}
  (xs: list (INV(x), n), f: (x) -<fun1> y): list_vt(y, n)

fun{
x:t0p}{y:vt0p
} list_map_clo{n:int}
  (xs: list (INV(x), n), f: &(x) -<clo1> y): list_vt(y, n)

fun{
x:t0p}{y:vt0p
} list_map_cloref{n:int}
  (xs: list (INV(x), n), f: (x) -<cloref1> y): list_vt(y, n)

(* ****** ****** *)

(*
fun{
x:t0p}{y:vt0p
} list_map_funenv
  {v:view}{vt:viewtype}{n:int}{fe:eff} (
  pfv: !v |
  xs: list (INV(x), n)
, f: (!v | x, !vt) -<fun,fe> y, env: !vt
) :<fe,!wrt> list_vt (y, n) // end of [list_map_funenv]
*)

(* ****** ****** *)
//
fun{
x:t0p}{y:vt0p
} list_imap{n:int}
  (xs: list (INV(x), n)): list_vt (y, n)
//
fun{
x:t0p}{y:vt0p
} list_imap$fopr (i: intGte(0), x: x): (y)
//
(* ****** ****** *)

fun{
x:t0p}{y:vt0p
} list_mapopt{n:int}
  (xs: list (INV(x), n)): listLte_vt (y, n)
//
fun{
x:t0p}{y:vt0p
} list_mapopt$fopr (x: x): Option_vt (y)
//
(*
fun{
x:t0p}{y:t0p
} list_mapopt_funenv
  {v:view}{vt:viewtype}{n:int}{fe:eff} (
  pfv: !v |
  xs: list (INV(x), n)
, f: (!v | x, !vt) -<fun,fe> Option_vt (y), env: !vt
) :<fe> listLte_vt (y, n) // end of [list_mapopt_funenv]
*)
//
(* ****** ****** *)

fun{
x1,x2:t0p}{y:vt0p
} list_map2{n1,n2:int}
(
  xs1: list (INV(x1), n1)
, xs2: list (INV(x2), n2)
) : list_vt (y, min(n1,n2)) // end of [list_map2]
//
fun{
x1,x2:t0p}{y:vt0p
} list_map2$fopr (x1: x1, x2: x2): (y)
//
(*
fun{
x1,x2:t0p}{y:t0p
} list_map2_funenv
  {v:view}{vt:viewtype}{n1,n2:int}{fe:eff}
(
  pfv: !v |
  xs1: list (INV(x1), n1)
, xs2: list (INV(x2), n2)
, f: (!v | x1, x2, !vt) -<fun,fe> y, env: !vt
) :<fe> list_vt (y, min(n1,n2)) // end of [list_map2_funenv]
*)
//
(* ****** ****** *)
//
fun{
a:vt0p
} list_tabulate{n:nat} (int n): list_vt (a, n)
//
fun{a:vt0p} list_tabulate$fopr (index: intGte(0)): (a)
//
(* ****** ****** *)

fun{
a:vt0p
} list_tabulate_fun{n:nat}
  (n: int n, f: natLt(n) -<fun1> a): list_vt (a, n)
fun{
a:vt0p
} list_tabulate_clo{n:nat}
  (n: int n, f: &(natLt(n)) -<clo1> a): list_vt (a, n)
fun{
a:vt0p
} list_tabulate_cloref{n:nat}
  (n: int n, f: natLt(n) -<cloref1> a): list_vt (a, n)

(* ****** ****** *)

fun{
x,y:t0p
} list_zip{m,n:int}
(
  xs: list (INV(x), m), ys: list (INV(y), n)
) :<!wrt> list_vt ((x, y), min(m,n)) // endfun

fun{
x,y:t0p}{xy:vt0p
} list_zipwith{m,n:int}
(
  xs: list (INV(x), m), ys: list (INV(y), n)
) : list_vt (xy, min(m,n)) // endfun
//
fun{
x,y:t0p}{xy:vt0p
} list_zipwith$fopr (x: x, y: y): (xy)
//
(* ****** ****** *)

fun{
x,y:t0p
} list_cross{m,n:int}
(
  xs: list (INV(x), m), ys: list (INV(y), n)
) :<!wrt> list_vt ((x, y), m*n) // endfun

fun{
x,y:t0p}{xy:vt0p
} list_crosswith{m,n:int}
(
  xs: list (INV(x), m), ys: list (INV(y), n)
) : list_vt (xy, m*n) // end of [list_crosswith]
//
fun{
x,y:t0p}{xy:vt0p
} list_crosswith$fopr (x: x, y: y): (xy)
//
(* ****** ****** *)

fun{
x:t0p
} list_foreach (xs: List (INV(x))): void
fun{
x:t0p}{env:vt0p
} list_foreach_env (xs: List (INV(x)), env: &(env) >> _): void
//
fun{
x:t0p}{env:vt0p
} list_foreach$cont (x: x, env: &env): bool
fun{
x:t0p}{env:vt0p
} list_foreach$fwork (x: x, env: &(env) >> _): void
//
(* ****** ****** *)

fun{x:t0p}
list_foreach_fun
  {fe:eff} (
  xs: List (INV(x)), f: (x) -<fun,fe> void
) :<fe> void // end of [list_foreach_fun]

fun{x:t0p}
list_foreach_clo
  {fe:eff} (
  xs: List (INV(x)), f: &(x) -<clo,fe> void
) :<fe> void // end of [list_foreach_clo]
fun{x:t0p}
list_foreach_vclo
  {v:view}{fe:eff} (
  pf: !v | xs: List (INV(x)), f: &(!v | x) -<clo,fe> void
) :<fe> void // end of [list_foreach_vclo]

fun{x:t0p}
list_foreach_cloptr
  {fe:eff} (
  xs: List (INV(x)), f: !(x) -<cloptr,fe> void
) :<fe> void // end of [list_foreach_cloptr]
fun{x:t0p}
list_foreach_vcloptr
  {v:view}{fe:eff} (
  pf: !v | xs: List (INV(x)), f: !(!v | x) -<cloptr,fe> void
) :<fe> void // end of [list_foreach_vcloptr]

fun{x:t0p}
list_foreach_cloref
  {fe:eff} (
  xs: List (INV(x)), f: (x) -<cloref,fe> void
) :<fe> void // end of [list_foreach_cloref]

fun{x:t0p}
list_foreach_funenv
  {v:view}{env:viewtype}{fe:eff} (
  pfv: !v
| xs: List (INV(x))
, f: (!v | x, !env) -<fun,fe> void
, env: !env
) :<fe> void // end of [list_foreach_funenv]

(* ****** ****** *)
//
fun{
x,y:t0p
} list_foreach2 (xs: List (INV(x)), ys: List (INV(y))): void
//
fun{
x,y:t0p}{env:vt0p
} list_foreach2_env (xs: List (INV(x)), ys: List (INV(y)), env: &(env) >> _): void
//
fun{
x,y:t0p}{env:vt0p
} list_foreach2$cont (x: x, y: y, env: &env): bool
fun{
x,y:t0p}{env:vt0p
} list_foreach2$fwork (x: x, y: y, env: &(env) >> _): void
//
(* ****** ****** *)

fun{
x:t0p
} list_iforeach{n:int} (xs: list (INV(x), n)): natLte(n)

fun{
x:t0p}{env:vt0p
} list_iforeach_env{n:int} (xs: list (INV(x), n), env: &(env) >> _): natLte(n)
//
fun{
x:t0p}{env:vt0p
} list_iforeach$cont (i: intGte(0), x: x, env: &env): bool
fun{
x:t0p}{env:vt0p
} list_iforeach$fwork (i: intGte(0), x: x, env: &(env) >> _): void
//
(* ****** ****** *)

fun{
x:t0p // type for elements
} list_iforeach_funenv
  {v:view}{vt:viewtype}{n:int}{fe:eff} (
  pfv: !v |
  xs: list (INV(x), n)
, f: (!v | natLt(n), x, !vt) -<fun,fe> void, env: !vt
) :<fe> int (n) // end of [list_iforeach_funenv]

(* ****** ****** *)

fun{
x,y:t0p
} list_iforeach2{m,n:int}
  (xs: list (INV(x), m), ys: list(INV(y), n)): natLte(min(m,n))

fun{
x,y:t0p}{env:vt0p
} list_iforeach2_env{m,n:int}
  (xs: list (INV(x), m), ys: list(INV(y), n), env: &(env) >> _): natLte(min(m,n))
//
fun{
x,y:t0p}{env:vt0p
} list_iforeach2$cont (i: intGte(0), x: x, y: y, env: &env): bool
fun{
x,y:t0p}{env:vt0p
} list_iforeach2$fwork (i: intGte(0), x: x, y: y, env: &(env) >> _): void
//
(* ****** ****** *)

fun{
res:vt0p}{x:t0p
} list_foldleft
  (xs: List (INV(x)), ini: res): res
fun{
res:vt0p}{x:t0p
} list_foldleft$fopr (acc: res, x: x): res

(* ****** ****** *)

fun{
x:t0p}{res:vt0p
} list_foldright
  (xs: List (INV(x)), snk: res): res
fun{
x:t0p}{res:vt0p
} list_foldright$fopr (x: x, acc: res): res

(* ****** ****** *)

fun{
a:t0p
} list_mergesort{n:int}
  (xs: list (INV(a), n)) :<!wrt> list_vt (a, n)
//
fun{a:t0p}
list_mergesort$cmp (x1: a, x2: a):<> int (* sign *)
//
(* ****** ****** *)

fun{
a:t0p
} list_mergesort_fun
  {n:int} (
  xs: list (INV(a), n), cmp: cmpval (a)
) :<!wrt> list_vt (a, n) // end of [list_mergesort_fun]

fun{
a:t0p
} list_mergesort_cloref
  {n:int} (
  xs: list (INV(a), n), cmp: (a, a) -<cloref> int
) :<!wrt> list_vt (a, n) // end of [list_mergesort_cloref]

(* ****** ****** *)
//
fun{
a:t0p
} list_quicksort{n:int}
  (xs: list (INV(a), n)) :<!wrt> list_vt (a, n)
//
fun{a:t0p}
list_quicksort$cmp (x1: a, x2: a):<> int (* sign *)
//
(* ****** ****** *)

fun{
a:t0p
} list_quicksort_fun
  {n:int} (
  xs: list (INV(a), n), cmp: cmpval (a)
) :<!wrt> list_vt (a, n) // end of [list_quicksort_fun]

(* ****** ****** *)
//
// overloading for certain symbols
//
overload = with list_equal
//
overload + with list_append
//
overload [] with list_get_at
//
overload iseqz with list_is_nil
overload isneqz with list_is_cons
//
overload .head with list_head
overload .tail with list_tail
//
overload length with list_length
//
overload copy with list_copy
//
overload print with print_list
overload prerr with prerr_list
overload fprint with fprint_list
overload fprint with fprint_list_sep
//
(* ****** ****** *)

(* end of [list.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)
(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/intrange.atxt
** Time of generation: Sat Oct 17 15:19:47 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: June, 2012 *)

(* ****** ****** *)
//
// HX-2013-04:
// intrange (l, r) is for integers i satisfying l <= i < r
//
(* ****** ****** *)
//
fun{}
intrange_foreach (l: int, r: int): int
fun{env:vt0p}
intrange_foreach_env (l: int, r: int, env: &(env) >> _): int
//
fun{env:vt0p}
intrange_foreach$cont (i: int, env: &env): bool
fun{env:vt0p}
intrange_foreach$fwork (i: int, env: &(env) >> _): void
//
(* ****** ****** *)

fun{}
int_foreach_cloref
(
  n: int, fwork: (int) -<cloref1> void
) : int // end of [int_foreach_cloref]
fun{}
intrange_foreach_cloref
(
  l: int, r: int, fwork: (int) -<cloref1> void
) : int // end of [intrange_foreach_cloref]

(* ****** ****** *)
//
fun{}
intrange_rforeach (l: int, r: int): int
fun{env:vt0p}
intrange_rforeach_env (l: int, r: int, env: &(env) >> _): int
//
fun{env:vt0p}
intrange_rforeach$cont (i: int, env: &env): bool
fun{env:vt0p}
intrange_rforeach$fwork (i: int, env: &(env) >> _): void
//
(* ****** ****** *)

fun{}
int_rforeach_cloref
(
  n: int, fwork: (int) -<cloref1> void
) : int // end of [int_rforeach_cloref]
fun{}
intrange_rforeach_cloref
(
  l: int, r: int, fwork: (int) -<cloref1> void
) : int // end of [intrange_rforeach_cloref]

(* ****** ****** *)
//
fun{}
intrange2_foreach
  (l1: int, r1: int, l2: int, r2: int): void
//
fun{env:vt0p}
intrange2_foreach_env
  (l1: int, r1: int, l2: int, r2: int, env: &(env) >> _): void
//
fun{env:vt0p}
intrange2_foreach$fwork (i: int, j: int, env: &env >> _): void
//
(* ****** ****** *)

(* end of [intrange.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/option.atxt
** Time of generation: Sat Oct 17 15:19:48 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2012 *)

(* ****** ****** *)

sortdef t0p = t@ype

(* ****** ****** *)

#if(0)
//
// HX: these decls are available in [basic_dyn.sats]
//
stadef option = option_t0ype_bool_type
typedef Option (a:t0p) = [b:bool] option (a, b)
#endif

(* ****** ****** *)

exception NotSomeExn of ()
(*
fun NotSomeExn ():<> exn = "mac#%NotSomeExn_make"
fun isNotSomeExn (x: !exn):<> bool = "mac#%isNotSomeExn"
macdef
ifNotSomeExn
  {tres}(exn, body) =
(
let val x = ,(exn) in
(
if isNotSomeExn(x)
  then
    let prval () = __vfree_exn (x) in ,(body) end
  else $raise (x)
) : tres // end of [if]
end (* end of [let] *)
) // end of [ifNotSomeExn]
*)

(* ****** ****** *)
//
castfn
option_cast
  {a:t0p}{b:bool}
  (opt: option (INV(a), b)):<> option (a, b)
//
(* ****** ****** *)
//
castfn
option_vt2t
  {a:t0p}{b:bool}
  (opt: option_vt (INV(a), b)):<> option (a, b)
castfn
option_of_option_vt
  {a:t0p}{b:bool}
  (opt: option_vt (INV(a), b)):<> option (a, b)
//
(* ****** ****** *)

fun{a:t0p}
option_some (x: a):<> option (a, true)
fun{a:t0p}
option_none ((*void*)):<> option (a, false)

(* ****** ****** *)

fun{}
option_is_some{a:t0p}
  {b:bool} (opt: option (a, b)):<> bool (b)
// end of [option_is_some]

fun{}
option_is_none{a:t0p}
  {b:bool} (opt: option (a, b)):<> bool (~b)
// end of [option_is_none]

(* ****** ****** *)

fun{a:t0p}
option_unsome (opt: option (INV(a), true)):<> a

fun{a:t0p}
option_unsome_exn (opt: Option (INV(a))):<!exn> a

(* ****** ****** *)
//
fun{a:t0p}
option_equal$eqfn (a, a):<> bool
fun{a:t0p}
option_equal
  (opt1: Option(a), opt2: Option(a)):<> bool
//
(* ****** ****** *)
//
fun{a:t0p}
fprint_option
  (out: FILEref, opt: Option (INV(a))): void
//
overload fprint with fprint_option
//
(* ****** ****** *)
//
// overloading for certain symbols
//
(* ****** ****** *)

overload = with option_equal

(* ****** ****** *)

overload iseqz with option_is_none
overload isneqz with option_is_some

(* ****** ****** *)

(* end of [option.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/matrixref.atxt
** Time of generation: Sat Oct 17 15:19:49 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: April, 2013 *)

(* ****** ****** *)

#define NSH (x) x // for commenting: no sharing
#define SHR (x) x // for commenting: it is shared

(* ****** ****** *)

sortdef tk = tkind

(* ****** ****** *)

sortdef t0p = t@ype and vt0p = viewt@ype

(* ****** ****** *)
//
// matrixref:
// reference to a matrix
// with no dimension info attached
//
(* ****** ****** *)
//
abstype
matrixref_vt0ype_int_int_type
  (a:vt@ype(*inv*), nrow: int, ncol:int) = ptr
//
stadef matrixref = matrixref_vt0ype_int_int_type
//
(* ****** ****** *)

praxi
lemma_matrixref_param
  {a:vt0p}{m,n:int}
  (M: matrixref (a, m, n)): [m >= 0; n >= 0] void
// end of [lemma_matrixref_param]

(* ****** ****** *)
//
castfn
matrixref2ptr
  {a:vt0p}{m,n:int} (M: matrixref (a, m, n)):<> Ptr0
//
(* ****** ****** *)
//
castfn
matrixptr_refize
  {a:vt0p}{l:addr}{m,n:int}
  (matrixptr (INV(a), l, m, n)):<!wrt> matrixref (a, m, n)
//
castfn
matrixref_get_viewptr
  {a:vt0p}
  {m,n:int}
(
  M: matrixref (a, m, n)
) :<> [l:addr] (vbox (matrix_v (a, l, m, n)) | ptr l)
//
(* ****** ****** *)

castfn
arrayref2matrixref
  {a:vt0p}{m,n:nat} (A: arrayref (a, m*n)):<> matrixref (a, m, n)
// end of [arrayref2matrixref]

(* ****** ****** *)

fun{
a:t0p
} matrixref_make_elt
  {m,n:int}
  (m: size_t m, n: size_t n, x0: a):<!wrt> matrixref (a, m, n)
// end of [matrixref_make_elt]

(* ****** ****** *)

fun{a:t0p}
matrixref_get_at_int
  {m,n:int}
(
  M: matrixref (a, m, n), i: natLt(m), n: int(n), j: natLt(n)
) :<!ref> (a) // end of [matrixref_get_at_int]

fun{a:t0p}
matrixref_get_at_size
  {m,n:int}
(
  M: matrixref (a, m, n), i: sizeLt(m), n: size_t(n), j: sizeLt(n)
) :<!ref> (a) // end of [matrixref_get_at_size]
//
symintr matrixref_get_at
overload matrixref_get_at with matrixref_get_at_int of 0
overload matrixref_get_at with matrixref_get_at_size of 0
//
(* ****** ****** *)

fun{a:t0p}
matrixref_set_at_int
  {m,n:int}
(
  M: matrixref (a, m, n), i: natLt (m), n: int n, j: natLt (n), x: a
) :<!refwrt> void // end of [matrixref_set_at_int]

fun{a:t0p}
matrixref_set_at_size
  {m,n:int}
(
  M: matrixref (a, m, n), i: sizeLt (m), n: size_t n, j: sizeLt (n), x: a
) :<!refwrt> void // end of [matrixref_set_at_size]

symintr matrixref_set_at
overload matrixref_set_at with matrixref_set_at_int of 0
overload matrixref_set_at with matrixref_set_at_size of 0

(* ****** ****** *)

fun{a:vt0p}
matrixref_exch_at_int
  {m,n:int}
(
  M: matrixref (a, m, n)
, i: natLt (m), n: int n, j: natLt (n), x: &a >> _
) :<!refwrt> void // end of [matrixref_exch_at_int]

fun{a:vt0p}
matrixref_exch_at_size
  {m,n:int}
(
  M: matrixref (a, m, n)
, i: sizeLt (m), n: size_t n, j: sizeLt (n), x: &a >> _
) :<!refwrt> void // end of [matrixref_exch_at_size]

symintr matrixref_exch_at
overload matrixref_exch_at with matrixref_exch_at_int of 0
overload matrixref_exch_at with matrixref_exch_at_size of 0

(* ****** ****** *)

(*
fprint_matrix$sep1 // col separation
fprint_matrix$sep2 // row separation
*)
fun{a:vt0p}
fprint_matrixref{m,n:int}
(
  out: FILEref
, M: matrixref (a, m, n), m: size_t m, n: size_t n
) : void // end of [fprint_matrixref]

fun{a:vt0p}
fprint_matrixref_sep{m,n:int}
(
  out: FILEref
, M: matrixref (a, m, n), m: size_t (m), n: size_t (n)
, sep1: NSH(string), sep2: NSH(string)
) : void // end of [fprint_matrixref_sep]

(* ****** ****** *)
//
fun{a:t0p}
matrixref_copy
  {m,n:int}
(
  M: matrixref (a, m, n), m: size_t(m), n: size_t(n)
) : matrixptr (a, m, n) // end-of-fun
//
(* ****** ****** *)

(*
fun{a:vt0p}
matrix_tabulate$fopr (i: size_t, j: size_t): (a)
*)
fun{a:vt0p}
matrixref_tabulate
  {m,n:int} (nrow: size_t m, ncol: size_t n): matrixref (a, m, n)
//
fun{a:vt0p}
matrixref_tabulate_cloref
  {m,n:int}
(
  nrow: size_t m, ncol: size_t n, f: (sizeLt(m), sizeLt(n)) -<cloref> a
) : matrixref (a, m, n) // end-of-fun
//
(* ****** ****** *)

(*
fun{
a:vt0p}{env:vt0p
} matrix_foreach$fwork
  (x: &a >> _, env: &(env) >> _): void
*)
//
fun{
a:vt0p
} matrixref_foreach{m,n:int}
(
  A: matrixref (a, m, n), m: size_t m, n: size_t n
) : void // end of [matrixref_foreach]
fun{
a:vt0p}{env:vt0p
} matrixref_foreach_env{m,n:int}
(
  A: matrixref (a, m, n), m: size_t m, n: size_t n, env: &(env) >> _
) : void // end of [matrixref_foreach_env]

(* ****** ****** *)
//
// mtrxszref: a reference to a matrix with size information attached
//
(* ****** ****** *)

abstype // in-variant
mtrxszref_vt0ype_type (a: vt@ype) = ptr
stadef mtrxszref = mtrxszref_vt0ype_type

(* ****** ****** *)

fun{}
mtrxszref_make_matrixref
  {a:vt0p}{m,n:int}
(
  M: matrixref (a, m, n), m: size_t m, n: size_t n
) :<!wrt> mtrxszref (a) // endfun

(* ****** ****** *)
//
fun{}
mtrxszref_get_ref{a:vt0p} (M: mtrxszref (a)):<> Ptr1
//
fun{}
mtrxszref_get_nrow{a:vt0p} (M: mtrxszref (a)):<> size_t
fun{}
mtrxszref_get_ncol{a:vt0p} (M: mtrxszref (a)):<> size_t
//
(* ****** ****** *)

symintr .ref
overload .ref with mtrxszref_get_ref

(* ****** ****** *)

fun{}
mtrxszref_get_refsize{a:vt0p}
(
  M: mtrxszref (a)
, nrol: &size_t? >> size_t m, ncol: &size_t? >> size_t (n)
) :<!wrt> #[m,n:nat] matrixref (a, m, n) // endfun

(* ****** ****** *)

fun{a:t0p}
mtrxszref_make_elt
  (nrow: size_t, ncol: size_t, init: a):<!wrt> mtrxszref (a)
// end of [mtrxszref_make_elt]

(* ****** ****** *)
//
fun{a:t0p}
mtrxszref_get_at_int
  (M: mtrxszref(a), i: int, j: int):<!exnref> (a)
fun{a:t0p}
mtrxszref_get_at_size
  (M: mtrxszref(a), i: size_t, j: size_t):<!exnref> (a)
//
symintr mtrxszref_get_at
overload mtrxszref_get_at with mtrxszref_get_at_int of 0
overload mtrxszref_get_at with mtrxszref_get_at_size of 0
//
(* ****** ****** *)
//
fun{a:t0p}
mtrxszref_set_at_int
  (M: mtrxszref(a), i: int, j: int, x: a):<!exnrefwrt> void
fun{a:t0p}
mtrxszref_set_at_size
  (M: mtrxszref(a), i: size_t, j: size_t, x: a):<!exnrefwrt> void
//
symintr mtrxszref_set_at
overload mtrxszref_set_at with mtrxszref_set_at_int of 0
overload mtrxszref_set_at with mtrxszref_set_at_size of 0
//
(* ****** ****** *)

(*
fprint_matrix$sep1 // col separation
fprint_matrix$sep2 // row separation
*)
fun{a:vt0p}
fprint_mtrxszref
(
  out: FILEref, M: mtrxszref(a)
) : void // end of [fprint_mtrxszref]

fun{a:vt0p}
fprint_mtrxszref_sep
(
  out: FILEref
, M: mtrxszref(a), sep1: NSH(string), sep2: NSH(string)
) : void // end of [fprint_mtrxszref_sep]

(* ****** ****** *)
//
(*
fun{
a:vt0p}{env:vt0p
} matrix_foreach$fwork
  (x: &a >> _, env: &(env) >> _): void
*)
//
fun{
a:vt0p
} mtrxszref_foreach(mtrxszref (a)): void
fun{
a:vt0p}{env:vt0p
} mtrxszref_foreach_env(mtrxszref(a), &(env) >> _) : void
//
fun{
a:vt0p
} mtrxszref_foreach_cloref
  (A: mtrxszref(a), fwork: (&(a) >> _) -<cloref1> void ): void
//
(* ****** ****** *)
//
(*
fun{a:vt0p}
matrix_tabulate$fopr (i: size_t, j: size_t): (a)
*)
fun{a:vt0p}
mtrxszref_tabulate (nrow: size_t, ncol: size_t): mtrxszref (a)
//
fun{a:vt0p}
mtrxszref_tabulate_cloref
  {m,n:int}
(
  nrow: size_t m, ncol: size_t n, f: (sizeLt(m), sizeLt(n)) -<cloref> a
) : mtrxszref (a) // end-of-fun
//
(* ****** ****** *)
//
// overloading for certain symbols
//
(* ****** ****** *)

overload [] with matrixref_get_at_int of 0
overload [] with matrixref_get_at_size of 0
overload [] with matrixref_set_at_int of 0
overload [] with matrixref_set_at_size of 0

(* ****** ****** *)

overload [] with mtrxszref_get_at_int of 0
overload [] with mtrxszref_get_at_size of 0
overload [] with mtrxszref_set_at_int of 0
overload [] with mtrxszref_set_at_size of 0

(* ****** ****** *)

overload .nrow with mtrxszref_get_nrow
overload .ncol with mtrxszref_get_ncol

(* ****** ****** *)

overload fprint with fprint_matrixref
overload fprint with fprint_matrixref_sep
overload fprint with fprint_mtrxszref
overload fprint with fprint_mtrxszref_sep

(* ****** ****** *)

overload ptrcast with matrixref2ptr

(* ****** ****** *)

(* end of [matrixref.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/string.atxt
** Time of generation: Sat Oct 17 15:19:45 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: September, 2011 *)

(* ****** ****** *)

(*
** HX: a string is a null-terminated arrayref of characters
*)

(* ****** ****** *)

sortdef tk = tkind

(* ****** ****** *)

typedef SHR(a:type) = a // for commenting purpose
typedef NSH(a:type) = a // for commenting purpose

(* ****** ****** *)
//
typedef
stringLt (n:int) = [k:nat | k < n] string (k)
typedef
stringLte (n:int) = [k:nat | k <= n] string (k)
//
typedef
stringGt (n:int) = [k:int | k > n] string (k)
typedef
stringGte (n:int) = [k:int | k >= n] string (k)
//
typedef
stringBtw
  (m:int, n:int) = [k:int | m <= k; k < n] string (k)
typedef
stringBtwe
  (m:int, n:int) = [k:int | m <= k; k <= n] string (k)
//
(* ****** ****** *)

typedef stringlst = List0 (string)
vtypedef stringlst_vt = List0_vt (string)

(* ****** ****** *)

dataprop
string_index_p
(
  n: int, int(*i*), int(*c*)
) =
  | string_index_p_eqz (n, n, 0)
  | {i:int | n > i}
    {c:int8 | c != 0}
    string_index_p_neqz (n, i, c)
// end of [string_index_p]

(* ****** ****** *)

exception StringSubscriptExn of ((*void*))

(* ****** ****** *)
//
praxi
lemma_string_param{n:int}(string n): [n >= 0] void
//
(* ****** ****** *)

castfn
string2ptr (x: string):<> Ptr1
overload ptrcast with string2ptr

(* ****** ****** *)
//
// HX: [string2string] = [string1_of_string0]
//
castfn g0ofg1_string (x: String):<> string
castfn g1ofg0_string (x: string):<> String0
//
overload g0ofg1 with g0ofg1_string // index-erasing
overload g1ofg0 with g1ofg0_string // index-inducing
//
(* ****** ****** *)

fun{}
string_sing (c: charNZ):<!wrt> strnptr (1)

(* ****** ****** *)
//
fun{
} string_is_empty{n:int} (str: string(n)):<> bool(n==0)
fun{
} string_isnot_empty{n:int} (str: string(n)):<> bool(n > 0)
//
(* ****** ****** *)
//
fun{}
string_is_atend_size
  {n:int}{i:nat | i <= n}
  (s: string (n), i: size_t (i)):<> bool (i==n)
fun{tk:tk}
string_is_atend_gint
  {n:int}{i:nat | i <= n}
  (s: string (n), i: g1int (tk, i)):<> bool (i==n)
fun{tk:tk}
string_is_atend_guint
  {n:int}{i:nat | i <= n}
  (s: string (n), i: g1uint (tk, i)):<> bool (i==n)
//
symintr string_is_atend
overload string_is_atend with string_is_atend_gint
overload string_is_atend with string_is_atend_guint
//
(* ****** ****** *)

macdef
string_isnot_atend
  (string, index) = ~string_is_atend (,(string), ,(index))
// end of [string_isnot_atend]

(* ****** ****** *)
//
fun{
} string_head{n:pos} (str: string(n)):<> charNZ
fun{
} string_tail{n:pos} (str: string(n)):<> string(n-1)
//
(* ****** ****** *)

fun{}
string_get_at_size
  {n:int}{i:nat | i < n}
  (s: string (n), i: size_t (i)):<> charNZ
fun{tk:tk}
string_get_at_gint
  {n:int}{i:nat | i < n}
  (s: string (n), i: g1int (tk, i)):<> charNZ
fun{tk:tk}
string_get_at_guint
  {n:int}{i:nat | i < n}
  (s: string (n), i: g1uint (tk, i)):<> charNZ
//
symintr string_get_at
overload string_get_at with string_get_at_size of 1
overload string_get_at with string_get_at_gint of 0
overload string_get_at with string_get_at_guint of 0
//
(* ****** ****** *)

fun{}
string_test_at_size
  {n:int}{i:nat | i <= n}
  (s: string (n), i: size_t (i)):<> [c:int] (string_index_p (n, i, c) | char (c))
fun{tk:tk}
string_test_at_gint
  {n:int}{i:nat | i <= n}
  (s: string (n), i: g1int (tk, i)):<> [c:int] (string_index_p (n, i, c) | char (c))
fun{tk:tk}
string_test_at_guint
  {n:int}{i:nat | i <= n}
  (s: string (n), i: g1uint (tk, i)):<> [c:int] (string_index_p (n, i, c) | char (c))
//
symintr string_test_at
overload string_test_at with string_test_at_size of 1
overload string_test_at with string_test_at_gint of 0
overload string_test_at with string_test_at_guint of 0
//
(* ****** ****** *)

fun lt_string_string
  (x1: string, x2: string):<> bool = "mac#%"
overload < with lt_string_string
fun lte_string_string
  (x1: string, x2: string):<> bool = "mac#%"
overload <= with lte_string_string

fun gt_string_string
  (x1: string, x2: string):<> bool = "mac#%"
overload > with gt_string_string
fun gte_string_string
  (x1: string, x2: string):<> bool = "mac#%"
overload >= with gte_string_string

fun eq_string_string
  (x1: string, x2: string):<> bool = "mac#%"
overload = with eq_string_string
fun neq_string_string
  (x1: string, x2: string):<> bool = "mac#%"
overload != with neq_string_string
overload <> with neq_string_string

fun compare_string_string
  (x1: string, x2: string):<> Sgn = "mac#%"
overload compare with compare_string_string

(* ****** ****** *)

fun{
} strcmp (x1: string, x2: string):<> int

fun{
} strintcmp
  {n1,n2:int | n2 >=0}
  (x1: string n1, n2: int n2):<> int(sgn(n1-n2))
// end of [strintcmp]

fun{
} strlencmp
  {n1,n2:int}
  (x1: string n1, x2: string n2):<> int(sgn(n1-n2))
// end of [strlencmp]

(* ****** ****** *)

fun{}
string_make_list
  {n:int} (cs: list(charNZ, n)):<!wrt> strnptr (n)
fun{}
string_make_listlen
  {n:int} (cs: list(charNZ, n), n: int n):<!wrt> strnptr (n)

(* ****** ****** *)

fun{
} string_make_rlist
  {n:int} (cs: list(charNZ, n)):<!wrt> strnptr (n)
// end of [string_make_rlist]

fun{
} string_make_rlistlen
  {n:int} (cs: list(charNZ, n), n: int n):<!wrt> strnptr (n)
// end of [string_make_rlistlen]

(* ****** ****** *)

fun{
} string_make_substring
  {n:int}{st,ln:nat | st+ln <= n}
  (str: string (n), st: size_t st, ln: size_t ln):<!wrt> strnptr (ln)
// end of [string_make_substring]

(* ****** ****** *)

fun print_string (x: string): void = "mac#%"
fun prerr_string (x: string): void = "mac#%"
fun fprint_string (out: FILEref, x: string): void = "mac#%"

(* ****** ****** *)
//
fun fprint_substring
  {n:int}{st,ln:nat | st+ln <= n}
(
  out: FILEref, str: string(n), st: size_t(st), ln: size_t(ln)
) : void = "mac#%" // end of [fprint_substring]
//
(* ****** ****** *)

fun{
} strchr{n:int}
  (str: string (n), c0: char):<> ssizeBtwe (~1, n)
// end of [strchr]

fun{
} strrchr{n:int}
  (str: string (n), c0: char):<> ssizeBtwe (~1, n)
// end of [strrchr]

fun{
} strstr{n:int}
  (haystack: string (n), needle: string):<> ssizeBtw (~1, n)
// end of [strstr]

(* ****** ****** *)

fun{
} strspn{n:int} // spanning
  (str: string (n), accept: string):<> sizeLte (n)
// end of [strspn]
fun{
} strcspn{n:int} // complement spanning
  (str: string (n), accept: string):<> sizeLte (n)
// end of [strcspn]

(* ****** ****** *)

fun{
} string_index{n:int}
  (str: string (n), c0: charNZ):<> ssizeBtw (~1, n)
// end of [string_index]

fun{
} string_rindex{n:int}
  (str: string (n), c0: charNZ):<> ssizeBtw (~1, n)
// end of [string_rindex]

(* ****** ****** *)
//
fun{
} string0_length
  (x: NSH(string)):<> size_t
fun{
} string1_length
  {n:int} (x: NSH(string(n))):<> size_t(n)
//
symintr strlen
symintr string_length
overload strlen with string0_length of 0
overload strlen with string1_length of 10
overload string_length with string0_length of 0
overload string_length with string1_length of 10
//
(* ****** ****** *)
//
fun{
} string0_nlength
  (x: NSH(string), n: size_t):<> size_t
fun{
} string1_nlength
  {n1,n2:int}
  (NSH(string(n1)), size_t(n2)):<> size_t(min(n1,n2))
//
symintr string_nlength
overload string_nlength with string0_nlength of 0
overload string_nlength with string1_nlength of 10
//
(* ****** ****** *)
//
fun{
} string0_copy
  (xs: NSH(string)):<!wrt> Strptr1
fun{
} string1_copy
  {n:int} (xs: NSH(string(n))):<!wrt> strnptr (n)
//
(* ****** ****** *)
//
fun{
} string0_append
(
  x1: NSH(string), x2: NSH(string)
) :<!wrt> Strptr1 // end-of-fun
fun{
} string1_append
  {n1,n2:int} (
  x1: NSH(string(n1)), x2: NSH(string(n2))
) :<!wrt> strnptr (n1+n2) // end of [string1_append]
//
symintr string_append
overload string_append with string0_append of 0
(*
overload string_append with string1_append of 20
*)
//
(* ****** ****** *)
//
fun{
} string0_append3
(
  x1: NSH(string), x2: NSH(string), x3: NSH(string)
) :<!wrt> Strptr1 // end-of-fun
fun{
} string0_append4
(
  x1: NSH(string), x2: NSH(string), x3: NSH(string), x4: NSH(string)
) :<!wrt> Strptr1 // end-of-fun
fun{
} string0_append5
(
  x1: NSH(string), x2: NSH(string), x3: NSH(string), x4: NSH(string), x5: NSH(string)
) :<!wrt> Strptr1 // end-of-fun
fun{
} string0_append6
(
  x1: NSH(string), x2: NSH(string), x3: NSH(string), x4: NSH(string), x5: NSH(string), x6: NSH(string)
) :<!wrt> Strptr1 // end-of-fun
//
overload string_append with string0_append3 of 0
overload string_append with string0_append4 of 0
overload string_append with string0_append5 of 0
overload string_append with string0_append6 of 0
//
(* ****** ****** *)

fun{
} stringarr_concat{n:int}
  (xs: arrayref(string, n), size_t n):<!wrt> Strptr1
fun{
} stringlst_concat (xs: List(string)):<!wrt> Strptr1

(* ****** ****** *)

fun{
} string_explode
  {n:int} (x: string(n)):<!wrt> list_vt (charNZ, n)
// end of [string_explode]

(* ****** ****** *)

fun{
} string_tabulate$fopr (size_t): charNZ
fun{
} string_tabulate{n:int} (n: size_t(n)): strnptr(n)

(* ****** ****** *)
//
fun{}
string_forall (str: string): bool
fun{}
string_forall$pred (c: char): bool
//
(* ****** ****** *)
//
fun{}
string_iforall (str: string): bool
fun{}
string_iforall$pred (i: int, c: char): bool
//
(* ****** ****** *)
//
fun{env:vt0p}
string_foreach$cont (c: char, env: &env): bool
fun{env:vt0p}
string_foreach$fwork (c: char, env: &(env) >> _): void
//
fun{
} string_foreach {n:int} (str: string(n)): sizeLte(n)
fun{
env:vt0p
} string_foreach_env
  {n:int} (str: string(n), env: &(env) >> _): sizeLte(n)
// end of [string_foreach_env]
//
(* ****** ****** *)
//
fun{env:vt0p}
string_rforeach$cont (c: char, env: &env): bool
fun{env:vt0p}
string_rforeach$fwork (c: char, env: &(env) >> _): void
//
fun{
} string_rforeach {n:int} (str: string(n)): sizeLte(n)
fun{
env:vt0p
} string_rforeach_env
  {n:int} (str: string(n), env: &(env) >> _): sizeLte(n)
// end of [string_rforeach_env]
//
(* ****** ****** *)

(*
** HX: [stropt_none] is just the null pointer
*)
fun stropt_none (): stropt (~1) = "mac#%"

(* ****** ****** *)
//
castfn stropt0_some (x: SHR(string)): Stropt1
castfn stropt1_some {n:int} (x: SHR(string n)): stropt (n)
//
symintr stropt_some
overload stropt_some with stropt0_some of 0
overload stropt_some with stropt1_some of 10
//
(* ****** ****** *)

fun{
} stropt_is_none{n:int} (stropt(n)):<> bool (n < 0)
fun{
} stropt_is_some{n:int} (stropt(n)):<> bool (n >= 0)

(* ****** ****** *)

castfn
stropt_unsome {n:nat} (x: stropt n):<> string (n)

(* ****** ****** *)

fun{
} stropt_length
  {n:int} (x: stropt (n)):<> ssize_t (n)
// end of [stropt_length]

(* ****** ****** *)

fun print_stropt (opt: Stropt0): void = "mac#%"
fun prerr_stropt (opt: Stropt0): void = "mac#%"
fun fprint_stropt (out: FILEref, opt: Stropt0): void = "mac#%"

(* ****** ****** *)
//
// overloading for certain symbols
//
overload
[] with string_get_at_size of 1
overload
[] with string_get_at_gint of 0
overload
[] with string_get_at_guint of 0
//
overload iseqz with string_is_empty
overload isneqz with string_isnot_empty
//
overload .head with string_head
overload .tail with string_tail
//
overload length with string_length
//
overload copy with string0_copy of 0
(*
//
// HX: too much of a surprise!
//
overload copy with string1_copy of 10
*)
//
overload print with print_string of 0
overload prerr with prerr_string of 0
overload fprint with fprint_string of 0
//
overload iseqz with stropt_is_none
overload isneqz with stropt_is_some
//
overload length with stropt_length
//
overload print with print_stropt of 0
overload prerr with prerr_stropt of 0
overload fprint with fprint_stropt of 0
//
(* ****** ****** *)

(* end of [string.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/option_vt.atxt
** Time of generation: Sat Oct 17 15:19:48 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2012 *)

(* ****** ****** *)

sortdef vt0p = viewt@ype

(* ****** ****** *)

#if(0)
//
// HX: these decls are available in [basic_dyn.sats]
//
stadef option_vt = option_vt0ype_bool_vtype
vtypedef Option_vt (a:vt0p) = [b:bool] option_vt (a, b)
//
#endif

(* ****** ****** *)

fun{a:vt0p}
option_vt_some (x: a):<!wrt> option_vt (a, true)
fun{a:vt0p}
option_vt_none ((*void*)):<!wrt> option_vt (a, false)

(* ****** ****** *)

fun{
a:vt0p
} option_vt_make_opt
  {b:bool} (
  b: bool b, x: &opt (INV(a), b) >> a?
) :<!wrt> option_vt (a, b) // endfun

(* ****** ****** *)

fun{}
option_vt_is_some{a:vt0p}
  {b:bool} (opt: !option_vt (INV(a), b)):<> bool (b)
// end of [option_vt_is_some]
fun{}
option_vt_is_none{a:vt0p}
  {b:bool} (opt: !option_vt (INV(a), b)):<> bool (~b)
// end of [option_vt_is_none]

(* ****** ****** *)

fun{a:vt0p}
option_vt_unsome (opt: option_vt (INV(a), true)):<!wrt> a
fun{a:vt0p}
option_vt_unnone (opt: option_vt (INV(a), false)):<!wrt> void

(* ****** ****** *)

fun{a:t0p}
option_vt_free (opt: Option_vt (INV(a))):<!wrt> void

(* ****** ****** *)

fun{a:vt0p}
fprint_option_vt{b:bool}
   (out: FILEref, opt: !option_vt (INV(a), b)): void
overload fprint with fprint_option_vt

(* ****** ****** *)
//
// overloading for certain symbols
//
(* ****** ****** *)

overload iseqz with option_vt_is_none
overload isneqz with option_vt_is_some

(* ****** ****** *)

(* end of [option_vt.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/memory.atxt
** Time of generation: Sat Oct 17 15:19:44 2015
*)

(* ****** ****** *)

typedef bytes (n:int) = @[byte][n]
typedef b0ytes (n:int) = @[byte?][n]

(* ****** ****** *)

viewdef bytes_v (l:addr, n:int) = bytes (n) @ l
viewdef b0ytes_v (l:addr, n:int) = b0ytes (n) @ l

(* ****** ****** *)

praxi
b0ytes2bytes
  {l:addr}{n:int} (&b0ytes(n) >> bytes(n)): void
// end of [b0ytes2bytes]
praxi
b0ytes2bytes_v
  {l:addr}{n:int} (pf: b0ytes_v (l, n)): bytes_v (l, n)
// end of [b0ytes2bytes_v]

(* ****** ****** *)

prfun
bytes_v_split
  {l:addr}
  {n:int}{i:nat | i <= n}
  (pf: bytes_v (l, n)): (bytes_v (l, i), bytes_v (l+i, n-i))
// end of [bytes_v_split]

prfun
bytes_v_split_at
  {l:addr}
  {n:int}{i:nat | i <= n}
  (pf: bytes_v (l, n) | i: size_t (i)): (bytes_v (l, i), bytes_v (l+i, n-i))
// end of [bytes_v_split_at]

(* ****** ****** *)

prfun
bytes_v_unsplit
  {l:addr}{n1,n2:int}
  (pf1: bytes_v (l, n1), pf2: bytes_v (l+n1, n2)): bytes_v (l, n1+n2)
// end of [bytes_v_unsplit]

(* ****** ****** *)
//
// HX-2013-08:
// for memory initialization
//
fun minit_gc (): void = "mac#%"
//
(* ****** ****** *)

fun
mfree_gc
  {l:addr}{n:int}
(
  pfat: b0ytes n @ l
, pfgc: mfree_gc_v (l) | ptr l
) :<!wrt> void = "mac#%"

fun
malloc_gc
  {n:int}
(
  bsz: size_t (n)
) :<!wrt>
  [l:agz]
(
  b0ytes n @ l, mfree_gc_v (l) | ptr l
) = "mac#%" // endfun

(* ****** ****** *)

absview memory$free_v (l:addr)

(* ****** ****** *)

fun{
} memory$free
  {l:addr}{n:int}
(
  pfat: b0ytes n @ l
, pfmf: memory$free_v (l) | ptr l
) :<!wrt> void // end-of-fun

fun{
} memory$alloc
  {n:int}
(
  bsz: size_t (n)
) :<!wrt>
  [l:agz]
(
  b0ytes n @ l, memory$free_v (l) | ptr l
) (* end of [memory$alloc] *)

(* ****** ****** *)

(* end of [memory.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/float.atxt
** Time of generation: Sat Oct 17 15:19:45 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: September, 2011 *)

(* ****** ****** *)

stadef fltknd = float_kind
stadef dblknd = double_kind
stadef ldblknd = ldouble_kind

(* ****** ****** *)

fun{
tk1,tk2:tk
} g0int2float (x: g0int (tk1)):<> g0float (tk2)

fun g0int2float_int_float (x: int):<> float = "mac#%"
fun g0int2float_int_double (x: int):<> double = "mac#%"
fun g0int2float_lint_double (x: lint):<> double = "mac#%"

(* ****** ****** *)

fun{
tk1,tk2:tk
} g0float2int (x: g0float (tk1)):<> g0int (tk2)

fun g0float2int_float_int (x: float):<> int = "mac#%"
fun g0float2int_float_lint (x: float):<> lint = "mac#%"
fun g0float2int_double_int (x: double):<> int = "mac#%"
fun g0float2int_double_lint (x: double):<> lint = "mac#%"
fun g0float2int_double_llint (x: double):<> llint = "mac#%"

(* ****** ****** *)

fun{
tk1,tk2:tk
} g0float2float (x: g0float (tk1)):<> g0float (tk2)

fun g0float2float_float_float (x: float):<> float = "mac#%"
fun g0float2float_float_double (x: float):<> double = "mac#%"
fun g0float2float_double_float (x: double):<> float = "mac#%"
fun g0float2float_double_double (x: double):<> double = "mac#%"

(* ****** ****** *)
//
fun{tk:tk}
g0string2float (str: NSH(string)):<> g0float (tk)
//
fun g0string2float_double (x: NSH(string)):<> double = "mac#%"
//
(* ****** ****** *)
//
typedef
g0float_uop_type
  (tk:tk) = g0float (tk) -<fun0> g0float (tk)
//
(* ****** ****** *)

fun{tk:tk}
g0float_neg : g0float_uop_type (tk)
overload ~ with g0float_neg of 0 // ~ for uminus
overload neg with g0float_neg of 0

fun{tk:tk}
g0float_abs : g0float_uop_type (tk)
overload abs with g0float_abs of 0

(* ****** ****** *)

fun{tk:tk}
g0float_succ : g0float_uop_type (tk)
overload succ with g0float_succ of 0
fun{tk:tk}
g0float_pred : g0float_uop_type (tk)
overload pred with g0float_pred of 0

(* ****** ****** *)

typedef
g0float_aop_type (tk:tk) =
  (g0float (tk), g0float (tk)) -<fun0> g0float (tk)
// end of [g0float_aop_type]

fun
{tk:tk}
g0float_add : g0float_aop_type(tk)
overload + with g0float_add of 0
fun
{tk:tk}
g0float_sub : g0float_aop_type(tk)
overload - with g0float_sub of 0
fun
{tk:tk}
g0float_mul : g0float_aop_type(tk)
overload * with g0float_mul of 0
fun
{tk:tk}
g0float_div : g0float_aop_type(tk)
overload / with g0float_div of 0
fun
{tk:tk}
g0float_mod : g0float_aop_type(tk)
overload % with g0float_mod of 0
overload mod with g0float_mod of 0

(* ****** ****** *)

fun{tk:tk}
g0float_isltz (x: g0float (tk)):<> bool
overload isltz with g0float_isltz of 0
fun{tk:tk}
g0float_isltez (x: g0float (tk)):<> bool
overload isltez with g0float_isltez of 0
fun{tk:tk}
g0float_isgtz (x: g0float (tk)):<> bool
overload isgtz with g0float_isgtz of 0
fun{tk:tk}
g0float_isgtez (x: g0float (tk)):<> bool
overload isgtez with g0float_isgtez of 0
fun{tk:tk}
g0float_iseqz (x: g0float (tk)):<> bool
overload iseqz with g0float_iseqz of 0
fun{tk:tk}
g0float_isneqz (x: g0float (tk)):<> bool
overload isneqz with g0float_isneqz of 0

(* ****** ****** *)

typedef
g0float_cmp_type (tk:tk) =
  (g0float (tk), g0float (tk)) -<fun0> bool
// end of [g0float_cmp_type]

fun
{tk:tk}
g0float_lt : g0float_cmp_type(tk)
overload < with g0float_lt of 0
fun
{tk:tk}
g0float_lte : g0float_cmp_type(tk)
overload <= with g0float_lte of 0
fun
{tk:tk}
g0float_gt : g0float_cmp_type(tk)
overload > with g0float_gt of 0
fun
{tk:tk}
g0float_gte : g0float_cmp_type(tk)
overload >= with g0float_gte of 0
fun
{tk:tk}
g0float_eq : g0float_cmp_type(tk)
overload = with g0float_eq of 0
fun
{tk:tk}
g0float_neq : g0float_cmp_type(tk)
overload != with g0float_neq of 0
overload <> with g0float_neq of 0

(* ****** ****** *)

typedef
g0float_compare_type (tk:tk) =
  (g0float (tk), g0float (tk)) -<fun0> (int)
// end of [g0float_compare_type]

fun{tk:tk}
g0float_compare : g0float_compare_type (tk)
overload compare with g0float_compare of 0

(* ****** ****** *)

fun{tk:tk}
g0float_max : g0float_aop_type (tk)
overload max with g0float_max of 0
fun{tk:tk}
g0float_min : g0float_aop_type (tk)
overload min with g0float_min of 0

(* ****** ****** *)

fun g0float_neg_float
  : g0float_uop_type(fltknd) = "mac#%"
fun g0float_abs_float
  : g0float_uop_type(fltknd) = "mac#%"

fun g0float_succ_float
  : g0float_uop_type(fltknd) = "mac#%"
fun g0float_pred_float
  : g0float_uop_type(fltknd) = "mac#%"

fun g0float_add_float
  : g0float_aop_type(fltknd) = "mac#%"
fun g0float_sub_float
  : g0float_aop_type(fltknd) = "mac#%"
fun g0float_mul_float
  : g0float_aop_type(fltknd) = "mac#%"
fun g0float_div_float
  : g0float_aop_type(fltknd) = "mac#%"
fun g0float_mod_float
  : g0float_aop_type(fltknd) = "mac#%"

fun g0float_lt_float
  : g0float_cmp_type(fltknd) = "mac#%"
fun g0float_lte_float
  : g0float_cmp_type(fltknd) = "mac#%"
fun g0float_gt_float
  : g0float_cmp_type(fltknd) = "mac#%"
fun g0float_gte_float
  : g0float_cmp_type(fltknd) = "mac#%"
fun g0float_eq_float
  : g0float_cmp_type(fltknd) = "mac#%"
fun g0float_neq_float
  : g0float_cmp_type(fltknd) = "mac#%"

fun g0float_compare_float
  : g0float_compare_type(fltknd) = "mac#%"

fun g0float_max_float
  : g0float_aop_type(fltknd) = "mac#%"
fun g0float_min_float
  : g0float_aop_type(fltknd) = "mac#%"

(* ****** ****** *)

fun g0float_neg_double
  : g0float_uop_type(dblknd) = "mac#%"
fun g0float_abs_double
  : g0float_uop_type(dblknd) = "mac#%"

fun g0float_succ_double
  : g0float_uop_type(dblknd) = "mac#%"
fun g0float_pred_double
  : g0float_uop_type(dblknd) = "mac#%"

fun g0float_add_double
  : g0float_aop_type(dblknd) = "mac#%"
fun g0float_sub_double
  : g0float_aop_type(dblknd) = "mac#%"
fun g0float_mul_double
  : g0float_aop_type(dblknd) = "mac#%"
fun g0float_div_double
  : g0float_aop_type(dblknd) = "mac#%"
fun g0float_mod_double
  : g0float_aop_type(dblknd) = "mac#%"

fun g0float_lt_double
  : g0float_cmp_type(dblknd) = "mac#%"
fun g0float_lte_double
  : g0float_cmp_type(dblknd) = "mac#%"
fun g0float_gt_double
  : g0float_cmp_type(dblknd) = "mac#%"
fun g0float_gte_double
  : g0float_cmp_type(dblknd) = "mac#%"
fun g0float_eq_double
  : g0float_cmp_type(dblknd) = "mac#%"
fun g0float_neq_double
  : g0float_cmp_type(dblknd) = "mac#%"

fun g0float_compare_double
  : g0float_compare_type(dblknd) = "mac#%"

fun g0float_max_double
  : g0float_aop_type(dblknd) = "mac#%"
fun g0float_min_double
  : g0float_aop_type(dblknd) = "mac#%"

(* ****** ****** *)

fun g0float_neg_ldouble
  : g0float_uop_type(ldblknd) = "mac#%"
fun g0float_abs_ldouble
  : g0float_uop_type(ldblknd) = "mac#%"

fun g0float_succ_ldouble
  : g0float_uop_type(ldblknd) = "mac#%"
fun g0float_pred_ldouble
  : g0float_uop_type(ldblknd) = "mac#%"

fun g0float_add_ldouble
  : g0float_aop_type(ldblknd) = "mac#%"
fun g0float_sub_ldouble
  : g0float_aop_type(ldblknd) = "mac#%"
fun g0float_mul_ldouble
  : g0float_aop_type(ldblknd) = "mac#%"
fun g0float_div_ldouble
  : g0float_aop_type(ldblknd) = "mac#%"
fun g0float_mod_ldouble
  : g0float_aop_type(ldblknd) = "mac#%"

fun g0float_lt_ldouble
  : g0float_cmp_type(ldblknd) = "mac#%"
fun g0float_lte_ldouble
  : g0float_cmp_type(ldblknd) = "mac#%"
fun g0float_gt_ldouble
  : g0float_cmp_type(ldblknd) = "mac#%"
fun g0float_gte_ldouble
  : g0float_cmp_type(ldblknd) = "mac#%"
fun g0float_eq_ldouble
  : g0float_cmp_type(ldblknd) = "mac#%"
fun g0float_neq_ldouble
  : g0float_cmp_type(ldblknd) = "mac#%"

fun g0float_compare_ldouble
  : g0float_compare_type(ldblknd) = "mac#%"

fun g0float_max_ldouble
  : g0float_aop_type(ldblknd) = "mac#%"
fun g0float_min_ldouble
  : g0float_aop_type(ldblknd) = "mac#%"

(* ****** ****** *)
//
fun fprint_float
  : fprint_type (float) = "mac#%"
overload fprint with fprint_float
fun print_float (x: float): void = "mac#%"
fun prerr_float (x: float): void = "mac#%"
overload print with print_float
overload prerr with prerr_float
//
fun fprint_double
  : fprint_type (double) = "mac#%"
overload fprint with fprint_double
fun print_double (x: double): void = "mac#%"
fun prerr_double (x: double): void = "mac#%"
overload print with print_double
overload prerr with prerr_double
//
fun fprint_ldouble
  : fprint_type (ldouble) = "mac#%"
overload fprint with fprint_ldouble
fun print_ldouble (x: ldouble): void = "mac#%"
fun prerr_ldouble (x: ldouble): void = "mac#%"
overload print with print_ldouble
overload prerr with prerr_ldouble
//
(* ****** ****** *)
//
fun
add_int_float
  (x: int, y: float): float = "mac#%"
fun
add_float_int
  (x: float, y: int): float = "mac#%"
overload + with add_int_float of 0
overload + with add_float_int of 0
//
fun
add_int_double
  (x: int, y: double): double = "mac#%"
fun
add_double_int
  (x: double, y: int): double = "mac#%"
overload + with add_int_double of 0
overload + with add_double_int of 0
//
(* ****** ****** *)
//
fun
sub_int_float
  (x: int, y: float): float = "mac#%"
fun
sub_float_int
  (x: float, y: int): float = "mac#%"
overload - with sub_int_float of 0
overload - with sub_float_int of 0
//
fun
sub_int_double
  (x: int, y: double): double = "mac#%"
fun
sub_double_int
  (x: double, y: int): double = "mac#%"
overload - with sub_int_double of 0
overload - with sub_double_int of 0
//
(* ****** ****** *)
//
fun
mul_int_float
  (x: int, y: float): float = "mac#%"
fun
mul_float_int
  (x: float, y: int): float = "mac#%"
overload * with mul_int_float of 0
overload * with mul_float_int of 0
//
fun
mul_int_double
  (x: int, y: double): double = "mac#%"
fun
mul_double_int
  (x: double, y: int): double = "mac#%"
overload * with mul_int_double of 0
overload * with mul_double_int of 0
//
(* ****** ****** *)
//
fun
div_int_float
  (x: int, y: float): float = "mac#%"
fun
div_float_int
  (x: float, y: int): float = "mac#%"
overload / with div_int_float of 0
overload / with div_float_int of 0
//
fun
div_int_double
  (x: int, y: double): double = "mac#%"
fun
div_double_int
  (x: double, y: int): double = "mac#%"
overload / with div_int_double of 0
overload / with div_double_int of 0
//
(* ****** ****** *)
//
fun
{tk:tk}
g0float_npow
  (x: g0float(tk), n: intGte(0)): g0float(tk)
//
overload ** with g0float_npow of 0
//
(* ****** ****** *)

macdef g0i2f (x) = g0int2float (,(x))
macdef g0f2i (x) = g0float2int (,(x))
macdef g0f2f (x) = g0float2float (,(x))

(* ****** ****** *)

(* end of [float.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/stream.atxt
** Time of generation: Sun Oct 18 14:27:08 2015
*)

(* ****** ****** *)

sortdef t0p = t@ype

(* ****** ****** *)
//
// HX: lazy streams
//
datatype
stream_con (a:t@ype+) =
  | stream_nil of ((*void*)) | stream_cons of (a, stream(a))
where stream (a:t@ype) = lazy (stream_con(a))
//
(* ****** ****** *)
//
exception StreamSubscriptExn of ((*void*))
//
(*
fun StreamSubscriptExn ():<> exn = "mac#StreamSubscriptExn_make"
fun isStreamSubscriptExn (x: !exn):<> bool = "mac#isStreamSubscriptExn"
*)
//
(* ****** ****** *)
//
fun{a:t0p}
stream_sing(x: a):<> stream_con(a)
//
(* ****** ****** *)

fun{a:t0p}
stream2list
  (xs: stream(INV(a))):<!laz> List0_vt(a)
// end of [stream2list]

(* ****** ****** *)

fun{a:t0p}
stream_nth_exn
  (xs: stream(INV(a)), n: intGte(0)):<!laz> (a)
// end of [stream_nth_exn]
fun{a:t0p}
stream_nth_opt
  (xs: stream(INV(a)), n: intGte(0)):<!laz> Option_vt(a)
// end of [stream_nth_opt]

(* ****** ****** *)

fun{a:t0p}
stream_take_exn{n:nat}
  (xs: stream(INV(a)), n: int n):<!laz> list_vt(a, n)
// end of [stream_take_lte]

(* ****** ****** *)

fun{a:t0p}
stream_drop_exn
  (xs: stream(INV(a)), n: intGte(0)):<!laz> stream(a)
// end of [stream_drop_exn]

(* ****** ****** *)
//
fun{a:t0p}
stream_append
  (xs: stream(INV(a)), ys: stream(a)):<!laz> stream(a)
//
fun{a:t0p}
stream_concat(xss: stream(stream(INV(a)))):<!laz> stream(a)
//
(* ****** ****** *)
//
fun{a:t0p}
stream_filter
  (xs: stream(INV(a))):<!laz> stream(a)
//
fun{a:t0p} stream_filter$pred (x: a):<> bool
//
fun{a:t0p}
stream_filter_fun
(
  xs: stream(INV(a)), pred: (a) -<fun> bool
) :<!laz> stream(a) // end-of-function
fun{a:t0p}
stream_filter_cloref
(
  xs: stream(INV(a)), pred: (a) -<cloref> bool
) :<!laz> stream(a) // end-of-function
//
(* ****** ****** *)

fun{
a:t0p}{b:t0p
} stream_map
  (xs: stream(INV(a))):<!laz> stream(b)
fun{
a:t0p}{b:t0p
} stream_map$fopr (x: a):<(*none*)> (b)
//
fun{
a:t0p}{b:t0p
} stream_map_fun
  (xs: stream(INV(a)), f: (a) -<fun> b):<!laz> stream(b)
fun{
a:t0p}{b:t0p
} stream_map_cloref
  (xs: stream(INV(a)), f: (a) -<cloref> b):<!laz> stream(b)
//
(* ****** ****** *)
//
fun{
a:t0p}{b:t0p
} stream_imap{n:int}
  (xs: stream(INV(a))):<!laz> stream(b)
//
fun{
a:t0p}{b:t0p
} stream_imap$fopr (i: intGte(0), x: a):<> (b)
//
fun{
a:t0p}{b:t0p
} stream_imap_fun
(
  xs: stream(INV(a)), f: (intGte(0), a) -<fun> b
) :<!laz> stream(b) // end-of-fun
fun{
a:t0p}{b:t0p
} stream_imap_cloref
(
  xs: stream(INV(a)), f: (intGte(0), a) -<cloref> b
) :<!laz> stream(b) // end-of-fun
//
(* ****** ****** *)
//
fun{
a1,a2:t0p}{b:t0p
} stream_map2
(
  xs1: stream(INV(a1))
, xs2: stream(INV(a2))
) :<!laz> stream(b) // end-of-fun
fun{
a1,a2:t0p}{b:t0p
} stream_map2$fopr (x1: a1, x2: a2):<> b
//
fun{
a1,a2:t0p}{b:t0p
} stream_map2_fun
(
  xs1: stream(INV(a1))
, xs2: stream(INV(a2)), f: (a1, a2) -<fun> b
) :<!laz> stream(b) // end-of-fun
fun{
a1,a2:t0p}{b:t0p
} stream_map2_cloref
(
  xs1: stream(INV(a1))
, xs2: stream(INV(a2)), f: (a1, a2) -<cloref> b
) :<!laz> stream(b) // end-of-fun
//
(* ****** ****** *)

//
fun{
res:t0p}{x:t0p
} stream_scan
  (stream(INV(x)), ini: res):<!laz> stream(res)
//
fun{
res:t0p}{x:t0p
} stream_scan$fopr(res: res, x: x):<(*none*)> res
//
fun{
res:t0p}{x:t0p
} stream_scan_fun
(
  stream(INV(x)), ini: res, (res, x) -<fun> res
) :<!laz> stream(res) // end-of-function
//
fun{
res:t0p}{x:t0p
} stream_scan_cloref
(
  stream(INV(x)), ini: res, (res, x) -<cloref> res
) :<!laz> stream(res) // end-of-function
//
(* ****** ****** *)
//
fun{a:t0p}
stream_merge
  (stream(INV(a)), stream(a)) :<!laz> stream(a)
//
fun{a:t0p} stream_merge$cmp (x1: a, x2: a):<> int
//
fun{a:t0p}
stream_merge_fun
(
  xs1: stream(INV(a)), xs2: stream(a), (a, a) -<fun> int
) :<!laz> stream(a) // end of [stream_merge_fun]
fun{a:t0p}
stream_merge_cloref
(
  xs1: stream(INV(a)), xs2: stream(a), (a, a) -<cloref> int
) :<!laz> stream(a) // end of [stream_merge_cloref]

(* ****** ****** *)
//
fun{a:t0p}
stream_mergeq
  (stream(INV(a)), stream(a)):<!laz> stream(a)
//
fun{a:t0p} stream_mergeq$cmp (x1: a, x2: a):<> int
//
fun{a:t0p}
stream_mergeq_fun
(
  xs1: stream(INV(a)), xs2: stream(a), (a, a) -<fun> int
) :<!laz> stream(a) // end of [stream_mergeq_fun]
fun{a:t0p}
stream_mergeq_cloref
(
  xs1: stream(INV(a)), xs2: stream(a), (a, a) -<cloref> int
) :<!laz> stream(a) // end of [stream_mergeq_cloref]
//
(* ****** ****** *)
//
fun{
a:t0p
} stream_tabulate (): stream(a)
fun{
a:t0p
} stream_tabulate$fopr (i: intGte(0)): (a)
//
fun{
a:t0p
} stream_tabulate_fun (f: intGte(0) -> a): stream(a)
fun{
a:t0p
} stream_tabulate_cloref (f: intGte(0) -> a): stream(a)
//
(* ****** ****** *)
//
fun{a:t0p}
stream_foreach (xs: stream(a)): void
fun{
a:t0p}{env:vt0p
} stream_foreach_env (xs: stream(a), &env >> _): void
//
fun{
a:t0p}{env:vt0p
} stream_foreach$cont (x: a, env: &env): bool
fun{
a:t0p}{env:vt0p
} stream_foreach$fwork (x: a, env: &env): void
//
(* ****** ****** *)
//
fun{}
fprint_stream$sep (out: FILEref): void
fun{a:t0p}
fprint_stream
  (out: FILEref, xs: stream(INV(a)), n: int): void
//
(* ****** ****** *)
//
// overloading for certain symbols
//
(* ****** ****** *)

overload [] with stream_nth_exn

(* ****** ****** *)

(* end of [stream.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/fcontainer.atxt
** Time of generation: Sat Oct 17 15:19:50 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2012 *)

(* ****** ****** *)

(*
**
** HX-2012-02:
**
** The basic idea is to implement "everything" else in terms of
** "foreach" so that they become available for a container-type
** whenever "foreach" is made available for that type,
**
*)

(* ****** ****** *)

sortdef t0p = t@ype and vt0p = viewt@ype

(* ****** ****** *)

fun{x:t0p} foreach$fwork (x: x): void
fun{xs:t0p}{x:t0p} foreach (xs: xs): void

fun{
xs:t0p}{x:t0p
} foreach_funenv
  {v:view}{vt:viewtype}{fe:eff} (
  pfv: !v | xs: xs, f: (!v | x, !vt) -<fun,fe> void, env: !vt
) :<fe> void // end of [foreach_funenv]

fun{
xs:t0p}{x:t0p
} foreach_fun {fe:eff}
  (xs: xs, f: (x) -<fun,fe> void):<fe> void
// end of [foreach_fun]

fun{
xs:t0p}{x:t0p
} foreach_clo {fe:eff}
  (xs: xs, f: &(x) -<clo,fe> void):<fe> void
// end of [foreach_clo]
fun{
xs:t0p}{x:t0p
} foreach_vclo
  {v:view}{fe:eff}
  (pfv: !v | xs: xs, f: &(!v | x) -<clo,fe> void):<fe> void
// end of [foreach_vclo]

fun{
xs:t0p}{x:t0p
} foreach_cloptr {fe:eff}
  (xs: xs, f: !(x) -<cloptr,fe> void):<fe> void
fun{
xs:t0p}{x:t0p
} foreach_vcloptr
  {v:view}{fe:eff}
  (pfv: !v | xs: xs, f: !(!v | x) -<cloptr,fe> void):<fe> void
// end of [foreach_vcloptr]

fun{
xs:t0p}{x:t0p
} foreach_cloref {fe:eff}
  (xs: xs, f: (x) -<cloref,fe> void):<fe> void
// end of [foreach_cloref]

(* ****** ****** *)

fun{x:t0p}
iforeach$fwork (i: size_t, x: x): void
fun{xs:t0p}{x:t0p} iforeach (xs: xs): void

fun{
xs:t0p}{x:t0p
} iforeach_funenv
  {v:view}{vt:viewtype}{fe:eff} (
  pfv: !v | xs: xs, f: (!v | int, x, !vt) -<fun,fe> void, env: !vt
) :<fe> int // end of [iforeach_funenv]

fun{
xs:t0p}{x:t0p
} iforeach_clo {fe:eff}
  (xs: xs, f: &(int, x) -<clo,fe> void):<fe> int
// end of [iforeach_clo]
fun{
xs:t0p}{x:t0p
} iforeach_vclo
  {v:view}{fe:eff}
  (pfv: !v | xs: xs, f: &(!v | int, x) -<clo,fe> void):<fe> int
// end of [iforeach_vclo]

fun{
xs:t0p}{x:t0p
} iforeach_cloptr {fe:eff}
  (xs: xs, f: !(int, x) -<cloptr,fe> void):<fe> int
fun{
xs:t0p}{x:t0p
} iforeach_vcloptr
  {v:view}{fe:eff}
  (pfv: !v | xs: xs, f: !(!v | int, x) -<cloptr,fe> void):<fe> int
// end of [iforeach_vcloptr]

fun{
xs:t0p}{x:t0p
} iforeach_cloref {fe:eff}
  (xs: xs, f: (int, x) -<cloref,fe> void):<fe> int
// end of [iforeach_cloref]

(* ****** ****** *)

fun{
x:t0p}{res:vt0p
} foldleft$fwork
  (res: res, x: x): res
fun{
xs:t0p}{x:t0p}{res:vt0p
} foldleft (xs: xs, ini: res): res

fun{
xs:t0p}{x:t0p}{res:vt0p
} foldleft_funenv
  {v:view}{vt:viewtype}{fe:eff} (
  pfv: !v
| xs: xs, ini: res
, f: (!v | res, x, !vt) -<fun,fe> res, env: !vt
) :<fe> res // end of [foldleft_funenv]

fun{
xs:t0p}{x:t0p}{res:vt0p
} foldleft_clo {fe:eff} (
  xs: xs, ini: res, f: &(res, x) -<clo,fe> res
) :<fe> res // end of [foldleft_clo]
fun{
xs:t0p}{x:t0p}{res:vt0p
} foldleft_vclo {v:view}{fe:eff} (
  pfv: !v
| xs: xs, ini: res, f: &(!v | res, x) -<clo,fe> res
) :<fe> res // end of [foldleft_vclo]

fun{
xs:t0p}{x:t0p}{res:vt0p
} foldleft_cloref {fe:eff} (
  xs: xs, ini: res, f: &(res, x) -<cloref,fe> res
) :<fe> res // end of [foldleft_cloref]

(* ****** ****** *)

fun{
x:t0p}{res:vt0p
} foldright$fwork
  (x: x, res: res): res
fun{
xs:t0p}{x:t0p}{res:vt0p
} foldright (xs: xs, snk: res): res

fun{
xs:t0p}{x:t0p}{res:vt0p
} foldright_funenv
  {v:view}{vt:viewtype}{fe:eff} (
  pfv: !v
| xs: xs, f: (!v | x, res, !vt) -<fun,fe> res, snk: res, env: !vt
) :<fe> res // end of [foldright_funenv]

fun{
xs:t0p}{x:t0p}{res:vt0p
} foldright_clo {fe:eff} (
  xs: xs, f: &(x, res) -<clo,fe> res, snk: res
) :<fe> res // end of [foldright_clo]
fun{
xs:t0p}{x:t0p}{res:vt0p
} foldright_vclo {v:view}{fe:eff} (
  pfv: !v
| xs: xs, f: &(!v | x, res) -<clo,fe> res, snk: res
) :<fe> res // end of [foldright_vclo]

fun{
xs:t0p}{x:t0p}{res:vt0p
} foldright_cloref {fe:eff} (
  xs: xs, f: (x, res) -<cloref,fe> res, snk: res
) :<fe> res // end of [foldright_cloref]

(* ****** ****** *)

fun{x:t0p} exists$pred (x: x): bool
fun{xs:t0p}{x:t0p} exists (xs: xs): bool

fun{
xs:t0p}{x:t0p
} exists_funenv
  {v:view}{vt:viewtype}{pe:eff} (
  pf: !v | xs: xs, p: (!v | x, !vt) -<fun,pe> bool, env: !vt
) :<pe> bool // end of [exists_funenv]

fun{
xs:t0p}{x:t0p
} exists_clo {fe:eff}
  (xs: xs, f: &(x) -<clo,fe> void):<fe> bool
// end of [exists_clo]
fun{
xs:t0p}{x:t0p
} exists_vclo
  {v:view}{fe:eff}
  (pfv: !v | xs: xs, f: &(!v | x) -<clo,fe> void):<fe> bool
// end of [exists_vclo]

(* ****** ****** *)

fun{x:t0p} forall$pred (x: x): bool
fun{xs:t0p}{x:t0p} forall (xs: xs): bool

fun{
xs:t0p}{x:t0p
} forall_funenv
  {v:view}{vt:viewtype}{pe:eff} (
  pf: !v | xs: xs, p: (!v | x, !vt) -<fun,pe> bool, env: !vt
) :<pe> bool // end of [forall_funenv]

(* ****** ****** *)

fun{
xs:t0p}{x:t0p
} ismember_fun {fe:eff}
  (xs: xs, x0: x, eq: (x, x) -<fun,fe> void):<fe> bool
// end of [ismember_fun]

(* ****** ****** *)

fun{
xs:t0p}{x:t0p
} listize (xs: xs):<> List0_vt (x)
fun{
xs:t0p}{x:t0p}{y:vt0p
} listize_funenv
  {v:view}{vt:viewtype}{fe:eff} (
  pfv: !v | xs: xs, f: (!v | x, !vt) -<fun,fe> y, env: !vt
) :<fe> List0_vt (y)

(* ****** ****** *)

fun{
xs:t0p}{x:t0p
} rlistize (xs: xs):<> List0_vt (x)
fun{
xs:t0p}{x:t0p}{y:vt0p
} rlistize_funenv
  {v:view}{vt:viewtype}{fe:eff} (
  pfv: !v | xs: xs, f: (!v | x, !vt) -<fun,fe> y, env: !vt
) :<fe> List0_vt (y)

(* ****** ****** *)

fun{
xs:t0p}{x:t0p
} streamize (xs: xs):<> stream (x)
fun{
xs:t0p}{x:t0p
} streamize_vt (xs: xs):<> stream_vt (x)

(* ****** ****** *)

(* end of [fcontainer.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/pointer.atxt
** Time of generation: Sat Oct 17 15:19:44 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2012 *)

(* ****** ****** *)

sortdef tk = tkind

(* ****** ****** *)
//
sortdef
t0p = t@ype and vt0p = viewt@ype
//
(* ****** ****** *)

stadef ptrknd = ptr_kind

(* ****** ****** *)

absprop is_word_aligned_p (l:addr)

(* ****** ****** *)
//
castfn
g0ofg1_ptr (p: Ptr):<> ptr
castfn
g1ofg0_ptr (p: ptr):<> Ptr0
//
overload g0ofg1 with g0ofg1_ptr
overload g1ofg0 with g1ofg0_ptr
//
(* ****** ****** *)
//
prfun
lemma_ptr_param
  {l:addr} (p: ptr l): [l >= null] void
//
(* ****** ****** *)

prfun
ptr_get_index
  {l1:addr} (p: ptr l1): [l2:addr] EQADDR(l1, l2)
// end of [ptr_get_index]

(* ****** ****** *)
//
symintr ptr_is_null
symintr ptr_isnot_null
//
(* ****** ****** *)
//
symintr add_ptr_bsz
symintr sub_ptr_bsz
//
// add_ptr_bsz (p, ofs) = p + ofs
// sub_ptr_bsz (p, ofs) = p - ofs
//
(* ****** ****** *)
//
symintr ptr_succ
symintr ptr_pred
//
// ptr_succ<a>(p) = p + sizeof<a>
// ptr_pred<a>(p) = p - sizeof<a>
//
(* ****** ****** *)
//
symintr ptr_add ptr_sub
//
// ptr_add<a> (p, ofs) = p + ofs*sizeof<a>
// ptr_sub<a> (p, ofs) = p - ofs*sizeof<a>
//
(* ****** ****** *)

fun ptr0_is_null (p: ptr):<> bool = "mac#%"
overload ptr_is_null with ptr0_is_null of 0
fun ptr0_isnot_null (p: ptr):<> bool = "mac#%"
overload ptr_isnot_null with ptr0_isnot_null of 0

(* ****** ****** *)
//
fun add_ptr0_bsz
  (p: ptr, ofs: size_t):<> ptr = "mac#%"
fun sub_ptr0_bsz
  (p: ptr, ofs: size_t):<> ptr = "mac#%"
//
overload add_ptr_bsz with add_ptr0_bsz of 0
overload sub_ptr_bsz with sub_ptr0_bsz of 0
//
(* ****** ****** *)

fun sub_ptr0_ptr0
  (p1: ptr, p2: ptr):<> ssize_t = "mac#%"
overload - with sub_ptr0_ptr0 of 0

(* ****** ****** *)
//
fun{a:vt0p} ptr0_succ (p: ptr):<> ptr
fun{a:vt0p} ptr0_pred (p: ptr):<> ptr
//
overload ptr_succ with ptr0_succ of 0
overload ptr_pred with ptr0_pred of 0
//
(* ****** ****** *)
//
fun{
a:vt0p}{tk:tk
} ptr0_add_gint (p: ptr, ofs: g0int (tk)):<> ptr
fun{
a:vt0p}{tk:tk
} ptr0_add_guint (p: ptr, ofs: g0uint (tk)):<> ptr
//
overload ptr_add with ptr0_add_gint of 0
overload ptr_add with ptr0_add_guint of 0
//
fun{
a:vt0p}{tk:tk
} ptr0_sub_gint (p: ptr, ofs: g0int (tk)):<> ptr
fun{
a:vt0p}{tk:tk
} ptr0_sub_guint (p: ptr, ofs: g0uint (tk)):<> ptr
//
overload ptr_sub with ptr0_sub_gint of 0
overload ptr_sub with ptr0_sub_guint of 0
//
(* ****** ****** *)

fun lt_ptr0_ptr0
  (p1: ptr, p2: ptr):<> bool = "mac#%"
overload < with lt_ptr0_ptr0 of 0
fun lte_ptr0_ptr0
  (p1: ptr, p2: ptr):<> bool = "mac#%"
overload <= with lte_ptr0_ptr0 of 0
fun gt_ptr0_ptr0
  (p1: ptr, p2: ptr):<> bool = "mac#%"
overload > with gt_ptr0_ptr0 of 0
fun gte_ptr0_ptr0
  (p1: ptr, p2: ptr):<> bool = "mac#%"
overload >= with gte_ptr0_ptr0 of 0
fun eq_ptr0_ptr0
  (p1: ptr, p2: ptr):<> bool = "mac#%"
overload = with eq_ptr0_ptr0 of 0
fun neq_ptr0_ptr0
  (p1: ptr, p2: ptr):<> bool = "mac#%"
overload != with neq_ptr0_ptr0 of 0
overload <> with neq_ptr0_ptr0 of 0

fun compare_ptr0_ptr0
  (p1: ptr, p2: ptr):<> int = "mac#%"
overload compare with compare_ptr0_ptr0 of 0

(* ****** ****** *)

fun gt_ptr0_intz
  (p: ptr, i: int(0)):<> bool = "mac#%"
overload > with gt_ptr0_intz of 0
fun eq_ptr0_intz
  (p: ptr, i: int(0)):<> bool = "mac#%"
overload = with eq_ptr0_intz of 0
fun neq_ptr0_intz
  (p: ptr, i: int(0)):<> bool = "mac#%"
overload != with neq_ptr0_intz of 0
overload <> with neq_ptr0_intz of 0

(* ****** ****** *)

(*
fun{a:vt0p}
ptr0_add_int (p: ptr, i: int): ptr
fun{a:vt0p}
ptr0_add_lint (p: ptr, i: lint): ptr
fun{a:vt0p}
ptr0_add_ssize (p: ptr, i: ssize): ptr
fun{a:vt0p}
ptr0_add_uint (p: ptr, u: uint): ptr
fun{a:vt0p}
ptr0_add_ulint (p: ptr, u: ulint): ptr
fun{a:vt0p}
ptr0_add_size (p: ptr, u: size): ptr
*)

(*
fun{a:vt0p}
ptr0_sub_int (p: ptr, i: int): ptr
fun{a:vt0p}
ptr0_sub_lint (p: ptr, i: lint): ptr
fun{a:vt0p}
ptr0_sub_ssize (p: ptr, i: ssize): ptr
fun{a:vt0p}
ptr0_sub_uint (p: ptr, u: uint): ptr
fun{a:vt0p}
ptr0_sub_ulint (p: ptr, u: ulint): ptr
fun{a:vt0p}
ptr0_sub_size (p: ptr, u: size): ptr
*)

(* ****** ****** *)
//
fun
print_ptr (p: ptr): void = "mac#%"
fun
prerr_ptr (p: ptr): void = "mac#%"
fun
fprint_ptr : fprint_type (ptr) = "mac#%"
//
overload print with print_ptr
overload prerr with prerr_ptr
overload fprint with fprint_ptr
//
(* ****** ****** *)
//
praxi
ptr1_is_gtez
  {l:addr}(p: ptr l): [l >= null] void
//
(* ****** ****** *)
//
fun
ptr1_is_null
  {l:addr}(p: ptr l):<> bool (l==null) = "mac#%"
fun
ptr1_isnot_null
  {l:addr}(p: ptr l):<> bool (l > null) = "mac#%"
//
overload ptr_is_null with ptr1_is_null of 10
overload ptr_isnot_null with ptr1_isnot_null of 10
//
(* ****** ****** *)
//
fun
add_ptr1_bsz{l:addr}{i:int}
  (p: ptr l, ofs: size_t (i)):<> ptr (l+i) = "mac#%"
fun
sub_ptr1_bsz{l:addr}{i:int}
  (p: ptr l, ofs: size_t (i)):<> ptr (l-i) = "mac#%"
//
overload add_ptr_bsz with add_ptr1_bsz of 20
overload sub_ptr_bsz with sub_ptr1_bsz of 20
//
(* ****** ****** *)
//
fun
sub_ptr1_ptr1{l1,l2:addr}
  (p1: ptr l1, p2: ptr l2):<> ssize_t (l1-l2) = "mac#%"
//
overload - with sub_ptr1_ptr1 of 20
//
(* ****** ****** *)
//
fun{
a:vt0p
} ptr1_succ{l:addr} (p: ptr l):<> ptr (l+sizeof(a))
fun{
a:vt0p
} ptr1_pred{l:addr} (p: ptr l):<> ptr (l-sizeof(a))
//
overload ptr_succ with ptr1_succ of 10
overload ptr_pred with ptr1_pred of 10
//
(* ****** ****** *)
//
fun{
a:vt0p}{tk:tk
} ptr1_add_gint
  {l:addr}{i:int}
  (p: ptr l, ofs: g1int (tk, i)):<> ptr(l+i*sizeof(a))
fun{
a:vt0p}{tk:tk
} ptr1_add_guint
  {l:addr}{i:int}
  (p: ptr l, ofs: g1uint (tk, i)):<> ptr(l+i*sizeof(a))
//
overload ptr_add with ptr1_add_gint of 20
overload ptr_add with ptr1_add_guint of 20
//
(* ****** ****** *)
//
fun{
a:vt0p}{tk:tk
} ptr1_sub_gint
  {l:addr}{i:int}
  (p: ptr l, ofs: g1int (tk, i)):<> ptr(l-i*sizeof(a))
fun{
a:vt0p}{tk:tk
} ptr1_sub_guint
  {l:addr}{i:int}
  (p: ptr l, ofs: g1uint (tk, i)):<> ptr(l-i*sizeof(a))
//
overload ptr_sub with ptr1_sub_gint of 20
overload ptr_sub with ptr1_sub_guint of 20
//
(* ****** ****** *)

fun lt_ptr1_ptr1
  {l1,l2:addr} (
  p1: ptr (l1), p2: ptr (l2)
) :<> bool (l1 < l2) = "mac#%"
overload < with lt_ptr1_ptr1 of 20
fun lte_ptr1_ptr1
  {l1,l2:addr} (
  p1: ptr (l1), p2: ptr (l2)
) :<> bool (l1 <= l2) = "mac#%"
overload <= with lte_ptr1_ptr1 of 20
fun gt_ptr1_ptr1
  {l1,l2:addr} (
  p1: ptr (l1), p2: ptr (l2)
) :<> bool (l1 > l2) = "mac#%"
overload > with gt_ptr1_ptr1 of 20
fun gte_ptr1_ptr1
  {l1,l2:addr} (
  p1: ptr (l1), p2: ptr (l2)
) :<> bool (l1 >= l2) = "mac#%"
overload >= with gte_ptr1_ptr1 of 20
fun eq_ptr1_ptr1
  {l1,l2:addr} (
  p1: ptr (l1), p2: ptr (l2)
) :<> bool (l1 == l2) = "mac#%"
overload = with eq_ptr1_ptr1 of 20
fun neq_ptr1_ptr1
  {l1,l2:addr} (
  p1: ptr (l1), p2: ptr (l2)
) :<> bool (l1 != l2) = "mac#%"
overload != with neq_ptr1_ptr1 of 20
overload <> with neq_ptr1_ptr1 of 20

fun compare_ptr1_ptr1
  {l1,l2:addr} (p1: ptr l1, p2: ptr l2) :<> int = "mac#%"
overload compare with compare_ptr1_ptr1 of 20

(* ****** ****** *)

fun gt_ptr1_intz {l:addr}
  (p: ptr l, i: int(0)):<> bool(l > null) = "mac#%"
overload > with gt_ptr1_intz of 10
fun eq_ptr1_intz {l:addr}
  (p: ptr l, i: int(0)):<> bool(l == null) = "mac#%"
overload = with eq_ptr1_intz of 10
fun neq_ptr1_intz {l:addr}
  (p: ptr l, i: int(0)):<> bool(l > null) = "mac#%"
overload != with neq_ptr1_intz of 10
overload <> with neq_ptr1_intz of 10

(* ****** ****** *)
//
// HX: implemented in [prelude/DATS/pointer.dats]
//
fun{a:vt0p}
ptr_get{l:addr}
  (pf: !INV(a) @ l >> a?! @ l | p: ptr l):<> a
// end of [ptr_get]

fun{a:vt0p}
ptr_set{l:addr}
  (pf: !a? @ l >> a @ l | p: ptr l, x: INV(a)):<!wrt> void
// end of [ptr_set]

fun{a:vt0p}
ptr_exch{l:addr}
  (pf: !INV(a) @ l | p: ptr l, x: &a >> a):<!wrt> void
// end of [ptr_exch]

(* ****** ****** *)
//
abstype
cptr_vt0ype_addr_type
  (a:vt@ype+, addr) = ptr // HX: for simulating C pointers
//
stadef cptr = cptr_vt0ype_addr_type
stadef cPtr0 (a:vt0p) = [l:addr] cptr (a, l)
stadef cPtr1 (a:vt0p) = [l:addr | l > null] cptr (a, l)
//
castfn
cptr2ptr{a:vt0p}{l:addr} (p: cptr (a, l)):<> ptr (l)
//
(* ****** ****** *)
//
fun cptr_null{a:vt0p} ():<> cptr (a, null) = "mac#%"
//
castfn cptr_rvar{a:vt0p} (x: &INV(a)):<> cPtr1 (a) // read
castfn cptr_wvar{a:vt0p} (x: &a? >> a):<> cPtr1 (a) // write
//
(* ****** ****** *)
//
fun cptr_succ
  {a:vt0p}{l:addr} (p: cptr (a, l)):<> cptr (a, l+sizeof(a))
fun cptr_pred
  {a:vt0p}{l:addr} (p: cptr (a, l)):<> cptr (a, l-sizeof(a))
//
(* ****** ****** *)
//
fun cptr_is_null
  {a:vt0p}{l:addr} (p: cptr (a, l)):<> bool (l==null) = "mac#%"
fun cptr_isnot_null
  {a:vt0p}{l:addr} (p: cptr (a, l)):<> bool (l > null) = "mac#%"
//
(* ****** ****** *)

typedef voidptr (l:addr) = cptr (void, l)
typedef voidptr0 = [l:addr] voidptr (l)
typedef voidptr1 = [l:addr | l > null] voidptr (l)

typedef charptr (l:addr) = cptr (char, l)
typedef charptr0 = [l:addr] charptr (l)
typedef charptr1 = [l:addr | l > null] charptr (l)

typedef constcharptr (l:addr) = charptr (l) // HX: commenting
typedef constcharptr0 = charptr0 // HX: for commenting purpose
typedef constcharptr1 = charptr1 // HX: for commenting purpose

(* ****** ****** *)
//
absprop
is_nullable (a: vt@ype+) // covariant
//
fun{a:vt0p}
ptr_nullize
  (pf: is_nullable (a) | x: &a? >> a):<!wrt> void
fun
ptr_nullize_tsz
  {a:vt0p} (
  pf: is_nullable (a) | x: &a? >> a, tsz: sizeof_t (a)
) :<!wrt> void = "mac#%" // end of [ptr_nullize_tsz]
//
(* ****** ****** *)

fun{
a:vt0p
} ptr_alloc ()
  :<> [l:agz] (a? @ l, mfree_gc_v (l) | ptr l)
// end of [ptr_alloc]

fun ptr_alloc_tsz
  {a:vt0p} (tsz: sizeof_t a)
  :<> [l:agz] (a? @ l, mfree_gc_v (l) | ptr l) = "mac#%"
// end of [ptr_alloc_tsz]

fun ptr_free
  {a:t@ype}{l:addr}
  (pfgc: mfree_gc_v (l), pfat: a @ l | p: ptr l):<> void = "mac#%"
// end of [ptr_free]

(* ****** ****** *)
//
absvtype ptrlin (l:addr) = ptr
//
praxi ptrlin_free{l:addr} (p: ptrlin (l)): void
//
castfn ptr2ptrlin{l:addr} (p: ptr l):<> ptrlin (l)
castfn ptrlin2ptr{l:addr} (p: ptrlin l):<> ptr (l)
//
(* ****** ****** *)
//
// HX-2015-03-24:
// singleton linear arrayptr
//
absvtype
aptr_vt0ype_addr_type
  (a:vt@ype+, addr) = ptr // HX: for safe ATS pointers
//
stadef aptr = aptr_vt0ype_addr_type
stadef aPtr0 (a:vt0p) = [l:addr] aptr (a, l)
stadef aPtr1 (a:vt0p) = [l:addr | l > null] aptr (a, l)
//
castfn
aptr2ptr{a:vt0p}{l:addr} (ap: !aptr (a, l)):<> ptr (l)
//
(* ****** ****** *)
//
fun
{a:vt0p}
aptr_make_elt(x: a):<!wrt> aPtr1(a)
fun
{a:vt0p}
aptr_getfree_elt{l:agz}(aptr(a, l)):<!wrt> (a)
//
fun
{a:t0p}
aptr_get_elt{l:agz}(ap: !aptr(INV(a), l)):<!wrt> a
fun
{a:t0p}
aptr_set_elt{l:agz}(ap: !aptr(INV(a), l) >> _, x: a):<!wrt> void
fun
{a:t0p}
aptr_exch_elt{l:agz}(ap: !aptr(INV(a), l) >> _, x: &(a)>>_):<!wrt> void
//
overload [] with aptr_get_elt
overload [] with aptr_set_elt
//
(* ****** ****** *)
//
// HX-2014-05-16:
// A hack to stop buggy compilation
//
fun ptr_as_volatile (p: ptr): void
//
(* ****** ****** *)
//
// overloading for certain symbols
//
overload succ with ptr0_succ
overload succ with ptr1_succ
overload succ with cptr_succ
//
overload pred with ptr0_pred
overload pred with ptr1_pred
overload pred with cptr_pred
//
overload iseqz with ptr0_is_null of 0
overload isneqz with ptr0_isnot_null of 0
//
overload iseqz with ptr1_is_null of 10
overload isneqz with ptr1_isnot_null of 10
//
overload iseqz with cptr_is_null of 10
overload isneqz with cptr_isnot_null of 10
//
(* ****** ****** *)

(* end of [pointer.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/grandom.atxt
** Time of generation: Sat Oct 17 15:19:47 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: June, 2015 *)

(* ****** ****** *)
//
fun{a:vt0p}
grandom_val (): a // for randval generation
//
fun{a:vt0p} // for random value
grandom_ref (x: &(a?) >> a): void // initialization
//
(* ****** ****** *)
//
fun{} grandom_int(): int
fun{} grandom_uint(): uint
//
fun{} grandom_bool(): bool
//
fun{} grandom_float(): float
fun{} grandom_double(): double
//
(* ****** ****** *)
//
fun{a:t0p}
grandom_list
  {n:nat}(n: int(n)): list(a, n)
//
fun{a:vt0p}
grandom_list_vt
  {n:nat}(n: int(n)): list_vt(a, n)
//
(* ****** ****** *)
//
fun{a:vt0p}
grandom_arrayptr
  {n:int}(asz: size_t(n)): arrayptr(a, n)
fun{a:vt0p}
grandom_arrayref
  {n:int}(asz: size_t(n)): arrayref(a, n)
//
fun{a:vt0p}
grandom_arrszref(asz: size_t): arrszref(a)
//
(* ****** ****** *)

(* end of [grandom.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)
(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/char.atxt
** Time of generation: Sat Oct 17 15:19:44 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: September, 2011 *)

(* ****** ****** *)
//
praxi
lemma_char_size
(
// argumentless
) : [sizeof(char)==sizeof(byte)] void
praxi
lemma_schar_size
(
// argumentless
) : [sizeof(schar)==sizeof(byte)] void
praxi
lemma_uchar_size
(
// argumentless
) : [sizeof(uchar)==sizeof(byte)] void
//
(* ****** ****** *)
//
castfn char2schar0 (c: char):<> schar
castfn schar2char0 (c: schar):<> char
//
castfn char2uchar0 (c: char):<> uchar
castfn uchar2char0 (c: uchar):<> char
//
(* ****** ****** *)
//
fun int2char0 (i: int):<> char = "mac#%"
fun int2schar0 (i: int):<> schar = "mac#%"
fun int2uchar0 (i: int):<> uchar = "mac#%"
//
fun uint2uchar0 (u: uint):<> uchar = "mac#%"
//
(* ****** ****** *)

fun char2int0 (c: char):<> int = "mac#%"
fun schar2int0 (c: schar):<> int = "mac#%"
fun uchar2int0 (c: uchar):<> int = "mac#%"

(* ****** ****** *)

fun char2uint0 (c: char):<> uint = "mac#%"
fun schar2uint0 (c: schar):<> uint = "mac#%"
fun uchar2uint0 (c: uchar):<> uint = "mac#%"

(* ****** ****** *)

fun char2u2int0 (c: char):<> int = "mac#%"
fun char2u2uint0 (c: char):<> uint = "mac#%"

(* ****** ****** *)
//
fun char0_iseqz (c: char):<> bool = "mac#%"
fun char0_isneqz (c: char):<> bool = "mac#%"
//
overload iseqz with char0_iseqz of 0
overload isneqz with char0_isneqz of 0
//
(* ****** ****** *)
//
fun add_char0_int0
  (c: char, i: int):<> char = "mac#%"
fun sub_char0_int0
  (c: char, i: int):<> char = "mac#%"
fun sub_char0_char0
  (c1: char, c2: char):<> int = "mac#%"
//
overload + with add_char0_int0 of 0
overload - with sub_char0_int0 of 0
overload - with sub_char0_char0 of 0
//
(* ****** ****** *)

fun lt_char0_char0
  (c1: char, c2: char):<> bool = "mac#%"
overload < with lt_char0_char0 of 0
fun lte_char0_char0
  (c1: char, c2: char):<> bool = "mac#%"
overload <= with lte_char0_char0 of 0

fun gt_char0_char0
  (c1: char, c2: char):<> bool = "mac#%"
overload > with gt_char0_char0 of 0
fun gte_char0_char0
  (c1: char, c2: char):<> bool = "mac#%"
overload >= with gte_char0_char0 of 0

fun eq_char0_char0
  (c1: char, c2: char):<> bool = "mac#%"
overload = with eq_char0_char0 of 0
fun neq_char0_char0
  (c1: char, c2: char):<> bool = "mac#%"
overload != with neq_char0_char0 of 0
overload <> with neq_char0_char0 of 0

fun compare_char0_char0
  (c1: char, c2: char):<> int = "mac#%"
overload compare with compare_char0_char0 of 0

(* ****** ****** *)
//
castfn g0ofg1_char (c: Char):<> char
castfn g1ofg0_char (c: char):<> Char
//
overload g0ofg1 with g0ofg1_char // index-erasing
overload g1ofg0 with g1ofg0_char // index-inducing
//
(* ****** ****** *)
//
castfn
char2schar1 {c:int} (c: char (c)):<> schar (c)
castfn
schar2char1 {c:int} (c: schar (c)):<> char (c)
//
castfn
char2uchar1 {c:int} (c: char (c)):<> uchar (i2u8(c))
castfn
uchar2char1 {c:int} (c: uchar (c)):<> char (u2i8(c))
//
(* ****** ****** *)
//
fun char1_iseqz
  {c:int}(c: char(c)):<> bool(c == 0) = "mac#%"
fun char1_isneqz
  {c:int}(c: char(c)):<> bool(c != 0) = "mac#%"
//
overload iseqz with char1_iseqz of 10
overload isneqz with char1_isneqz of 10
//
(* ****** ****** *)

fun
lt_char1_char1 {c1,c2:int}
  (c1: char (c1), c2: char (c2)):<> bool (c1 < c2) = "mac#%"
overload < with lt_char1_char1 of 20
fun
lte_char1_char1 {c1,c2:int}
  (c1: char (c1), c2: char (c2)):<> bool (c1 <= c2) = "mac#%"
overload <= with lte_char1_char1 of 20

fun
gt_char1_char1 {c1,c2:int}
  (c1: char (c1), c2: char (c2)):<> bool (c1 > c2) = "mac#%"
overload > with gt_char1_char1 of 20
fun
gte_char1_char1 {c1,c2:int}
  (c1: char (c1), c2: char (c2)):<> bool (c1 >= c2) = "mac#%"
overload >= with gte_char1_char1 of 20

fun
eq_char1_char1 {c1,c2:int}
  (c1: char (c1), c2: char (c2)):<> bool (c1 == c2) = "mac#%"
overload = with eq_char1_char1 of 20
fun
neq_char1_char1 {c1,c2:int}
  (c1: char (c1), c2: char (c2)):<> bool (c1 != c2) = "mac#%"
overload != with neq_char1_char1 of 20
overload <> with neq_char1_char1 of 20

fun compare_char1_char1
  {c1,c2:int}
  (c1: char c1, c2: char c2) :<> int (c1-c2) = "mac#%"
overload compare with compare_char1_char1 of 20

(* ****** ****** *)
//
fun eq_char0_int0 : (char, int) -<fun0> bool = "mac#%"
fun eq_int0_char0 : (int, char) -<fun0> bool = "mac#%"
overload = with eq_char0_int0 of 0
overload = with eq_int0_char0 of 0
fun neq_char0_int0 : (char, int) -<fun0> bool = "mac#%"
fun neq_int0_char0 : (int, char) -<fun0> bool = "mac#%"
overload != with neq_char0_int0 of 0
overload <> with neq_char0_int0 of 0
overload != with neq_int0_char0 of 0
overload <> with neq_int0_char0 of 0
//
fun compare_char0_int0 : (char, int) -<fun0> int = "mac#%"
fun compare_int0_char0 : (int, char) -<fun0> int = "mac#%"
overload compare with compare_char0_int0
overload compare with compare_int0_char0
//
(* ****** ****** *)
//
// unsigned characters
//
(* ****** ****** *)

fun lt_uchar0_uchar0
  (c1: uchar, c2: uchar):<> bool = "mac#%"
overload < with lt_uchar0_uchar0 of 0
fun lte_uchar0_uchar0
  (c1: uchar, c2: uchar):<> bool = "mac#%"
overload <= with lte_uchar0_uchar0 of 0

fun gt_uchar0_uchar0
  (c1: uchar, c2: uchar):<> bool = "mac#%"
overload > with gt_uchar0_uchar0 of 0
fun gte_uchar0_uchar0
  (c1: uchar, c2: uchar):<> bool = "mac#%"
overload >= with gte_uchar0_uchar0 of 0

fun eq_uchar0_uchar0
  (c1: uchar, c2: uchar):<> bool = "mac#%"
overload = with eq_uchar0_uchar0 of 0
fun neq_uchar0_uchar0
  (c1: uchar, c2: uchar):<> bool = "mac#%"
overload != with neq_uchar0_uchar0 of 0
overload <> with neq_uchar0_uchar0 of 0

fun compare_uchar0_uchar0
  (c1: uchar, c2: uchar):<> int = "mac#%"
overload compare with compare_uchar0_uchar0 of 0

(* ****** ****** *)

fun
lt_uchar1_uchar1 {c1,c2:int}
  (c1: uchar (c1), c2: uchar (c2)) :<> bool (c1 < c2) = "mac#%"
overload < with lt_uchar1_uchar1 of 20
fun
lte_uchar1_uchar1 {c1,c2:int}
  (c1: uchar (c1), c2: uchar (c2)) :<> bool (c1 <= c2) = "mac#%"
overload <= with lte_uchar1_uchar1 of 20

fun
gt_uchar1_uchar1 {c1,c2:int}
  (c1: uchar (c1), c2: uchar (c2)) :<> bool (c1 > c2) = "mac#%"
overload > with gt_uchar1_uchar1 of 20
fun
gte_uchar1_uchar1 {c1,c2:int}
  (c1: uchar (c1), c2: uchar (c2)) :<> bool (c1 >= c2) = "mac#%"
overload >= with gte_uchar1_uchar1 of 20

fun
eq_uchar1_uchar1 {c1,c2:int}
  (c1: uchar (c1), c2: uchar (c2)) :<> bool (c1 == c2) = "mac#%"
overload = with eq_uchar1_uchar1 of 20
fun
neq_uchar1_uchar1 {c1,c2:int}
  (c1: uchar (c1), c2: uchar (c2)) :<> bool (c1 != c2) = "mac#%"
overload != with neq_uchar1_uchar1 of 20
overload <> with neq_uchar1_uchar1 of 20

fun compare_uchar1_uchar1
  {c1,c2:int}
  (c1: uchar c1, c2: uchar c2) :<> int (c1-c2) = "mac#%"
overload compare with compare_uchar1_uchar1 of 20

(* ****** ****** *)

sortdef tk = tkind

(* ****** ****** *)

fun{tk:tk}
g0int_of_char (c: char):<> g0int (tk)
fun{tk:tk}
g0int_of_schar (c: schar):<> g0int (tk)
fun{tk:tk}
g0int_of_uchar (c: uchar):<> g0int (tk)

fun{tk:tk}
g0uint_of_uchar (c: uchar):<> g0uint (tk)

(* ****** ****** *)

fun{tk:tk}
g1int_of_char1 // c:int8
  {c:int} (c: char (c)):<> g1int (tk, c)
// end of [g1int_of_char1]
fun{tk:tk}
g1int_of_schar1 // c:int8
  {c:int} (c: schar (c)):<> g1int (tk, c)
// end of [g1int_of_schar1]
fun{tk:tk}
g1int_of_uchar1 // c:uint8
  {c:int} (c: uchar (c)):<> g1int (tk, c)
// end of [g1int_of_uchar1]

(*
** HX: g1uint_of_schar1: schar -> int -> uint
*)
fun{tk:tk}
g1uint_of_uchar1
  {c:int} (c: uchar (c)):<> g1uint (tk, c)
// end of [g1uint_of_uchar1]

(* ****** ****** *)
//
// HX:
// return is dynamically allocated
//
fun{}
char2string(c: char):<> string
fun{}
char2strptr(c: char):<!wrt> Strptr1
//
(* ****** ****** *)

fun print_char (x: char): void = "mac#%"
fun prerr_char (x: char): void = "mac#%"
overload print with print_char
overload prerr with prerr_char
fun fprint_char : fprint_type (char) = "mac#%"
overload fprint with fprint_char
fun print_schar (x: schar): void = "mac#%"
fun prerr_schar (x: schar): void = "mac#%"
overload print with print_schar
overload prerr with prerr_schar
fun fprint_schar : fprint_type (schar) = "mac#%"
overload fprint with fprint_schar
fun print_uchar (x: uchar): void = "mac#%"
fun prerr_uchar (x: uchar): void = "mac#%"
overload print with print_uchar
overload prerr with prerr_uchar
fun fprint_uchar : fprint_type (uchar) = "mac#%"
overload fprint with fprint_uchar

(* ****** ****** *)

symintr isalpha
fun isalpha_int (c: int):<> bool = "mac#%"
overload isalpha with isalpha_int of 0
fun isalpha_char (c: char):<> bool = "mac#%"
overload isalpha with isalpha_char of 0
symintr isalnum
fun isalnum_int (c: int):<> bool = "mac#%"
overload isalnum with isalnum_int of 0
fun isalnum_char (c: char):<> bool = "mac#%"
overload isalnum with isalnum_char of 0

symintr isascii
fun isascii_int (c: int):<> bool = "mac#%"
overload isascii with isascii_int of 0
fun isascii_char (c: char):<> bool = "mac#%"
overload isascii with isascii_char of 0

symintr isblank
fun isblank_int (c: int):<> bool = "mac#%"
overload isblank with isblank_int of 0
fun isblank_char (c: char):<> bool = "mac#%"
overload isblank with isblank_char of 0
symintr isspace
fun isspace_int (c: int):<> bool = "mac#%"
overload isspace with isspace_int of 0
fun isspace_char (c: char):<> bool = "mac#%"
overload isspace with isspace_char of 0

symintr iscntrl
fun iscntrl_int (c: int):<> bool = "mac#%"
overload iscntrl with iscntrl_int of 0
fun iscntrl_char (c: char):<> bool = "mac#%"
overload iscntrl with iscntrl_char of 0

symintr isdigit
fun isdigit_int (c: int):<> bool = "mac#%"
overload isdigit with isdigit_int of 0
fun isdigit_char (c: char):<> bool = "mac#%"
overload isdigit with isdigit_char of 0
symintr isxdigit
fun isxdigit_int (c: int):<> bool = "mac#%"
overload isxdigit with isxdigit_int of 0
fun isxdigit_char (c: char):<> bool = "mac#%"
overload isxdigit with isxdigit_char of 0

symintr isgraph
fun isgraph_int (c: int):<> bool = "mac#%"
overload isgraph with isgraph_int of 0
fun isgraph_char (c: char):<> bool = "mac#%"
overload isgraph with isgraph_char of 0
symintr isprint
fun isprint_int (c: int):<> bool = "mac#%"
overload isprint with isprint_int of 0
fun isprint_char (c: char):<> bool = "mac#%"
overload isprint with isprint_char of 0
symintr ispunct
fun ispunct_int (c: int):<> bool = "mac#%"
overload ispunct with ispunct_int of 0
fun ispunct_char (c: char):<> bool = "mac#%"
overload ispunct with ispunct_char of 0

symintr islower
fun islower_int (c: int):<> bool = "mac#%"
overload islower with islower_int of 0
fun islower_char (c: char):<> bool = "mac#%"
overload islower with islower_char of 0
symintr isupper
fun isupper_int (c: int):<> bool = "mac#%"
overload isupper with isupper_int of 0
fun isupper_char (c: char):<> bool = "mac#%"
overload isupper with isupper_char of 0

(* ****** ****** *)

fun toascii (c: int):<> int = "mac#%"

(* ****** ****** *)

symintr tolower
fun tolower_int (c: int):<> int = "mac#%"
fun tolower_char (c: char):<> char = "mac#%"
overload tolower with tolower_int
overload tolower with tolower_char

symintr toupper
fun toupper_int (c: int):<> int = "mac#%"
fun toupper_char (c: char):<> char = "mac#%"
overload toupper with toupper_int
overload toupper with toupper_char

(* ****** ****** *)

fun int2digit (i: intBtw(0, 10)): char = "mac#%"
fun int2xdigit (i: intBtw(0, 16)): char = "mac#%"
fun int2xxdigit (i: intBtw(0, 16)): char = "mac#%"

(* ****** ****** *)

symintr c2uc
overload c2uc with char2uchar0 of 0
overload c2uc with char2uchar1 of 10
symintr uc2c
overload uc2c with uchar2char0 of 0
overload uc2c with uchar2char1 of 10

(* ****** ****** *)

symintr char2i
overload char2i with char2int0 of 0
symintr char2ui
overload char2ui with char2uint0 of 0
symintr uchar2i
overload uchar2i with uchar2int0 of 0
symintr uchar2ui
overload uchar2ui with uchar2uint0 of 0

(* ****** ****** *)

symintr char2u2i
overload char2u2i with char2u2int0 of 0
symintr char2u2ui
overload char2u2ui with char2u2uint0 of 0

(* ****** ****** *)
//
fun int2byte0 (i: int): byte = "mac#%"
fun byte2int0 (b: byte):<> int = "mac#%"
//
fun uint2byte0 (u: uint): byte = "mac#%"
fun byte2uint0 (b: byte):<> uint = "mac#%"
//
symintr byte2i
overload byte2i with byte2int0 of 0
symintr i2byte
overload i2byte with int2byte0 of 0
//
symintr byte2ui
overload byte2i with byte2uint0 of 0
symintr ui2byte
overload i2byte with uint2byte0 of 0
//
(* ****** ****** *)

(* end of [char.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/unsafe.atxt
** Time of generation: Sat Oct 17 15:19:46 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: April, 2012 *)

(* ****** ****** *)

#define
ATS_PACKNAME "ATSLIB.prelude.unsafe"

(* ****** ****** *)

sortdef t0p = t@ype and vt0p = viewt@ype

(* ****** ****** *)
//
praxi
prop_assert{b:bool}((*void*)): [b] void
//
praxi
eqint_assert{i1,i2:int}((*void*)): EQINT(i1,i2)
praxi
eqaddr_assert{l1,l2:addr}((*void*)): EQADDR(l1,l2)
praxi
eqbool_assert{b1,b2:bool}((*void*)): EQBOOL(b1,b2)
//
(* ****** ****** *)
//
castfn
cast{to:t0p}{from:t0p} (x: INV(from)):<> to
//
(* ****** ****** *)
//
castfn
castvwtp0
  {to:vt0p}{from:vt0p} (x: INV(from)):<> to
//
// HX:
// [castvwtp1] is mostly used in a situation
// where a linear value is passed as a read-only value;
// for instance, casting [strptr] to [string] is often
// done for treating a linear string as a nonlinear one
// temporarily.
//
castfn
castvwtp1
  {to:vt0p}{from:vt0p} (x: !INV(from)>>from):<> to
//
(* ****** ****** *)
//
castfn cast2ptr {a:type} (x: INV(a)):<> ptr
castfn cast2Ptr0 {a:type} (x: INV(a)):<> Ptr0
castfn cast2Ptr1 {a:type} (x: INV(a)):<> Ptr1
//
castfn cast2int {a:t0p} (x: INV(a)):<> int
castfn cast2uint {a:t0p} (x: INV(a)):<> uint
//
castfn cast2lint {a:t0p} (x: INV(a)):<> lint
castfn cast2ulint {a:t0p} (x: INV(a)):<> ulint
//
castfn cast2llint {a:t0p} (x: INV(a)):<> llint
castfn cast2ullint {a:t0p} (x: INV(a)):<> ullint
//
castfn cast2size {a:t0p} (x: INV(a)):<> size_t
castfn cast2ssize {a:t0p} (x: INV(a)):<> ssize_t
//
castfn cast2sint {a:t0p} (x: INV(a)):<> sint
castfn cast2usint {a:t0p} (x: INV(a)):<> usint
//
castfn cast2intptr {a:t0p} (x: INV(a)):<> intptr
castfn cast2uintptr {a:t0p} (x: INV(a)):<> uintptr
//
(* ****** ****** *)

praxi cast2void {a:vt0p} (x: INV(a)):<prf> void

(* ****** ****** *)
//
praxi castview0 {to:view}{from:view} (pf: from):<prf> to
praxi castview1 {to:view}{from:view} (pf: !INV(from)):<prf> to
//
praxi castview2void {to:view}{from:view} (x: !INV(from) >> to):<prf> void
//
praxi castvwtp2void {to:vt0p}{from:vt0p} (x: !INV(from) >> to):<prf> void
//
(* ****** ****** *)

fun{} int2ptr (i: int): ptr and ptr2int (p: ptr): int

(* ****** ****** *)
//
// HX: these are popular ones:
//
castfn list_vt2t
  {a:t0p}{n:int} (xs: !list_vt (INV(a), n)):<> list (a, n)
// end of [list_vt2t]

castfn arrayptr2ref
  {a:vt0p}{n:int} (x: !arrayptr (INV(a), n)):<> arrayref (a, n)
// end of [arrayptr2ref]

castfn strptr2string {l:agz} (x: !strptr l):<> String0
castfn strptr2stropt {l:addr} (x: !strptr l):<> Stropt0
castfn strnptr2string {l:addr}{n:nat} (x: !strnptr (l, n)):<> string (n)

(* ****** ****** *)
//
// HX: only if you know what you are doing ...
//
symintr ptr_vtake

castfn ptr0_vtake
  {a:vt0p} (ptr):<> [l:addr] (a@l, a@l -<lin,prf> void | ptr l)
overload ptr_vtake with ptr0_vtake of 0

castfn ptr1_vtake
  {a:vt0p}{l:addr} (ptr l):<> (a@l, a@l -<lin,prf> void | ptr l) 
overload ptr_vtake with ptr1_vtake of 10

(* ****** ****** *)

castfn
ref_vtake{a:vt0p}
  {l:addr} (r: ref (a)):<> [l:addr] (a@l, a@l -<lin,prf> void | ptr l)
// end of [ref_vtake]

(* ****** ****** *)

praxi
vtakeout_void {v:view} (pf: !v): vtakeout0 (v)
castfn
vttakeout_void {a:vt0p} (x: !a):<> vttakeout0 (a)

(* ****** ****** *)
//
// HX: only if you know what you are doing ...
//
fun{a:vt0p} ptr0_get (p: ptr):<> a
fun{a:vt0p} ptr1_get (p: Ptr1):<> a
//
fun{a:vt0p} ptr0_set (p: ptr, x: INV(a)):<!wrt> void
fun{a:vt0p} ptr1_set (p: Ptr1, x: INV(a)):<!wrt> void
//
fun{a:vt0p} ptr0_exch (p: ptr, x: &INV(a) >> a):<!wrt> void
fun{a:vt0p} ptr1_exch (p: Ptr1, x: &INV(a) >> a):<!wrt> void
//
fun{a:vt0p} ptr0_intch (p1: ptr, p2: ptr):<!wrt> void
fun{a:vt0p} ptr1_intch (p1: Ptr1, p2: Ptr1):<!wrt> void
//
(* ****** ****** *)
//
fun{a:vt0p}
ptr0_get_at_int (p: ptr, i: int):<> a
fun{a:vt0p}
ptr0_set_at_int (p: ptr, i: int, x: a):<!wrt> void
fun{a:vt0p}
ptr0_get_at_size (p: ptr, i: size_t):<> a
fun{a:vt0p}
ptr0_set_at_size (p: ptr, i: size_t, x: a):<!wrt> void
//
symintr ptr0_get_at
symintr ptr0_set_at
//
overload ptr0_get_at with ptr0_get_at_int
overload ptr0_get_at with ptr0_get_at_size
overload ptr0_set_at with ptr0_set_at_int
overload ptr0_set_at with ptr0_set_at_size
//
(* ****** ****** *)
//
// HX-2012-06:
// generic ops on numbers: +=, -=, *=, /=, %=
//
fun{a:t0p} ptr0_addby (p: ptr, x: a):<!wrt> void // !p += x
fun{a:t0p} ptr1_addby (p: Ptr1, x: a):<!wrt> void // !p += x
//
fun{a:t0p} ptr0_subby (p: ptr, x: a):<!wrt> void // !p -= x
fun{a:t0p} ptr1_subby (p: Ptr1, x: a):<!wrt> void // !p -= x
//
fun{a:t0p} ptr0_mulby (p: ptr, x: a):<!wrt> void // !p *= x
fun{a:t0p} ptr1_mulby (p: Ptr1, x: a):<!wrt> void // !p *= x
//
fun{a:t0p} ptr0_divby (p: ptr, x: a):<!exnwrt> void // !p /= x
fun{a:t0p} ptr1_divby (p: Ptr1, x: a):<!exnwrt> void // !p /= x
//
fun{a:t0p} ptr0_modby (p: ptr, x: a):<!exnwrt> void // !p %= x
fun{a:t0p} ptr1_modby (p: Ptr1, x: a):<!exnwrt> void // !p %= x
//
(* ****** ****** *)

fun{a:vt0p} ptr1_list_next (p: Ptr1): Ptr0 // HX: &(p->next)

(* ****** ****** *)
//
// HX: only if you know what you are doing ...
//
castfn
ptr2cptr{a:vt0p}{l:addr} (p: ptr(l)):<> cptr (a, l)
//
(* ****** ****** *)
//
castfn
cptr_vtake
  {a:vt0p}{l:agz}
  (p: cptr (INV(a), l)):<> (a@l, a@l -<lin,prf> void | ptr l)
// end of [cptr_vtake]
//
fun{a:vt0p} cptr_get (p: cPtr1 (INV(a))):<> a
fun{a:vt0p} cptr_set (p: cPtr1 (INV(a)), x: a):<!wrt> void
fun{a:vt0p} cptr_exch (p: cPtr1 (INV(a)), x: &a >> a):<!wrt> void
//
(* ****** ****** *)

(* end of [unsafe.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/tostring.atxt
** Time of generation: Sat Oct 17 15:19:50 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: August, 2012 *)

(* ****** ****** *)

vtypedef
RD(a:vt0p) = a // for commenting: read-only
#define NSH (x) x // for commenting: no sharing
#define SHR (x) x // for commenting: it is shared

(* ****** ****** *)

sortdef t0p = t@ype
sortdef vt0p = vt@ype

(* ****** ****** *)

fun{}
tostring_int(int):<> string
fun{}
tostrptr_int(int):<!wrt> Strptr1

(* ****** ****** *)

fun{}
tostring_uint(uint):<> string
fun{}
tostrptr_uint(uint):<!wrt> Strptr1

(* ****** ****** *)

fun{}
tostring_bool(bool):<> string
fun{}
tostrptr_bool(bool):<!wrt> Strptr1

(* ****** ****** *)

fun{}
tostring_char(char):<> string
fun{}
tostrptr_char(char):<!wrt> Strptr1

(* ****** ****** *)
//
fun
{a:t0p}
tostrptr_list
  (xs0: List(INV(a))): Strptr1
//
fun{}
tostrptr_list$beg((*void*)): String
fun{}
tostrptr_list$end((*void*)): String
fun{}
tostrptr_list$sep((*void*)): String
//
(* ****** ****** *)
//
fun
{a:vt0p}
tostrptr_array
  {n:int}
(
  &array(INV(a), n), size_t(n)
) : Strptr1 // end-of-function
//
fun{}
tostrptr_array$beg((*void*)): String
fun{}
tostrptr_array$end((*void*)): String
fun{}
tostrptr_array$sep((*void*)): String
//
(* ****** ****** *)
//
fun
{a:vt0p}
tostrptr_arrayref
  {n:int}
  (arrayref(a,n), size_t(n)): Strptr1
//
fun
{a:vt0p}
tostrptr_arrszref(arrszref(a)): Strptr1
//
(* ****** ****** *)

(* end of [tostring.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/integer.atxt
** Time of generation: Sat Oct 17 15:19:43 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: September, 2011 *)

(* ****** ****** *)
//
// HX: for unindexed integer types
//
(* ****** ****** *)

sortdef tk = tkind

(* ****** ****** *)

typedef SHR(a:t@ype) = a // for commenting purpose
typedef NSH(a:t@ype) = a // for commenting purpose

(* ****** ****** *)
//
stadef intknd = int_kind
stadef lintknd = lint_kind
stadef llintknd = llint_kind
stadef ssizeknd = ssize_kind
//
stadef uintknd = uint_kind
stadef ulintknd = ulint_kind
stadef ullintknd = ullint_kind
stadef sizeknd = size_kind
//
(* ****** ****** *)
//
fun{
k1,k2:tk
} g0int2int (x: g0int (k1)):<> g0int (k2)
//
fun g0int2int_int_int (x: int):<> int = "mac#%"
fun g0int2int_int_lint (x: int):<> lint = "mac#%"
fun g0int2int_int_llint (x: int):<> llint = "mac#%"
fun g0int2int_int_ssize (x: int):<> ssize_t = "mac#%"
//
fun g0int2int_lint_int (x: int):<> int = "mac#%"
fun g0int2int_lint_lint (x: int):<> lint = "mac#%"
fun g0int2int_lint_llint (x: int):<> llint = "mac#%"
fun g0int2int_lint_ssize (x: int):<> ssize_t = "mac#%"
//
fun g0int2int_ssize_int (x: int):<> int = "mac#%"
fun g0int2int_ssize_lint (x: int):<> lint = "mac#%"
fun g0int2int_ssize_llint (x: int):<> llint = "mac#%"
fun g0int2int_ssize_ssize (x: int):<> ssize_t = "mac#%"
//
fun g0int2int_sint_int (x: sint):<> int = "mac#%"
//
(* ****** ****** *)
//
// HX-2015-09-20:
// These functions are implemented in prelude/string.cats:
//
fun{tk:tk}
g0int2string (x: g0int (tk)):<!wrt> Strptr1
//
fun g0int2string_int (x: int):<!wrt> Strptr1 = "mac#%"
fun g0int2string_lint (x: lint):<!wrt> Strptr1 = "mac#%"
fun g0int2string_llint (x: llint):<!wrt> Strptr1 = "mac#%"
(*
fun g0int2string_ssize (x: ssize_t):<!wrt> Strptr1 = "mac#%"
*)
//
(* ****** ****** *)
//
fun{tk:tk}
g0string2int (str: NSH(string)):<> g0int (tk)
//
fun g0string2int_int (x: NSH(string)):<> int = "mac#%"
fun g0string2int_lint (x: NSH(string)):<> lint = "mac#%"
fun g0string2int_llint (x: NSH(string)):<> llint = "mac#%"
fun g0string2int_ssize (x: NSH(string)):<> ssize_t = "mac#%"
//
(* ****** ****** *)

typedef
g0int_uop_type
  (tk: tkind) = (g0int (tk)) -<fun0> g0int (tk)
// end of [g0int_uop_type]

(* ****** ****** *)

fun
{tk:tk}
g0int_neg : g0int_uop_type(tk)
overload ~ with g0int_neg of 0 // ~ for uminus
overload neg with g0int_neg of 0

fun
{tk:tk}
g0int_abs : g0int_uop_type(tk)
overload abs with g0int_abs of 0

(* ****** ****** *)

fun
{tk:tk}
g0int_succ : g0int_uop_type(tk)
overload succ with g0int_succ of 0

fun
{tk:tk}
g0int_pred : g0int_uop_type(tk)
overload pred with g0int_pred of 0

(* ****** ****** *)

fun
{tk:tk}
g0int_half : g0int_uop_type(tk)
overload half with g0int_half of 0

(*
fun
{tk:tk}
g0int_double : g0int_uop_type(tk)
overload double with g0int_double of 0
*)

(* ****** ****** *)

typedef
g0int_aop_type (tk: tkind) =
   (g0int (tk), g0int (tk)) -<fun0> g0int (tk)
// end of [g0int_aop_type]

fun
{tk:tk}
g0int_add : g0int_aop_type(tk)
overload + with g0int_add of 0
fun
{tk:tk}
g0int_sub : g0int_aop_type(tk)
overload - with g0int_sub of 0
fun
{tk:tk}
g0int_mul : g0int_aop_type(tk)
overload * with g0int_mul of 0
fun
{tk:tk}
g0int_div : g0int_aop_type(tk)
overload / with g0int_div of 0
fun
{tk:tk}
g0int_mod : g0int_aop_type(tk)
overload % with g0int_mod of 0
overload mod with g0int_mod of 0

(* ****** ****** *)

fun{}
mul_int1_size0 {i:nat} (int(i), size_t):<> size_t
fun{}
mul_size0_int1 {j:nat} (size_t, int(j)):<> size_t

(* ****** ****** *)

overload * with mul_int1_size0 of 11
overload * with mul_size0_int1 of 11

(* ****** ****** *)
//
fun
{tk:tk}
g0int_asl
  (x: g0int(tk), n: intGte(0)):<> g0int(tk)
fun
{tk:tk}
g0int_asr
  (x: g0int(tk), n: intGte(0)):<> g0int(tk)
//
overload << with g0int_asl of 0
overload >> with g0int_asr of 0
//
(* ****** ****** *)
//
fun
{tk:tk}
g0int_npow
  (x: g0int(tk), n: intGte(0)):<> g0int(tk)
//
overload ** with g0int_npow of 0
//
(* ****** ****** *)
//
fun{tk:tk}
g0int_isltz (x: g0int (tk)):<> bool
fun{tk:tk}
g0int_isltez (x: g0int (tk)):<> bool
//
fun{tk:tk}
g0int_isgtz (x: g0int (tk)):<> bool
fun{tk:tk}
g0int_isgtez (x: g0int (tk)):<> bool
//
fun{tk:tk}
g0int_iseqz (x: g0int (tk)):<> bool
fun{tk:tk}
g0int_isneqz (x: g0int (tk)):<> bool
//
overload isltz with g0int_isltz of 0
overload isltez with g0int_isltez of 0
overload isgtz with g0int_isgtz of 0
overload isgtez with g0int_isgtez of 0
overload iseqz with g0int_iseqz of 0
overload isneqz with g0int_isneqz of 0
//
(* ****** ****** *)

typedef
g0int_cmp_type (tk:tk) =
  (g0int (tk), g0int (tk)) -<fun0> bool
// end of [g0int_cmp_type]

fun
{tk:tk}
g0int_lt : g0int_cmp_type(tk)
overload < with g0int_lt of 0
fun
{tk:tk}
g0int_lte : g0int_cmp_type(tk)
overload <= with g0int_lte of 0

fun
{tk:tk}
g0int_gt : g0int_cmp_type(tk)
overload > with g0int_gt of 0
fun
{tk:tk}
g0int_gte : g0int_cmp_type(tk)
overload >= with g0int_gte of 0

fun
{tk:tk}
g0int_eq : g0int_cmp_type(tk)
overload = with g0int_eq of 0
fun
{tk:tk}
g0int_neq : g0int_cmp_type(tk)
overload != with g0int_neq of 0
overload <> with g0int_neq of 0

(* ****** ****** *)

fun{tk:tk}
g0int_compare
  (x: g0int (tk), y: g0int (tk)):<> int
overload compare with g0int_compare of 0

(* ****** ****** *)

fun
{tk:tk}
g0int_max : g0int_aop_type(tk)
overload max with g0int_max of 0
fun
{tk:tk}
g0int_min : g0int_aop_type(tk)
overload min with g0int_min of 0

(* ****** ****** *)

fun{tk:tk}
lt_g0int_int (x: g0int (tk), y: int):<> bool
overload < with lt_g0int_int of 11
fun{tk:tk}
lte_g0int_int (x: g0int (tk), y: int):<> bool
overload <= with lte_g0int_int of 11
//
fun{tk:tk}
gt_g0int_int (x: g0int (tk), y: int):<> bool
overload > with gt_g0int_int of 11
fun{tk:tk}
gte_g0int_int (x: g0int (tk), y: int):<> bool
overload >= with gte_g0int_int of 11
//
fun{tk:tk}
eq_g0int_int (x: g0int (tk), y: int):<> bool
overload = with eq_g0int_int of 11
fun{tk:tk}
neq_g0int_int (x: g0int (tk), y: int):<> bool
overload != with neq_g0int_int of 11
overload <> with neq_g0int_int of 11
//
fun{tk:tk}
compare_g0int_int (x: g0int (tk), y: int):<> int
overload compare with compare_g0int_int of 11

(* ****** ****** *)
//
// HX: for indexed integer types
//
castfn
g0ofg1_int {tk:tk} (x: g1int tk):<> g0int (tk)
castfn
g1ofg0_int {tk:tk} (x: g0int tk):<> g1int (tk)
overload g0ofg1 with g0ofg1_int // index-erasing
overload g1ofg0 with g1ofg0_int // index-inducing
//
(* ****** ****** *)
//
fun{
k1,k2:tk
} g1int2int // i2i
  {i:int} (x: g1int (k1, i)):<> g1int (k2, i)
//
fun g1int2int_int_int {i:int} (x: int i):<> int (i) = "mac#%"
fun g1int2int_int_lint {i:int} (x: int i):<> lint (i) = "mac#%"
fun g1int2int_int_llint {i:int} (x: int i):<> llint (i) = "mac#%"
fun g1int2int_int_ssize {i:int} (x: int i):<> ssize_t (i) = "mac#%"
//
(* ****** ****** *)

fun{tk:tk}
g1string2int (str: NSH(string)):<> g1int (tk)

(* ****** ****** *)

prfun
g1int_get_index
  {tk:tk}{i1:int}
  (x: g1int (tk, i1)): [i2:int] EQINT (i1, i2)
// end of [g1int_get_index]

(* ****** ****** *)

typedef
g1int_neg_type (tk:tk) =
  {i:int} g1int (tk, i) -<fun0> g1int (tk, ~i)
fun
{tk:tk}
g1int_neg : g1int_neg_type(tk)
overload ~ with g1int_neg of 10 // ~ for uminus
overload neg with g1int_neg of 10

typedef
g1int_abs_type (tk:tk) =
  {i:int} g1int (tk, i) -<fun0> g1int (tk, abs(i))
fun
{tk:tk}
g1int_abs : g1int_abs_type(tk)
overload abs with g1int_abs of 10

(* ****** ****** *)

typedef
g1int_succ_type (tk:tk) =
  {i:int} g1int (tk, i) -<fun0> g1int (tk, i+1)
fun{tk:tk}
g1int_succ : g1int_succ_type(tk)
overload succ with g1int_succ of 10

typedef
g1int_pred_type (tk:tk) =
  {i:int} g1int (tk, i) -<fun0> g1int (tk, i-1)
fun{tk:tk}
g1int_pred : g1int_pred_type(tk)
overload pred with g1int_pred of 10

typedef
g1int_half_type (tk:tk) =
  {i:int} g1int (tk, i) -<fun0> g1int (tk, i/2)
fun{tk:tk}
g1int_half : g1int_half_type(tk)
overload half with g1int_half of 10

(*
typedef
g1int_double_type (tk:tk) =
  {i:int} g1int (tk, i) -<fun0> g1int (tk, 2*i)
fun{tk:tk}
g1int_double : g1int_double_type(tk)
overload double with g1int_double of 10
*)

(* ****** ****** *)
//
typedef
g1int_add_type
  (tk:tk) =
  {i,j:int}
  (g1int (tk,i), g1int (tk,j)) -<fun0> g1int (tk, i+j)
//
fun
{tk:tk}
g1int_add : g1int_add_type(tk)
//
fun{}
add_size1_int1
  {i,j:int | i+j >= 0} (x: size_t (i), j: int (j)):<> size_t (i+j)
fun{}
add_int1_size1
  {i,j:int | i+j >= 0} (x: int (i), j: size_t (j)):<> size_t (i+j)
//
(* ****** ****** *)

overload + with g1int_add of 20
overload + with add_size1_int1 of 22
overload + with add_int1_size1 of 22

(* ****** ****** *)
//
typedef
g1int_sub_type
  (tk:tk) =
  {i,j:int}
  (g1int (tk,i), g1int (tk,j)) -<fun0> g1int (tk, i-j)
//
fun
{tk:tk}
g1int_sub : g1int_sub_type(tk)
//
fun{}
sub_size1_int1
  {i,j:int | i-j >= 0} (x: size_t (i), j: int (j)):<> size_t (i-j)
//
(* ****** ****** *)

overload - with g1int_sub of 20
overload - with sub_size1_int1 of 22

(* ****** ****** *)
//
typedef
g1int_mul_type
  (tk:tk) =
  {i,j:int}
  (g1int (tk,i), g1int (tk,j)) -<fun0> g1int (tk, i*j)
//
fun
{tk:tk}
g1int_mul : g1int_mul_type(tk)
//
fun
{tk:tk}
g1int_mul2
  {i,j:int}
(
  x: g1int (tk, i)
, y: g1int (tk, j)
) :<> [ij:int]
  (MUL (i, j, ij) | g1int (tk, ij))
// end of [g1int_mul2]
//
fun{}
mul_int1_size1
  {i,j:int | i >= 0} (x: int (i), j: size_t (j)):<> size_t (i*j)
fun{}
mul_size1_int1
  {i,j:int | j >= 0} (x: size_t (i), j: int (j)):<> size_t (i*j)
//
(* ****** ****** *)

overload * with g1int_mul of 20
overload * with mul_int1_size1 of 22
overload * with mul_size1_int1 of 22

(* ****** ****** *)
//
typedef
g1int_div_type
  (tk:tk) =
  {i,j:int | j != 0}
  (g1int (tk, i), g1int (tk, j)) -<fun0> g1int (tk)
//
fun
{tk:tk}
g1int_div : g1int_div_type(tk)
//
(* ****** ****** *)
//
typedef
g1int_ndiv_type
  (tk:tk) =
  {i,j:int | i >= 0; j > 0}
  (g1int (tk, i), g1int (tk, j)) -<fun0> g1int (tk, ndiv_int_int(i,j))
//
fun{tk:tk}
g1int_ndiv : g1int_ndiv_type(tk)

(* ****** ****** *)

fun{tk:tk}
g1int_ndiv2
  {i,j:int | i >= 0; j > 0}
(
  x: g1int (tk, i), y: g1int (tk, j)
) :<>
[
  q,r:int | 0 <= r; r < j
] (
  DIVMOD (i, j, q, r) | g1int (tk, q)
) (* end of [g1int_ndiv2] *)

(* ****** ****** *)

overload / with g1int_div of 20
overload ndiv with g1int_ndiv of 20

(* ****** ****** *)

(*
** HX: [g1int_mod] is intentionally skipped
*)

(* ****** ****** *)

typedef
g1int_nmod_type
  (tk:tk) =
  {i,j:int | i >= 0; j > 0}
  (g1int (tk, i), g1int (tk, j)) -<fun0> g1int (tk, nmod_int_int(i, j))
// end of [g1int_nmod_type]

fun{tk:tk}
g1int_nmod : g1int_nmod_type(tk)

(* ****** ****** *)

fun{tk:tk}
g1int_nmod2
  {i,j:int | i >= 0; j > 0}
(
  x: g1int (tk, i), y: g1int (tk, j)
) :<> [q,r:nat | r < j]
(
  DIVMOD (i, j, q, r) | g1int (tk, r)
) (* end of [g1int_nmod2] *)

(* ****** ****** *)
//
fun{tk:tk}
nmod_g1int_int1
  {i,j:int | i >= 0; j > 0}
  (x: g1int (tk, i), y: int (j)):<> int(i%j)
//
fun{tk:tk}
nmod2_g1int_int1
  {i,j:int | i >= 0; j > 0}
(
  x: g1int (tk, i), y: int (j)
) :<> [q,r:nat | r < j] (DIVMOD (i, j, q, r) | int (r))
//
(* ****** ****** *)

overload nmod with g1int_nmod of 20
overload nmod with nmod_g1int_int1 of 21

(* ****** ****** *)

typedef
g1int_ngcd_type
  (tk:tk) =
  {i,j:int | i >= 0; j >= 0}
  (g1int (tk, i), g1int (tk, j)) -<fun0> [r:nat] g1int (tk, r)
// end of [g1int_ngcd_type]

fun{tk:tk}
g1int_ngcd : g1int_ngcd_type(tk)
(*
overload ngcd with g1int_ngcd of 20 // HX: [ngcd] is no longer pre-declared
*)

(* ****** ****** *)

typedef
g1int_isltz_type (tk:tk) =
  {i:int} (g1int (tk, i)) -<fun0> bool (i < 0)
typedef
g1int_isltez_type (tk:tk) =
  {i:int} (g1int (tk, i)) -<fun0> bool (i <= 0)
fun{tk:tk}
g1int_isltz : g1int_isltz_type(tk)
overload isltz with g1int_isltz of 10
fun{tk:tk}
g1int_isltez : g1int_isltez_type(tk)
overload isltez with g1int_isltez of 10

(* ****** ****** *)

typedef
g1int_isgtz_type (tk:tk) =
  {i:int} (g1int (tk, i)) -<fun0> bool (i > 0)
typedef
g1int_isgtez_type (tk:tk) =
  {i:int} (g1int (tk, i)) -<fun0> bool (i >= 0)
fun{tk:tk}
g1int_isgtz : g1int_isgtz_type(tk)
overload isgtz with g1int_isgtz of 10
fun{tk:tk}
g1int_isgtez : g1int_isgtez_type(tk)
overload isgtez with g1int_isgtez of 10

(* ****** ****** *)

typedef
g1int_iseqz_type (tk:tk) =
  {i:int} (g1int (tk, i)) -<fun0> bool (i > 0)
typedef
g1int_isneqz_type (tk:tk) =
  {i:int} (g1int (tk, i)) -<fun0> bool (i >= 0)
fun{tk:tk}
g1int_iseqz : g1int_iseqz_type(tk)
overload iseqz with g1int_iseqz of 10
fun{tk:tk}
g1int_isneqz : g1int_isneqz_type(tk)
overload isneqz with g1int_isneqz of 10

(* ****** ****** *)
//
typedef
g1int_lt_type
  (tk:tk) =
  {i,j:int}
  (g1int (tk, i), g1int (tk, j)) -<fun0> bool (i < j)
typedef
g1int_lte_type
  (tk:tk) =
  {i,j:int}
  (g1int (tk, i), g1int (tk, j)) -<fun0> bool (i <= j)
//
fun{tk:tk}
g1int_lt : g1int_lt_type(tk)
overload < with g1int_lt of 20
fun{tk:tk}
g1int_lte : g1int_lte_type(tk)
overload <= with g1int_lte of 20
//
(* ****** ****** *)
//
typedef
g1int_gt_type
  (tk:tk) =
  {i,j:int}
  (g1int (tk, i), g1int (tk, j)) -<fun0> bool (i > j)
typedef
g1int_gte_type
  (tk:tk) =
  {i,j:int}
  (g1int (tk, i), g1int (tk, j)) -<fun0> bool (i >= j)
//
fun
{tk:tk}
g1int_gt : g1int_gt_type(tk)
overload > with g1int_gt of 20
fun
{tk:tk}
g1int_gte : g1int_gte_type(tk)
overload >= with g1int_gte of 20
//
(* ****** ****** *)
//
typedef
g1int_eq_type
  (tk:tk) =
  {i,j:int}
  (g1int (tk, i), g1int (tk, j)) -<fun0> bool (i == j)
typedef
g1int_neq_type
  (tk:tk) =
  {i,j:int}
  (g1int (tk, i), g1int (tk, j)) -<fun0> bool (i != j)
//
fun
{tk:tk}
g1int_eq : g1int_eq_type(tk)
overload = with g1int_eq of 20
fun
{tk:tk}
g1int_neq : g1int_neq_type(tk)
overload != with g1int_neq of 20
overload <> with g1int_neq of 20
//
(* ****** ****** *)
//
typedef
g1int_compare_type
  (tk:tk) =
  {i,j:int}
  (g1int (tk, i), g1int (tk, j)) -<fun0> int (sgn(i-j))
//
fun{tk:tk}
g1int_compare : g1int_compare_type(tk)
overload compare with g1int_compare of 20
//
(* ****** ****** *)
//
typedef
g1int_max_type
  (tk:tk) =
  {i,j:int}
  (g1int (tk, i), g1int (tk, j)) -<fun0> g1int (tk, max(i, j))
//
fun
{tk:tk}
g1int_max : g1int_max_type(tk)
overload max with g1int_max of 20
//
typedef
g1int_min_type
  (tk:tk) =
  {i,j:int}
  (g1int (tk, i), g1int (tk, j)) -<fun0> g1int (tk, min(i, j))
//
fun
{tk:tk}
g1int_min : g1int_min_type(tk)
overload min with g1int_min of 20
//
(* ****** ****** *)

fun{tk:tk}
lt_g1int_int{i,j:int}
  (x: g1int (tk, i), y: int (j)):<> bool (i < j)
overload < with lt_g1int_int of 21
fun{tk:tk}
lte_g1int_int{i,j:int}
  (x: g1int (tk, i), y: int (j)):<> bool (i <= j)
overload <= with lte_g1int_int of 21
//
fun{tk:tk}
gt_g1int_int{i,j:int}
  (x: g1int (tk, i), y: int (j)):<> bool (i > j)
overload > with gt_g1int_int of 21
fun{tk:tk}
gte_g1int_int{i,j:int}
  (x: g1int (tk, i), y: int (j)):<> bool (i >= j)
overload >= with gte_g1int_int of 21
//
fun{tk:tk}
eq_g1int_int{i,j:int}
  (x: g1int (tk, i), y: int (j)):<> bool (i == j)
overload = with eq_g1int_int of 21
fun{tk:tk}
neq_g1int_int{i,j:int}
  (x: g1int (tk, i), y: int (j)):<> bool (i != j)
overload != with neq_g1int_int of 21
overload <> with neq_g1int_int of 21
//
fun{tk:tk}
compare_g1int_int{i,j:int}
  (x: g1int (tk, i), y: int (j)):<> int (sgn(i-j))
overload compare with compare_g1int_int of 21
//
(* ****** ****** *)

fun
{tk:tk}
g1int_sgn {i:int} (x: g1int (tk, i)):<> int(sgn(i))

(* ****** ****** *)
//
// HX: for unsigned unindexed integer types
//
(* ****** ****** *)

fun{
k1,k2:tk
} g0int2uint (x: g0int (k1)):<> g0uint (k2)
//
fun g0int2uint_int_uint (x: int):<> uint = "mac#%"
fun g0int2uint_int_ulint (x: int):<> ulint = "mac#%"
fun g0int2uint_int_ullint (x: int):<> ullint = "mac#%"
fun g0int2uint_int_size (x: int):<> size_t = "mac#%"
//
fun g0int2uint_lint_ulint (x: lint):<> ulint = "mac#%"
fun g0int2uint_lint_ullint (x: lint):<> ullint = "mac#%"
fun g0int2uint_lint_size (x: lint):<> size_t = "mac#%"
//
fun g0int2uint_llint_ullint (x: llint):<> ullint = "mac#%"
//
fun g0int2uint_ssize_size (x: ssize_t):<> size_t = "mac#%"
//
(* ****** ****** *)

fun{
k1,k2:tk
} g0uint2int (x: g0uint (k1)):<> g0int (k2)
//
fun g0uint2int_uint_int (x: uint):<> int = "mac#%"
fun g0uint2int_uint_lint (x: uint):<> lint = "mac#%"
fun g0uint2int_uint_llint (x: uint):<> llint = "mac#%"
fun g0uint2int_uint_ssize (x: uint):<> ssize_t = "mac#%"
//
fun g0uint2int_size_int (x: size_t):<> int = "mac#%"
fun g0uint2int_size_lint (x: size_t):<> lint = "mac#%"
fun g0uint2int_size_llint (x: size_t):<> llint = "mac#%"
fun g0uint2int_size_ssize (x: size_t):<> ssize_t = "mac#%"
//
(* ****** ****** *)

fun{
k1,k2:tk
} g0uint2uint (x: g0uint (k1)):<> g0uint (k2)
//
fun g0uint2uint_uint_uint (x: uint):<> uint = "mac#%"
fun g0uint2uint_uint_ulint (x: uint):<> ulint = "mac#%"
fun g0uint2uint_uint_ullint (x: uint):<> ullint = "mac#%"
fun g0uint2uint_uint_size (x: uint):<> size_t = "mac#%"
//
fun g0uint2uint_ulint_uint (x: ulint):<> uint = "mac#%"
fun g0uint2uint_ulint_ulint (x: ulint):<> ulint = "mac#%"
fun g0uint2uint_ulint_ullint (x: ulint):<> ullint = "mac#%"
fun g0uint2uint_ulint_size (x: ulint):<> size_t = "mac#%"
//
fun g0uint2uint_size_uint (x: size_t):<> uint = "mac#%"
fun g0uint2uint_size_ulint (x: size_t):<> ulint = "mac#%"
fun g0uint2uint_size_ullint (x: size_t):<> ullint = "mac#%"
fun g0uint2uint_size_size (x: size_t):<> size_t = "mac#%"
//
fun g0uint2uint_usint_uint (x: usint):<> uint = "mac#%"
//
(* ****** ****** *)

fun{tk:tk}
g0string2uint (str: NSH(string)):<> g0uint (tk)
//
fun g0string2uint_uint (x: NSH(string)):<> uint = "mac#%"
fun g0string2uint_ulint (x: NSH(string)):<> ulint = "mac#%"
fun g0string2uint_ullint (x: NSH(string)):<> ullint = "mac#%"
fun g0string2uint_size (x: NSH(string)):<> size_t = "mac#%"
//
(* ****** ****** *)

fun{tk:tk}
g0uint_succ (x: g0uint (tk)):<> g0uint (tk)
overload succ with g0uint_succ of 0
fun{tk:tk}
g0uint_pred (x: g0uint (tk)):<> g0uint (tk)
overload pred with g0uint_pred of 0

fun{tk:tk}
g0uint_half (x: g0uint (tk)):<> g0uint (tk)
overload half with g0uint_half of 0

(*
fun{tk:tk}
g0uint_double (x: g0uint (tk)):<> g0uint (tk)
overload double with g0uint_double of 0
*)

(* ****** ****** *)

fun{
tk:tk
} g0uint_add
  (x: g0uint (tk), y: g0uint (tk)):<> g0uint (tk)
overload + with g0uint_add of 0
fun{
tk:tk
} g0uint_sub
  (x: g0uint (tk), y: g0uint (tk)):<> g0uint (tk)
overload - with g0uint_sub of 0
fun{
tk:tk
} g0uint_mul
  (x: g0uint (tk), y: g0uint (tk)):<> g0uint (tk)
overload * with g0uint_mul of 0
fun{
tk:tk
} g0uint_div
  (x: g0uint (tk), y: g0uint (tk)):<> g0uint (tk)
overload / with g0uint_div of 0
fun{
tk:tk
} g0uint_mod
  (x: g0uint (tk), y: g0uint (tk)):<> g0uint (tk)
overload % with g0uint_mod of 0
overload mod with g0uint_mod of 0

(* ****** ****** *)

fun
{tk:tk}
g0uint_lsl (x: g0uint (tk), n: intGte(0)):<> g0uint (tk)
overload << with g0uint_lsl
fun
{tk:tk}
g0uint_lsr (x: g0uint (tk), n: intGte(0)):<> g0uint (tk)
overload >> with g0uint_lsr

(* ****** ****** *)

fun
{tk:tk}
g0uint_lnot (x: g0uint (tk)):<> g0uint (tk)
overload ~ with g0uint_lnot
overload lnot with g0uint_lnot
fun
{tk:tk}
g0uint_lor (x: g0uint (tk), y: g0uint (tk)):<> g0uint (tk)
overload lor with g0uint_lor
fun
{tk:tk}
g0uint_lxor (x: g0uint (tk), y: g0uint (tk)):<> g0uint (tk)
overload lxor with g0uint_lxor
fun
{tk:tk}
g0uint_land (x: g0uint (tk), y: g0uint (tk)):<> g0uint (tk)
overload land with g0uint_land

(* ****** ****** *)

fun{tk:tk}
g0uint_isgtz (x: g0uint (tk)):<> bool
overload isgtz with g0uint_isgtz of 0
fun{tk:tk}
g0uint_iseqz (x: g0uint (tk)):<> bool
overload iseqz with g0uint_iseqz of 0
fun{tk:tk}
g0uint_isneqz (x: g0uint (tk)):<> bool
overload isneqz with g0uint_isneqz of 0

(* ****** ****** *)

fun{
tk:tk
} g0uint_lt
  (x: g0uint (tk), y: g0uint (tk)):<> bool
overload < with g0uint_lt of 0
fun{
tk:tk
} g0uint_lte
  (x: g0uint (tk), y: g0uint (tk)):<> bool
overload <= with g0uint_lte of 0

fun{
tk:tk
} g0uint_gt
  (x: g0uint (tk), y: g0uint (tk)):<> bool
overload > with g0uint_gt of 0
fun{
tk:tk
} g0uint_gte
  (x: g0uint (tk), y: g0uint (tk)):<> bool
overload >= with g0uint_gte of 0

fun{
tk:tk
} g0uint_eq
  (x: g0uint (tk), y: g0uint (tk)):<> bool
overload = with g0uint_eq of 0
fun{
tk:tk
} g0uint_neq
  (x: g0uint (tk), y: g0uint (tk)):<> bool
overload != with g0uint_neq of 0
overload <> with g0uint_neq of 0

fun{tk:tk}
g0uint_compare (x: g0uint (tk), y: g0uint (tk)):<> int
overload compare with g0uint_compare of 0

(* ****** ****** *)

fun
{tk:tk}
g0uint_max
  (x: g0uint (tk), y: g0uint (tk)):<> g0uint (tk)
overload max with g0uint_max of 0

fun
{tk:tk}
g0uint_min
  (x: g0uint (tk), y: g0uint (tk)):<> g0uint (tk)
overload min with g0uint_min of 0

(* ****** ****** *)

fun{tk:tk}
lt_g0uint_int (x: g0uint (tk), y: int):<> bool
overload < with lt_g0uint_int of 11
fun{tk:tk}
lte_g0uint_int (x: g0uint (tk), y: int):<> bool
overload <= with lte_g0uint_int of 11

fun{tk:tk}
gt_g0uint_int (x: g0uint (tk), y: int):<> bool
overload > with gt_g0uint_int of 11
fun{tk:tk}
gte_g0uint_int (x: g0uint (tk), y: int):<> bool
overload >= with gte_g0uint_int of 11

fun{tk:tk}
eq_g0uint_int (x: g0uint (tk), y: int):<> bool
overload = with eq_g0uint_int of 11
fun{tk:tk}
neq_g0uint_int (x: g0uint (tk), y: int):<> bool
overload != with neq_g0uint_int of 11
overload <> with neq_g0uint_int of 11

(* ****** ****** *)
//
// HX: for unsigned indexed integer types
//
praxi
lemma_g1uint_param
  {tk:tk} {i:int} (x: g1uint (tk, i)):<> [i >= 0] void
// end of [lemma_g1uint_param]

(* ****** ****** *)

castfn
size_of_int {i:nat} (x: int i):<> size_t (i)
castfn
ssize_of_int {i:int} (x: int i):<> ssize_t (i)

(* ****** ****** *)
//
castfn
g0ofg1_uint {tk:tk} (x: g1uint tk):<> g0uint (tk)
castfn
g1ofg0_uint {tk:tk} (x: g0uint tk):<> g1uint0 (tk)
//
overload g0ofg1 with g0ofg1_uint // index-erasing
overload g1ofg0 with g1ofg0_uint // index-inducing
//
(* ****** ****** *)
//
fun{
k1,k2:tk
} g1int2uint // i2u
  {i:nat} (x: g1int (k1, i)):<> g1uint (k2, i)
//
fun g1int2uint_int_uint{i:nat} (x: int i):<> uint (i) = "mac#%"
fun g1int2uint_int_ulint{i:nat} (x: int i):<> ulint (i) = "mac#%"
fun g1int2uint_int_ullint{i:nat} (x: int i):<> ullint (i) = "mac#%"
fun g1int2uint_int_size{i:nat} (x: int i):<> size_t (i) = "mac#%"
//
fun g1int2uint_ssize_size{i:nat} (x: ssize_t(i)):<> size_t(i) = "mac#%"
//
(* ****** ****** *)

typedef
g1uint2int_type
  (k1:tk, k2:tk) = 
  {u:int} (g1uint (k1, u)) -<fun0> [u>=0] g1int (k2, u)
//
fun{
k1,k2:tk
} g1uint2int : g1uint2int_type (k1, k2)
//
fun g1uint2int_uint_int : g1uint2int_type (uintknd, intknd) = "mac#%"
fun g1uint2int_uint_lint : g1uint2int_type (uintknd, lintknd) = "mac#%"
fun g1uint2int_uint_llint : g1uint2int_type (uintknd, llintknd) = "mac#%"
fun g1uint2int_uint_ssize : g1uint2int_type (uintknd, ssizeknd) = "mac#%"
//
fun g1uint2int_size_int : g1uint2int_type (sizeknd, intknd) = "mac#%"
fun g1uint2int_size_lint : g1uint2int_type (sizeknd, lintknd) = "mac#%"
fun g1uint2int_size_llint : g1uint2int_type (sizeknd, llintknd) = "mac#%"
fun g1uint2int_size_ssize : g1uint2int_type (sizeknd, ssizeknd) = "mac#%"
//
(* ****** ****** *)
//
typedef
g1uint2uint_type
  (k1:tk, k2:tk) =
  {u:int} (g1uint (k1, u)) -<fun0> g1uint (k2, u)
//
fun{
k1,k2:tk
} g1uint2uint : g1uint2uint_type (k1, k2)
//
fun g1uint2uint_uint_uint : g1uint2uint_type (uintknd, uintknd) = "mac#%"
fun g1uint2uint_uint_ulint : g1uint2uint_type (uintknd, ulintknd) = "mac#%"
fun g1uint2uint_uint_ullint : g1uint2uint_type (uintknd, ullintknd) = "mac#%"
fun g1uint2uint_uint_size : g1uint2uint_type (uintknd, sizeknd) = "mac#%"
//
fun g1uint2uint_ulint_uint : g1uint2uint_type (uintknd, uintknd) = "mac#%"
fun g1uint2uint_ulint_ulint : g1uint2uint_type (uintknd, ulintknd) = "mac#%"
fun g1uint2uint_ulint_ullint : g1uint2uint_type (uintknd, ullintknd) = "mac#%"
fun g1uint2uint_ulint_size : g1uint2uint_type (uintknd, sizeknd) = "mac#%"
//
fun g1uint2uint_size_uint : g1uint2uint_type (sizeknd, uintknd) = "mac#%"
fun g1uint2uint_size_ulint : g1uint2uint_type (sizeknd, ulintknd) = "mac#%"
fun g1uint2uint_size_ullint : g1uint2uint_type (sizeknd, ullintknd) = "mac#%"
fun g1uint2uint_size_size : g1uint2uint_type (sizeknd, sizeknd) = "mac#%"
//
(* ****** ****** *)

fun{tk:tk}
g1string2uint (str: NSH(string)):<> g1uint (tk)

(* ****** ****** *)

prfun
g1uint_get_index
  {tk:tk}{i1:int}
  (x: g1uint (tk, i1)): [i2:int] EQINT (i1, i2)
// end of [g1uint_get_index]

(* ****** ****** *)
//
typedef
g1uint_succ_type
  (tk:tk) =
  {i:int}
  (g1uint (tk, i)) -<fun0> g1uint (tk, i+1)
typedef
g1uint_pred_type
  (tk:tk) =
  {i:int | i > 0}
  (g1uint (tk, i)) -<fun0> g1uint (tk, i-1)
//
fun{tk:tk}
g1uint_succ : g1uint_succ_type(tk)
overload succ with g1uint_succ of 10
fun{tk:tk}
g1uint_pred : g1uint_pred_type(tk)
overload pred with g1uint_pred of 10
//
(* ****** ****** *)

typedef
g1uint_half_type (tk:tk) =
  {i:int} (g1uint (tk, i)) -<fun0> g1uint (tk, i/2)
fun{tk:tk}
g1uint_half : g1uint_half_type(tk)
overload half with g1uint_half of 10

(*
typedef
g1uint_double_type (tk:tk) =
  {i:int} (g1uint (tk, i)) -<fun0> g1uint (tk, 2*i)
fun{tk:tk}
g1uint_double : g1uint_double_type(tk)
overload double with g1uint_double of 10
*)

(* ****** ****** *)

typedef
g1uint_add_type
  (tk:tk) =
  {i,j:int}
  (g1uint (tk, i), g1uint (tk, j)) -<fun0> g1uint (tk, i+j)
fun
{tk:tk}
g1uint_add : g1uint_add_type(tk)
overload + with g1uint_add of 20

typedef
g1uint_sub_type
  (tk:tk) =
  {i,j:int | i >= j}
  (g1uint (tk, i), g1uint (tk, j)) -<fun0> g1uint (tk, i-j)
fun
{tk:tk}
g1uint_sub : g1uint_sub_type(tk)
overload - with g1uint_sub of 20

(* ****** ****** *)

typedef
g1uint_mul_type
  (tk:tk) =
  {i,j:int}
  (g1uint (tk, i), g1uint (tk, j)) -<fun0> g1uint (tk, i*j)
fun
{tk:tk}
g1uint_mul : g1uint_mul_type(tk)
overload * with g1uint_mul of 20

fun
{tk:tk}
g1uint_mul2 {i,j:int}
(
  x: g1uint (tk, i), y: g1uint (tk, j)
) :<> [ij:int] (MUL (i, j, ij) | g1uint (tk, ij))

(* ****** ****** *)

typedef
g1uint_div_type
  (tk:tk) =
  {i,j:int | j > 0}
  (g1uint (tk, i), g1uint (tk, j)) -<fun0> g1uint (tk)
// end of [g1uint_div_type]

fun
{tk:tk}
g1uint_div : g1uint_div_type(tk)
overload / with g1uint_div of 20

fun
{tk:tk}
g1uint_div2 {i,j:int | j > 0}
(
  x: g1uint (tk, i), y: g1uint (tk, j)
) :<> [q,r:int | 0 <= r; r < j] (DIVMOD (i, j, q, r) | g1uint (tk, q))

(* ****** ****** *)

typedef
g1uint_mod_type
  (tk:tk) =
  {i,j:int | j > 0}
  (g1uint (tk, i), g1uint (tk, j)) -<fun0> [r:nat | r < j] g1uint (tk, r)
// end of [g1uint_mod_type]

fun
{tk:tk}
g1uint_mod : g1uint_mod_type(tk)
overload mod with g1uint_mod of 20

fun
{tk:tk}
g1uint_mod2
  {i,j:int | j > 0}
(
  x: g1uint (tk, i), y: g1uint (tk, j)
) :<>
[
  q,r:int | 0 <= r; r < j
] (
  DIVMOD (i, j, q, r) | g1uint (tk, r)
) // end of [g1uint_mod2]

(* ****** ****** *)

typedef
g1uint_isgtz_type (tk:tk) =
  {i:int} (g1uint (tk, i)) -<fun0> bool (i > 0)
fun{tk:tk}
g1uint_isgtz : g1uint_isgtz_type(tk)
overload isgtz with g1uint_isgtz of 10

(* ****** ****** *)

typedef
g1uint_iseqz_type (tk:tk) =
  {i:int} (g1uint (tk, i)) -<fun0> bool (i > 0)
typedef
g1uint_isneqz_type (tk:tk) =
  {i:int} (g1uint (tk, i)) -<fun0> bool (i >= 0)
fun{tk:tk}
g1uint_iseqz : g1uint_iseqz_type(tk)
overload iseqz with g1uint_iseqz of 10
fun{tk:tk}
g1uint_isneqz : g1uint_isneqz_type(tk)
overload isneqz with g1uint_isneqz of 10

(* ****** ****** *)

typedef
g1uint_lt_type (tk:tk) =
  {i,j:int} (g1uint (tk, i), g1uint (tk, j)) -<fun0> bool (i < j)
fun{tk:tk}
g1uint_lt : g1uint_lt_type(tk)
overload < with g1uint_lt of 20
typedef
g1uint_lte_type (tk:tk) =
  {i,j:int} (g1uint (tk, i), g1uint (tk, j)) -<fun0> bool (i <= j)
fun{tk:tk}
g1uint_lte : g1uint_lte_type(tk)
overload <= with g1uint_lte of 20

(* ****** ****** *)

typedef
g1uint_gt_type (tk:tk) =
  {i,j:int} (g1uint (tk, i), g1uint (tk, j)) -<fun0> bool (i > j)
fun
{tk:tk}
g1uint_gt : g1uint_gt_type(tk)
overload > with g1uint_gt of 20
typedef
g1uint_gte_type (tk:tk) =
  {i,j:int} (g1uint (tk, i), g1uint (tk, j)) -<fun0> bool (i >= j)
fun
{tk:tk}
g1uint_gte : g1uint_gte_type(tk)
overload >= with g1uint_gte of 20

(* ****** ****** *)
//
typedef
g1uint_eq_type
  (tk:tk) =
  {i,j:int}
  (g1uint (tk, i), g1uint (tk, j)) -<fun0> bool (i == j)
typedef
g1uint_neq_type
  (tk:tk) =
  {i,j:int}
  (g1uint (tk, i), g1uint (tk, j)) -<fun0> bool (i != j)
//
fun
{tk:tk}
g1uint_eq : g1uint_eq_type(tk)
overload = with g1uint_eq of 20
fun
{tk:tk}
g1uint_neq : g1uint_neq_type(tk)
overload != with g1uint_neq of 20
overload <> with g1uint_neq of 20
//
(* ****** ****** *)

typedef
g1uint_compare_type
  (tk:tk) =
  {i,j:int}
  (g1uint (tk, i), g1uint (tk, j)) -<fun0> int (sgn(i-j))
fun{tk:tk}
g1uint_compare : g1uint_compare_type(tk)
overload compare with g1uint_compare of 20

(* ****** ****** *)

typedef
g1uint_max_type
  (tk:tk) =
  {i,j:int}
  (g1uint (tk, i), g1uint (tk, j)) -<fun0> g1uint (tk, max(i, j))
fun
{tk:tk}
g1uint_max : g1uint_max_type(tk)
overload max with g1uint_max of 20

typedef
g1uint_min_type
  (tk:tk) =
  {i,j:int}
  (g1uint (tk, i), g1uint (tk, j)) -<fun0> g1uint (tk, min(i, j))
fun
{tk:tk}
g1uint_min : g1uint_min_type(tk)
overload min with g1uint_min of 20

(* ****** ****** *)
//
fun{tk:tk}
lt_g1uint_int {i:int;j:nat}
  (x: g1uint (tk, i), y: int (j)):<> bool (i < j)
overload < with lt_g1uint_int of 21
fun{tk:tk}
lte_g1uint_int {i:int;j:nat}
  (x: g1uint (tk, i), y: int (j)):<> bool (i <= j)
overload <= with lte_g1uint_int of 21
//
fun{tk:tk}
gt_g1uint_int {i:int;j:nat}
  (x: g1uint (tk, i), y: int (j)):<> bool (i > j)
overload > with gt_g1uint_int of 21
fun{tk:tk}
gte_g1uint_int {i:int;j:nat}
  (x: g1uint (tk, i), y: int (j)):<> bool (i >= j)
overload >= with gte_g1uint_int of 21
//
fun{tk:tk}
eq_g1uint_int {i:int;j:nat}
  (x: g1uint (tk, i), y: int (j)):<> bool (i == j)
overload = with eq_g1uint_int of 21
fun{tk:tk}
neq_g1uint_int {i:int;j:nat}
  (x: g1uint (tk, i), y: int (j)):<> bool (i != j)
overload != with neq_g1uint_int of 21
//
(* ****** ****** *)
//
fun g0int_neg_int (x: int):<> int = "mac#%"
fun g0int_abs_int (x: int):<> int = "mac#%"
fun g0int_succ_int (x: int):<> int = "mac#%"
fun g0int_pred_int (x: int):<> int = "mac#%"
fun g0int_half_int (x: int):<> int = "mac#%"
fun g0int_asl_int (x: int, n: intGte(0)):<> int = "mac#%"
fun g0int_asr_int (x: int, n: intGte(0)):<> int = "mac#%"
fun g0int_add_int (x: int, y: int):<> int = "mac#%"
fun g0int_sub_int (x: int, y: int):<> int = "mac#%"
fun g0int_mul_int (x: int, y: int):<> int = "mac#%"
fun g0int_div_int (x: int, y: int):<> int = "mac#%"
fun g0int_mod_int (x: int, y: int):<> int = "mac#%"
fun g0int_isltz_int (x: int):<> bool = "mac#%"
fun g0int_isltez_int (x: int):<> bool = "mac#%"
fun g0int_isgtz_int (x: int):<> bool = "mac#%"
fun g0int_isgtez_int (x: int):<> bool = "mac#%"
fun g0int_iseqz_int (x: int):<> bool = "mac#%"
fun g0int_isneqz_int (x: int):<> bool = "mac#%"
fun g0int_lt_int (x: int, y: int):<> bool = "mac#%"
fun g0int_lte_int (x: int, y: int):<> bool = "mac#%"
fun g0int_gt_int (x: int, y: int):<> bool = "mac#%"
fun g0int_gte_int (x: int, y: int):<> bool = "mac#%"
fun g0int_eq_int (x: int, y: int):<> bool = "mac#%"
fun g0int_neq_int (x: int, y: int):<> bool = "mac#%"
fun g0int_compare_int (x: int, y: int):<> int = "mac#%"
fun g0int_max_int (x: int, y: int):<> int = "mac#%"
fun g0int_min_int (x: int, y: int):<> int = "mac#%"
//
fun g0int_neg_lint (x: lint):<> lint = "mac#%"
fun g0int_abs_lint (x: lint):<> lint = "mac#%"
fun g0int_succ_lint (x: lint):<> lint = "mac#%"
fun g0int_pred_lint (x: lint):<> lint = "mac#%"
fun g0int_half_lint (x: lint):<> lint = "mac#%"
fun g0int_asl_lint (x: lint, n: intGte(0)):<> lint = "mac#%"
fun g0int_asr_lint (x: lint, n: intGte(0)):<> lint = "mac#%"
fun g0int_add_lint (x: lint, y: lint):<> lint = "mac#%"
fun g0int_sub_lint (x: lint, y: lint):<> lint = "mac#%"
fun g0int_mul_lint (x: lint, y: lint):<> lint = "mac#%"
fun g0int_div_lint (x: lint, y: lint):<> lint = "mac#%"
fun g0int_mod_lint (x: lint, y: lint):<> lint = "mac#%"
fun g0int_isltz_lint (x: lint):<> bool = "mac#%"
fun g0int_isltez_lint (x: lint):<> bool = "mac#%"
fun g0int_isgtz_lint (x: lint):<> bool = "mac#%"
fun g0int_isgtez_lint (x: lint):<> bool = "mac#%"
fun g0int_iseqz_lint (x: lint):<> bool = "mac#%"
fun g0int_isneqz_lint (x: lint):<> bool = "mac#%"
fun g0int_lt_lint (x: lint, y: lint):<> bool = "mac#%"
fun g0int_lte_lint (x: lint, y: lint):<> bool = "mac#%"
fun g0int_gt_lint (x: lint, y: lint):<> bool = "mac#%"
fun g0int_gte_lint (x: lint, y: lint):<> bool = "mac#%"
fun g0int_eq_lint (x: lint, y: lint):<> bool = "mac#%"
fun g0int_neq_lint (x: lint, y: lint):<> bool = "mac#%"
fun g0int_compare_lint (x: lint, y: lint):<> int = "mac#%"
fun g0int_max_lint (x: lint, y: lint):<> lint = "mac#%"
fun g0int_min_lint (x: lint, y: lint):<> lint = "mac#%"
//
fun g0int_neg_llint (x: llint):<> llint = "mac#%"
fun g0int_abs_llint (x: llint):<> llint = "mac#%"
fun g0int_succ_llint (x: llint):<> llint = "mac#%"
fun g0int_pred_llint (x: llint):<> llint = "mac#%"
fun g0int_half_llint (x: llint):<> llint = "mac#%"
fun g0int_asl_llint (x: llint, n: intGte(0)):<> llint = "mac#%"
fun g0int_asr_llint (x: llint, n: intGte(0)):<> llint = "mac#%"
fun g0int_add_llint (x: llint, y: llint):<> llint = "mac#%"
fun g0int_sub_llint (x: llint, y: llint):<> llint = "mac#%"
fun g0int_mul_llint (x: llint, y: llint):<> llint = "mac#%"
fun g0int_div_llint (x: llint, y: llint):<> llint = "mac#%"
fun g0int_mod_llint (x: llint, y: llint):<> llint = "mac#%"
fun g0int_isltz_llint (x: llint):<> bool = "mac#%"
fun g0int_isltez_llint (x: llint):<> bool = "mac#%"
fun g0int_isgtz_llint (x: llint):<> bool = "mac#%"
fun g0int_isgtez_llint (x: llint):<> bool = "mac#%"
fun g0int_iseqz_llint (x: llint):<> bool = "mac#%"
fun g0int_isneqz_llint (x: llint):<> bool = "mac#%"
fun g0int_lt_llint (x: llint, y: llint):<> bool = "mac#%"
fun g0int_lte_llint (x: llint, y: llint):<> bool = "mac#%"
fun g0int_gt_llint (x: llint, y: llint):<> bool = "mac#%"
fun g0int_gte_llint (x: llint, y: llint):<> bool = "mac#%"
fun g0int_eq_llint (x: llint, y: llint):<> bool = "mac#%"
fun g0int_neq_llint (x: llint, y: llint):<> bool = "mac#%"
fun g0int_compare_llint (x: llint, y: llint):<> int = "mac#%"
fun g0int_max_llint (x: llint, y: llint):<> llint = "mac#%"
fun g0int_min_llint (x: llint, y: llint):<> llint = "mac#%"
//
fun g0int_neg_ssize (x: ssize_t):<> ssize_t = "mac#%"
fun g0int_abs_ssize (x: ssize_t):<> ssize_t = "mac#%"
fun g0int_succ_ssize (x: ssize_t):<> ssize_t = "mac#%"
fun g0int_pred_ssize (x: ssize_t):<> ssize_t = "mac#%"
fun g0int_half_ssize (x: ssize_t):<> ssize_t = "mac#%"
fun g0int_asl_ssize (x: ssize_t, n: intGte(0)):<> ssize_t = "mac#%"
fun g0int_asr_ssize (x: ssize_t, n: intGte(0)):<> ssize_t = "mac#%"
fun g0int_add_ssize (x: ssize_t, y: ssize_t):<> ssize_t = "mac#%"
fun g0int_sub_ssize (x: ssize_t, y: ssize_t):<> ssize_t = "mac#%"
fun g0int_mul_ssize (x: ssize_t, y: ssize_t):<> ssize_t = "mac#%"
fun g0int_div_ssize (x: ssize_t, y: ssize_t):<> ssize_t = "mac#%"
fun g0int_mod_ssize (x: ssize_t, y: ssize_t):<> ssize_t = "mac#%"
fun g0int_isltz_ssize (x: ssize_t):<> bool = "mac#%"
fun g0int_isltez_ssize (x: ssize_t):<> bool = "mac#%"
fun g0int_isgtz_ssize (x: ssize_t):<> bool = "mac#%"
fun g0int_isgtez_ssize (x: ssize_t):<> bool = "mac#%"
fun g0int_iseqz_ssize (x: ssize_t):<> bool = "mac#%"
fun g0int_isneqz_ssize (x: ssize_t):<> bool = "mac#%"
fun g0int_lt_ssize (x: ssize_t, y: ssize_t):<> bool = "mac#%"
fun g0int_lte_ssize (x: ssize_t, y: ssize_t):<> bool = "mac#%"
fun g0int_gt_ssize (x: ssize_t, y: ssize_t):<> bool = "mac#%"
fun g0int_gte_ssize (x: ssize_t, y: ssize_t):<> bool = "mac#%"
fun g0int_eq_ssize (x: ssize_t, y: ssize_t):<> bool = "mac#%"
fun g0int_neq_ssize (x: ssize_t, y: ssize_t):<> bool = "mac#%"
fun g0int_compare_ssize (x: ssize_t, y: ssize_t):<> int = "mac#%"
fun g0int_max_ssize (x: ssize_t, y: ssize_t):<> ssize_t = "mac#%"
fun g0int_min_ssize (x: ssize_t, y: ssize_t):<> ssize_t = "mac#%"
//
(* ****** ****** *)
//
fun fprint_int
  : fprint_type (int) = "mac#%"
overload fprint with fprint_int
fun print_int (x: int): void = "mac#%"
fun prerr_int (x: int): void = "mac#%"
overload print with print_int
overload prerr with prerr_int
//
fun fprint_lint
  : fprint_type (lint) = "mac#%"
overload fprint with fprint_lint
fun print_lint (x: lint): void = "mac#%"
fun prerr_lint (x: lint): void = "mac#%"
overload print with print_lint
overload prerr with prerr_lint
//
fun fprint_llint
  : fprint_type (llint) = "mac#%"
overload fprint with fprint_llint
fun print_llint (x: llint): void = "mac#%"
fun prerr_llint (x: llint): void = "mac#%"
overload print with print_llint
overload prerr with prerr_llint
//
fun fprint_ssize
  : fprint_type (ssize_t) = "mac#%"
overload fprint with fprint_ssize
fun print_ssize (x: ssize_t): void = "mac#%"
fun prerr_ssize (x: ssize_t): void = "mac#%"
overload print with print_ssize
overload prerr with prerr_ssize
//
(* ****** ****** *)
//
fun g0uint_succ_uint (x: uint):<> uint = "mac#%"
fun g0uint_pred_uint (x: uint):<> uint = "mac#%"
fun g0uint_half_uint (x: uint):<> uint = "mac#%"
fun g0uint_add_uint (x: uint, y: uint):<> uint = "mac#%"
fun g0uint_sub_uint (x: uint, y: uint):<> uint = "mac#%"
fun g0uint_mul_uint (x: uint, y: uint):<> uint = "mac#%"
fun g0uint_div_uint (x: uint, y: uint):<> uint = "mac#%"
fun g0uint_mod_uint (x: uint, y: uint):<> uint = "mac#%"
fun g0uint_lsl_uint (x: uint, n: intGte(0)):<> uint = "mac#%"
fun g0uint_lsr_uint (x: uint, n: intGte(0)):<> uint = "mac#%"
fun g0uint_lnot_uint (x: uint):<> uint = "mac#%"
fun g0uint_lor_uint (x: uint, y: uint):<> uint = "mac#%"
fun g0uint_lxor_uint (x: uint, y: uint):<> uint = "mac#%"
fun g0uint_land_uint (x: uint, y: uint):<> uint = "mac#%"
fun g0uint_isgtz_uint (x: uint):<> bool = "mac#%"
fun g0uint_iseqz_uint (x: uint):<> bool = "mac#%"
fun g0uint_isneqz_uint (x: uint):<> bool = "mac#%"
fun g0uint_lt_uint (x: uint, y: uint):<> bool = "mac#%"
fun g0uint_lte_uint (x: uint, y: uint):<> bool = "mac#%"
fun g0uint_gt_uint (x: uint, y: uint):<> bool = "mac#%"
fun g0uint_gte_uint (x: uint, y: uint):<> bool = "mac#%"
fun g0uint_eq_uint (x: uint, y: uint):<> bool = "mac#%"
fun g0uint_neq_uint (x: uint, y: uint):<> bool = "mac#%"
fun g0uint_compare_uint (x: uint, y: uint):<> int = "mac#%"
fun g0uint_max_uint (x: uint, y: uint):<> uint = "mac#%"
fun g0uint_min_uint (x: uint, y: uint):<> uint = "mac#%"
//
fun g0uint_succ_ulint (x: ulint):<> ulint = "mac#%"
fun g0uint_pred_ulint (x: ulint):<> ulint = "mac#%"
fun g0uint_half_ulint (x: ulint):<> ulint = "mac#%"
fun g0uint_add_ulint (x: ulint, y: ulint):<> ulint = "mac#%"
fun g0uint_sub_ulint (x: ulint, y: ulint):<> ulint = "mac#%"
fun g0uint_mul_ulint (x: ulint, y: ulint):<> ulint = "mac#%"
fun g0uint_div_ulint (x: ulint, y: ulint):<> ulint = "mac#%"
fun g0uint_mod_ulint (x: ulint, y: ulint):<> ulint = "mac#%"
fun g0uint_lsl_ulint (x: ulint, n: intGte(0)):<> ulint = "mac#%"
fun g0uint_lsr_ulint (x: ulint, n: intGte(0)):<> ulint = "mac#%"
fun g0uint_lnot_ulint (x: ulint):<> ulint = "mac#%"
fun g0uint_lor_ulint (x: ulint, y: ulint):<> ulint = "mac#%"
fun g0uint_lxor_ulint (x: ulint, y: ulint):<> ulint = "mac#%"
fun g0uint_land_ulint (x: ulint, y: ulint):<> ulint = "mac#%"
fun g0uint_isgtz_ulint (x: ulint):<> bool = "mac#%"
fun g0uint_iseqz_ulint (x: ulint):<> bool = "mac#%"
fun g0uint_isneqz_ulint (x: ulint):<> bool = "mac#%"
fun g0uint_lt_ulint (x: ulint, y: ulint):<> bool = "mac#%"
fun g0uint_lte_ulint (x: ulint, y: ulint):<> bool = "mac#%"
fun g0uint_gt_ulint (x: ulint, y: ulint):<> bool = "mac#%"
fun g0uint_gte_ulint (x: ulint, y: ulint):<> bool = "mac#%"
fun g0uint_eq_ulint (x: ulint, y: ulint):<> bool = "mac#%"
fun g0uint_neq_ulint (x: ulint, y: ulint):<> bool = "mac#%"
fun g0uint_compare_ulint (x: ulint, y: ulint):<> int = "mac#%"
fun g0uint_max_ulint (x: ulint, y: ulint):<> ulint = "mac#%"
fun g0uint_min_ulint (x: ulint, y: ulint):<> ulint = "mac#%"
//
fun g0uint_succ_ullint (x: ullint):<> ullint = "mac#%"
fun g0uint_pred_ullint (x: ullint):<> ullint = "mac#%"
fun g0uint_half_ullint (x: ullint):<> ullint = "mac#%"
fun g0uint_add_ullint (x: ullint, y: ullint):<> ullint = "mac#%"
fun g0uint_sub_ullint (x: ullint, y: ullint):<> ullint = "mac#%"
fun g0uint_mul_ullint (x: ullint, y: ullint):<> ullint = "mac#%"
fun g0uint_div_ullint (x: ullint, y: ullint):<> ullint = "mac#%"
fun g0uint_mod_ullint (x: ullint, y: ullint):<> ullint = "mac#%"
fun g0uint_lsl_ullint (x: ullint, n: intGte(0)):<> ullint = "mac#%"
fun g0uint_lsr_ullint (x: ullint, n: intGte(0)):<> ullint = "mac#%"
fun g0uint_lnot_ullint (x: ullint):<> ullint = "mac#%"
fun g0uint_lor_ullint (x: ullint, y: ullint):<> ullint = "mac#%"
fun g0uint_lxor_ullint (x: ullint, y: ullint):<> ullint = "mac#%"
fun g0uint_land_ullint (x: ullint, y: ullint):<> ullint = "mac#%"
fun g0uint_isgtz_ullint (x: ullint):<> bool = "mac#%"
fun g0uint_iseqz_ullint (x: ullint):<> bool = "mac#%"
fun g0uint_isneqz_ullint (x: ullint):<> bool = "mac#%"
fun g0uint_lt_ullint (x: ullint, y: ullint):<> bool = "mac#%"
fun g0uint_lte_ullint (x: ullint, y: ullint):<> bool = "mac#%"
fun g0uint_gt_ullint (x: ullint, y: ullint):<> bool = "mac#%"
fun g0uint_gte_ullint (x: ullint, y: ullint):<> bool = "mac#%"
fun g0uint_eq_ullint (x: ullint, y: ullint):<> bool = "mac#%"
fun g0uint_neq_ullint (x: ullint, y: ullint):<> bool = "mac#%"
fun g0uint_compare_ullint (x: ullint, y: ullint):<> int = "mac#%"
fun g0uint_max_ullint (x: ullint, y: ullint):<> ullint = "mac#%"
fun g0uint_min_ullint (x: ullint, y: ullint):<> ullint = "mac#%"
//
fun g0uint_succ_size (x: size_t):<> size_t = "mac#%"
fun g0uint_pred_size (x: size_t):<> size_t = "mac#%"
fun g0uint_half_size (x: size_t):<> size_t = "mac#%"
fun g0uint_add_size (x: size_t, y: size_t):<> size_t = "mac#%"
fun g0uint_sub_size (x: size_t, y: size_t):<> size_t = "mac#%"
fun g0uint_mul_size (x: size_t, y: size_t):<> size_t = "mac#%"
fun g0uint_div_size (x: size_t, y: size_t):<> size_t = "mac#%"
fun g0uint_mod_size (x: size_t, y: size_t):<> size_t = "mac#%"
fun g0uint_lsl_size (x: size_t, n: intGte(0)):<> size_t = "mac#%"
fun g0uint_lsr_size (x: size_t, n: intGte(0)):<> size_t = "mac#%"
fun g0uint_lnot_size (x: size_t):<> size_t = "mac#%"
fun g0uint_lor_size (x: size_t, y: size_t):<> size_t = "mac#%"
fun g0uint_lxor_size (x: size_t, y: size_t):<> size_t = "mac#%"
fun g0uint_land_size (x: size_t, y: size_t):<> size_t = "mac#%"
fun g0uint_isgtz_size (x: size_t):<> bool = "mac#%"
fun g0uint_iseqz_size (x: size_t):<> bool = "mac#%"
fun g0uint_isneqz_size (x: size_t):<> bool = "mac#%"
fun g0uint_lt_size (x: size_t, y: size_t):<> bool = "mac#%"
fun g0uint_lte_size (x: size_t, y: size_t):<> bool = "mac#%"
fun g0uint_gt_size (x: size_t, y: size_t):<> bool = "mac#%"
fun g0uint_gte_size (x: size_t, y: size_t):<> bool = "mac#%"
fun g0uint_eq_size (x: size_t, y: size_t):<> bool = "mac#%"
fun g0uint_neq_size (x: size_t, y: size_t):<> bool = "mac#%"
fun g0uint_compare_size (x: size_t, y: size_t):<> int = "mac#%"
fun g0uint_max_size (x: size_t, y: size_t):<> size_t = "mac#%"
fun g0uint_min_size (x: size_t, y: size_t):<> size_t = "mac#%"
//
(* ****** ****** *)
//
fun fprint_uint
  : fprint_type (uint) = "mac#%"
overload fprint with fprint_uint
fun print_uint (x: uint): void = "mac#%"
fun prerr_uint (x: uint): void = "mac#%"
overload print with print_uint
overload prerr with prerr_uint
//
fun fprint_ulint
  : fprint_type (ulint) = "mac#%"
overload fprint with fprint_ulint
fun print_ulint (x: ulint): void = "mac#%"
fun prerr_ulint (x: ulint): void = "mac#%"
overload print with print_ulint
overload prerr with prerr_ulint
//
fun fprint_ullint
  : fprint_type (ullint) = "mac#%"
overload fprint with fprint_ullint
fun print_ullint (x: ullint): void = "mac#%"
fun prerr_ullint (x: ullint): void = "mac#%"
overload print with print_ullint
overload prerr with prerr_ullint
//
fun fprint_size
  : fprint_type (size_t) = "mac#%"
overload fprint with fprint_size
fun print_size (x: size_t): void = "mac#%"
fun prerr_size (x: size_t): void = "mac#%"
overload print with print_size
overload prerr with prerr_size
//
(* ****** ****** *)
//
fun g1int_neg_int : g1int_neg_type (intknd) = "mac#%"
fun g1int_abs_int : g1int_abs_type (intknd) = "mac#%"
fun g1int_succ_int : g1int_succ_type (intknd) = "mac#%"
fun g1int_pred_int : g1int_pred_type (intknd) = "mac#%"
fun g1int_half_int : g1int_half_type (intknd) = "mac#%"
fun g1int_add_int : g1int_add_type (intknd) = "mac#%"
fun g1int_sub_int : g1int_sub_type (intknd) = "mac#%"
fun g1int_mul_int : g1int_mul_type (intknd) = "mac#%"
fun g1int_div_int : g1int_div_type (intknd) = "mac#%"
fun g1int_nmod_int : g1int_nmod_type (intknd) = "mac#%"
fun g1int_isltz_int : g1int_isltz_type (intknd) = "mac#%"
fun g1int_isltez_int : g1int_isltez_type (intknd) = "mac#%"
fun g1int_isgtz_int : g1int_isgtz_type (intknd) = "mac#%"
fun g1int_isgtez_int : g1int_isgtez_type (intknd) = "mac#%"
fun g1int_iseqz_int : g1int_iseqz_type (intknd) = "mac#%"
fun g1int_isneqz_int : g1int_isneqz_type (intknd) = "mac#%"
fun g1int_lt_int : g1int_lt_type (intknd) = "mac#%"
fun g1int_lte_int : g1int_lte_type (intknd) = "mac#%"
fun g1int_gt_int : g1int_gt_type (intknd) = "mac#%"
fun g1int_gte_int : g1int_gte_type (intknd) = "mac#%"
fun g1int_eq_int : g1int_eq_type (intknd) = "mac#%"
fun g1int_neq_int : g1int_neq_type (intknd) = "mac#%"
fun g1int_compare_int : g1int_compare_type (intknd) = "mac#%"
fun g1int_max_int : g1int_max_type (intknd) = "mac#%"
fun g1int_min_int : g1int_min_type (intknd) = "mac#%"
//
fun g1int_neg_lint : g1int_neg_type (lintknd) = "mac#%"
fun g1int_abs_lint : g1int_abs_type (lintknd) = "mac#%"
fun g1int_succ_lint : g1int_succ_type (lintknd) = "mac#%"
fun g1int_pred_lint : g1int_pred_type (lintknd) = "mac#%"
fun g1int_half_lint : g1int_half_type (lintknd) = "mac#%"
fun g1int_add_lint : g1int_add_type (lintknd) = "mac#%"
fun g1int_sub_lint : g1int_sub_type (lintknd) = "mac#%"
fun g1int_mul_lint : g1int_mul_type (lintknd) = "mac#%"
fun g1int_div_lint : g1int_div_type (lintknd) = "mac#%"
fun g1int_nmod_lint : g1int_nmod_type (lintknd) = "mac#%"
fun g1int_isltz_lint : g1int_isltz_type (lintknd) = "mac#%"
fun g1int_isltez_lint : g1int_isltez_type (lintknd) = "mac#%"
fun g1int_isgtz_lint : g1int_isgtz_type (lintknd) = "mac#%"
fun g1int_isgtez_lint : g1int_isgtez_type (lintknd) = "mac#%"
fun g1int_iseqz_lint : g1int_iseqz_type (lintknd) = "mac#%"
fun g1int_isneqz_lint : g1int_isneqz_type (lintknd) = "mac#%"
fun g1int_lt_lint : g1int_lt_type (lintknd) = "mac#%"
fun g1int_lte_lint : g1int_lte_type (lintknd) = "mac#%"
fun g1int_gt_lint : g1int_gt_type (lintknd) = "mac#%"
fun g1int_gte_lint : g1int_gte_type (lintknd) = "mac#%"
fun g1int_eq_lint : g1int_eq_type (lintknd) = "mac#%"
fun g1int_neq_lint : g1int_neq_type (lintknd) = "mac#%"
fun g1int_compare_lint : g1int_compare_type (lintknd) = "mac#%"
fun g1int_max_lint : g1int_max_type (lintknd) = "mac#%"
fun g1int_min_lint : g1int_min_type (lintknd) = "mac#%"
//
fun g1int_neg_llint : g1int_neg_type (llintknd) = "mac#%"
fun g1int_abs_llint : g1int_abs_type (llintknd) = "mac#%"
fun g1int_succ_llint : g1int_succ_type (llintknd) = "mac#%"
fun g1int_pred_llint : g1int_pred_type (llintknd) = "mac#%"
fun g1int_half_llint : g1int_half_type (llintknd) = "mac#%"
fun g1int_add_llint : g1int_add_type (llintknd) = "mac#%"
fun g1int_sub_llint : g1int_sub_type (llintknd) = "mac#%"
fun g1int_mul_llint : g1int_mul_type (llintknd) = "mac#%"
fun g1int_div_llint : g1int_div_type (llintknd) = "mac#%"
fun g1int_nmod_llint : g1int_nmod_type (llintknd) = "mac#%"
fun g1int_isltz_llint : g1int_isltz_type (llintknd) = "mac#%"
fun g1int_isltez_llint : g1int_isltez_type (llintknd) = "mac#%"
fun g1int_isgtz_llint : g1int_isgtz_type (llintknd) = "mac#%"
fun g1int_isgtez_llint : g1int_isgtez_type (llintknd) = "mac#%"
fun g1int_iseqz_llint : g1int_iseqz_type (llintknd) = "mac#%"
fun g1int_isneqz_llint : g1int_isneqz_type (llintknd) = "mac#%"
fun g1int_lt_llint : g1int_lt_type (llintknd) = "mac#%"
fun g1int_lte_llint : g1int_lte_type (llintknd) = "mac#%"
fun g1int_gt_llint : g1int_gt_type (llintknd) = "mac#%"
fun g1int_gte_llint : g1int_gte_type (llintknd) = "mac#%"
fun g1int_eq_llint : g1int_eq_type (llintknd) = "mac#%"
fun g1int_neq_llint : g1int_neq_type (llintknd) = "mac#%"
fun g1int_compare_llint : g1int_compare_type (llintknd) = "mac#%"
fun g1int_max_llint : g1int_max_type (llintknd) = "mac#%"
fun g1int_min_llint : g1int_min_type (llintknd) = "mac#%"
//
fun g1int_neg_ssize : g1int_neg_type (ssizeknd) = "mac#%"
fun g1int_abs_ssize : g1int_abs_type (ssizeknd) = "mac#%"
fun g1int_succ_ssize : g1int_succ_type (ssizeknd) = "mac#%"
fun g1int_pred_ssize : g1int_pred_type (ssizeknd) = "mac#%"
fun g1int_half_ssize : g1int_half_type (ssizeknd) = "mac#%"
fun g1int_add_ssize : g1int_add_type (ssizeknd) = "mac#%"
fun g1int_sub_ssize : g1int_sub_type (ssizeknd) = "mac#%"
fun g1int_mul_ssize : g1int_mul_type (ssizeknd) = "mac#%"
fun g1int_div_ssize : g1int_div_type (ssizeknd) = "mac#%"
fun g1int_nmod_ssize : g1int_nmod_type (ssizeknd) = "mac#%"
fun g1int_isltz_ssize : g1int_isltz_type (ssizeknd) = "mac#%"
fun g1int_isltez_ssize : g1int_isltez_type (ssizeknd) = "mac#%"
fun g1int_isgtz_ssize : g1int_isgtz_type (ssizeknd) = "mac#%"
fun g1int_isgtez_ssize : g1int_isgtez_type (ssizeknd) = "mac#%"
fun g1int_iseqz_ssize : g1int_iseqz_type (ssizeknd) = "mac#%"
fun g1int_isneqz_ssize : g1int_isneqz_type (ssizeknd) = "mac#%"
fun g1int_lt_ssize : g1int_lt_type (ssizeknd) = "mac#%"
fun g1int_lte_ssize : g1int_lte_type (ssizeknd) = "mac#%"
fun g1int_gt_ssize : g1int_gt_type (ssizeknd) = "mac#%"
fun g1int_gte_ssize : g1int_gte_type (ssizeknd) = "mac#%"
fun g1int_eq_ssize : g1int_eq_type (ssizeknd) = "mac#%"
fun g1int_neq_ssize : g1int_neq_type (ssizeknd) = "mac#%"
fun g1int_compare_ssize : g1int_compare_type (ssizeknd) = "mac#%"
fun g1int_max_ssize : g1int_max_type (ssizeknd) = "mac#%"
fun g1int_min_ssize : g1int_min_type (ssizeknd) = "mac#%"
//
(* ****** ****** *)
//
fun g1uint_succ_uint : g1uint_succ_type (uintknd) = "mac#%"
fun g1uint_pred_uint : g1uint_pred_type (uintknd) = "mac#%"
fun g1uint_half_uint : g1uint_half_type (uintknd) = "mac#%"
fun g1uint_add_uint : g1uint_add_type (uintknd) = "mac#%"
fun g1uint_sub_uint : g1uint_sub_type (uintknd) = "mac#%"
fun g1uint_mul_uint : g1uint_mul_type (uintknd) = "mac#%"
fun g1uint_div_uint : g1uint_div_type (uintknd) = "mac#%"
fun g1uint_mod_uint : g1uint_mod_type (uintknd) = "mac#%"
fun g1uint_isgtz_uint : g1uint_isgtz_type (uintknd) = "mac#%"
fun g1uint_iseqz_uint : g1uint_iseqz_type (uintknd) = "mac#%"
fun g1uint_isneqz_uint : g1uint_isneqz_type (uintknd) = "mac#%"
fun g1uint_lt_uint : g1uint_lt_type (uintknd) = "mac#%"
fun g1uint_lte_uint : g1uint_lte_type (uintknd) = "mac#%"
fun g1uint_gt_uint : g1uint_gt_type (uintknd) = "mac#%"
fun g1uint_gte_uint : g1uint_gte_type (uintknd) = "mac#%"
fun g1uint_eq_uint : g1uint_eq_type (uintknd) = "mac#%"
fun g1uint_neq_uint : g1uint_neq_type (uintknd) = "mac#%"
fun g1uint_compare_uint : g1uint_compare_type (uintknd) = "mac#%"
fun g1uint_max_uint : g1uint_max_type (uintknd) = "mac#%"
fun g1uint_min_uint : g1uint_min_type (uintknd) = "mac#%"
//
fun g1uint_succ_ulint : g1uint_succ_type (ulintknd) = "mac#%"
fun g1uint_pred_ulint : g1uint_pred_type (ulintknd) = "mac#%"
fun g1uint_half_ulint : g1uint_half_type (ulintknd) = "mac#%"
fun g1uint_add_ulint : g1uint_add_type (ulintknd) = "mac#%"
fun g1uint_sub_ulint : g1uint_sub_type (ulintknd) = "mac#%"
fun g1uint_mul_ulint : g1uint_mul_type (ulintknd) = "mac#%"
fun g1uint_div_ulint : g1uint_div_type (ulintknd) = "mac#%"
fun g1uint_mod_ulint : g1uint_mod_type (ulintknd) = "mac#%"
fun g1uint_isgtz_ulint : g1uint_isgtz_type (ulintknd) = "mac#%"
fun g1uint_iseqz_ulint : g1uint_iseqz_type (ulintknd) = "mac#%"
fun g1uint_isneqz_ulint : g1uint_isneqz_type (ulintknd) = "mac#%"
fun g1uint_lt_ulint : g1uint_lt_type (ulintknd) = "mac#%"
fun g1uint_lte_ulint : g1uint_lte_type (ulintknd) = "mac#%"
fun g1uint_gt_ulint : g1uint_gt_type (ulintknd) = "mac#%"
fun g1uint_gte_ulint : g1uint_gte_type (ulintknd) = "mac#%"
fun g1uint_eq_ulint : g1uint_eq_type (ulintknd) = "mac#%"
fun g1uint_neq_ulint : g1uint_neq_type (ulintknd) = "mac#%"
fun g1uint_compare_ulint : g1uint_compare_type (ulintknd) = "mac#%"
fun g1uint_max_ulint : g1uint_max_type (ulintknd) = "mac#%"
fun g1uint_min_ulint : g1uint_min_type (ulintknd) = "mac#%"
//
fun g1uint_succ_ullint : g1uint_succ_type (ullintknd) = "mac#%"
fun g1uint_pred_ullint : g1uint_pred_type (ullintknd) = "mac#%"
fun g1uint_half_ullint : g1uint_half_type (ullintknd) = "mac#%"
fun g1uint_add_ullint : g1uint_add_type (ullintknd) = "mac#%"
fun g1uint_sub_ullint : g1uint_sub_type (ullintknd) = "mac#%"
fun g1uint_mul_ullint : g1uint_mul_type (ullintknd) = "mac#%"
fun g1uint_div_ullint : g1uint_div_type (ullintknd) = "mac#%"
fun g1uint_mod_ullint : g1uint_mod_type (ullintknd) = "mac#%"
fun g1uint_isgtz_ullint : g1uint_isgtz_type (ullintknd) = "mac#%"
fun g1uint_iseqz_ullint : g1uint_iseqz_type (ullintknd) = "mac#%"
fun g1uint_isneqz_ullint : g1uint_isneqz_type (ullintknd) = "mac#%"
fun g1uint_lt_ullint : g1uint_lt_type (ullintknd) = "mac#%"
fun g1uint_lte_ullint : g1uint_lte_type (ullintknd) = "mac#%"
fun g1uint_gt_ullint : g1uint_gt_type (ullintknd) = "mac#%"
fun g1uint_gte_ullint : g1uint_gte_type (ullintknd) = "mac#%"
fun g1uint_eq_ullint : g1uint_eq_type (ullintknd) = "mac#%"
fun g1uint_neq_ullint : g1uint_neq_type (ullintknd) = "mac#%"
fun g1uint_compare_ullint : g1uint_compare_type (ullintknd) = "mac#%"
fun g1uint_max_ullint : g1uint_max_type (ullintknd) = "mac#%"
fun g1uint_min_ullint : g1uint_min_type (ullintknd) = "mac#%"
//
fun g1uint_succ_size : g1uint_succ_type (sizeknd) = "mac#%"
fun g1uint_pred_size : g1uint_pred_type (sizeknd) = "mac#%"
fun g1uint_half_size : g1uint_half_type (sizeknd) = "mac#%"
fun g1uint_add_size : g1uint_add_type (sizeknd) = "mac#%"
fun g1uint_sub_size : g1uint_sub_type (sizeknd) = "mac#%"
fun g1uint_mul_size : g1uint_mul_type (sizeknd) = "mac#%"
fun g1uint_div_size : g1uint_div_type (sizeknd) = "mac#%"
fun g1uint_mod_size : g1uint_mod_type (sizeknd) = "mac#%"
fun g1uint_isgtz_size : g1uint_isgtz_type (sizeknd) = "mac#%"
fun g1uint_iseqz_size : g1uint_iseqz_type (sizeknd) = "mac#%"
fun g1uint_isneqz_size : g1uint_isneqz_type (sizeknd) = "mac#%"
fun g1uint_lt_size : g1uint_lt_type (sizeknd) = "mac#%"
fun g1uint_lte_size : g1uint_lte_type (sizeknd) = "mac#%"
fun g1uint_gt_size : g1uint_gt_type (sizeknd) = "mac#%"
fun g1uint_gte_size : g1uint_gte_type (sizeknd) = "mac#%"
fun g1uint_eq_size : g1uint_eq_type (sizeknd) = "mac#%"
fun g1uint_neq_size : g1uint_neq_type (sizeknd) = "mac#%"
fun g1uint_compare_size : g1uint_compare_type (sizeknd) = "mac#%"
fun g1uint_max_size : g1uint_max_type (sizeknd) = "mac#%"
fun g1uint_min_size : g1uint_min_type (sizeknd) = "mac#%"
//
(* ****** ****** *)
//
macdef g0i2i (x) = g0int2int (,(x))
macdef g1i2i (x) = g1int2int (,(x))
//
macdef g0i2u (x) = g0int2uint (,(x))
macdef g1i2u (x) = g1int2uint (,(x))
//
macdef g0u2i (x) = g0uint2int (,(x))
macdef g1u2i (x) = g1uint2int (,(x))
//
macdef g0u2u (x) = g0uint2uint (,(x))
macdef g1u2u (x) = g1uint2uint (,(x))
//
macdef i2u (x) = g1int2uint_int_uint (,(x))
macdef i2sz (x) = g1int2uint_int_size (,(x))
macdef i2ssz (x) = g1int2int_int_ssize (,(x))
//
(* ****** ****** *)
//
macdef u2i (x) = g1uint2int_uint_int (,(x))
macdef u2sz (x) = g1uint2uint_uint_size (,(x))
//
(* ****** ****** *)
//
(*
macdef sz2i (x) = g1uint2int_size_int (,(x))
macdef sz2u (x) = g1uint2uint_size_uint (,(x))
*)
//
symintr sz2i
overload sz2i with g0uint2int_size_int of 0
overload sz2i with g1uint2int_size_int of 10
//
symintr sz2u
overload sz2u with g0uint2uint_size_uint of 0
overload sz2u with g1uint2uint_size_uint of 10
//
(* ****** ****** *)

(* end of [integer.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/array.atxt
** Time of generation: Sat Oct 17 15:19:48 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: Feburary, 2012 *)

(* ****** ****** *)

vtypedef
RD(a:vt0p) = a // for commenting: read-only
#define NSH (x) x // for commenting: no sharing
#define SHR (x) x // for commenting: it is shared

(* ****** ****** *)

sortdef t0p = t@ype
sortdef vtp = viewtype
sortdef vt0p = viewt@ype

(* ****** ****** *)

(*
//
// HX: [array_v] can also be defined as follows:
//
dataview
array_v
(
  a:vt@ype+, addr, int
) = // HX: for arry view
  | {l:addr}
    array_v_nil (a, l, 0)
  | {l:addr}{n:int}
    array_v_cons (a, l, n+1) of (a @ l, array_v (a, l+sizeof a, n))
// end of [array_v]
*)

(* ****** ****** *)

dataview
arrayopt_v
(
  a:vt@ype+, addr, int, bool
) = // HX: for optional array view
  | {l:addr}{n:int}
    arrayopt_v_some (a, l, n, true) of array_v (a, l, n)
  | {l:addr}{n:int}
    arrayopt_v_none (a, l, n, false) of array_v (a?, l, n)
// end of [arrayopt_v]

(* ****** ****** *)

exception
ArraySubscriptExn of ()
(*
fun ArraySubscriptExn ():<> exn = "mac#%ArraySubscriptExn_make"
fun isArraySubscriptExn (x: !exn):<> bool = "mac#%isArraySubscriptExn"
macdef
ifArraySubscriptExn
  {tres}(exn, body) =
(
let val x = ,(exn) in
(
if isArraySubscriptExn(x)
  then
    let prval () = __vfree_exn (x) in ,(body) end
  else $raise (x)
) : tres // end of [if]
end (* end of [let] *)
) // end of [ifArraySubscriptExn]
*)

(* ****** ****** *)

praxi
lemma_array_param{a:vt0p}
  {l:addr}{n:int} (A: &(@[INV(a)][n])): [n >= 0] void
// end of [lemma_array_param]
praxi
lemma_array_v_param{a:vt0p}
  {l:addr}{n:int} (pf: !array_v (INV(a), l, n)): [n >= 0] void
// end of [lemma_array_v_param]

(* ****** ****** *)

praxi
array_v_nil :
  {a:vt0p}{l:addr} () -<prf> array_v (a, l, 0)
praxi
array_v_unnil :
  {a:vt0p}{l:addr} array_v (a, l, 0) -<prf> void

prfun
array_v_unnil_nil :
  {a1,a2:vt0p}{l:addr} array_v (a1, l, 0) -<prf> array_v (a2, l, 0)
// end of [array_v_unnil_nil]

(* ****** ****** *)

praxi
array_v_cons :
  {a:vt0p}{l:addr}{n:int}
  (a @ l, array_v (INV(a), l+sizeof(a), n)) -<prf> array_v (a, l, n+1)
praxi
array_v_uncons :
  {a:vt0p}{l:addr}{n:int | n > 0}
  array_v (INV(a), l, n) -<prf> (a @ l, array_v (a, l+sizeof(a), n-1))

(* ****** ****** *)

prfun
array_v_sing
  {a:vt0p}{l:addr} (pf: INV(a) @ l): array_v (a, l, 1)
prfun
array_v_unsing
  {a:vt0p}{l:addr} (pf: array_v (INV(a), l, 1)): a @ l

(* ****** ****** *)
//
fun{a:vt0p}
array_getref_at
  {n:int} (A: &RD(@[INV(a)][n]), i: sizeLt n):<> cPtr1(a)
//
(* ****** ****** *)

fun{
a:t0p}{tk:tk
} array_get_at_gint
  {n:int} (A: &RD(@[INV(a)][n]), i: g1intLt (tk, n)):<> a
overload [] with array_get_at_gint of 0

fun{
a:t0p}{tk:tk
} array_get_at_guint
  {n:int} (A: &RD(@[INV(a)][n]), i: g1uintLt (tk, n)):<> a
overload [] with array_get_at_guint of 0

symintr array_get_at
overload array_get_at with array_get_at_gint of 0
overload array_get_at with array_get_at_guint of 0

(* ****** ****** *)

fun{
a:t0p}{tk:tk
} array_set_at_gint
  {n:int} (A: &(@[INV(a)][n]), i: g1intLt (tk, n), x: a):<!wrt> void
overload [] with array_set_at_gint of 0

fun{
a:t0p}{tk:tk
} array_set_at_guint
  {n:int} (A: &(@[INV(a)][n]), i: g1uintLt (tk, n), x: a):<!wrt> void
overload [] with array_set_at_guint of 0

symintr array_set_at
overload array_set_at with array_set_at_gint of 0
overload array_set_at with array_set_at_guint of 0

(* ****** ****** *)

fun{
a:vt0p}{tk:tk
} array_exch_at_gint{n:int}
(
  A: &(@[INV(a)][n]), i: g1intLt (tk, n), x: &a >> _
) :<!wrt> void
fun{
a:vt0p}{tk:tk
} array_exch_at_guint{n:int}
(
  A: &(@[INV(a)][n]), i: g1uintLt (tk, n), x: &a >> _
) :<!wrt> void

symintr array_exch_at
overload array_exch_at with array_exch_at_gint of 0
overload array_exch_at with array_exch_at_guint of 0

(* ****** ****** *)

fun{a:vt0p}
array_subreverse
 {n:int}
 {i,j:int |
  0 <= i; i <= j; j <= n}
(
  A: &(@[INV(a)][n]), i: size_t (i), j: size_t (j)
) :<!wrt> void // end of [array_subreverse]

(* ****** ****** *)

fun{a:vt0p}
array_interchange{n:int}
(
  A: &(@[INV(a)][n]), i: sizeLt (n), j: sizeLt (n)
) :<!wrt> void // end of [array_interchange]

(* ****** ****** *)

fun{a:vt0p}
array_subcirculate{n:int}
(
  A: &(@[INV(a)][n]), i: sizeLt (n), j: sizeLt (n)
) :<!wrt> void // end of [array_subcirculate]

(* ****** ****** *)

fun{a:vt0p}
array_ptr_takeout
  {l:addr}{n:int}{i:nat | i < n}
(
  array_v (INV(a), l, n) | ptr l, size_t i
) : (
  a @ (l+i*sizeof(a))
, a @ (l+i*sizeof(a)) -<lin,prf> array_v (a, l, n)
| ptr (l+i*sizeof(a))
) // end of [array_ptr_takeout]

(* ****** ****** *)

fun{a:vt0p}
array_ptr_alloc
  {n:int}
(
  asz: size_t n
) :<!wrt> [l:agz]
(
  array_v (a?, l, n), mfree_gc_v (l) | ptr l
) // end of [array_ptr_alloc]

fun{}
array_ptr_free
  {a:vt0p}{l:addr}{n:int}
(
  array_v (a?, l, n), mfree_gc_v (l) | ptr l
) :<!wrt> void // end of [array_ptr_free]

(* ****** ****** *)
//
fun{}
fprint_array$sep (out: FILEref): void
//
fun{a:vt0p}
fprint_array_int{n:int}
(
  out: FILEref, A: &RD(@[INV(a)][n]), n: int(n)
) : void // end of [fprint_array_int]
fun{a:vt0p}
fprint_array_size{n:int}
(
  out: FILEref, A: &RD(@[INV(a)][n]), n: size_t(n)
) : void // end of [fprint_array_size]
//
symintr fprint_array
overload fprint_array with fprint_array_int
overload fprint_array with fprint_array_size
//
fun{a:vt0p}
fprint_array_sep{n:int}
(
  out: FILEref
, A: &RD(@[INV(a)][n]), n: size_t n, sep: NSH(string)
) : void // end of [fprint_array_sep]
//
(* ****** ****** *)

overload fprint with fprint_array
overload fprint with fprint_array_sep

(* ****** ****** *)

fun{a:vt0p}
array_copy{n:int}
(
  to: &(@[a?][n]) >> @[a][n]
, from: &RD(@[INV(a)][n]) >> @[a?!][n]
, n: size_t (n)
) :<!wrt> void // end of [array_copy]

(* ****** ****** *)

fun{a:t0p}
array_copy_from_list{n:int}
(
  A: &(@[a?][n]) >> @[a][n], xs: list (INV(a), n)
) :<!wrt> void // end of [array_copy_from_list]

fun{a:vt0p}
array_copy_from_list_vt{n:int}
(
  A: &(@[a?][n]) >> @[a][n], xs: list_vt (INV(a), n)
) :<!wrt> void // end of [array_copy_from_list_vt]

(* ****** ****** *)

fun{a:vt0p}
array_copy_to_list_vt{n:int}
(
  A: &RD(@[INV(a)][n]) >> @[a?!][n], n: size_t n
) :<!wrt> list_vt (a, n) // endfun

macdef array2list = array_copy_to_list_vt

(* ****** ****** *)

fun{a:vt0p}
array_tabulate$fopr (i: size_t): (a)
fun{a:vt0p}
array_ptr_tabulate
  {n:int} (asz: size_t n)
  : [l:addr] (array_v (a, l, n), mfree_gc_v (l) | ptr l)
// end of [arrayptr_tabulate]

(* ****** ****** *)
//
fun{
a:vt0p
} array_foreach{n:int}
(
  A: &(@[INV(a)][n]) >> @[a][n], asz: size_t n
) : sizeLte (n) // end of [array_foreach]
//
fun{
a:vt0p}{env:vt0p
} array_foreach_env{n:int}
(
  A: &(@[INV(a)][n]) >> @[a][n], asz: size_t n, env: &(env) >> _
) : sizeLte (n) // end of [array_foreach_env]
//
fun{
a:vt0p}{env:vt0p
} array_foreach$cont (x: &a, env: &env): bool
fun{
a:vt0p}{env:vt0p
} array_foreach$fwork (x: &a >> _, env: &(env) >> _): void
//
(* ****** ****** *)
//
fun{a:vt0p}
array_foreach_funenv
  {v:view}
  {vt:vtype}
  {n:int}
  {fe:eff}
(
  pfv: !v
| A: &(@[INV(a)][n]) >> @[a][n]
, asz: size_t n
, f: (!v | &a >> _, !vt) -<fun,fe> void
, env: !vt
) :<fe> void
// end of [array_foreach_funenv]
//
fun
array_foreach_funenv_tsz
  {a:vt0p}
  {v:view}
  {vt:vtype}
  {n:int}
  {fe:eff}
(
  pfv: !v
| A: &(@[INV(a)][n]) >> @[a][n]
, asz: size_t(n), tsz: sizeof_t(a)
, f: (!v | &a >> _, !vt) -<fun,fe> void
, env: !vt
) :<fe> void = "ext#%"
// end of [array_foreach_funenv_tsz]
//
(* ****** ****** *)
//
fun{a:vt0p}
array_foreach_fun
  {n:int}{fe:eff}
(
  &(@[INV(a)][n]) >> @[a][n]
, size_t (n), (&a >> _) -<fun,fe> void
) :<fe> void // end of [array_foreach_fun]
fun{a:vt0p}
array_foreach_clo
  {n:int}{fe:eff}
(
  A: &(@[INV(a)][n]) >> @[a][n]
, asz: size_t (n), f: &(&a >> _) -<clo,fe> void
) :<fe> void // end of [array_foreach_clo]
fun{a:vt0p}
array_foreach_cloptr
  {n:int}{fe:eff}
(
  A: &(@[INV(a)][n]) >> @[a][n]
, asz: size_t n, f: (&a >> _) -<cloptr,fe> void
) :<fe> void // end of [array_foreach_cloptr]
fun{a:vt0p}
array_foreach_cloref
  {n:int}{fe:eff}
(
  A: &(@[INV(a)][n]) >> @[a][n]
, asz: size_t(n), f: (&a >> _) -<cloref,fe> void
) :<fe> void // end of [array_foreach_cloref]
//
(* ****** ****** *)
//
fun{a:vt0p}
array_foreach_vclo
  {v:view}{n:int}{fe:eff}
(
  pfv: !v
| A: &(@[INV(a)][n]) >> @[a][n]
, asz: size_t n, f: &(!v | &a >> _) -<clo,fe> void
) :<fe> void // end of [array_foreach_vclo]
fun{a:vt0p}
array_foreach_vcloptr
  {v:view}{n:int}{fe:eff}
(
  pfv: !v
| A: &(@[INV(a)][n]) >> @[a][n]
, asz: size_t(n), f: !(!v | &a >> _) -<cloptr,fe> void
) :<fe> void // end of [array_foreach_vcloptr]
//
(* ****** ****** *)

fun{
a1,a2:vt0p
} array_foreach2
  {n:int}
(
  A1: &(@[INV(a1)][n]) >> @[a1][n]
, A2: &(@[INV(a2)][n]) >> @[a2][n]
, asz: size_t (n)
) : sizeLte (n) // end of [array_foreach2]
//
fun{
a1,a2:vt0p}{env:vt0p
} array_foreach2_env
  {n:int}
(
  A1: &(@[INV(a1)][n]) >> @[a1][n]
, A2: &(@[INV(a2)][n]) >> @[a2][n]
, asz:size_t (n)
, env: &(env) >> env
) : sizeLte (n) // end of [array_foreach2_env]
//
fun{
a1,a2:vt0p}{env:vt0p
} array_foreach2$cont
  (x1: &a1, x2: &a2, env: &env): bool
fun{
a1,a2:vt0p}{env:vt0p
} array_foreach2$fwork
  (x1: &a1 >> _, x2: &a2 >> _, env: &(env) >> _): void
//
(* ****** ****** *)

fun{
a:vt0p
} array_iforeach{n:int}
(
  A: &(@[INV(a)][n]) >> @[a][n], asz: size_t n
) : sizeLte (n) // end of [array_iforeach]
//
fun{
a:vt0p}{env:vt0p
} array_iforeach_env{n:int}
(
  A: &(@[INV(a)][n]) >> @[a][n], asz: size_t n, env: &(env) >> _
) : sizeLte (n) // end of [array_iforeach_env]
//
fun{
a:vt0p}{env:vt0p
} array_iforeach$cont (i: size_t, x: &a, env: &env): bool
fun{
a:vt0p}{env:vt0p
} array_iforeach$fwork (i: size_t, x: &a >> _, env: &(env) >> _): void
//
(* ****** ****** *)

fun{
a:vt0p
} array_rforeach{n:int}
(
  A: &(@[INV(a)][n]) >> @[a][n], asz: size_t n
) : sizeLte (n) // end of [array_rforeach]
//
fun{
a:vt0p}{env:vt0p
} array_rforeach_env{n:int}
(
  A: &(@[INV(a)][n]) >> @[a][n], asz: size_t n, env: &(env) >> _
) : sizeLte (n) // end of [array_rforeach_env]
//
fun{
a:vt0p}{env:vt0p
} array_rforeach$cont (x: &a, env: &env): bool
fun{
a:vt0p}{env:vt0p
} array_rforeach$fwork (x: &a >> _, env: &(env) >> _): void
//
(* ****** ****** *)
//
fun{a:vt0p}
array_initize{n:int}
(
  A: &(@[a?][n]) >> @[a][n], asz: size_t n
) : void // end of [array_initize]
//
fun{a:vt0p}
array_initize$init (i: size_t, x: &a? >> a): void
//
(* ****** ****** *)

fun{a:t0p}
array_initize_elt{n:int}
(
  A: &(@[a?][n]) >> @[a][n], asz: size_t n, elt: a
) :<!wrt> void // end of [array_initize_elt]

(* ****** ****** *)

fun{a:t0p}
array_initize_list{n:int}
(
  A: &(@[a?][n]) >> @[a][n], asz: int n, xs: list (INV(a), n)
) :<!wrt> void // end of [array_initize_list]
fun{a:t0p}
array_initize_rlist{n:int}
(
  A: &(@[a?][n]) >> @[a][n], asz: int n, xs: list (INV(a), n)
) :<!wrt> void // end of [array_initize_rlist]

(* ****** ****** *)

fun{a:vt0p}
array_initize_list_vt{n:int}
(
  A: &(@[a?][n]) >> @[a][n], asz: int n, xs: list_vt (INV(a), n)
) :<!wrt> void // end of [array_initize_list_vt]
fun{a:vt0p}
array_initize_rlist_vt{n:int}
(
  A: &(@[a?][n]) >> @[a][n], asz: int n, xs: list_vt (INV(a), n)
) :<!wrt> void // end of [array_initize_rlist_vt]

(* ****** ****** *)
//
fun{a:vt0p}
array_uninitize{n:int}
(
  A: &(@[INV(a)][n]) >> @[a?][n], asz: size_t n
) : void // end of [array_uninitize]
//
fun{a:vt0p}
array_uninitize$clear (i: size_t, x: &a >> a?): void
//
(* ****** ****** *)
//
fun{a:vt0p}
array_bsearch
  {n:int} (A: &RD(@[a][n]), n: size_t (n)):<> sizeLte (n)
//
fun{a:vt0p}
array_bsearch$ford (x: &RD(a)):<> int
//
fun{a:vt0p}
array_bsearch_fun{n:int}
(
  A: &RD(@[a][n]), asz: size_t (n), key: &RD(a), cmp: cmpref (a)
) :<> sizeLte (n) // end of [array_bsearch_fun]
//
(* ****** ****** *)

(*
** HX: this one is based on [bsearch] in [stdlib]
*)
fun{a:vt0p}
array_bsearch_stdlib{n:int}
(
  A: &RD(@[a][n]), asz: size_t (n), key: &RD(a), cmp: cmpref (a)
) :<> Ptr0 (* found/~found : ~null/null *)

(* ****** ****** *)
//
fun{a:vt0p}
array_quicksort{n:int}
  (A: &(@[INV(a)][n]) >> @[a][n], n: size_t n):<!wrt> void
fun{a:vt0p}
array_quicksort$cmp (x1: &RD(a), x2: &RD(a)):<> int(*sgn*)
//
(* ****** ****** *)

(*
** HX: this one is based on [qsort] in [stdlib]
*)
fun{a:vt0p}
array_quicksort_stdlib{n:int}
(
  A: &(@[INV(a)][n]) >> @[a][n], n: size_t n, cmp: cmpref (a)
) :<!wrt> void // end of [array_quicksort_stdlib]

(* ****** ****** *)
//
fun{
a:vt0p}{b:vt0p
} array_mapto{n:int}
(
  A: &array(INV(a), n)
, B: &array(b?, n) >> array (b, n)
, n: size_t (n)
) : void // end of [array_mapto]
//
fun{
a:vt0p}{b:vt0p
} array_mapto$fwork (x: &a, y: &b? >> b) : void
//
(* ****** ****** *)
//
fun{
a,b:vt0p}{c:vt0p
} array_map2to{n:int}
(
  A: &array(INV(a), n)
, B: &array(INV(b), n)
, C: &array(c?, n) >> array (c, n)
, n: size_t (n)
) : void // end of [array_map2to]
//
fun{
a,b:vt0p}{c:vt0p
} array_map2to$fwork (x: &a, y: &b, z: &c? >> c) : void
//
(* ****** ****** *)
//
fun{a:vt0p}
array_permute{n:int}
  (A: &(@[INV(a)][n]) >> @[a][n], n: size_t n): void
//
fun{}
array_permute$randint {n:int | n > 0} (size_t n): sizeLt (n)
//
(* ****** ****** *)

(* end of [array.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/integer_ptr.atxt
** Time of generation: Sat Oct 17 15:19:46 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: January, 2013 *)

(* ****** ****** *)
//
// HX: for unindexed integer types
//
(* ****** ****** *)

sortdef tk = tkind

(* ****** ****** *)

typedef SHR(a:t@ype) = a // for commenting purpose
typedef NSH(a:t@ype) = a // for commenting purpose

(* ****** ****** *)
//
stadef intptrknd = intptr_kind
stadef uintptrknd = uintptr_kind
//
(* ****** ****** *)
//
fun g0int2int_int_intptr(int):<> intptr = "mac#%"
fun g1int2int_int_intptr{i:int}(int(i)):<> intptr(i) = "mac#%"
fun g0int2int_lint_intptr(lint):<> intptr = "mac#%"
fun g1int2int_lint_intptr{i:int}(lint(i)):<> intptr(i) = "mac#%"
//
(* ****** ****** *)
//
fun g0int2uint_int_uintptr(int):<> uintptr = "mac#%"
fun g1int2uint_int_uintptr{i:nat}(int(i)):<> uintptr(i) = "mac#%"
//
(* ****** ****** *)
//
fun g0uint2uint_uint_uintptr(uint):<> uintptr = "mac#%"
fun g1uint2uint_uint_uintptr{u:int}(uint(u)):<> uintptr(u) = "mac#%"
fun g0uint2uint_ulint_uintptr(ulint):<> uintptr = "mac#%"
fun g1uint2uint_ulint_uintptr{u:int}(ulint(u)):<> uintptr(u) = "mac#%"
//
(* ****** ****** *)
//
fun g0int_neg_intptr (x: intptr):<> intptr = "mac#%"
fun g0int_abs_intptr (x: intptr):<> intptr = "mac#%"
fun g0int_succ_intptr (x: intptr):<> intptr = "mac#%"
fun g0int_pred_intptr (x: intptr):<> intptr = "mac#%"
fun g0int_half_intptr (x: intptr):<> intptr = "mac#%"
fun g0int_asl_intptr (x: intptr, n: intGte(0)):<> intptr = "mac#%"
fun g0int_asr_intptr (x: intptr, n: intGte(0)):<> intptr = "mac#%"
fun g0int_add_intptr (x: intptr, y: intptr):<> intptr = "mac#%"
fun g0int_sub_intptr (x: intptr, y: intptr):<> intptr = "mac#%"
fun g0int_mul_intptr (x: intptr, y: intptr):<> intptr = "mac#%"
fun g0int_div_intptr (x: intptr, y: intptr):<> intptr = "mac#%"
fun g0int_mod_intptr (x: intptr, y: intptr):<> intptr = "mac#%"
fun g0int_isltz_intptr (x: intptr):<> bool = "mac#%"
fun g0int_isltez_intptr (x: intptr):<> bool = "mac#%"
fun g0int_isgtz_intptr (x: intptr):<> bool = "mac#%"
fun g0int_isgtez_intptr (x: intptr):<> bool = "mac#%"
fun g0int_iseqz_intptr (x: intptr):<> bool = "mac#%"
fun g0int_isneqz_intptr (x: intptr):<> bool = "mac#%"
fun g0int_lt_intptr (x: intptr, y: intptr):<> bool = "mac#%"
fun g0int_lte_intptr (x: intptr, y: intptr):<> bool = "mac#%"
fun g0int_gt_intptr (x: intptr, y: intptr):<> bool = "mac#%"
fun g0int_gte_intptr (x: intptr, y: intptr):<> bool = "mac#%"
fun g0int_eq_intptr (x: intptr, y: intptr):<> bool = "mac#%"
fun g0int_neq_intptr (x: intptr, y: intptr):<> bool = "mac#%"
fun g0int_compare_intptr (x: intptr, y: intptr):<> int = "mac#%"
fun g0int_max_intptr (x: intptr, y: intptr):<> intptr = "mac#%"
fun g0int_min_intptr (x: intptr, y: intptr):<> intptr = "mac#%"
//
(* ****** ****** *)
//
fun fprint_intptr
  : fprint_type (intptr) = "mac#%"
overload fprint with fprint_intptr
fun print_intptr (x: intptr): void = "mac#%"
fun prerr_intptr (x: intptr): void = "mac#%"
overload print with print_intptr
overload prerr with prerr_intptr
//
(* ****** ****** *)
//
fun g0uint_succ_uintptr (x: uintptr):<> uintptr = "mac#%"
fun g0uint_pred_uintptr (x: uintptr):<> uintptr = "mac#%"
fun g0uint_half_uintptr (x: uintptr):<> uintptr = "mac#%"
fun g0uint_add_uintptr (x: uintptr, y: uintptr):<> uintptr = "mac#%"
fun g0uint_sub_uintptr (x: uintptr, y: uintptr):<> uintptr = "mac#%"
fun g0uint_mul_uintptr (x: uintptr, y: uintptr):<> uintptr = "mac#%"
fun g0uint_div_uintptr (x: uintptr, y: uintptr):<> uintptr = "mac#%"
fun g0uint_mod_uintptr (x: uintptr, y: uintptr):<> uintptr = "mac#%"
fun g0uint_lsl_uintptr (x: uintptr, n: intGte(0)):<> uintptr = "mac#%"
fun g0uint_lsr_uintptr (x: uintptr, n: intGte(0)):<> uintptr = "mac#%"
fun g0uint_lnot_uintptr (x: uintptr):<> uintptr = "mac#%"
fun g0uint_lor_uintptr (x: uintptr, y: uintptr):<> uintptr = "mac#%"
fun g0uint_lxor_uintptr (x: uintptr, y: uintptr):<> uintptr = "mac#%"
fun g0uint_land_uintptr (x: uintptr, y: uintptr):<> uintptr = "mac#%"
fun g0uint_isgtz_uintptr (x: uintptr):<> bool = "mac#%"
fun g0uint_iseqz_uintptr (x: uintptr):<> bool = "mac#%"
fun g0uint_isneqz_uintptr (x: uintptr):<> bool = "mac#%"
fun g0uint_lt_uintptr (x: uintptr, y: uintptr):<> bool = "mac#%"
fun g0uint_lte_uintptr (x: uintptr, y: uintptr):<> bool = "mac#%"
fun g0uint_gt_uintptr (x: uintptr, y: uintptr):<> bool = "mac#%"
fun g0uint_gte_uintptr (x: uintptr, y: uintptr):<> bool = "mac#%"
fun g0uint_eq_uintptr (x: uintptr, y: uintptr):<> bool = "mac#%"
fun g0uint_neq_uintptr (x: uintptr, y: uintptr):<> bool = "mac#%"
fun g0uint_compare_uintptr (x: uintptr, y: uintptr):<> int = "mac#%"
fun g0uint_max_uintptr (x: uintptr, y: uintptr):<> uintptr = "mac#%"
fun g0uint_min_uintptr (x: uintptr, y: uintptr):<> uintptr = "mac#%"
//
(* ****** ****** *)
//
fun fprint_uintptr
  : fprint_type (uintptr) = "mac#%"
overload fprint with fprint_uintptr
fun print_uintptr (x: uintptr): void = "mac#%"
fun prerr_uintptr (x: uintptr): void = "mac#%"
overload print with print_uintptr
overload prerr with prerr_uintptr
//
(* ****** ****** *)
//
fun g1int_neg_intptr : g1int_neg_type (intptrknd) = "mac#%"
fun g1int_abs_intptr : g1int_abs_type (intptrknd) = "mac#%"
fun g1int_succ_intptr : g1int_succ_type (intptrknd) = "mac#%"
fun g1int_pred_intptr : g1int_pred_type (intptrknd) = "mac#%"
fun g1int_half_intptr : g1int_half_type (intptrknd) = "mac#%"
fun g1int_add_intptr : g1int_add_type (intptrknd) = "mac#%"
fun g1int_sub_intptr : g1int_sub_type (intptrknd) = "mac#%"
fun g1int_mul_intptr : g1int_mul_type (intptrknd) = "mac#%"
fun g1int_div_intptr : g1int_div_type (intptrknd) = "mac#%"
fun g1int_nmod_intptr : g1int_nmod_type (intptrknd) = "mac#%"
fun g1int_isltz_intptr : g1int_isltz_type (intptrknd) = "mac#%"
fun g1int_isltez_intptr : g1int_isltez_type (intptrknd) = "mac#%"
fun g1int_isgtz_intptr : g1int_isgtz_type (intptrknd) = "mac#%"
fun g1int_isgtez_intptr : g1int_isgtez_type (intptrknd) = "mac#%"
fun g1int_iseqz_intptr : g1int_iseqz_type (intptrknd) = "mac#%"
fun g1int_isneqz_intptr : g1int_isneqz_type (intptrknd) = "mac#%"
fun g1int_lt_intptr : g1int_lt_type (intptrknd) = "mac#%"
fun g1int_lte_intptr : g1int_lte_type (intptrknd) = "mac#%"
fun g1int_gt_intptr : g1int_gt_type (intptrknd) = "mac#%"
fun g1int_gte_intptr : g1int_gte_type (intptrknd) = "mac#%"
fun g1int_eq_intptr : g1int_eq_type (intptrknd) = "mac#%"
fun g1int_neq_intptr : g1int_neq_type (intptrknd) = "mac#%"
fun g1int_compare_intptr : g1int_compare_type (intptrknd) = "mac#%"
fun g1int_max_intptr : g1int_max_type (intptrknd) = "mac#%"
fun g1int_min_intptr : g1int_min_type (intptrknd) = "mac#%"
//
(* ****** ****** *)
//
fun g1uint_succ_uintptr : g1uint_succ_type (uintptrknd) = "mac#%"
fun g1uint_pred_uintptr : g1uint_pred_type (uintptrknd) = "mac#%"
fun g1uint_half_uintptr : g1uint_half_type (uintptrknd) = "mac#%"
fun g1uint_add_uintptr : g1uint_add_type (uintptrknd) = "mac#%"
fun g1uint_sub_uintptr : g1uint_sub_type (uintptrknd) = "mac#%"
fun g1uint_mul_uintptr : g1uint_mul_type (uintptrknd) = "mac#%"
fun g1uint_div_uintptr : g1uint_div_type (uintptrknd) = "mac#%"
fun g1uint_mod_uintptr : g1uint_mod_type (uintptrknd) = "mac#%"
fun g1uint_isgtz_uintptr : g1uint_isgtz_type (uintptrknd) = "mac#%"
fun g1uint_iseqz_uintptr : g1uint_iseqz_type (uintptrknd) = "mac#%"
fun g1uint_isneqz_uintptr : g1uint_isneqz_type (uintptrknd) = "mac#%"
fun g1uint_lt_uintptr : g1uint_lt_type (uintptrknd) = "mac#%"
fun g1uint_lte_uintptr : g1uint_lte_type (uintptrknd) = "mac#%"
fun g1uint_gt_uintptr : g1uint_gt_type (uintptrknd) = "mac#%"
fun g1uint_gte_uintptr : g1uint_gte_type (uintptrknd) = "mac#%"
fun g1uint_eq_uintptr : g1uint_eq_type (uintptrknd) = "mac#%"
fun g1uint_neq_uintptr : g1uint_neq_type (uintptrknd) = "mac#%"
fun g1uint_compare_uintptr : g1uint_compare_type (uintptrknd) = "mac#%"
fun g1uint_max_uintptr : g1uint_max_type (uintptrknd) = "mac#%"
fun g1uint_min_uintptr : g1uint_min_type (uintptrknd) = "mac#%"
//
(* ****** ****** *)
//
macdef i2ptr (x) = g1int2int_int_intptr (,(x))
//
macdef u2ptr (x) = g1uint2uint_uint_uintptr (,(x))
//
(* ****** ****** *)

(* end of [integer_ptr.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/gnumber.atxt
** Time of generation: Sat Oct 17 15:19:47 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: September, 2011 *)

(* ****** ****** *)

(* Author: Brandon Barker *)
(* Authoremail: brandon.barker AT gmail DOT com *)
(* Start time: July, 2013 *)

(* ****** ****** *)
//
// HX: for unindexed gnumber types
//
(* ****** ****** *)

sortdef tk = tkind

(* ****** ****** *)

typedef SHR(a:type) = a // for commenting purpose
typedef NSH(a:type) = a // for commenting purpose

(* ****** ****** *)

abstype
fprecision_prop (a1:t0p, a2:t0p)
propdef
fprecision (a1:t0p, a2:t0p) = fprecision_prop (a1, a2)
praxi
fprecision_float (): fprecision (float, float)
praxi
fprecision_double (): fprecision (double, double)
praxi
fprecision_ldouble (): fprecision (ldouble, ldouble)

(* ****** ****** *)
//
// HX: generic number operations
//
(* ****** ****** *)
//

//
fun{a:t0p} gnumber_int (x: int):<> a
fun{a:t0p} gnumber_double (x: double):<> a
//
(* ****** ****** *)

fun{a:t0p} gabs_val (x: a):<> a
fun{a:t0p} gneg_val (x: a):<> a
fun{a:t0p} gsucc_val (x: a):<> a
fun{a:t0p} gpred_val (x: a):<> a
fun{a:t0p} grecip_val (x: a):<!exn> a

(* ****** ****** *)

fun{a:t0p} gadd_val_val (x: a, y: a):<> a
fun{a:t0p} gsub_val_val (x: a, y: a):<> a
fun{a:t0p} gmul_val_val (x: a, y: a):<> a
fun{a:t0p} gdiv_val_val (x: a, y: a):<!exn> a
fun{a:t0p} gmod_val_val (x: a, y: a):<!exn> a

(* ****** ****** *)
//
fun{a:t0p} gadd_val_int (x: a, y: int):<> a
fun{a:t0p} gsub_val_int (x: a, y: int):<> a
//
fun{a:t0p} gmul_int_val (x: int, y: a):<> a
fun{a:t0p} gmul_val_int (x: a, y: int):<> a
//
fun{a:t0p} gdiv_int_val (x: int, y: a):<!exn> a
fun{a:t0p} gdiv_val_int (x: a, y: int):<!exn> a
fun{a:t0p} gmod_val_int (x: a, y: int):<!exn> a
//
(* ****** ****** *)

fun{a:t0p} gsqrt_val (x: a):<!exn> a

(* ****** ****** *)

fun{a:t0p} gconjugate_val (x: a):<> a

(* ****** ****** *)

fun{a:t0p} gpow_int_val (n: intGte(0), x: a):<> a

(* ****** ****** *)

(* end of [gnumber.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/gorder.atxt
** Time of generation: Sat Oct 17 15:19:47 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: September, 2011 *)

(* ****** ****** *)

typedef SHR(a:type) = a // for commenting purpose
typedef NSH(a:type) = a // for commenting purpose

(* ****** ****** *)
//
// HX: generic ordering ops
//
(* ****** ****** *)
//
fun
{a:t0p}
gisltz_val (x: a):<> bool
fun
{a:t0p}
gisltez_val (x: a):<> bool
//
fun
{a:t0p}
gisgtz_val (x: a):<> bool
fun
{a:t0p}
gisgtez_val (x: a):<> bool
//
fun
{a:t0p}
giseqz_val (x: a):<> bool
fun
{a:t0p}
gisneqz_val (x: a):<> bool
//
(* ****** ****** *)
//
fun
{a:t0p}
glt_val_val (x: a, y: a):<> bool
fun
{a:t0p}
glte_val_val (x: a, y: a):<> bool
//
fun
{a:t0p}
ggt_val_val (x: a, y: a):<> bool
fun
{a:t0p}
ggte_val_val (x: a, y: a):<> bool
//
(* ****** ****** *)
//
fun
{a:t0p}
glt_val_int (x: a, y: int):<> bool
fun
{a:t0p}
glte_val_int (x: a, y: int):<> bool
//
fun
{a:t0p}
ggt_val_int (x: a, y: int):<> bool
fun
{a:t0p}
ggte_val_int (x: a, y: int):<> bool
//
(* ****** ****** *)
//
fun
{a:t0p}
geq_val_val (x: a, y: a):<> bool
fun
{a:t0p}
gneq_val_val (x: a, y: a):<> bool
//
(* ****** ****** *)
//
fun
{a:t0p}
geq_val_int (x: a, y: int):<> bool
fun
{a:t0p}
gneq_val_int (x: a, y: int):<> bool
//
(* ****** ****** *)
//
fun
{a:t0p}
gcompare_val_val (x: a, y: a):<> int
//
(* ****** ****** *)
//
fun
{a:t0p}
gmax_val_val (x: a, y: a):<> (a)
fun
{a:t0p}
gmin_val_val (x: a, y: a):<> (a)
//
(* ****** ****** *)
//
fun
{a:vt0p}
glt_ref_ref (x: &INV(a), y: &a):<> bool
fun
{a:vt0p}
glte_ref_ref (x: &INV(a), y: &a):<> bool
//
fun
{a:vt0p}
ggt_ref_ref (x: &INV(a), y: &a):<> bool
fun
{a:vt0p}
ggte_ref_ref (x: &INV(a), y: &a):<> bool
//
(* ****** ****** *)
//
fun
{a:vt0p}
geq_ref_ref (x: &INV(a), y: &a):<> bool
fun
{a:vt0p}
gneq_ref_ref (x: &INV(a), y: &a):<> bool
//
(* ****** ****** *)
//
fun
{a:vt0p}
gcompare_ref_ref (x: &INV(a), y: &a):<> int
//
(* ****** ****** *)

(* end of [gorder.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/matrixptr.atxt
** Time of generation: Sat Oct 17 15:19:49 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2012 *)

(* ****** ****** *)

typedef SHR(a:type) = a // for commenting purpose
typedef NSH(a:type) = a // for commenting purpose

(* ****** ****** *)

sortdef t0p = t@ype and vt0p = viewt@ype

(* ****** ****** *)

absvtype
matrixptr_vt0ype_addr_int_int_vtype
  (a:vt@ype+, l: addr, m: int, n: int) = ptr
//
stadef
matrixptr = matrixptr_vt0ype_addr_int_int_vtype
vtypedef
matrixptr
  (a:vt@ype, m: int, n: int) = [l:addr] matrixptr(a, l, m, n)
//
(* ****** ****** *)

absvtype
matrixptrout_vt0ype_addr_int_int_vtype
  (a:vt@ype, l: addr, m: int, n: int) = ptr
//
stadef
matrixptrout = matrixptrout_vt0ype_addr_int_int_vtype
//
(* ****** ****** *)

praxi
lemma_matrixptr_param{a:vt0p}
  {l:addr}{m,n:int} (A: !matrixptr(a, l, m, n)): [m >= 0; n >= 0] void
// end of [lemma_matrixptr_param]

(* ****** ****** *)

castfn
matrixptr_encode :
  {a:vt0p}{l:addr}{m,n:int}
  (matrix_v(INV(a), l, m, n), mfree_gc_v(l) | ptr l) -<0> matrixptr(a, l, m, n)
// end of [matrixptr_encode]

castfn
matrixptr_encode2 :
  {a:vt0p}{l:addr}{m,n:int}
  @(matrix_v(INV(a), l, m, n), mfree_gc_v(l) | ptr l) -<0> matrixptr(a, l, m, n)
// end of [matrixptr_encode2]

(* ****** ****** *)
//
castfn
matrixptr2ptr
  {a:vt0p}
  {l:addr}{m,n:int}
  (A: !matrixptr(INV(a), l, m, n)):<> ptr(l)
//
castfn
matrixptrout2ptr
  {a:t0p}
  {l:addr}{m,n:int}
  (A: !matrixptrout(INV(a), l, m, n)):<> ptr(l)
//
(* ****** ****** *)

praxi
matrixptr_takeout
  {a:vt0p}{l:addr}{m,n:int}
(
  !matrixptr(INV(a), l, m, n) >> matrixptrout(a?, l, m, n)
) : matrix_v(a, l, m, n) // endfun
praxi
matrixptr_addback
  {a:vt0p}{l:addr}{m,n:int}
(
  pf: matrix_v(INV(a), l, m, n)
| mat: !matrixptrout(a?, l, m, n) >> matrixptr(a, l, m, n)
) : void // end of [matrixptr_addback]

(* ****** ****** *)

fun{
} arrayptr2matrixptr_int
  {a:vt0p}{l:addr}{m,n:nat}
  (A: arrayptr(INV(a), l, m*n), m: int m, n: int n):<> matrixptr(a, l, m, n)
fun{
} arrayptr2matrixptr_size
  {a:vt0p}{l:addr}{m,n:int}
  (A: arrayptr(INV(a), l, m*n), m: size_t m, n: size_t n):<> matrixptr(a, l, m, n)
//
symintr arrayptr2matrixptr
overload arrayptr2matrixptr with arrayptr2matrixptr_int
overload arrayptr2matrixptr with arrayptr2matrixptr_size
//
(* ****** ****** *)

fun{
a:t0p
} matrixptr_make_elt
  {m,n:int}
  (m: size_t m, n: size_t n, x: a):<!wrt> matrixptr(a, m, n)
// end of [matrixptr_make_elt]

(* ****** ****** *)

fun{a:t0p}
matrixptr_get_at_int
  {m,n:int}
(
  A: !matrixptr(INV(a), m, n), i: natLt (m), n: int n, j: natLt (n)
) :<> (a) // end of [matrixptr_get_at_int]
fun{a:t0p}
matrixptr_get_at_size
  {m,n:int}
(
  A: !matrixptr(INV(a), m, n), i: sizeLt (m), n: size_t n, j: sizeLt (n)
) :<> (a) // end of [matrixptr_get_at_size]
//
symintr matrixptr_get_at
overload matrixptr_get_at with matrixptr_get_at_int of 0
overload matrixptr_get_at with matrixptr_get_at_size of 0
//
(* ****** ****** *)

fun{a:t0p}
matrixptr_set_at_int
  {m,n:int}
(
  A: !matrixptr(INV(a), m, n), i: natLt (m), n: int n, j: natLt (n), x: a
) :<!wrt> void // end of [matrixptr_set_at_int]
fun{a:t0p}
matrixptr_set_at_size
  {m,n:int}
(
  A: !matrixptr(INV(a), m, n), i: sizeLt (m), n: size_t n, j: sizeLt (n), x: a
) :<!wrt> void // end of [matrixptr_set_at_size]
//
symintr matrixptr_set_at
overload matrixptr_set_at with matrixptr_set_at_int of 0
overload matrixptr_set_at with matrixptr_set_at_size of 0
//
(* ****** ****** *)

fun{a:vt0p}
matrixptr_exch_at_int
  {m,n:int}
(
  A: !matrixptr(INV(a), m, n)
, i: natLt (m), n: int n, j: natLt (n), x: &a>>a
) :<!wrt> void // end of [matrixptr_exch_at_int]
fun{a:vt0p}
matrixptr_exch_at_size
  {m,n:int}
(
  A: !matrixptr(INV(a), m, n)
, i: sizeLt (m), n: size_t n, j: sizeLt (n), x: &a>>a
) :<!wrt> void // end of [matrixptr_exch_at_size]
//
symintr matrixptr_exch_at
overload matrixptr_exch_at with matrixptr_exch_at_int
overload matrixptr_exch_at with matrixptr_exch_at_size
//
(* ****** ****** *)

(*
fprint_matrix$sep1 // col separation
fprint_matrix$sep2 // row separation
*)
fun{a:vt0p}
fprint_matrixptr{m,n:int}
(
  out: FILEref
, M: !matrixptr(INV(a), m, n), m: size_t m, n: size_t n
) : void // end of [fprint_matrixptr]

fun{a:vt0p}
fprint_matrixptr_sep{m,n:int}
(
  out: FILEref
, M: !matrixptr(INV(a), m, n), m: size_t (m), n: size_t (n)
, sep1: NSH(string), sep2: NSH(string)
) : void // end of [fprint_matrixptr_sep]

(* ****** ****** *)

fun matrixptr_free
  {a:t0p}{l:addr}{m,n:int}
  (A: matrixptr(INV(a), l, m, n)):<!wrt> void = "mac#%"
// end of [matrixptr_free]

(*
fun{a:vt0p}
matrix_uninitize$clear
  (i: size_t, j: size_t, x: &a >> a?): void
*)
fun{
a:vt0p
} matrixptr_freelin
  {l:addr}{m,n:int}
  (A: matrixptr(INV(a), l, m, n)):<!wrt> void = "mac#%"
// end of [matrixptr_freelin]

(* ****** ****** *)
//
(*
fun{a:vt0p}
matrix_tabulate$fopr (i: size_t, j: size_t): (a)
*)
fun{a:vt0p}
matrixptr_tabulate
  {m,n:int} (nrow: size_t m, ncol: size_t n): matrixptr (a, m, n)
//
fun{a:vt0p}
matrixptr_tabulate_cloref
  {m,n:int}
(
  nrow: size_t m, ncol: size_t n, f: (sizeLt(m), sizeLt(n)) -<cloref> a
) : matrixptr (a, m, n) // end-of-fun
//
(* ****** ****** *)

(*
fun{
a:vt0p}{env:vt0p
} matrix_foreach$fwork (x: &a >> _, env: &(env) >> _): void
*)
//
fun{
a:vt0p
} matrixptr_foreach{m,n:int}
(
  A: !matrixptr(INV(a), m, n) >> _, m: size_t m, n: size_t n
) : void // end of [matrixptr_foreach]
fun{
a:vt0p}{env:vt0p
} matrixptr_foreach_env{m,n:int}
(
  A: !matrixptr(INV(a), m, n) >> _, m: size_t m, n: size_t n, env: &(env) >> _
) : void // end of [matrixptr_foreach_env]

(* ****** ****** *)
//
// overloading for certain symbols
//
(* ****** ****** *)

overload [] with matrixptr_get_at_int
overload [] with matrixptr_get_at_size
overload [] with matrixptr_set_at_int
overload [] with matrixptr_set_at_size

(* ****** ****** *)

overload fprint with fprint_matrixptr
overload fprint with fprint_matrixptr_sep

(* ****** ****** *)

overload ptrcast with matrixptr2ptr
overload ptrcast with matrixptrout2ptr

(* ****** ****** *)

(* end of [matrixptr.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/arrayptr.atxt
** Time of generation: Sat Oct 17 15:19:49 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2012 *)

(* ****** ****** *)

#define NSH (x) x // for commenting: no sharing
#define SHR (x) x // for commenting: it is shared

(* ****** ****** *)

sortdef t0p = t@ype and vt0p = viewt@ype

(* ****** ****** *)

#if(0)
//
// HX-2013-06:
// it is declared in [basic_dyn.sats]
//
absvtype
arrayptr_vt0ype_addr_int_vtype
  (a:vt0ype+, l: addr, n: int) = ptr (l)
//
stadef
arrayptr = arrayptr_vt0ype_addr_int_vtype
vtypedef
arrayptr
  (a:vt0p, n:int) = [l:addr] arrayptr (a, l, n)
//
#endif

(* ****** ****** *)

absvtype
arrayptrout_vt0ype_addr_int_vtype
  (a:t@ype, l: addr, n: int) = ptr (l)
stadef arrayptrout = arrayptrout_vt0ype_addr_int_vtype

(* ****** ****** *)

praxi
lemma_arrayptr_param{a:vt0p}
  {l:addr}{n:int} (A: !arrayptr (a, l, n)): [n >= 0] void
// end of [lemma_arrayptr_param]

(* ****** ****** *)

castfn
arrayptr_encode :
  {a:vt0p}{l:addr}{n:int}
  (array_v (INV(a), l, n), mfree_gc_v l | ptr l) -<0> arrayptr (a, l, n)
// end of [arrayptr_encode]
castfn
arrayptr_encode2 :
  {a:vt0p}{l:addr}{n:int}
  @(array_v (INV(a), l, n), mfree_gc_v l | ptr l) -<0> arrayptr (a, l, n)
// end of [arrayptr_encode2]

(* ****** ****** *)

castfn
arrayptr_objectify
  {a:vt0p}{l:addr}{n:int}
  (array_v (INV(a), l, n) | ptr(l)):<> (mfree_ngc_v(l) | arrayptr(a, l, n))
// end of [arrayptr_objectify]
castfn
arrayptr_unobjectify
  {a:vt0p}{l:addr}{n:int}
  (mfree_ngc_v(l) | arrayptr(INV(a), l, n)):<> (array_v (a, l, n) | ptr(l))
// end of [arrayptr_objectify]

(* ****** ****** *)
//
castfn
arrayptr2ptr
  {a:vt0p}
  {l:addr}{n:int} (A: !arrayptr (INV(a), l, n)):<> ptr (l)
castfn
arrayptrout2ptr
  {a:t0p}{l:addr}{n:int} (A: !arrayptrout (INV(a), l, n)):<> ptr (l)
//
(* ****** ****** *)

praxi
arrayptr_takeout
  {a:vt0p}{l:addr}{n:int}
(
  A: !arrayptr (INV(a), l, n) >> arrayptrout (a?, l, n)
) : array_v (a, l, n) // end of [arrayptr_takeout]

praxi
arrayptr_addback
  {a:vt0p}{l:addr}{n:int}
(
  pf: array_v (INV(a), l, n) | A: !arrayptrout (a?, l, n) >> arrayptr (a, l, n)
) : void // end of [arrayptr_addback]

(* ****** ****** *)

castfn
arrayptr_takeout_viewptr
  {a:vt0p}{l:addr}{n:int}
(
  A: !arrayptr (INV(a), l, n) >> arrayptrout (a?, l, n)
) : (array_v (a, l, n) | ptr l) // endfun

(* ****** ****** *)

castfn
arrpsz_encode :
  {a:vt0p}{n:int}
  @(arrayptr (INV(a), n), size_t n) -<0> arrpsz (a, n)
// end of [arrpsz_encode]

castfn
arrpsz_decode :
  {a:vt0p}{n:int}
  arrpsz (INV(a), n) -<0> @(arrayptr (a, n), size_t n)
// end of [arrpsz_decode]

(* ****** ****** *)

fun
arrpsz_get_ptrsize
  {a:vt0p}{n:int}
(
  psz: arrpsz (INV(a), n), asz: &size_t? >> size_t (n)
) :<!wrt> arrayptr (a, n) = "mac#%" // endfun

(* ****** ****** *)

symintr arrayptr

(* ****** ****** *)

fun{
a:t0p
} arrayptr_make_elt
  {n:int} (asz: size_t n, x: a):<!wrt> arrayptr (a, n)
// end of [arrayptr_make_elt]

(* ****** ****** *)

fun{
} arrayptr_make_intrange
  {l,r:int | l <= r}
  (l: int l, r: int r):<!wrt> arrayptr (intBtw(l, r), r-l)
// end of [arrayptr_make_intrange]

(* ****** ****** *)
//
// HX: this one is a field-selection
//
fun
arrayptr_make_arrpsz
  {a:vt0p}{n:int}
  (psz: arrpsz (INV(a), n)):<> arrayptr (a, n) = "mac#%"
overload arrayptr with arrayptr_make_arrpsz

(* ****** ****** *)

fun{a:t0p}
arrayptr_make_list{n:int}
  (asz: int n, xs: list (INV(a), n)):<!wrt> arrayptr (a, n)
// end of [arrayptr_make_list]
fun{a:t0p}
arrayptr_make_rlist{n:int}
  (asz: int n, xs: list (INV(a), n)):<!wrt> arrayptr (a, n)
// end of [arrayptr_make_rlist]

(* ****** ****** *)

fun{a:t0p}
arrayptr_make_subarray
  {n:int}{st,ln:int | st+ln <= n}
  (A: RD(arrayref (a, n)), size_t (st), size_t (ln)): arrayptr (a, ln)
// end of [arrayref_make_subarray]

(* ****** ****** *)

fun{a:vt0p}
arrayptr_make_list_vt{n:int}
  (asz: int n, xs: list_vt (INV(a), n)):<!wrt> arrayptr (a, n)
// end of [arrayptr_make_list_vt]
fun{a:vt0p}
arrayptr_make_rlist_vt{n:int}
  (asz: int n, xs: list_vt (INV(a), n)):<!wrt> arrayptr (a, n)
// end of [arrayptr_make_rlist_vt]

(* ****** ****** *)

fun{a:vt0p}
arrayptr_make_uninitized
  {n:int} (asz: size_t n):<!wrt> arrayptr (a?, n)
// end of [arrayptr_make_uninitized]

(* ****** ****** *)

fun{a:vt0p}
arrayptr_imake_list{n:int}
(
  A: !arrayptr (INV(a), n) >> arrayptr (a?!, n), n: size_t (n)
) : list_vt (a, n) // end of [arrayptr_imake_list]

(* ****** ****** *)

fun arrayptr_free
  {a:t0p}{l:addr}{n:int}
  (A: arrayptr (INV(a), l, n)):<!wrt> void = "mac#%"
// end of [arrayptr_free]

(* ****** ****** *)

(*
fun{}
fprint_array$sep (out: FILEref): void
*)
fun{a:vt0p}
fprint_arrayptr
  {l:addr}{n:int}
(
  out: FILEref, A: !arrayptr (INV(a), l, n), n: size_t n
) : void // end of [fprint_arrayptr]
fun{a:vt0p}
fprint_arrayptr_sep
  {l:addr}{n:int}
(
  out: FILEref
, A: !arrayptr (INV(a), l, n), n: size_t n, sep: NSH(string)
) : void // end of [fprint_arrayptr_sep]

(* ****** ****** *)

symintr arrayptr_get_at
//
fun{
a:t0p}{tk:tk
} arrayptr_get_at_gint
  {n:int}{i:nat | i < n}
  (A: !arrayptr (INV(a), n), i: g1int (tk, i)):<> (a)
fun{
a:t0p}{tk:tk
} arrayptr_get_at_guint
  {n:int}{i:nat | i < n}
  (A: !arrayptr (INV(a), n), i: g1uint (tk, i)):<> (a)
//
overload arrayptr_get_at with arrayptr_get_at_gint
overload arrayptr_get_at with arrayptr_get_at_guint
//
(* ****** ****** *)

symintr arrayptr_set_at
//
fun{
a:t0p}{tk:tk
} arrayptr_set_at_gint
  {n:int}{i:nat | i < n}
  (A: !arrayptr (INV(a), n), i: g1int (tk, i), x: a):<!wrt> void
fun{
a:t0p}{tk:tk
} arrayptr_set_at_guint
  {n:int}{i:nat | i < n}
  (A: !arrayptr (INV(a), n), i: g1uint (tk, i), x: a):<!wrt> void
//
overload arrayptr_set_at with arrayptr_set_at_gint of 0
overload arrayptr_set_at with arrayptr_set_at_guint of 0
//
(* ****** ****** *)

symintr arrayptr_exch_at

fun{
a:vt0p}{tk:tk
} arrayptr_exch_at_gint
  {n:int}{i:nat | i < n}
  (A: !arrayptr (INV(a), n), i: g1int (tk, i), x: &a >> _):<!wrt> void
// end of [arrayptr_exch_at_gint]

fun{
a:vt0p}{tk:tk
} arrayptr_exch_at_guint
  {n:int}{i:nat | i < n}
  (A: !arrayptr (INV(a), n), i: g1uint (tk, i), x: &a >> _):<!wrt> void
// end of [arrayptr_exch_at_guint]

overload arrayptr_exch_at with arrayptr_exch_at_gint of 0
overload arrayptr_exch_at with arrayptr_exch_at_guint of 0

(* ****** ****** *)

fun{a:vt0p}
arrayptr_interchange
  {n:int}
(
  A: !arrayptr (INV(a), n), i: sizeLt n, j: sizeLt n
) :<!wrt> void // end of [arrayptr_interchange]

(* ****** ****** *)

(*
fun{a:vt0p}{env:vt0p}
array_foreach$cont (x: &a, env: &env): void
fun{a:vt0p}{env:vt0p}
array_foreach$fwork (x: &a >> a, env: &(env) >> _): void
*)
fun{
a:vt0p
} arrayptr_foreach{n:int}
(
  A: !arrayptr (INV(a), n), asz: size_t (n)
) : sizeLte(n) // end of [arrayptr_foreach]
fun{
a:vt0p}{env:vt0p
} arrayptr_foreach_env{n:int}
(
  A: !arrayptr (INV(a), n), asz: size_t (n), env: &(env) >> _
) : sizeLte(n) // end of [arrayptr_foreach_env]

(* ****** ****** *)

fun{a:vt0p}
arrayptr_foreach_fun
  {n:int}{fe:eff}
(
  A: !arrayptr (INV(a), n), asz: size_t n, f: (&a) -<fun,fe> void
) :<fe> void // end of [arrayptr_foreach_fun]

fun{a:vt0p}
arrayptr_foreach_funenv
  {v:view}
  {vt:vtype}
  {n:int}
  {fe:eff}
(
  pfv: !v
| A: !arrayptr (INV(a), n)
, asz: size_t n
, f: (!v | &a, !vt) -<fun,fe> void
, env: !vt
) :<fe> void
// end of [arrayptr_foreach_funenv]

(* ****** ****** *)

(*
fun{a:vt0p}{env:vt0p}
array_iforeach$cont (i: size_t, x: &a, env: &env): void
fun{a:vt0p}{env:vt0p}
array_iforeach$fwork (i: size_t, x: &a >> a, env: &(env) >> _): void
*)
fun{
a:vt0p
} arrayptr_iforeach{n:int}
(
  A: !arrayptr (INV(a), n), asz: size_t (n)
) : sizeLte(n) // end of [arrayptr_iforeach]
fun{
a:vt0p}{env:vt0p
} arrayptr_iforeach_env{n:int}
(
  A: !arrayptr (INV(a), n), asz: size_t (n), env: &(env) >> _
) : sizeLte(n) // end of [arrayptr_iforeach_env]

(* ****** ****** *)

(*
fun{a:vt0p}{env:vt0p}
array_rforeach$cont (x: &a, env: &env): void
fun{a:vt0p}{env:vt0p}
array_rforeach$fwork (x: &a >> a, env: &(env) >> _): void
*)
fun{
a:vt0p
} arrayptr_rforeach{n:int}
(
  A: !arrayptr (INV(a), n), asz: size_t (n)
) : sizeLte(n) // end of [arrayptr_rforeach]
fun{
a:vt0p}{env:vt0p
} arrayptr_rforeach_env{n:int}
(
  A: !arrayptr (INV(a), n), asz: size_t (n), env: &(env) >> _
) : sizeLte(n) // end of [arrayptr_rforeach_env]

(* ****** ****** *)

(*
fun{a:vt0p}
array_initize$init (i: size_t, x: &a >> a?): void
*)
fun{a:vt0p}
arrayptr_initize
  {l:addr}{n:int}
(
  A: !arrayptr (a?, l, n) >> arrayptr (a, l, n), asz: size_t n
) : void // end of [arrayptr_initize]
macdef arrayptr_initialize = arrayptr_initize

(* ****** ****** *)

(*
fun{a:vt0p}
array_uninitize$clear (i: size_t, x: &a >> a?): void
*)
fun{a:vt0p}
arrayptr_uninitize
  {l:addr}{n:int}
(
  A: !arrayptr (INV(a), l, n) >> arrayptr (a?, l, n), asz: size_t n
) : void // end of [arrayptr_uninitize]
macdef
arrayptr_uninitialize = arrayptr_uninitize

(* ****** ****** *)

(*
fun{a:vt0p}
array_uninitize$clear (i: size_t, x: &a >> a?): void
*)
fun{a:vt0p}
arrayptr_freelin
  {l:addr}{n:int}
  (A: arrayptr (INV(a), l, n), asz: size_t (n)): void
// end of [arrayptr_freelin]

(* ****** ****** *)
//
(*
fun{a:vt0p}
array_tabulate$fopr (index: size_t): (a)
*)
fun{a:vt0p}
arrayptr_tabulate
  {n:int} (asz: size_t n): arrayptr (a, n)
//
fun{a:vt0p}
arrayptr_tabulate_cloref
  {n:int}
  (size_t n, (sizeLt(n)) -<cloref> a): arrayptr (a, n)
//
(* ****** ****** *)
//
fun
{a:vt0p}
arrayptr_quicksort
  {n:int}(A: !arrayptr(a, n) >> _, asz: size_t(n)): void
//
(* ****** ****** *)
//
// overloading for certain symbols
//
(* ****** ****** *)

overload [] with arrayptr_get_at_gint of 0
overload [] with arrayptr_get_at_guint of 0
overload [] with arrayptr_set_at_gint of 0
overload [] with arrayptr_set_at_guint of 0

(* ****** ****** *)

overload free with arrayptr_free

(* ****** ****** *)

overload fprint with fprint_arrayptr
overload fprint with fprint_arrayptr_sep

(* ****** ****** *)

overload ptrcast with arrayptr2ptr
overload ptrcast with arrayptrout2ptr

(* ****** ****** *)

(* end of [arrayptr.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/stream_vt.atxt
** Time of generation: Sun Oct 18 08:25:08 2015
*)

(* ****** ****** *)

sortdef t0p = t@ype and vt0p = vt@ype

(* ****** ****** *)
//
// HX: lazy linear streams
//
datavtype
stream_vt_con
  (a:vt@ype+) =
  | stream_vt_nil of ((*void*))
  | stream_vt_cons of (a, stream_vt(a))
//
where
stream_vt(a:vt@ype) = lazy_vt(stream_vt_con(a))
//
(* ****** ****** *)

vtypedef
streamopt_vt (a:vt0p) = Option_vt(stream_vt(a))

(* ****** ****** *)
//
// HX-2014-04-07:
// this is a regular function
// instead of a cast function
//
fun{a:t0p}
stream_vt2t
  (xs: stream_vt (INV(a))): stream (a)
//
(* ****** ****** *)

fun{a:vt0p}
stream2list_vt
  (xs: stream_vt (INV(a))): List0_vt (a)
// end of [stream2list_vt]

(* ****** ****** *)

fun{a:t0p}
stream_vt_free (xs: stream_vt a):<!wrt> void

(* ****** ****** *)
//
fun{a:t0p}
stream_vt_drop_exn
  (xs: stream_vt(INV(a)), n: intGte(0)): stream_vt(a)
// end of [stream_vt_drop_exn]
//
fun{a:t0p}
stream_vt_drop_opt
  (xs: stream_vt(INV(a)), n: intGte(0)): streamopt_vt(a)
// end of [stream_vt_drop_opt]
//
(* ****** ****** *)
//
fun{a:t0p}
stream_vt_head
  (xs: stream_vt(INV(a))):<!exnwrt> (a)
fun{a:t0p}
stream_vt_tail
  (xs: stream_vt(INV(a))):<!exnwrt> stream_vt(a)
//
fun{a:vt0p}
stream_vt_uncons
  (xs: &stream_vt(INV(a)) >> stream_vt(a)):<!exnwrt> (a)
//
(* ****** ****** *)

fun{
a:vt0p}{env:vt0p
} stream_vt_foreach$fwork
  (x: &a >> a?!, env: &env >> _): void // lin-cleared
fun{a:vt0p}
stream_vt_foreach (xs: stream_vt (INV(a))): void
fun{
a:vt0p}{env:vt0p
} stream_vt_foreach_env (xs: stream_vt (INV(a)), &env >> _): void

(* ****** ****** *)
//
fun{a:vt0p}
stream_vt_filter$pred (x: &a):<> bool
//
fun{a:t0p}
stream_vt_filter (xs: stream_vt (INV(a))): stream_vt (a)
//
fun{a:t0p}
stream_vt_filter_fun
(
  xs: stream_vt (INV(a)), pred: (&a) -<fun> bool
) : stream_vt (a) // end of [stream_vt_filter_fun]
fun{a:t0p}
stream_vt_filter_cloptr
(
  xs: stream_vt (INV(a)), pred: (&a) -<cloptr> bool
) : stream_vt (a) // end of [stream_vt_filter_cloptr]
//
fun{a:vt0p}
stream_vt_filterlin$clear (x: &a >> a?):<!wrt> void
fun{a:vt0p}
stream_vt_filterlin (xs: stream_vt (INV(a))): stream_vt (a)
//
(* ****** ****** *)
//
fun{
a:vt0p}{b:vt0p
} stream_vt_map$fopr (x: &a >> a?!): b // lin-cleared
fun{
a:vt0p}{b:vt0p
} stream_vt_map (xs: stream_vt (INV(a))): stream_vt (b)
//
fun{
a:vt0p}{b:vt0p
} stream_vt_map_fun
  (xs: stream_vt (INV(a)), f: (&a >> a?!) -<fun> b): stream_vt (b)
fun{
a:vt0p}{b:vt0p
} stream_vt_map_cloptr
  (xs: stream_vt (INV(a)), f: (&a >> a?!) -<cloptr> b): stream_vt (b)
//
(* ****** ****** *)
//
fun{
a1,a2:t0p}{b:vt0p
} stream_vt_map2$fopr
  (x1: &a1 >> _, x2: &a2 >> _): b
fun{
a1,a2:t0p}{b:vt0p
} stream_vt_map2 (
  xs1: stream_vt (INV(a1))
, xs2: stream_vt (INV(a2))
) : stream_vt (b) // end of [stream_vt_map2]
//
fun{
a1,a2:t0p}{b:vt0p
} stream_vt_map2_fun
(
  xs1: stream_vt (INV(a1))
, xs2: stream_vt (INV(a2))
, f: (&a1 >> _, &a2 >> _) -<fun> b
) : stream_vt (b) // end of [stream_vt_map2_fun]
fun{
a1,a2:t0p}{b:vt0p
} stream_vt_map2_cloptr
(
  xs1: stream_vt (INV(a1))
, xs2: stream_vt (INV(a2))
, f: (&a1 >> _, &a2 >> _) -<cloptr> b
) : stream_vt (b) // end of [stream_vt_map2_cloptr]
//
(* ****** ****** *)

fun{a:vt0p}
stream_vt_tabulate (): stream_vt (a)
fun{a:vt0p}
stream_vt_tabulate$fopr (i: intGte(0)): (a)

(* ****** ****** *)
//
absvtype
streamer_vtype (a:vt@ype+) = ptr
//
vtypedef
streamer_vt (a:vt0p) = streamer_vtype (a)
//
(* ****** ****** *)
//
fun{}
streamer_vt_make
  {a:vt0p} (stream_vt(INV(a))): streamer_vt(a)
//
fun{}
streamer_vt_free{a:vt0p} (streamer_vt(INV(a))): void
//
fun{
a:vt@ype
} streamer_vt_eval_exn (xser: !streamer_vt(INV(a))): (a)
//
(* ****** ****** *)
//
// overloading for certain symbols
//
(* ****** ****** *)

(* ****** ****** *)

overload ~ with streamer_vt_free

(* ****** ****** *)

overload [] with streamer_vt_eval_exn

(* ****** ****** *)

overload .head with stream_vt_head
overload .tail with stream_vt_tail

(* ****** ****** *)

(* end of [stream_vt.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/strptr.atxt
** Time of generation: Sat Oct 17 15:19:45 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2012 *)

(* ****** ****** *)

(*
** HX-2012:
** a Strptr0 is either the null-pointer or Strptr1
** a Strptr1 is a null-terminated arrayptr of characters
*)

(* ****** ****** *)

abst@ype
strbuf_t0ype (m:int, n:int) // HX: [m] byte size

(* ****** ****** *)

stadef
strbuf = strbuf_t0ype
viewdef
strbuf_v (l:addr, m:int, n:int) = strbuf (m, n) @ l

(* ****** ****** *)
//
praxi
strbuf2bytes
  {m,n:int} (buf: &strbuf (m, n) >> b0ytes (m)): void
//
praxi
strbuf2bytes_v
  {l:addr}{m,n:int} (pf: strbuf_v (l, m, n)): b0ytes_v (l, m)
//
(* ****** ****** *)

praxi
lemma_strptr_param
  {l:addr} (x: !strptr l): [l>=null] void
// end of [lemma_strptr_param]

praxi
lemma_strnptr_param
  {l:addr}{n:int}
(
  x: !strnptr (l, n)
) : [(l>null&&n>=0) || (l==null&&n==(~1))] void
// end of [lemma_strnptr_param]

(* ****** ****** *)

praxi
lemma_strbuf_param
  {l:addr}{m,n:int} (x: &strbuf (m, n)): [m>n] void
// end of [lemma_strbuf_param]

praxi
lemma_strbuf_v_param
  {l:addr}{m,n:int} (pf: !strbuf_v (l, m, n)): [l>null;m>n] void
// end of [lemma_strbuf_v_param]

(* ****** ****** *)

castfn
strptr2ptr
  {l:addr} (x: !strptr l):<> ptr (l)
castfn
strnptr2ptr
  {l:addr}{n:int} (x: !strnptr (l, n)):<> ptr (l)
// end of [strnptr2ptr]

(* ****** ****** *)
//
castfn
strnptr2strptr
  {l:addr}{n:int} (x: strnptr (l, n)):<> strptr (l)
// end of [strnptr2strptr]

castfn
strptr2strnptr
  {l:addr} (x: strptr (l)):<> [n:int] strnptr (l, n)
// end of [strptr2strnptr]
//
(* ****** ****** *)
//
castfn
strptr2stropt
  {l:addr}
(
  x: strptr (l)
) :<> [n:int|(l==null&&n < 0)||(l>null&&n>=0)] stropt (n)
castfn
strptr2stropt0 (x: Strptr0):<> Stropt0
castfn
stropt2stropt1 (x: Strptr1):<> Stropt1
//
castfn
strnptr2stropt
  {l:addr}{n:int} (x: strnptr (l, n)):<> stropt (n)
//
(* ****** ****** *)
//
castfn
strptr2string (x: Strptr1):<> String
//
castfn
strnptr2string
  {l:addr}{n:nat} (x: strnptr (l, n)):<> string (n)
//
(* ****** ****** *)

fun strptr_null ():<> strptr (null) = "mac#%"

(* ****** ****** *)

praxi
strptr_free_null
   {l:addr | l <= null} (x: strptr (l)):<> void
// end of [strptr_free_null]

(* ****** ****** *)

fun{}
strptr_is_null
  {l:addr} (x: !strptr l):<> bool (l==null)
fun{}
strptr_isnot_null
  {l:addr} (x: !strptr l):<> bool (l > null)

(* ****** ****** *)

fun{} strptr_is_empty (x: !Strptr1):<> bool
fun{} strptr_isnot_empty (x: !Strptr1):<> bool

(* ****** ****** *)

fun{}
strnptr_is_null
  {l:addr}{n:int} (x: !strnptr (l, n)):<> bool (l==null)
fun{}
strnptr_isnot_null
  {l:addr}{n:int} (x: !strnptr (l, n)):<> bool (l > null)

(* ****** ****** *)

fun lt_strptr_strptr
  (x1: !Strptr0, x2: !Strptr0):<> bool = "mac#%"
overload < with lt_strptr_strptr
fun lte_strptr_strptr
  (x1: !Strptr0, x2: !Strptr0):<> bool = "mac#%"
overload <= with lte_strptr_strptr

fun gt_strptr_strptr
  (x1: !Strptr0, x2: !Strptr0):<> bool = "mac#%"
overload > with gt_strptr_strptr
fun gte_strptr_strptr
  (x1: !Strptr0, x2: !Strptr0):<> bool = "mac#%"
overload >= with gte_strptr_strptr

fun eq_strptr_strptr
  (x1: !Strptr0, x2: !Strptr0):<> bool = "mac#%"
overload = with eq_strptr_strptr
fun neq_strptr_strptr
  (x1: !Strptr0, x2: !Strptr0):<> bool = "mac#%"
overload != with neq_strptr_strptr
overload <> with neq_strptr_strptr

(* ****** ****** *)
//
fun compare_strptr_strptr
  (x1: !Strptr0, x2: !Strptr0):<> Sgn = "mac#%"
//
(* ****** ****** *)

fun eq_strptr_string
  (x1: !Strptr1, x2: string):<> bool = "mac#%"
overload = with eq_strptr_string

fun neq_strptr_string
  (x1: !Strptr1, x2: string):<> bool = "mac#%"
overload != with neq_strptr_string
overload <> with neq_strptr_string

(* ****** ****** *)
//
fun compare_strptr_string
  (x1: !Strptr1, x2: string):<> Sgn = "mac#%"
//
(* ****** ****** *)

fun strptr_free (x: Strptr0):<!wrt> void = "mac#%"
fun strnptr_free (x: Strnptr0):<!wrt> void = "mac#%"

(* ****** ****** *)
//
fun
fprint_strptr
(
  out: FILEref, x: !Strptr0
) : void = "mac#%"
//
fun print_strptr (x: !Strptr0): void = "mac#%"
fun prerr_strptr (x: !Strptr0): void = "mac#%"
//
(* ****** ****** *)
//
fun print_strbuf
  {m,n:int} (buf: &strbuf(m, n)): void = "mac#%"
fun prerr_strbuf
  {m,n:int} (buf: &strbuf(m, n)): void = "mac#%"
//
fun
fprint_strbuf{m,n:int}
  (out: FILEref, buf: &strbuf (m, n)): void = "mac#%"
//
(* ****** ****** *)
//
fun{}
strnptr_get_at_size {n:int}
  (str: !strnptr (n), i: sizeLt n):<> charNZ
//
fun{tk:tk}
strnptr_get_at_gint
  {n:int}{i:nat | i < n}
  (s: !strnptr (n), i: g1int (tk, i)):<> charNZ
fun{tk:tk}
strnptr_get_at_guint
  {n:int}{i:nat | i < n}
  (s: !strnptr (n), i: g1uint (tk, i)):<> charNZ
//
symintr strnptr_get_at
overload strnptr_get_at with strnptr_get_at_size of 1
overload strnptr_get_at with strnptr_get_at_gint of 0
overload strnptr_get_at with strnptr_get_at_guint of 0
//
(* ****** ****** *)
//
fun{}
strnptr_set_at_size {n:int}
  (str: !strnptr (n), i: sizeLt n, c: charNZ):<!wrt> void
//
fun{tk:tk}
strnptr_set_at_gint
  {n:int}{i:nat | i < n}
  (s: !strnptr (n), i: g1int (tk, i), c: charNZ):<!wrt> void
fun{tk:tk}
strnptr_set_at_guint
  {n:int}{i:nat | i < n}
  (s: !strnptr (n), i: g1uint (tk, i), c: charNZ):<!wrt> void
//
symintr strnptr_set_at
overload strnptr_set_at with strnptr_set_at_size of 1
overload strnptr_set_at with strnptr_set_at_gint of 0
overload strnptr_set_at with strnptr_set_at_guint of 0
//
(* ****** ****** *)

fun{}
strptr_length (x: !Strptr0):<> ssize_t
fun{}
strnptr_length {n:int} (x: !strnptr n):<> ssize_t (n)

(* ****** ****** *)
//
fun{
} strptr0_copy (x: !Strptr0):<!wrt> Strptr0
fun{
} strptr1_copy (x: !Strptr1):<!wrt> Strptr1
fun{
} strnptr_copy
  {n:int} (x: !strnptr (n)):<!wrt> strnptr (n)
//
(* ****** ****** *)
//
fun{
} strptr_append (x1: !Strptr0, x2: !Strptr0):<!wrt> Strptr0
fun{
} strnptr_append {n1,n2:nat}
  (x1: !strnptr n1, x2: !strnptr n2):<!wrt> strnptr (n1+n2)
//
(* ****** ****** *)

fun{
} strptrlst_free (xs: List_vt (Strptr0)):<!wrt> void

(* ****** ****** *)

fun{
} strptrlst_concat (xs: List_vt (Strptr0)):<!wrt> Strptr0

(* ****** ****** *)

fun{env:vt0p}
strnptr_foreach$cont (c: &charNZ, env: &env): bool
fun{env:vt0p}
strnptr_foreach$fwork (c: &charNZ >> _, env: &env): void
fun{}
strnptr_foreach {n:nat} (str: !strnptr n): sizeLte(n)
fun{env:vt0p}
strnptr_foreach_env
  {n:nat} (str: !strnptr n, env: &(env) >> _): sizeLte(n)
// end of [strnptr_foreach_env]

(* ****** ****** *)

fun{env:vt0p}
strnptr_rforeach$cont (c: &charNZ, env: &env): bool
fun{env:vt0p}
strnptr_rforeach$fwork (c: &charNZ >> _, env: &env): void
fun{}
strnptr_rforeach {n:nat} (str: !strnptr n): sizeLte(n)
fun{env:vt0p}
strnptr_rforeach_env
  {n:nat} (str: !strnptr n, env: &(env) >> _): sizeLte(n)
// end of [strnptr_rforeach_env]

(* ****** ****** *)
//
// overloading for certain symbols
//
overload
[] with strnptr_get_at_size of 1
overload
[] with strnptr_get_at_gint of 0
overload
[] with strnptr_get_at_guint of 0
//
overload
[] with strnptr_set_at_size of 1
overload
[] with strnptr_set_at_gint of 0
overload
[] with strnptr_set_at_guint of 0
//
overload iseqz with strptr_is_null
overload iseqz with strnptr_is_null
overload isneqz with strptr_isnot_null
overload isneqz with strnptr_isnot_null
//
overload
compare with compare_strptr_strptr
overload
compare with compare_strptr_string
//
overload length with strptr_length
overload length with strnptr_length
//
overload copy with strptr0_copy of 0
overload copy with strptr1_copy of 10
//
overload free with strptr_free
overload free with strnptr_free
//
overload print with print_strptr
overload prerr with prerr_strptr
overload fprint with fprint_strptr
//
overload print with print_strbuf
overload prerr with prerr_strbuf
overload fprint with fprint_strbuf
//
overload ptrcast with strptr2ptr
overload ptrcast with strnptr2ptr
//
(* ****** ****** *)

(* end of [strptr.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/integer_fixed.atxt
** Time of generation: Sat Oct 17 15:19:46 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: January, 2013 *)

(* ****** ****** *)
//
// HX: for unindexed integer types
//
(* ****** ****** *)

sortdef tk = tkind

(* ****** ****** *)

typedef SHR(a:t@ype) = a // for commenting purpose
typedef NSH(a:t@ype) = a // for commenting purpose

(* ****** ****** *)
//
stadef int8knd = int8_kind
stadef int16knd = int16_kind
stadef int32knd = int32_kind
stadef int64knd = int64_kind
//
stadef uint8knd = uint8_kind
stadef uint16knd = uint16_kind
stadef uint32knd = uint32_kind
stadef uint64knd = uint64_kind
//
(* ****** ****** *)
//
fun g0int2int_int8_int (x: int8):<> int = "mac#%"
fun g0int2int_int16_int (x: int16):<> int = "mac#%"
fun g0int2int_int32_int (x: int32):<> int = "mac#%"
fun g0int2int_int64_int (x: int64):<> int = "mac#%"
//
(* ****** ****** *)
//
fun g0int_neg_int8 (x: int8):<> int8 = "mac#%"
fun g0int_abs_int8 (x: int8):<> int8 = "mac#%"
fun g0int_succ_int8 (x: int8):<> int8 = "mac#%"
fun g0int_pred_int8 (x: int8):<> int8 = "mac#%"
fun g0int_half_int8 (x: int8):<> int8 = "mac#%"
fun g0int_asl_int8 (x: int8, n: intGte(0)):<> int8 = "mac#%"
fun g0int_asr_int8 (x: int8, n: intGte(0)):<> int8 = "mac#%"
fun g0int_add_int8 (x: int8, y: int8):<> int8 = "mac#%"
fun g0int_sub_int8 (x: int8, y: int8):<> int8 = "mac#%"
fun g0int_mul_int8 (x: int8, y: int8):<> int8 = "mac#%"
fun g0int_div_int8 (x: int8, y: int8):<> int8 = "mac#%"
fun g0int_mod_int8 (x: int8, y: int8):<> int8 = "mac#%"
fun g0int_isltz_int8 (x: int8):<> bool = "mac#%"
fun g0int_isltez_int8 (x: int8):<> bool = "mac#%"
fun g0int_isgtz_int8 (x: int8):<> bool = "mac#%"
fun g0int_isgtez_int8 (x: int8):<> bool = "mac#%"
fun g0int_iseqz_int8 (x: int8):<> bool = "mac#%"
fun g0int_isneqz_int8 (x: int8):<> bool = "mac#%"
fun g0int_lt_int8 (x: int8, y: int8):<> bool = "mac#%"
fun g0int_lte_int8 (x: int8, y: int8):<> bool = "mac#%"
fun g0int_gt_int8 (x: int8, y: int8):<> bool = "mac#%"
fun g0int_gte_int8 (x: int8, y: int8):<> bool = "mac#%"
fun g0int_eq_int8 (x: int8, y: int8):<> bool = "mac#%"
fun g0int_neq_int8 (x: int8, y: int8):<> bool = "mac#%"
fun g0int_compare_int8 (x: int8, y: int8):<> int = "mac#%"
fun g0int_max_int8 (x: int8, y: int8):<> int8 = "mac#%"
fun g0int_min_int8 (x: int8, y: int8):<> int8 = "mac#%"
//
fun g0int_neg_int16 (x: int16):<> int16 = "mac#%"
fun g0int_abs_int16 (x: int16):<> int16 = "mac#%"
fun g0int_succ_int16 (x: int16):<> int16 = "mac#%"
fun g0int_pred_int16 (x: int16):<> int16 = "mac#%"
fun g0int_half_int16 (x: int16):<> int16 = "mac#%"
fun g0int_asl_int16 (x: int16, n: intGte(0)):<> int16 = "mac#%"
fun g0int_asr_int16 (x: int16, n: intGte(0)):<> int16 = "mac#%"
fun g0int_add_int16 (x: int16, y: int16):<> int16 = "mac#%"
fun g0int_sub_int16 (x: int16, y: int16):<> int16 = "mac#%"
fun g0int_mul_int16 (x: int16, y: int16):<> int16 = "mac#%"
fun g0int_div_int16 (x: int16, y: int16):<> int16 = "mac#%"
fun g0int_mod_int16 (x: int16, y: int16):<> int16 = "mac#%"
fun g0int_isltz_int16 (x: int16):<> bool = "mac#%"
fun g0int_isltez_int16 (x: int16):<> bool = "mac#%"
fun g0int_isgtz_int16 (x: int16):<> bool = "mac#%"
fun g0int_isgtez_int16 (x: int16):<> bool = "mac#%"
fun g0int_iseqz_int16 (x: int16):<> bool = "mac#%"
fun g0int_isneqz_int16 (x: int16):<> bool = "mac#%"
fun g0int_lt_int16 (x: int16, y: int16):<> bool = "mac#%"
fun g0int_lte_int16 (x: int16, y: int16):<> bool = "mac#%"
fun g0int_gt_int16 (x: int16, y: int16):<> bool = "mac#%"
fun g0int_gte_int16 (x: int16, y: int16):<> bool = "mac#%"
fun g0int_eq_int16 (x: int16, y: int16):<> bool = "mac#%"
fun g0int_neq_int16 (x: int16, y: int16):<> bool = "mac#%"
fun g0int_compare_int16 (x: int16, y: int16):<> int = "mac#%"
fun g0int_max_int16 (x: int16, y: int16):<> int16 = "mac#%"
fun g0int_min_int16 (x: int16, y: int16):<> int16 = "mac#%"
//
fun g0int_neg_int32 (x: int32):<> int32 = "mac#%"
fun g0int_abs_int32 (x: int32):<> int32 = "mac#%"
fun g0int_succ_int32 (x: int32):<> int32 = "mac#%"
fun g0int_pred_int32 (x: int32):<> int32 = "mac#%"
fun g0int_half_int32 (x: int32):<> int32 = "mac#%"
fun g0int_asl_int32 (x: int32, n: intGte(0)):<> int32 = "mac#%"
fun g0int_asr_int32 (x: int32, n: intGte(0)):<> int32 = "mac#%"
fun g0int_add_int32 (x: int32, y: int32):<> int32 = "mac#%"
fun g0int_sub_int32 (x: int32, y: int32):<> int32 = "mac#%"
fun g0int_mul_int32 (x: int32, y: int32):<> int32 = "mac#%"
fun g0int_div_int32 (x: int32, y: int32):<> int32 = "mac#%"
fun g0int_mod_int32 (x: int32, y: int32):<> int32 = "mac#%"
fun g0int_isltz_int32 (x: int32):<> bool = "mac#%"
fun g0int_isltez_int32 (x: int32):<> bool = "mac#%"
fun g0int_isgtz_int32 (x: int32):<> bool = "mac#%"
fun g0int_isgtez_int32 (x: int32):<> bool = "mac#%"
fun g0int_iseqz_int32 (x: int32):<> bool = "mac#%"
fun g0int_isneqz_int32 (x: int32):<> bool = "mac#%"
fun g0int_lt_int32 (x: int32, y: int32):<> bool = "mac#%"
fun g0int_lte_int32 (x: int32, y: int32):<> bool = "mac#%"
fun g0int_gt_int32 (x: int32, y: int32):<> bool = "mac#%"
fun g0int_gte_int32 (x: int32, y: int32):<> bool = "mac#%"
fun g0int_eq_int32 (x: int32, y: int32):<> bool = "mac#%"
fun g0int_neq_int32 (x: int32, y: int32):<> bool = "mac#%"
fun g0int_compare_int32 (x: int32, y: int32):<> int = "mac#%"
fun g0int_max_int32 (x: int32, y: int32):<> int32 = "mac#%"
fun g0int_min_int32 (x: int32, y: int32):<> int32 = "mac#%"
//
fun g0int_neg_int64 (x: int64):<> int64 = "mac#%"
fun g0int_abs_int64 (x: int64):<> int64 = "mac#%"
fun g0int_succ_int64 (x: int64):<> int64 = "mac#%"
fun g0int_pred_int64 (x: int64):<> int64 = "mac#%"
fun g0int_half_int64 (x: int64):<> int64 = "mac#%"
fun g0int_asl_int64 (x: int64, n: intGte(0)):<> int64 = "mac#%"
fun g0int_asr_int64 (x: int64, n: intGte(0)):<> int64 = "mac#%"
fun g0int_add_int64 (x: int64, y: int64):<> int64 = "mac#%"
fun g0int_sub_int64 (x: int64, y: int64):<> int64 = "mac#%"
fun g0int_mul_int64 (x: int64, y: int64):<> int64 = "mac#%"
fun g0int_div_int64 (x: int64, y: int64):<> int64 = "mac#%"
fun g0int_mod_int64 (x: int64, y: int64):<> int64 = "mac#%"
fun g0int_isltz_int64 (x: int64):<> bool = "mac#%"
fun g0int_isltez_int64 (x: int64):<> bool = "mac#%"
fun g0int_isgtz_int64 (x: int64):<> bool = "mac#%"
fun g0int_isgtez_int64 (x: int64):<> bool = "mac#%"
fun g0int_iseqz_int64 (x: int64):<> bool = "mac#%"
fun g0int_isneqz_int64 (x: int64):<> bool = "mac#%"
fun g0int_lt_int64 (x: int64, y: int64):<> bool = "mac#%"
fun g0int_lte_int64 (x: int64, y: int64):<> bool = "mac#%"
fun g0int_gt_int64 (x: int64, y: int64):<> bool = "mac#%"
fun g0int_gte_int64 (x: int64, y: int64):<> bool = "mac#%"
fun g0int_eq_int64 (x: int64, y: int64):<> bool = "mac#%"
fun g0int_neq_int64 (x: int64, y: int64):<> bool = "mac#%"
fun g0int_compare_int64 (x: int64, y: int64):<> int = "mac#%"
fun g0int_max_int64 (x: int64, y: int64):<> int64 = "mac#%"
fun g0int_min_int64 (x: int64, y: int64):<> int64 = "mac#%"
//
(* ****** ****** *)

fun fprint_int8
  : fprint_type (int8) = "mac#%"
overload fprint with fprint_int8
fun print_int8 (x: int8): void = "mac#%"
fun prerr_int8 (x: int8): void = "mac#%"
overload print with print_int8
overload prerr with prerr_int8

fun fprint_int16
  : fprint_type (int16) = "mac#%"
overload fprint with fprint_int16
fun print_int16 (x: int16): void = "mac#%"
fun prerr_int16 (x: int16): void = "mac#%"
overload print with print_int16
overload prerr with prerr_int16

fun fprint_int32
  : fprint_type (int32) = "mac#%"
overload fprint with fprint_int32
fun print_int32 (x: int32): void = "mac#%"
fun prerr_int32 (x: int32): void = "mac#%"
overload print with print_int32
overload prerr with prerr_int32

fun fprint_int64
  : fprint_type (int64) = "mac#%"
overload fprint with fprint_int64
fun print_int64 (x: int64): void = "mac#%"
fun prerr_int64 (x: int64): void = "mac#%"
overload print with print_int64
overload prerr with prerr_int64


(* ****** ****** *)
//
fun g0int2uint_int8_uint (x: int8):<> uint = "mac#%"
fun g0int2uint_int16_uint (x: int16):<> uint = "mac#%"
fun g0int2uint_int32_uint (x: int32):<> uint = "mac#%"
fun g0int2uint_int64_uint (x: int64):<> uint = "mac#%"
//
fun g0uint2int_uint8_int (x: uint8):<> int = "mac#%"
fun g0uint2int_uint16_int (x: uint16):<> int = "mac#%"
fun g0uint2int_uint32_int (x: uint32):<> int = "mac#%"
fun g0uint2int_uint64_int (x: uint64):<> int = "mac#%"
//
fun g0uint2uint_uint8_uint (x: uint8):<> uint = "mac#%"
fun g0uint2uint_uint16_uint (x: uint16):<> uint = "mac#%"
fun g0uint2uint_uint32_uint (x: uint32):<> uint = "mac#%"
fun g0uint2uint_uint64_uint (x: uint64):<> uint = "mac#%"
//
(* ****** ****** *)
//
fun g0uint_succ_uint8 (x: uint8):<> uint8 = "mac#%"
fun g0uint_pred_uint8 (x: uint8):<> uint8 = "mac#%"
fun g0uint_half_uint8 (x: uint8):<> uint8 = "mac#%"
fun g0uint_add_uint8 (x: uint8, y: uint8):<> uint8 = "mac#%"
fun g0uint_sub_uint8 (x: uint8, y: uint8):<> uint8 = "mac#%"
fun g0uint_mul_uint8 (x: uint8, y: uint8):<> uint8 = "mac#%"
fun g0uint_div_uint8 (x: uint8, y: uint8):<> uint8 = "mac#%"
fun g0uint_mod_uint8 (x: uint8, y: uint8):<> uint8 = "mac#%"
fun g0uint_lsl_uint8 (x: uint8, n: intGte(0)):<> uint8 = "mac#%"
fun g0uint_lsr_uint8 (x: uint8, n: intGte(0)):<> uint8 = "mac#%"
fun g0uint_lnot_uint8 (x: uint8):<> uint8 = "mac#%"
fun g0uint_lor_uint8 (x: uint8, y: uint8):<> uint8 = "mac#%"
fun g0uint_lxor_uint8 (x: uint8, y: uint8):<> uint8 = "mac#%"
fun g0uint_land_uint8 (x: uint8, y: uint8):<> uint8 = "mac#%"
fun g0uint_isgtz_uint8 (x: uint8):<> bool = "mac#%"
fun g0uint_iseqz_uint8 (x: uint8):<> bool = "mac#%"
fun g0uint_isneqz_uint8 (x: uint8):<> bool = "mac#%"
fun g0uint_lt_uint8 (x: uint8, y: uint8):<> bool = "mac#%"
fun g0uint_lte_uint8 (x: uint8, y: uint8):<> bool = "mac#%"
fun g0uint_gt_uint8 (x: uint8, y: uint8):<> bool = "mac#%"
fun g0uint_gte_uint8 (x: uint8, y: uint8):<> bool = "mac#%"
fun g0uint_eq_uint8 (x: uint8, y: uint8):<> bool = "mac#%"
fun g0uint_neq_uint8 (x: uint8, y: uint8):<> bool = "mac#%"
fun g0uint_compare_uint8 (x: uint8, y: uint8):<> int = "mac#%"
fun g0uint_max_uint8 (x: uint8, y: uint8):<> uint8 = "mac#%"
fun g0uint_min_uint8 (x: uint8, y: uint8):<> uint8 = "mac#%"
//
fun g0uint_succ_uint16 (x: uint16):<> uint16 = "mac#%"
fun g0uint_pred_uint16 (x: uint16):<> uint16 = "mac#%"
fun g0uint_half_uint16 (x: uint16):<> uint16 = "mac#%"
fun g0uint_add_uint16 (x: uint16, y: uint16):<> uint16 = "mac#%"
fun g0uint_sub_uint16 (x: uint16, y: uint16):<> uint16 = "mac#%"
fun g0uint_mul_uint16 (x: uint16, y: uint16):<> uint16 = "mac#%"
fun g0uint_div_uint16 (x: uint16, y: uint16):<> uint16 = "mac#%"
fun g0uint_mod_uint16 (x: uint16, y: uint16):<> uint16 = "mac#%"
fun g0uint_lsl_uint16 (x: uint16, n: intGte(0)):<> uint16 = "mac#%"
fun g0uint_lsr_uint16 (x: uint16, n: intGte(0)):<> uint16 = "mac#%"
fun g0uint_lnot_uint16 (x: uint16):<> uint16 = "mac#%"
fun g0uint_lor_uint16 (x: uint16, y: uint16):<> uint16 = "mac#%"
fun g0uint_lxor_uint16 (x: uint16, y: uint16):<> uint16 = "mac#%"
fun g0uint_land_uint16 (x: uint16, y: uint16):<> uint16 = "mac#%"
fun g0uint_isgtz_uint16 (x: uint16):<> bool = "mac#%"
fun g0uint_iseqz_uint16 (x: uint16):<> bool = "mac#%"
fun g0uint_isneqz_uint16 (x: uint16):<> bool = "mac#%"
fun g0uint_lt_uint16 (x: uint16, y: uint16):<> bool = "mac#%"
fun g0uint_lte_uint16 (x: uint16, y: uint16):<> bool = "mac#%"
fun g0uint_gt_uint16 (x: uint16, y: uint16):<> bool = "mac#%"
fun g0uint_gte_uint16 (x: uint16, y: uint16):<> bool = "mac#%"
fun g0uint_eq_uint16 (x: uint16, y: uint16):<> bool = "mac#%"
fun g0uint_neq_uint16 (x: uint16, y: uint16):<> bool = "mac#%"
fun g0uint_compare_uint16 (x: uint16, y: uint16):<> int = "mac#%"
fun g0uint_max_uint16 (x: uint16, y: uint16):<> uint16 = "mac#%"
fun g0uint_min_uint16 (x: uint16, y: uint16):<> uint16 = "mac#%"
//
fun g0uint_succ_uint32 (x: uint32):<> uint32 = "mac#%"
fun g0uint_pred_uint32 (x: uint32):<> uint32 = "mac#%"
fun g0uint_half_uint32 (x: uint32):<> uint32 = "mac#%"
fun g0uint_add_uint32 (x: uint32, y: uint32):<> uint32 = "mac#%"
fun g0uint_sub_uint32 (x: uint32, y: uint32):<> uint32 = "mac#%"
fun g0uint_mul_uint32 (x: uint32, y: uint32):<> uint32 = "mac#%"
fun g0uint_div_uint32 (x: uint32, y: uint32):<> uint32 = "mac#%"
fun g0uint_mod_uint32 (x: uint32, y: uint32):<> uint32 = "mac#%"
fun g0uint_lsl_uint32 (x: uint32, n: intGte(0)):<> uint32 = "mac#%"
fun g0uint_lsr_uint32 (x: uint32, n: intGte(0)):<> uint32 = "mac#%"
fun g0uint_lnot_uint32 (x: uint32):<> uint32 = "mac#%"
fun g0uint_lor_uint32 (x: uint32, y: uint32):<> uint32 = "mac#%"
fun g0uint_lxor_uint32 (x: uint32, y: uint32):<> uint32 = "mac#%"
fun g0uint_land_uint32 (x: uint32, y: uint32):<> uint32 = "mac#%"
fun g0uint_isgtz_uint32 (x: uint32):<> bool = "mac#%"
fun g0uint_iseqz_uint32 (x: uint32):<> bool = "mac#%"
fun g0uint_isneqz_uint32 (x: uint32):<> bool = "mac#%"
fun g0uint_lt_uint32 (x: uint32, y: uint32):<> bool = "mac#%"
fun g0uint_lte_uint32 (x: uint32, y: uint32):<> bool = "mac#%"
fun g0uint_gt_uint32 (x: uint32, y: uint32):<> bool = "mac#%"
fun g0uint_gte_uint32 (x: uint32, y: uint32):<> bool = "mac#%"
fun g0uint_eq_uint32 (x: uint32, y: uint32):<> bool = "mac#%"
fun g0uint_neq_uint32 (x: uint32, y: uint32):<> bool = "mac#%"
fun g0uint_compare_uint32 (x: uint32, y: uint32):<> int = "mac#%"
fun g0uint_max_uint32 (x: uint32, y: uint32):<> uint32 = "mac#%"
fun g0uint_min_uint32 (x: uint32, y: uint32):<> uint32 = "mac#%"
//
fun g0uint_succ_uint64 (x: uint64):<> uint64 = "mac#%"
fun g0uint_pred_uint64 (x: uint64):<> uint64 = "mac#%"
fun g0uint_half_uint64 (x: uint64):<> uint64 = "mac#%"
fun g0uint_add_uint64 (x: uint64, y: uint64):<> uint64 = "mac#%"
fun g0uint_sub_uint64 (x: uint64, y: uint64):<> uint64 = "mac#%"
fun g0uint_mul_uint64 (x: uint64, y: uint64):<> uint64 = "mac#%"
fun g0uint_div_uint64 (x: uint64, y: uint64):<> uint64 = "mac#%"
fun g0uint_mod_uint64 (x: uint64, y: uint64):<> uint64 = "mac#%"
fun g0uint_lsl_uint64 (x: uint64, n: intGte(0)):<> uint64 = "mac#%"
fun g0uint_lsr_uint64 (x: uint64, n: intGte(0)):<> uint64 = "mac#%"
fun g0uint_lnot_uint64 (x: uint64):<> uint64 = "mac#%"
fun g0uint_lor_uint64 (x: uint64, y: uint64):<> uint64 = "mac#%"
fun g0uint_lxor_uint64 (x: uint64, y: uint64):<> uint64 = "mac#%"
fun g0uint_land_uint64 (x: uint64, y: uint64):<> uint64 = "mac#%"
fun g0uint_isgtz_uint64 (x: uint64):<> bool = "mac#%"
fun g0uint_iseqz_uint64 (x: uint64):<> bool = "mac#%"
fun g0uint_isneqz_uint64 (x: uint64):<> bool = "mac#%"
fun g0uint_lt_uint64 (x: uint64, y: uint64):<> bool = "mac#%"
fun g0uint_lte_uint64 (x: uint64, y: uint64):<> bool = "mac#%"
fun g0uint_gt_uint64 (x: uint64, y: uint64):<> bool = "mac#%"
fun g0uint_gte_uint64 (x: uint64, y: uint64):<> bool = "mac#%"
fun g0uint_eq_uint64 (x: uint64, y: uint64):<> bool = "mac#%"
fun g0uint_neq_uint64 (x: uint64, y: uint64):<> bool = "mac#%"
fun g0uint_compare_uint64 (x: uint64, y: uint64):<> int = "mac#%"
fun g0uint_max_uint64 (x: uint64, y: uint64):<> uint64 = "mac#%"
fun g0uint_min_uint64 (x: uint64, y: uint64):<> uint64 = "mac#%"
//
(* ****** ****** *)

fun fprint_uint8
  : fprint_type (uint8) = "mac#%"
overload fprint with fprint_uint8
fun print_uint8 (x: uint8): void = "mac#%"
fun prerr_uint8 (x: uint8): void = "mac#%"
overload print with print_uint8
overload prerr with prerr_uint8

fun fprint_uint16
  : fprint_type (uint16) = "mac#%"
overload fprint with fprint_uint16
fun print_uint16 (x: uint16): void = "mac#%"
fun prerr_uint16 (x: uint16): void = "mac#%"
overload print with print_uint16
overload prerr with prerr_uint16

fun fprint_uint32
  : fprint_type (uint32) = "mac#%"
overload fprint with fprint_uint32
fun print_uint32 (x: uint32): void = "mac#%"
fun prerr_uint32 (x: uint32): void = "mac#%"
overload print with print_uint32
overload prerr with prerr_uint32

fun fprint_uint64
  : fprint_type (uint64) = "mac#%"
overload fprint with fprint_uint64
fun print_uint64 (x: uint64): void = "mac#%"
fun prerr_uint64 (x: uint64): void = "mac#%"
overload print with print_uint64
overload prerr with prerr_uint64


(* ****** ****** *)
//
fun g1int_neg_int8 : g1int_neg_type (int8knd) = "mac#%"
fun g1int_abs_int8 : g1int_abs_type (int8knd) = "mac#%"
fun g1int_succ_int8 : g1int_succ_type (int8knd) = "mac#%"
fun g1int_pred_int8 : g1int_pred_type (int8knd) = "mac#%"
fun g1int_half_int8 : g1int_half_type (int8knd) = "mac#%"
fun g1int_add_int8 : g1int_add_type (int8knd) = "mac#%"
fun g1int_sub_int8 : g1int_sub_type (int8knd) = "mac#%"
fun g1int_mul_int8 : g1int_mul_type (int8knd) = "mac#%"
fun g1int_div_int8 : g1int_div_type (int8knd) = "mac#%"
fun g1int_nmod_int8 : g1int_nmod_type (int8knd) = "mac#%"
fun g1int_isltz_int8 : g1int_isltz_type (int8knd) = "mac#%"
fun g1int_isltez_int8 : g1int_isltez_type (int8knd) = "mac#%"
fun g1int_isgtz_int8 : g1int_isgtz_type (int8knd) = "mac#%"
fun g1int_isgtez_int8 : g1int_isgtez_type (int8knd) = "mac#%"
fun g1int_iseqz_int8 : g1int_iseqz_type (int8knd) = "mac#%"
fun g1int_isneqz_int8 : g1int_isneqz_type (int8knd) = "mac#%"
fun g1int_lt_int8 : g1int_lt_type (int8knd) = "mac#%"
fun g1int_lte_int8 : g1int_lte_type (int8knd) = "mac#%"
fun g1int_gt_int8 : g1int_gt_type (int8knd) = "mac#%"
fun g1int_gte_int8 : g1int_gte_type (int8knd) = "mac#%"
fun g1int_eq_int8 : g1int_eq_type (int8knd) = "mac#%"
fun g1int_neq_int8 : g1int_neq_type (int8knd) = "mac#%"
fun g1int_compare_int8 : g1int_compare_type (int8knd) = "mac#%"
fun g1int_max_int8 : g1int_max_type (int8knd) = "mac#%"
fun g1int_min_int8 : g1int_min_type (int8knd) = "mac#%"
//
fun g1int_neg_int16 : g1int_neg_type (int16knd) = "mac#%"
fun g1int_abs_int16 : g1int_abs_type (int16knd) = "mac#%"
fun g1int_succ_int16 : g1int_succ_type (int16knd) = "mac#%"
fun g1int_pred_int16 : g1int_pred_type (int16knd) = "mac#%"
fun g1int_half_int16 : g1int_half_type (int16knd) = "mac#%"
fun g1int_add_int16 : g1int_add_type (int16knd) = "mac#%"
fun g1int_sub_int16 : g1int_sub_type (int16knd) = "mac#%"
fun g1int_mul_int16 : g1int_mul_type (int16knd) = "mac#%"
fun g1int_div_int16 : g1int_div_type (int16knd) = "mac#%"
fun g1int_nmod_int16 : g1int_nmod_type (int16knd) = "mac#%"
fun g1int_isltz_int16 : g1int_isltz_type (int16knd) = "mac#%"
fun g1int_isltez_int16 : g1int_isltez_type (int16knd) = "mac#%"
fun g1int_isgtz_int16 : g1int_isgtz_type (int16knd) = "mac#%"
fun g1int_isgtez_int16 : g1int_isgtez_type (int16knd) = "mac#%"
fun g1int_iseqz_int16 : g1int_iseqz_type (int16knd) = "mac#%"
fun g1int_isneqz_int16 : g1int_isneqz_type (int16knd) = "mac#%"
fun g1int_lt_int16 : g1int_lt_type (int16knd) = "mac#%"
fun g1int_lte_int16 : g1int_lte_type (int16knd) = "mac#%"
fun g1int_gt_int16 : g1int_gt_type (int16knd) = "mac#%"
fun g1int_gte_int16 : g1int_gte_type (int16knd) = "mac#%"
fun g1int_eq_int16 : g1int_eq_type (int16knd) = "mac#%"
fun g1int_neq_int16 : g1int_neq_type (int16knd) = "mac#%"
fun g1int_compare_int16 : g1int_compare_type (int16knd) = "mac#%"
fun g1int_max_int16 : g1int_max_type (int16knd) = "mac#%"
fun g1int_min_int16 : g1int_min_type (int16knd) = "mac#%"
//
fun g1int_neg_int32 : g1int_neg_type (int32knd) = "mac#%"
fun g1int_abs_int32 : g1int_abs_type (int32knd) = "mac#%"
fun g1int_succ_int32 : g1int_succ_type (int32knd) = "mac#%"
fun g1int_pred_int32 : g1int_pred_type (int32knd) = "mac#%"
fun g1int_half_int32 : g1int_half_type (int32knd) = "mac#%"
fun g1int_add_int32 : g1int_add_type (int32knd) = "mac#%"
fun g1int_sub_int32 : g1int_sub_type (int32knd) = "mac#%"
fun g1int_mul_int32 : g1int_mul_type (int32knd) = "mac#%"
fun g1int_div_int32 : g1int_div_type (int32knd) = "mac#%"
fun g1int_nmod_int32 : g1int_nmod_type (int32knd) = "mac#%"
fun g1int_isltz_int32 : g1int_isltz_type (int32knd) = "mac#%"
fun g1int_isltez_int32 : g1int_isltez_type (int32knd) = "mac#%"
fun g1int_isgtz_int32 : g1int_isgtz_type (int32knd) = "mac#%"
fun g1int_isgtez_int32 : g1int_isgtez_type (int32knd) = "mac#%"
fun g1int_iseqz_int32 : g1int_iseqz_type (int32knd) = "mac#%"
fun g1int_isneqz_int32 : g1int_isneqz_type (int32knd) = "mac#%"
fun g1int_lt_int32 : g1int_lt_type (int32knd) = "mac#%"
fun g1int_lte_int32 : g1int_lte_type (int32knd) = "mac#%"
fun g1int_gt_int32 : g1int_gt_type (int32knd) = "mac#%"
fun g1int_gte_int32 : g1int_gte_type (int32knd) = "mac#%"
fun g1int_eq_int32 : g1int_eq_type (int32knd) = "mac#%"
fun g1int_neq_int32 : g1int_neq_type (int32knd) = "mac#%"
fun g1int_compare_int32 : g1int_compare_type (int32knd) = "mac#%"
fun g1int_max_int32 : g1int_max_type (int32knd) = "mac#%"
fun g1int_min_int32 : g1int_min_type (int32knd) = "mac#%"
//
fun g1int_neg_int64 : g1int_neg_type (int64knd) = "mac#%"
fun g1int_abs_int64 : g1int_abs_type (int64knd) = "mac#%"
fun g1int_succ_int64 : g1int_succ_type (int64knd) = "mac#%"
fun g1int_pred_int64 : g1int_pred_type (int64knd) = "mac#%"
fun g1int_half_int64 : g1int_half_type (int64knd) = "mac#%"
fun g1int_add_int64 : g1int_add_type (int64knd) = "mac#%"
fun g1int_sub_int64 : g1int_sub_type (int64knd) = "mac#%"
fun g1int_mul_int64 : g1int_mul_type (int64knd) = "mac#%"
fun g1int_div_int64 : g1int_div_type (int64knd) = "mac#%"
fun g1int_nmod_int64 : g1int_nmod_type (int64knd) = "mac#%"
fun g1int_isltz_int64 : g1int_isltz_type (int64knd) = "mac#%"
fun g1int_isltez_int64 : g1int_isltez_type (int64knd) = "mac#%"
fun g1int_isgtz_int64 : g1int_isgtz_type (int64knd) = "mac#%"
fun g1int_isgtez_int64 : g1int_isgtez_type (int64knd) = "mac#%"
fun g1int_iseqz_int64 : g1int_iseqz_type (int64knd) = "mac#%"
fun g1int_isneqz_int64 : g1int_isneqz_type (int64knd) = "mac#%"
fun g1int_lt_int64 : g1int_lt_type (int64knd) = "mac#%"
fun g1int_lte_int64 : g1int_lte_type (int64knd) = "mac#%"
fun g1int_gt_int64 : g1int_gt_type (int64knd) = "mac#%"
fun g1int_gte_int64 : g1int_gte_type (int64knd) = "mac#%"
fun g1int_eq_int64 : g1int_eq_type (int64knd) = "mac#%"
fun g1int_neq_int64 : g1int_neq_type (int64knd) = "mac#%"
fun g1int_compare_int64 : g1int_compare_type (int64knd) = "mac#%"
fun g1int_max_int64 : g1int_max_type (int64knd) = "mac#%"
fun g1int_min_int64 : g1int_min_type (int64knd) = "mac#%"
//
(* ****** ****** *)
//
fun g1uint_succ_uint8 : g1uint_succ_type (uint8knd) = "mac#%"
fun g1uint_pred_uint8 : g1uint_pred_type (uint8knd) = "mac#%"
fun g1uint_half_uint8 : g1uint_half_type (uint8knd) = "mac#%"
fun g1uint_add_uint8 : g1uint_add_type (uint8knd) = "mac#%"
fun g1uint_sub_uint8 : g1uint_sub_type (uint8knd) = "mac#%"
fun g1uint_mul_uint8 : g1uint_mul_type (uint8knd) = "mac#%"
fun g1uint_div_uint8 : g1uint_div_type (uint8knd) = "mac#%"
fun g1uint_mod_uint8 : g1uint_mod_type (uint8knd) = "mac#%"
fun g1uint_isgtz_uint8 : g1uint_isgtz_type (uint8knd) = "mac#%"
fun g1uint_iseqz_uint8 : g1uint_iseqz_type (uint8knd) = "mac#%"
fun g1uint_isneqz_uint8 : g1uint_isneqz_type (uint8knd) = "mac#%"
fun g1uint_lt_uint8 : g1uint_lt_type (uint8knd) = "mac#%"
fun g1uint_lte_uint8 : g1uint_lte_type (uint8knd) = "mac#%"
fun g1uint_gt_uint8 : g1uint_gt_type (uint8knd) = "mac#%"
fun g1uint_gte_uint8 : g1uint_gte_type (uint8knd) = "mac#%"
fun g1uint_eq_uint8 : g1uint_eq_type (uint8knd) = "mac#%"
fun g1uint_neq_uint8 : g1uint_neq_type (uint8knd) = "mac#%"
fun g1uint_compare_uint8 : g1uint_compare_type (uint8knd) = "mac#%"
fun g1uint_max_uint8 : g1uint_max_type (uint8knd) = "mac#%"
fun g1uint_min_uint8 : g1uint_min_type (uint8knd) = "mac#%"
//
fun g1uint_succ_uint16 : g1uint_succ_type (uint16knd) = "mac#%"
fun g1uint_pred_uint16 : g1uint_pred_type (uint16knd) = "mac#%"
fun g1uint_half_uint16 : g1uint_half_type (uint16knd) = "mac#%"
fun g1uint_add_uint16 : g1uint_add_type (uint16knd) = "mac#%"
fun g1uint_sub_uint16 : g1uint_sub_type (uint16knd) = "mac#%"
fun g1uint_mul_uint16 : g1uint_mul_type (uint16knd) = "mac#%"
fun g1uint_div_uint16 : g1uint_div_type (uint16knd) = "mac#%"
fun g1uint_mod_uint16 : g1uint_mod_type (uint16knd) = "mac#%"
fun g1uint_isgtz_uint16 : g1uint_isgtz_type (uint16knd) = "mac#%"
fun g1uint_iseqz_uint16 : g1uint_iseqz_type (uint16knd) = "mac#%"
fun g1uint_isneqz_uint16 : g1uint_isneqz_type (uint16knd) = "mac#%"
fun g1uint_lt_uint16 : g1uint_lt_type (uint16knd) = "mac#%"
fun g1uint_lte_uint16 : g1uint_lte_type (uint16knd) = "mac#%"
fun g1uint_gt_uint16 : g1uint_gt_type (uint16knd) = "mac#%"
fun g1uint_gte_uint16 : g1uint_gte_type (uint16knd) = "mac#%"
fun g1uint_eq_uint16 : g1uint_eq_type (uint16knd) = "mac#%"
fun g1uint_neq_uint16 : g1uint_neq_type (uint16knd) = "mac#%"
fun g1uint_compare_uint16 : g1uint_compare_type (uint16knd) = "mac#%"
fun g1uint_max_uint16 : g1uint_max_type (uint16knd) = "mac#%"
fun g1uint_min_uint16 : g1uint_min_type (uint16knd) = "mac#%"
//
fun g1uint_succ_uint32 : g1uint_succ_type (uint32knd) = "mac#%"
fun g1uint_pred_uint32 : g1uint_pred_type (uint32knd) = "mac#%"
fun g1uint_half_uint32 : g1uint_half_type (uint32knd) = "mac#%"
fun g1uint_add_uint32 : g1uint_add_type (uint32knd) = "mac#%"
fun g1uint_sub_uint32 : g1uint_sub_type (uint32knd) = "mac#%"
fun g1uint_mul_uint32 : g1uint_mul_type (uint32knd) = "mac#%"
fun g1uint_div_uint32 : g1uint_div_type (uint32knd) = "mac#%"
fun g1uint_mod_uint32 : g1uint_mod_type (uint32knd) = "mac#%"
fun g1uint_isgtz_uint32 : g1uint_isgtz_type (uint32knd) = "mac#%"
fun g1uint_iseqz_uint32 : g1uint_iseqz_type (uint32knd) = "mac#%"
fun g1uint_isneqz_uint32 : g1uint_isneqz_type (uint32knd) = "mac#%"
fun g1uint_lt_uint32 : g1uint_lt_type (uint32knd) = "mac#%"
fun g1uint_lte_uint32 : g1uint_lte_type (uint32knd) = "mac#%"
fun g1uint_gt_uint32 : g1uint_gt_type (uint32knd) = "mac#%"
fun g1uint_gte_uint32 : g1uint_gte_type (uint32knd) = "mac#%"
fun g1uint_eq_uint32 : g1uint_eq_type (uint32knd) = "mac#%"
fun g1uint_neq_uint32 : g1uint_neq_type (uint32knd) = "mac#%"
fun g1uint_compare_uint32 : g1uint_compare_type (uint32knd) = "mac#%"
fun g1uint_max_uint32 : g1uint_max_type (uint32knd) = "mac#%"
fun g1uint_min_uint32 : g1uint_min_type (uint32knd) = "mac#%"
//
fun g1uint_succ_uint64 : g1uint_succ_type (uint64knd) = "mac#%"
fun g1uint_pred_uint64 : g1uint_pred_type (uint64knd) = "mac#%"
fun g1uint_half_uint64 : g1uint_half_type (uint64knd) = "mac#%"
fun g1uint_add_uint64 : g1uint_add_type (uint64knd) = "mac#%"
fun g1uint_sub_uint64 : g1uint_sub_type (uint64knd) = "mac#%"
fun g1uint_mul_uint64 : g1uint_mul_type (uint64knd) = "mac#%"
fun g1uint_div_uint64 : g1uint_div_type (uint64knd) = "mac#%"
fun g1uint_mod_uint64 : g1uint_mod_type (uint64knd) = "mac#%"
fun g1uint_isgtz_uint64 : g1uint_isgtz_type (uint64knd) = "mac#%"
fun g1uint_iseqz_uint64 : g1uint_iseqz_type (uint64knd) = "mac#%"
fun g1uint_isneqz_uint64 : g1uint_isneqz_type (uint64knd) = "mac#%"
fun g1uint_lt_uint64 : g1uint_lt_type (uint64knd) = "mac#%"
fun g1uint_lte_uint64 : g1uint_lte_type (uint64knd) = "mac#%"
fun g1uint_gt_uint64 : g1uint_gt_type (uint64knd) = "mac#%"
fun g1uint_gte_uint64 : g1uint_gte_type (uint64knd) = "mac#%"
fun g1uint_eq_uint64 : g1uint_eq_type (uint64knd) = "mac#%"
fun g1uint_neq_uint64 : g1uint_neq_type (uint64knd) = "mac#%"
fun g1uint_compare_uint64 : g1uint_compare_type (uint64knd) = "mac#%"
fun g1uint_max_uint64 : g1uint_max_type (uint64knd) = "mac#%"
fun g1uint_min_uint64 : g1uint_min_type (uint64knd) = "mac#%"
//
(* ****** ****** *)

(* end of [integer_fixed.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/extern.atxt
** Time of generation: Sat Oct 17 15:19:51 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2012 *)

(* ****** ****** *)

sortdef vt0p = viewt@ype

(* ****** ****** *)

abstype
carrayptr (a:t@ype, l:addr, n:int) = ptr(l)
typedef
carrayptr0 (a:t@ype, n:int) = [l:addr] carrayptr (a, l, n)
typedef
carrayptr1 (a:t@ype, n:int) = [l:addr | l > null] carrayptr (a, l, n)

(* ****** ****** *)
//
// HX-2014-01-30: these are inherently unsafe:
//
castfn
carrayptr_null
  {a:t@ype}{n:nat} (p: ptr(null)):<> carrayptr (a, null, n)
castfn
carrayptr_array
  {a:t@ype}{n:int} (A: &array(INV(a), n)):<> carrayptr1 (a, n)
castfn
carrayptr_arrayref
  {a:t@ype}{n:int} (A: arrayref(INV(a), n)):<> carrayptr1 (a, n)
castfn
carrayptr_arrayptr
  {a:t@ype}{l:addr}{n:int}
  (A: !arrayptr(INV(a), l, n)):<> [l > null] carrayptr (a, l, n)
//
(* ****** ****** *)

symintr carrayptr
overload carrayptr with carrayptr_null
overload carrayptr with carrayptr_array
overload carrayptr with carrayptr_arrayref
overload carrayptr with carrayptr_arrayptr

(* ****** ****** *)
//
// HX: note that (vt1 \minus v2) roughly means that a ticket of
// [v2] is taken from [vt1]; the ticket must be returned before
// [vt1] is consumed. However, the ticket should not be issued
// repeatedly for otherwise safety may be potentially compromised.
//
absview
minus_viewt0ype_view_view (vt1: vt0p, v2: view) = vt1
viewdef
minus(vt1: vt0p, v2: view) = minus_viewt0ype_view_view(vt1, v2)
//
praxi minus_addback
  {vt1:vt0p}{v2:view} (pf1: minus (vt1, v2), pf2: v2 | x: !vt1): void
//
(* ****** ****** *)

vtypedef vtget0 (vt1:vt0p, vt2: vt0p) = (minus (vt1, vt2) | vt2)

(* ****** ****** *)

castfn
argv_takeout_strarr
  {n:int} (
  argv: !argv (n)
) :<> [l:addr] (
  array_v (string, l, n), minus (argv n, array_v (string, l, n)) | ptr l
) // end of [argv_takeout_strarr]

castfn
argv_takeout_parray
  {n:int} (
  argv: !argv (n)
) :<> [l:addr] (
  parray_v (string, l, n), minus (argv n, parray_v (string, l, n)) | ptr l
) // end of [argv_takeout_parray]

(* ****** ****** *)

(* end of [extern.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/filebas.atxt
** Time of generation: Sun Oct 18 14:27:08 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2012 *)

(* ****** ****** *)

sortdef t0p = t@ype and vt0p = viewt@ype

(* ****** ****** *)

#define NSH (x) x // for commenting: no sharing
#define SHR (x) x // for commenting: it is shared

(* ****** ****** *)

val stdin_ref : FILEref = "mac#%FILE_stdin"
val stdout_ref : FILEref = "mac#%FILE_stdout"
val stderr_ref : FILEref = "mac#%FILE_stderr"

(* ****** ****** *)

fun{} dirsep_get ():<> charNZ
fun{} dirname_self ():<> string
fun{} dirname_parent ():<> string

(* ****** ****** *)

fun{}
filename_get_ext (name: string):<> vStrptr0
fun{}
filename_test_ext (name: string, ext: string):<> bool

(* ****** ****** *)

fun{}
filename_get_base (name: string):<> vStrptr1
fun{}
filename_test_base (name: string, base: string):<> bool

(* ****** ****** *)
//
val file_mode_r
  : file_mode (file_mode_r()) = "mac#%" // = "r"
val file_mode_rr
  : file_mode (file_mode_rw()) = "mac#%" // = "r+"
//
val file_mode_w
  : file_mode (file_mode_w()) = "mac#%" // = "w"
val file_mode_ww
  : file_mode (file_mode_rw()) = "mac#%" // = "w+"
//
val file_mode_a
  : file_mode (file_mode_rw()) = "mac#%" // = "a"
val file_mode_aa
  : file_mode (file_mode_rw()) = "mac#%" // = "a+"
//
(* ****** ****** *)
//
(*
** HX: [stat] is called
*)
fun
test_file_exists (path: NSH(string)): bool = "mac#%"
//
(* ****** ****** *)
//
// HX-2011-02-16:
// [stat] is called to obtain the mode of a given file
// for [f] to be applied to it.
//
fun{}
test_file_mode (path: NSH(string)): int
//
fun{} test_file_mode$pred (mode: uint): bool
//
fun test_file_mode_fun
  (path: NSH(string), f: uint -> bool): int = "mac#%"
//
// HX: [stat] is called // ~1/0/1: error/false/true
//
fun test_file_isblk (path: NSH(string)): int = "mac#%"
fun test_file_ischr (path: NSH(string)): int = "mac#%"
fun test_file_isdir (path: NSH(string)): int = "mac#%"
fun test_file_isfifo (path: NSH(string)): int = "mac#%"
fun test_file_isreg (path: NSH(string)): int = "mac#%"
//
// HX: [lstat] is called // ~1/0/1: error/false/true
//
fun test_file_islnk (path: NSH(string)): int = "mac#%"
//
(* ****** ****** *)

fun
fileref_open_exn
  (path: NSH(string), fm: file_mode): FILEref = "mac#%"
// end of [fileref_open_exn]

fun{}
fileref_open_opt
  (path: NSH(string), fm: file_mode): Option_vt (FILEref)
// end of [fileref_open_opt]

(* ****** ****** *)

fun fileref_close (fil: FILEref): void = "mac#%"

(* ****** ****** *)

fun fileref_flush (fil: FILEref): void = "mac#%"

(* ****** ****** *)
//
// HX: error indication: EOF
//
fun fileref_getc (inp: FILEref): int = "mac#%"
//
(* ****** ****** *)
//
// HX: no error reporting
//
symintr fileref_putc
//
fun fileref_putc_int
  (out: FILEref, c: int): void = "mac#%"
overload fileref_putc with fileref_putc_int
fun fileref_putc_char
  (out: FILEref, c: char): void = "mac#%"
overload fileref_putc with fileref_putc_char
//
(* ****** ****** *)
//
// HX: no error reporting
//
fun fileref_puts
  (out: FILEref, s: NSH(string)): void = "mac#%"
//
(* ****** ****** *)
//
fun fileref_is_eof (fil: FILEref): bool = "mac#%"
//
macdef
fileref_isnot_eof (inp) = ~fileref_is_eof (,(inp))
//
(* ****** ****** *)

typedef
fileref_load_type (a:t@ype) =
  (FILEref, &a? >> opt (a, b)) -<fun1> #[b:bool] bool (b)
// end of [fileref_load_type]

fun{a:t0p}
fileref_load : fileref_load_type (a)

fun fileref_load_int : fileref_load_type (int) = "mac#%"
fun fileref_load_lint : fileref_load_type (lint) = "mac#%"
fun fileref_load_uint : fileref_load_type (uint) = "mac#%"
fun fileref_load_ulint : fileref_load_type (ulint) = "mac#%"

fun fileref_load_float : fileref_load_type (float) = "mac#%"
fun fileref_load_double : fileref_load_type (double) = "mac#%"

(* ****** ****** *)

fun{a:t0p}
fileref_get_optval
  (inp: FILEref): Option_vt (a)
// end of [fileref_get_optval]

fun{
a:t0p
} fileref_get_exnmsg
  (inp: FILEref, msg: NSH(string)): a
// end of [fileref_get_exnmsg]

macdef
fileref_get_exnloc
  (inp) = fileref_get_exnmsg (,(inp), $mylocation)
// end of [fileref_get_exnloc]

(* ****** ****** *)

typedef charlst = List0 (char)
vtypedef charlst_vt = List0_vt (char)

(* ****** ****** *)
//
fun
fileref_get_line_charlst (inp: FILEref): charlst_vt
//
(* ****** ****** *)
//
(*
** HX: only for files of "tiny" size
*)
fun
fileref_get_lines_charlstlst (inp: FILEref): List0_vt (charlst_vt)
//
(* ****** ****** *)
//
(*
** HX: for handling files of "tiny" size
*)
fun
fileref_get_file_charlst (inp: FILEref): List0_vt (char)
fun
fileref_get2_file_charlst (inp: FILEref, n: int): List0_vt (char)
//
(* ****** ****** *)
//
fun
fileref_put_charlst (inp: FILEref, cs: NSH(List(char))): void
//
(* ****** ****** *)
//
//
// HX-2013-05:
// these functions are based on [fgets];
// they should only be applied to files containing
// no occurrences of the NUL character ('\000').
//
fun{}
fileref_get_line_string (inp: FILEref): Strptr1
//
fun{}
fileref_get_line_string_main
  (inp: FILEref, n: &int? >> int n): #[n:nat] strnptr (n)
fun{}
fileref_get_line_string$bufsize ((*void*)): intGte(1)
//
fun{}
fileref_get_lines_stringlst (inp: FILEref): List0_vt (Strptr1)
//
(* ****** ****** *)
//
fun{}
fileref_get_file_string (inp: FILEref): Strptr1
fun{}
fileref_get_file_string$bufsize ((*void*)): intGte(1)
//
(* ****** ****** *)
//
fun{}
fileref_get_word (inp: FILEref): Strptr0
fun{}
fileref_get_word$isalpha (c: charNZ): bool
//
(* ****** ****** *)
//
fun{}
fileref_foreach (inp: FILEref): void
fun{
env:vt0p
} fileref_foreach_env (inp: FILEref, env: &(env) >> _): void
//
fun{}
fileref_foreach$bufsize (): sizeGte(1)
fun{
env:vt0p
} fileref_foreach$fwork (c: char, env: &(env) >> _): void
fun{
env:vt0p
} fileref_foreach$fworkv
  {n:int} (arrayref(char, n), size_t(n), &(env) >> _): void
//
(* ****** ****** *)

(* end of [filebas.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/parray.atxt
** Time of generation: Sat Oct 17 15:19:51 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: April, 2012 *)

(* ****** ****** *)

sortdef vtp = viewtype

(* ****** ****** *)

(*
** HX: for null-pointer terminated arrays
*)

dataview
parray_v (
  a:viewt@ype+, addr(*l*), int(*n*)
) = // for arrays with a sentinel at the end
  | {l:addr}{n:int}
    parray_v_cons (a, l, n+1) of (a @ l, parray_v (a, l+sizeof(a), n))
  | {l:addr} parray_v_nil (a, l, 0) of (ptr null @ l)
// end of [parray_v]

(* ****** ****** *)

prfun
lemma_parray_v_params{a:vtp}
  {l:addr}{n:int} (pf: !parray_v (INV(a), l, n)): [l > null;n >= 0] void
// end of [lemma_parray_v_params]

(* ****** ****** *)

fun{
a:vtp
} parray_is_empty
  {l:addr}{n:int} (
  pf: !parray_v (INV(a), l, n) | p: ptr l
) :<> bool (n == 0) // end of [parray_is_empty]

fun{
a:vtp
} parray_isnot_empty
  {l:addr}{n:int}
  (pf: !parray_v (INV(a), l, n) | p: ptr l):<> bool (n > 0)
// end of [parray_isnot_empty]

(* ****** ****** *)

fun{
a:vtp
} parray_size
  {l:addr}{n:int}
  (pf: !parray_v (INV(a), l, n) | p: ptr l):<> size_t (n)
// end of [parray_size]

(* ****** ****** *)

(* end of [parray.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/checkast.atxt
** Time of generation: Sat Oct 17 15:19:46 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: December, 2013 *)

(* ****** ****** *)

#define
ATS_PACKNAME "ATSLIB.prelude.checkast"

(* ****** ****** *)

sortdef t0p = t@ype and vt0p = viewt@ype

(* ****** ****** *)

fun{tk:tk}
checkast_gintLt{i:int}
  (x: g0int(tk), i: int i, msg: RD(string)): g1intLt(tk, i)
fun{tk:tk}
checkast_gintLte{i:int}
  (x: g0int(tk), i: int i, msg: RD(string)): g1intLte(tk, i)
fun{tk:tk}
checkast_gintGt{i:int}
  (x: g0int(tk), i: int i, msg: RD(string)): g1intGt(tk, i)
fun{tk:tk}
checkast_gintGte{i:int}
  (x: g0int(tk), i: int i, msg: RD(string)): g1intGte(tk, i)
fun{tk:tk}
checkast_gintBtw{i,j:int}
  (x: g0int(tk), i: int i, j: int j, msg: RD(string)): g1intBtw(tk, i, j)
fun{tk:tk}
checkast_gintBtwe{i,j:int}
  (x: g0int(tk), i: int i, j: int j, msg: RD(string)): g1intBtwe(tk, i, j)

(* ****** ****** *)

macdef
ckastloc_gintLt (x, i) = checkast_gintLt (,(x), ,(i), $mylocation)
macdef
ckastloc_gintLte (x, i) = checkast_gintLte (,(x), ,(i), $mylocation)
macdef
ckastloc_gintGt (x, i) = checkast_gintGt (,(x), ,(i), $mylocation)
macdef
ckastloc_gintGte (x, i) = checkast_gintGte (,(x), ,(i), $mylocation)
macdef
ckastloc_gintBtw (x, i, j) = checkast_gintBtw (,(x), ,(i), ,(j), $mylocation)
macdef
ckastloc_gintBtwe (x, i, j) = checkast_gintBtwe (,(x), ,(i), ,(j), $mylocation)

(* ****** ****** *)

fun{}
checkast_Ptr1 (x: ptr, msg: RD(string)): Ptr1

(* ****** ****** *)

macdef
ckastloc_Ptr1 (x) = checkast_Ptr1 (,(x), $mylocation)

(* ****** ****** *)

fun{}
checkast_Strptr1 (x: Strptr0, msg: RD(string)): Strptr1

(* ****** ****** *)

macdef
ckastloc_Strptr1 (x) = checkast_Strptr1 (,(x), $mylocation)

(* ****** ****** *)

(* end of [checkast.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/array_prf.atxt
** Time of generation: Sat Oct 17 15:19:49 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2012 *)

(* ****** ****** *)

sortdef t0p = t@ype and vt0p = viewt@ype

(* ****** ****** *)

prfun
array_v_split
  {a:vt0p}
  {l:addr}
  {n:int}{i:nat | i <= n}
(
  pfarr: array_v (INV(a), l, n)
) :<prf> @(
  array_v (a, l, i), array_v (a, l+i*sizeof(a), n-i)
) // end of [array_v_split]

prfun
array_v_split_at
  {a:vt0p}
  {l:addr}
  {n:int}{i:nat | i <= n}
(
  pfarr: array_v (INV(a), l, n) | i: size_t (i)
) :<prf> @(
  array_v (a, l, i), array_v (a, l+i*sizeof(a), n-i)
) // end of [array_v_split_at]

prfun
array_v_unsplit
  {a:vt0p}
  {l:addr}
  {n1,n2:int}
(
  pf1arr: array_v (INV(a), l, n1)
, pf2arr: array_v (a, l+n1*sizeof(a), n2)
) :<prf> array_v (a, l, n1+n2) // end of [array_v_unsplit]

(* ****** ****** *)
//
prfun
array_v_extend :
  {a:vt0p}
  {l:addr}{n:int}
  (array_v (INV(a), l, n), a @ l+n*sizeof(a)) -<prf> array_v (a, l, n+1)
//
prfun
array_v_unextend :
  {a:vt0p}
  {l:addr}
  {n:int | n > 0}
  (array_v (INV(a), l, n)) -<prf> (array_v (a, l, n-1), a @ l+(n-1)*sizeof(a))
//
(* ****** ****** *)

prfun
array_v_takeout
  {a:vt0p}
  {l:addr}
  {n:int }
  {i:nat | i < n}
(
  pfarr: array_v (INV(a), l, n)
) :<prf> vtakeout (
  array_v (a, l, n), a @ (l+i*sizeof(a))
) (* end of [array_v_takeout] *)

(* ****** ****** *)

praxi
array_v_group
  {a:vt0p}{l:addr}{m,n:int}
  (pf: array_v (INV(a), l, m*n)): array_v (@[a][n], l, m)
// end of [array_v_group]

praxi
array_v_ungroup
  {a:vt0p}{l:addr}{m,n:int}
  (pf: array_v (@[INV(a)][n], l, m)): array_v (INV(a), l, m*n)
// end of [array_v_ungroup]

(* ****** ****** *)

(* end of [array_prf.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/giterator.atxt
** Time of generation: Sat Oct 17 15:19:50 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2012 *)

(* ****** ****** *)

typedef SHR(a:type) = a // for commenting purpose
typedef NSH(a:type) = a // for commenting purpose

(* ****** ****** *)

sortdef tk = tkind
sortdef t0p = t@ype
sortdef vtp = viewtype
sortdef vt0p = viewt@ype

(* ****** ****** *)
//
absviewtype
giter_viewtype ( // HX: boxed
  knd: tkind, kpm: tkind, x: viewt@ype+, f: int, r: int
) // end of [giter_viewtype]
stadef giter_5 = giter_viewtype
//
viewtypedef giter_3 (
  knd: tkind, kpm: tkind, x: vt0p
) = [f,r:int] giter_viewtype (knd, kpm, x, f, r)
viewtypedef giter_4 (
  knd: tkind, kpm: tkind, x: vt0p, fr:int
) = [f,r:int | f+r==fr] giter_viewtype (knd, kpm, x, f, r)
//
stadef giter = giter_3
stadef giter = giter_4
stadef giter = giter_5
//
(* ****** ****** *)

prfun lemma_giter_param
  {knd:tk}{kpm:tk}{x:vt0p}{f,r:int}
  (itr: !giter (knd, kpm, x, f, r)): [f>=0;r>=0] void
// end of [lemma_giter_param]

(* ****** ****** *)
//
// HX: for fun list giters
//
stacst giter_list_kind : tkind
stacst giter_list_param : () -> tkind

fun{x:t0p}
giter_make_list
  {n:int}
(
  xs: list (INV(x), n)
) : giter
  (giter_list_kind, giter_list_param(), x, 0, n)
// end of [giter_make_list]

fun giter_free_list
  {x:t0p}{f,r:int}
(
  itr: giter
    (giter_list_kind, giter_list_param(), x, f, r)
) : list (x, r) // end of [giter_free_list]

(* ****** ****** *)
//
// HX: for singly-linked list giters
//
stacst giter_list_vt_kind : tkind
stacst giter_list_vt_param : () -> tkind

fun{x:t0p}
giter_make_list_vt
  {n:int}
(
  xs: list_vt (INV(x), n)
) : giter
  (giter_list_vt_kind, giter_list_vt_param(), x, 0, n)
// end of [giter_make_list_vt]

fun giter_free_list_vt
  {x:t0p}{f,r:int}
(
  itr: giter
    (giter_list_vt_kind, giter_list_vt_param(), x, f, r)
) : list_vt (x, f+r) // end of [giter_free_list_vt]

(* ****** ****** *)
//
// HX: for linear array giters
//
stacst giter_array_kind : tkind
stacst giter_array_param : (addr) -> tkind

fun{x:vt0p}
giter_make_array
  {l:addr}{n:int}
(
  pf: array_v (INV(x), l, n) | p: ptr l, n: size_t n
) : giter (giter_array_kind, giter_array_param(l), x, 0, n)
// end of [giter_make_array]

fun giter_free_array
  {x:vt0p}{l:addr}{f,r:int}
(
  itr: giter
    (giter_array_kind, giter_array_param(l), x, f, r)
) : (array_v (x, l, f+r) | void) // endfun

(* ****** ****** *)
//
// HX: for functional string giters
//
stacst giter_string_kind : tkind
stacst giter_string_param : () -> tkind

fun
giter_make_string
  {n:int}
(
  str: string (n)
) : giter (
  giter_string_kind, giter_string_param(), char, 0, n
) // end of [giter_make_string]

fun
giter_free_string
  {f,r:int}
(
  itr: giter (giter_string_kind, giter_string_param(), char, f, r)
) : string (f+r) // end of [giter_free_string]

(* ****** ****** *)

fun{
knd:tk
}{x:vt0p
} fprint_giter_sep
  {kpm:tk}{f,r:int}
(
  out: FILEref
, itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f+r, 0)
, sep: NSH(string)
) : void // end of [fprint_giter_sep]

(* ****** ****** *)

macdef BEG = 0 and END = 1

(* ****** ****** *)

fun{
knd:tk}{x:vt0p
} giter_is_atbeg
  {kpm:tk}{f,r:int}
  (itr: !giter (knd, kpm, INV(x), f, r)):<> bool (f==0)
// end of [giter_is_atbeg]

fun{
knd:tk}{x:vt0p
} giter_isnot_atbeg
  {kpm:tk}{f,r:int}
  (itr: !giter (knd, kpm, INV(x), f, r)):<> bool (f > 0)
// end of [giter_isnot_atbeg]

fun{
knd:tk}{x:vt0p
} eq_int_iter
  {kpm:tk}{f,r:int}
(
  BEG: int(0), itr: !giter (knd, kpm, INV(x), f, r)
) : bool (f==0) // end of [eq_int_iter]
fun{
knd:tk}{x:vt0p
} lt_int_iter
  {kpm:tk}{f,r:int}
(
  BEG: int(0), itr: !giter (knd, kpm, INV(x), f, r)
) : bool (f > 0) // end of [lt_int_iter]

overload = with eq_int_iter
overload < with lt_int_iter

(* ****** ****** *)

fun{
knd:tk}{x:vt0p
} giter_is_atend
  {kpm:tk}{f,r:int}
  (itr: !giter (knd, kpm, INV(x), f, r)):<> bool (r==0)
// end of [giter_is_atend]
fun{
knd:tk}{x:vt0p
} giter_isnot_atend
  {kpm:tk}{f,r:int}
  (itr: !giter (knd, kpm, INV(x), f, r)):<> bool (r > 0)
// end of [giter_isnot_atend]

fun{
knd:tk}{x:vt0p
} eq_giter_int
  {kpm:tk}{f,r:int}
(
  itr: !giter (knd, kpm, INV(x), f, r), END: int(1)
) : bool (r==0) // end of [eq_giter_int]
fun{
knd:tk}{x:vt0p
} lt_giter_int
  {kpm:tk}{f,r:int}
(
  itr: !giter (knd, kpm, INV(x), f, r), END: int(1)
) : bool (r > 0) // end of [lt_giter_int]

overload = with eq_giter_int
overload < with lt_giter_int

(* ****** ****** *)

fun{
knd:tk}{x:t0p
} giter_get
  {kpm:tk}{f,r:int | r > 0}
  (itr: !giter (knd, kpm, INV(x), f, r)): x
// end of [giter_get]

fun{
knd:tk}{x:t0p
} giter_set
  {kpm:tk}{f,r:int | r > 0}
  (itr: !giter (knd, kpm, INV(x), f, r), x: x): void
// end of [giter_set]

fun{
knd:tk}{x:vt0p
} giter_exch
  {kpm:tk}{f,r:int | r > 0}
  (itr: !giter (knd, kpm, INV(x), f, r), x: &x >> x): void
// end of [giter_exch]

overload get with giter_get
overload set with giter_set
overload exch with giter_exch

fun{
knd:tk}{x:vt0p
} giter_getref
  {kpm:tk}{f,r:int | r > 0}
  (itr: !giter (knd, kpm, INV(x), f, r)): Ptr1
// end of [giter_getref]

fun{
knd:tk}{x:vt0p
} giter_vttake
  {kpm:tk}{f,r:int | r > 0}
  (itr: !giter (knd, kpm, INV(x), f, r)): vttakeout0 (x)
// end of [giter_vttake]

(* ****** ****** *)

fun{
knd:tk}{x:vt0p
} giter_inc
  {kpm:tk}{f,r:int | r > 0}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f+1, r-1)
) : void // end of [giter_inc]
fun{
knd:tk}{x:vt0p
} giter_dec
  {kpm:tk}{f,r:int | f > 0}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f-1, r+1)
) : void // end of [giter_dec]

overload ++ with giter_inc
overload -- with giter_dec
overload inc with giter_inc
overload dec with giter_dec 

(* ****** ****** *)

fun{
knd:tk}{x:t0p
} giter_get_inc
  {kpm:tk}{f,r:int | r > 0}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f+1, r-1)
) : x // end of [giter_get_inc]

fun{
knd:tk}{x:t0p
} giter_set_inc
  {kpm:tk}{f,r:int | r > 0}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f+1, r-1), x: x
) : void // end of [giter_set_inc]

fun{
knd:tk}{x:vt0p
} giter_exch_inc
  {kpm:tk}{f,r:int | r > 0}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f+1, r-1)
, x: &x >> x
) : void // end of [giter_exch_inc]

overload !++ with giter_get_inc
overload =++ with giter_set_inc
overload getinc with giter_get_inc
overload setinc with giter_set_inc
overload exchinc with giter_exch_inc

fun{
knd:tk}{x:vt0p
} giter_getref_inc
  {kpm:tk}{f,r:int | r > 0}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f+1, r-1)
) : Ptr1 // end of [giter_getref_inc]

fun{
knd:tk}{x:vt0p
} giter_vttake_inc
  {kpm:tk}{f,r:int | r > 0}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f+1, r-1)
) : vttakeout0 (x) // end of [giter_vttake_inc]

(* ****** ****** *)

fun{
knd:tk}{x:t0p
} giter_dec_get
  {kpm:tk}{f,r:int | f > 0}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f-1, r+1)
) : x // end of [giter_dec_get]

fun{
knd:tk}{x:t0p
} giter_dec_set
  {kpm:tk}{f,r:int | f > 0}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f-1, r+1), x: x
) : void // end of [giter_dec_set]

fun{
knd:tk}{x:vt0p
} giter_dec_exch
  {kpm:tk}{f,r:int | f > 0}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f-1, r+1)
, x: &x >> x
) : void // end of [giter_dec_exch]

overload --! with giter_dec_get
overload --= with giter_dec_set
overload decget with giter_dec_get
overload decset with giter_dec_set
overload decexch with giter_dec_exch

fun{
knd:tk}{x:vt0p
} giter_dec_getref
  {kpm:tk}{f,r:int | f > 0}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f-1, r+1)
) : Ptr1 // end of [giter_dec_getref]

fun{
knd:tk}{x:vt0p
} giter_dec_vttake
  {kpm:tk}{f,r:int | f > 0}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f-1, r+1)
) : vttakeout0 (x) // end of [giter_dec_vttake]

(* ****** ****** *)

fun{
knd:tk}{x:vt0p
} giter_get_fofs
  {kpm:tk}{f,r:int}
  (itr: !giter (knd, kpm, INV(x), f, r)): size_t (f)
// end of [giter_get_fofs]

fun{
knd:tk}{x:vt0p
} giter_get_rofs
  {kpm:tk}{f,r:int}
  (itr: !giter (knd, kpm, INV(x), f, r)): size_t (r)
// end of [giter_get_rofs]

(* ****** ****** *)

fun{
knd:tk}{x:vt0p
} giter_fjmp // forward-jmp
  {kpm:tk}
  {f,r:int}
  {i:int | 0 <= i; i <= r}
(
//
// HX: O(log(n))-time expected (O(1) for arrays)
//
  itr: !giter (knd, kpm, INV(x), f, r)
         >> giter (knd, kpm, x, f+i, r-i), i: size_t (i)
) : void // end of [giter_fjmp]

(* ****** ****** *)

fun{
knd:tk}{x:t0p
} giter_fget_at // forward-get
  {kpm:tk}
  {f,r:int}
  {i:int | 0 <= i; i < r}
(
  itr: !giter (knd, kpm, INV(x), f, r), i: size_t (i)
) : x // end of [giter_fget_at]
fun{
knd:tk}{x:t0p
} giter_fset_at // forward-set
  {kpm:tk}
  {f,r:int}
  {i:int | 0 <= i; i < r}
(
  itr: !giter (knd, kpm, INV(x), f, r), i: size_t (i), x: x
) : void // end of [giter_fset_at]

fun{
knd:tk}{x:vt0p
} giter_fexch_at // forward-exch
  {kpm:tk}
  {f,r:int}
  {i:int | 0 <= i; i < r}
(
  itr: !giter (knd, kpm, INV(x), f, r), i: size_t (i), x: &x >> x
) : void // end of [giter_fexch_at]

fun{
knd:tk}{x:vt0p
} giter_fgetref_at // forward-get
  {kpm:tk}
  {f,r:int}
  {i:int | 0 <= i; i < r}
(
  itr: !giter (knd, kpm, INV(x), f, r), i: size_t (i)
) : Ptr1 // end of [giter_fgetref_at]

(* ****** ****** *)

fun{
knd:tk}{x:vt0p
} giter_fbjmp // forward/backward-jmp
  {kpm:tk}
  {f,r:int}
  {i:int | ~f <= i; i <= r}
(
//
// HX: O(log(n))-time expected (O(1) for arrays)
//
  itr: !giter (knd, kpm, INV(x), f, r)
         >> giter (knd, kpm, x, f+i, r-i), i: ssize_t (i)
) : void // end of [giter_fbjmp]

(* ****** ****** *)

fun{
knd:tk}{x:vt0p
} giter_fbgetref_at // forward/backward-getref
  {kpm:tk}
  {f,r:int}
  {i:int | ~f <= i; i < r}
(
  itr: !giter (knd, kpm, INV(x), f, r), i: ssize_t (i)
) : Ptr1 // end of [giter_fbgetref_at]

fun{
knd:tk}{x:t0p
} giter_fbget_at // forward/backward-get
  {kpm:tk}
  {f,r:int}
  {i:int | ~f <= i; i < r}
(
  itr: !giter (knd, kpm, INV(x), f, r), i: ssize_t (i)
) : x // end of [giter_fbget_at]
fun{
knd:tk}{x:t0p
} giter_fbset_at // forward/backward-set
  {kpm:tk}
  {f,r:int}
  {i:int | ~f <= i; i < r}
(
  itr: !giter (knd, kpm, INV(x), f, r), i: ssize_t (i), x: x
) : void // end of [giter_fbset_at]

fun{
knd:tk}{x:vt0p
} giter_fbexch_at // forward/backward-exch
  {kpm:tk}
  {f,r:int}
  {i:int | ~f <= i; i < r}
(
  itr: !giter (knd, kpm, INV(x), f, r), i: ssize_t (i), x: &x >> x
) : void // end of [giter_fbexch_at]

(* ****** ****** *)

fun{
knd:tk}{x:t0p
} giter_fgetlst
//
// forward-getlst
//
  {kpm:tk}
  {f,r:int}
  {i:nat}
(
  itr: !giter (knd, kpm, INV(x), f, r)
         >> giter (knd, kpm, x, f+i1, r-i1)
, i: &int i >> int (i-i1)
) : #[
  i1:int | i1==min(i, r)
] list_vt (x, i1) // end of [giter_fgetlst]

fun{
knd:tk}{x:t0p
} giter_bgetlst
//
// backward-getlst
//
  {kpm:tk}
  {f,r:int}
  {i:nat}
(
  itr: !giter (knd, kpm, INV(x), f, r)
         >> giter (knd, kpm, x, f-i1, r+i1)
, i: &int i >> int (i-i1)
) : #[
  i1:int | i1==min(i, f)
] list_vt (x, i1) // end of [giter_bgetlst]

(* ****** ****** *)

fun{
knd:tk}{x:vt0p
} giter_ins
  {kpm:tk}{f,r:int}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f, r+1), x: x
) : void // end of [giter_ins]

fun{
knd:tk}{x:vt0p
} giter_ins_inc
  {kpm:tk}{f,r:int}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f+1, r), x: x
) : void // end of [giter_ins_inc]

(* ****** ****** *)

fun{
knd:tk}{x:vt0p
} giter_rmv
  {kpm:tk}{f,r:int | r > 0}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f, r-1)
) : x(*removed*) // end of [giter_rmv]

fun{
knd:tk}{x:vt0p
} giter_dec_rmv
  {kpm:tk}{f,r:int | f > 0}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f-1, r)
) : x(*removed*) // end of [giter_dec_rmv]

(* ****** ****** *)
//
// HX: some common generic functions on giters
//
(* ****** ****** *)

fun{
knd:tk}{x:t0p
} giter_listize_cpy {kpm:tk}{f,r:int}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f+r, 0)
) : list_vt (x, r) // end of [giter_listize_cpy]
fun{
knd:tk}{x:t0p
} giter_rlistize_cpy {kpm:tk}{f,r:int}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f+r, 0)
) : list_vt (x, r) // end of [giter_rlistize_cpy]

(* ****** ****** *)

fun{
knd:tk}{x:vt0p
} giter_listize_rmv {kpm:tk}{f,r:int}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f, 0)
) : list_vt (x, r) // end of [giter_listize_rmv]
fun{
knd:tk}{x:vt0p
} giter_rlistize_rmv {kpm:tk}{f,r:int}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f, 0)
) : list_vt (x, r) // end of [giter_rlistize_rmv]

(* ****** ****** *)

fun{
x:vt0p}{env:vt0p
} giter_foreach$cont (x: &x, env: &env): bool
fun{
x:vt0p}{env:vt0p
} giter_foreach$fwork (x: &x, env: &env): void
fun{
knd:tk}{x:vt0p
} giter_foreach
  {kpm:tk}{f,r:int}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f1, r1)
) : #[f1,r1:int | f <= f1; f+r==f1+r1] void // end of [giter_foreach]
fun{
knd:tk}{x:vt0p}{env:vt0p
} giter_foreach_env
  {kpm:tk}{f,r:int}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f1, r1)
, env: &(env) >> env
) : #[f1,r1:int | f <= f1; f+r==f1+r1] void // end of [giter_foreach_env]

(* ****** ****** *)

fun{
x:vt0p}{env:vt0p
} giter_rforeach$cont (x: &x, env: &env): bool
fun{
x:vt0p}{env:vt0p
} giter_rforeach$fwork (x: &x, env: &env): void
fun{
knd:tk}{x:vt0p
} giter_rforeach
  {kpm:tk}{f,r:int}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f1, r1)
) : #[f1,r1:int | f >= f1; f+r==f1+r1] void // end of [giter_rforeach]
fun{
knd:tk}{x:vt0p}{env:vt0p
} giter_rforeach_env
  {kpm:tk}{f,r:int}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f1, r1)
, env: &(env) >> env
) : #[f1,r1:int | f <= f1; f+r==f1+r1] void // end of [giter_rforeach_env]

(* ****** ****** *)

(*
** HX-2012-05:
** Note that [iter] should support at least log-time
** fjmp and fget in order to make binary search meaningful.
**
** ford (x) = cmp (x0, x), where [x0] is the key being searched
**
** The after-interator points to the left-most location
** where the value [x0] can be inserted without violating
** orderedness.
*)
fun{x:vt0p}
giter_bsearch$ford (x: &x): int
fun{
knd:tk}{x:vt0p
} giter_bsearch
  {kpm:tk}
  {f,r:int}
  {ra:int | ra <= r}
(
  itr: !giter (knd, kpm, INV(x), f, r) >> giter (knd, kpm, x, f1, r1)
, ra: size_t (ra) // range being searched
) : #[
  f1,r1:int | f1>=f;f+ra>=f1;f1+r1==f+r
] void // end of [giter_bsearch]

(* ****** ****** *)

(* end of [giterator.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/arith_prf.atxt
** Time of generation: Sat Oct 17 15:19:45 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: September, 2011 *)

(* ****** ****** *)

dataprop
MUL (int, int, int) =
  | {n:int}
    MULbas (0, n, 0)
  | {m:nat}{n:int}{p:int}
    MULind (m+1, n, p+n) of MUL (m, n, p)
  | {m:pos}{n:int}{p:int}
    MULneg (~m, n, ~p) of MUL (m, n, p)
// end of [MUL]

(* ****** ****** *)

praxi mul_make : {m,n:int} () -<prf> MUL (m, n, m*n)
praxi mul_elim : {m,n:int} {p:int} MUL (m, n, p) -<prf> [p == m*n] void

(* ****** ****** *)

prfun mul_istot {m,n:int} ():<prf> [p:int] MUL (m, n, p)

prfun mul_isfun {m,n:int} {p1,p2:int}
  (pf1: MUL (m, n, p1), pf2: MUL (m, n, p2)):<prf> [p1==p2] void
prfun mul_isfun2 {m,n:int} {p1,p2:int}
  (pf1: MUL (m, n, p1), pf2: MUL (m, n, p2)):<prf> EQINT (p1, p2)

(* ****** ****** *)
//
// HX: (m+i)*n = m*n+i*n
//
praxi mul_add_const {i:int}
  {m,n:int} {p:int} (pf: MUL (m, n, p)):<prf> MUL (m+i, n, p+i*n)
// end of [mul_add_const]

(* ****** ****** *)
//
// HX: (ax+b)*(cy+d) = ac*xy + ad*x + bc*y + bd
//
praxi mul_expand_linear // a,b,c,d: constants!
  {a,b:int}
  {c,d:int}
  {x,y:int}
  {xy:int} (
  pf: MUL (x, y, xy)
) :<prf> MUL (a*x+b, c*y+d, a*c*xy+a*d*x+b*c*y+b*d)
// end of [mul_expand_linear]

(* ****** ****** *)
//
// HX: (a1x1+a2x2+b)*(c1y1+c2y2+d) = ...
//
praxi mul_expand2_linear // a1,b1,c1,a2,b2,c2: constants!
  {a1,a2,b:int}
  {c1,c2,d:int}
  {x1,x2:int}
  {y1,y2:int}
  {x1y1,x1y2,x2y1,x2y2:int} (
  pf11: MUL (x1, y1, x1y1), pf12: MUL (x1, y2, x1y2)
, pf21: MUL (x2, y1, x2y1), pf22: MUL (x2, y2, x2y2)
) :<prf> MUL (
  a1*x1+a2*x2+b
, c1*y1+c2*y2+d
, a1*c1*x1y1 + a1*c2*x1y2 +
  a2*c1*x2y1 + a2*c2*x2y2 +
  a1*d*x1 + a2*d*x2 +
  b*c1*y1 + b*c2*y2 +
  b*d
) // end of [mul_expand2_linear]

(* ****** ****** *)

prfun mul_gte_gte_gte
  : {m,n:int | m >= 0; n >= 0} () -<prf> [m*n >= 0] void
prfun mul_lte_gte_lte
  : {m,n:int | m <= 0; n >= 0} () -<prf> [m*n <= 0] void
prfun mul_gte_lte_lte
  : {m,n:int | m >= 0; n <= 0} () -<prf> [m*n <= 0] void
prfun mul_lte_lte_gte
  : {m,n:int | m <= 0; n <= 0} () -<prf> [m*n >= 0] void

(* ****** ****** *)

prfun mul_nat_nat_nat :
  {m,n:nat} {p:int} MUL (m, n, p) -<prf> [p >= 0] void
prfun mul_pos_pos_pos :
  {m,n:pos} {p:int} MUL (m, n, p) -<prf> [p >= m+n-1] void

(* ****** ****** *)

prfun mul_negate
  {m,n:int} {p:int} (pf: MUL (m, n, p)):<prf> MUL (~m, n, ~p)
prfun mul_negate2
  {m,n:int} {p:int} (pf: MUL (m, n, p)):<prf> MUL (m, ~n, ~p)

(* ****** ****** *)
//
// HX: m*n = n*m
//
prfun mul_commute
  {m,n:int} {p:int} (pf: MUL (m, n, p)):<prf> MUL (n, m, p)
prfun mul_is_commutative
  {m,n:int} {p,q:int} (pf1: MUL (m, n, p), pf2: MUL (n, m, q)): [p==q] void

(* ****** ****** *)
//
// HX: m*(n1+n2) = m*n1+m*n2
//
prfun mul_distribute
  {m:int} {n1,n2:int} {p1,p2:int}
  (pf1: MUL (m, n1, p1), pf2: MUL (m, n2, p2)):<prf> MUL (m, n1+n2, p1+p2)
//
// HX: (m1+m2)*n = m1*n + m2*n
//
prfun mul_distribute2
  {m1,m2:int} {n:int} {p1,p2:int}
  (pf1: MUL (m1, n, p1), pf2: MUL (m2, n, p2)):<prf> MUL (m1+m2, n, p1+p2)
//
(* ****** ****** *)

prfun
mul_is_associative
  {x,y,z:int}
  {xy,yz:int}
  {xy_z,x_yz:int} (
  pf1: MUL (x, y, xy), pf2: MUL (y, z, yz)
, pf3: MUL (xy, z, xy_z), pf4: MUL (x, yz, x_yz)
) :<prf> [xy_z==x_yz] void

(* ****** ****** *)
//
// HX-2010-12-30: 
//
absprop
DIVMOD (
  x:int, y: int, q: int, r: int // x = q * y + r
) // end of [DIVMOD]

propdef
DIV (x:int, y:int, q:int) = [r:int] DIVMOD (x, y, q, r)
propdef
MOD (x:int, y:int, r:int) = [q:int] DIVMOD (x, y, q, r)

(* ****** ****** *)
//
praxi
div_istot
  {x,y:int | x >= 0; y > 0} (): DIV (x, y, x/y)
//
praxi
divmod_istot
  {x,y:int |
   x >= 0; y > 0}
  ((*void*)): [q,r:nat | r < y] DIVMOD (x, y, q, r)
//
(* ****** ****** *)

praxi
divmod_isfun
  {x,y:int | x >= 0; y > 0}
  {q1,q2:int} {r1,r2:int} (
  pf1: DIVMOD (x, y, q1, r1)
, pf2: DIVMOD (x, y, q2, r2)
) : [q1==q2;r1==r2] void // end of [divmod_isfun]

(* ****** ****** *)

praxi
divmod_elim
  {x,y:int | x >= 0; y > 0}
  {q,r:int}
(
  pf: DIVMOD (x, y, q, r)
) : [qy:nat | 0 <= r; r < y; x==qy+r] MUL (q, y, qy)

praxi
divmod_mul_elim
  {x,y:int | x >= 0; y > 0}
  {q,r:int}
  (pf: DIVMOD (x, y, q, r))
: [0 <= q; 0 <= r; r < y; q==ndiv_int_int(x, y); x==q*y+r] void
// end of [divmod_mul_elim]

(* ****** ****** *)
//
dataprop
EXP2 (int, int) =
  | EXP2bas (0, 1)
  | {n:nat}{p:nat}
    EXP2ind (n+1, 2*p) of EXP2 (n, p)
// end of [EXP2]
//
prfun lemma_exp2_param :
  {n:int}{p:int} EXP2 (n, p) -<prf> [n>=0;p>=1] void
// end of [lemma_exp2_param]
//
prfun exp2_istot {n:nat} (): [p:nat] EXP2 (n, p)
prfun exp2_isfun {n:nat} {p1,p2:int}
  (pf1: EXP2 (n, p1), pf2: EXP2 (n, p2)): [p1==p2] void
// end of [exp2_isfun]
//
// HX: proven in [arith_prf.dats]
//
prfun exp2_ispos
  {n:nat} {p:int} (pf: EXP2 (n, p)): [p >= 1] void
// end of [exp2_ispos]
//
// HX: proven in [arith_prf.dats]
//
prfun exp2_is_mono
  {n1,n2:nat | n1 <= n2} {p1,p2:int}
  (pf1: EXP2 (n1, p1), pf2: EXP2 (n2, p2)): [p1 <= p2] void
// end of [exp2_is_mono]
//
// HX: proven in [arith_prf.dats]
//
prfun exp2_muladd
  {n1,n2:nat | n1 <= n2} {p1,p2:int} {p:int} (
  pf1: EXP2 (n1, p1), pf2: EXP2 (n2, p2), pf3: MUL (p1, p2, p)
) : EXP2 (n1+n2, p) // end of [exp2_muladd]
//
(* ****** ****** *)

absprop EXP (int(*base*), int(*power*), int(*res*))

praxi lemma_exp_param
  {b:int}{n:int}{p:int} (pf: EXP (b, n, p)): [n >= 0] void
// end of [lemma_exp_param]

praxi exp_istot {b:int}{n:nat} (): [p:nat] EXP (b, n, p)
praxi exp_isfun {b:int}{n:int}{p1,p2:int}
  (pf1: EXP (b, n, p1), pf2: EXP (b, n, p2)): [p1==p2] void
// end of [exp_isfun]

praxi exp_elim_0 {n:pos}{p:int} (pf: EXP (0, n, p)): [p==0] void
praxi exp_elim_1 {n:int}{p:int} (pf: EXP (1, n, p)): [p==1] void
praxi exp_elim_2 {n:int}{p:int} (pf: EXP (2, n, p)): EXP2 (n, p)
praxi exp_elim_b_0 {b:int}{p:int} (pf: EXP (b, 0, p)): [p==1] void
praxi exp_elim_b_1 {b:int}{p:int} (pf: EXP (b, 1, p)): [p==b] void
praxi exp_elim_b_2 {b:int}{p:int} (pf: EXP (b, 2, p)): MUL (b, b, p)

praxi exp_muladd
  {b:int}{n1,n2:int}{p1,p2:int}{p:int} (
  pf1: EXP (b, n1, p1), pf2: EXP (b, n2, p2)
) : EXP (b, n1+n2, p1*p2) // end of [exp_muladd]

praxi exp_expmul
  {b:int}{n1,n2:int}{bn1:int}{bn1n2:int} (
  pf1: EXP (b, n1, bn1), pf2: EXP (bn1, n2, bn1n2)
) : EXP (b, n1*n2, bn1n2) // end of [exp_muladd]

(* ****** ****** *)

(* end of [arith_prf.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/matrix.atxt
** Time of generation: Sat Oct 17 15:19:49 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: Feburary, 2012 *)

(* ****** ****** *)

vtypedef
RD(a:vt0p) = a // for commenting: read-only
#define NSH (x) x // for commenting: no sharing
#define SHR (x) x // for commenting: it is shared

(* ****** ****** *)

sortdef t0p = t@ype
sortdef vtp = viewtype
sortdef vt0p = viewt@ype

(* ****** ****** *)

absvt@ype
matrix_vt0ype_int_int_vt0ype
  (a:vt@ype+, row:int, col:int) = array(a, row*col)
stadef matrix = matrix_vt0ype_int_int_vt0ype

(* ****** ****** *)

viewdef
matrix_v (
  a:viewt@ype+, l:addr, row:int, col:int
) = matrix (a, row, col) @ l

(* ****** ****** *)

exception
MatrixSubscriptExn of ((*void*))

(* ****** ****** *)
//
praxi
lemma_matrix_param{a:vt0p}
  {l:addr}{m,n:int} (M: &matrix(INV(a), m, n)): [m >= 0; n >= 0] void
//
praxi
lemma_matrix_v_param{a:vt0p}
  {l:addr}{m,n:int} (pf: !matrix_v (INV(a), l, m, n)): [m >= 0; n >= 0] void
//
(* ****** ****** *)
//
praxi
array2matrix_v
  {a:vt0p}{l:addr}{m,n:int}
  (pf: array_v (INV(a), l, m * n)) : matrix_v (a, l, m, n)
praxi
matrix2array_v
  {a:vt0p}{l:addr}{m,n:int}
  (pf: matrix_v (INV(a), l, m, n)) : array_v (a, l, m * n)
//
(* ****** ****** *)
//
// HX: ATS matrices is of row-major style
//
absview
matrow_view (a:viewt@ype+, l:addr, m:int, n:int)
stadef matrow_v = matrow_view
absview
matcol_view (a:viewt@ype+, l:addr, m:int, n:int)
stadef matcol_v = matcol_view
//
(* ****** ****** *)

fun{a:vt0p}
matrix_getref_at_int
  {m,n:int}
(
  M: &RD(matrix (INV(a), m, n))
, i: natLt (m), n: int n, j: natLt (n)
) :<> cPtr1 (a) // endfun

fun{a:vt0p}
matrix_getref_at_size
  {m,n:int}
(
  M: &RD(matrix (INV(a), m, n))
, i: sizeLt (m), n: size_t n, j: sizeLt (n)
) :<> cPtr1 (a) // endfun

symintr matrix_getref_at
overload matrix_getref_at with matrix_getref_at_int
overload matrix_getref_at with matrix_getref_at_size

(* ****** ****** *)

fun{a:t0p}
matrix_get_at_int
  {m,n:int}
(
  M: &RD(matrix (INV(a), m, n))
, i: natLt (m), n: int n, j: natLt (n)
) :<> (a) // endfun
overload [] with matrix_get_at_int

fun{a:t0p}
matrix_get_at_size
  {m,n:int}
(
  M: &RD(matrix (INV(a), m, n))
, i: sizeLt (m), n: size_t n, j: sizeLt (n)
) :<> (a) // endfun
overload [] with matrix_get_at_size

symintr matrix_get_at
overload matrix_get_at with matrix_get_at_int of 0
overload matrix_get_at with matrix_get_at_size of 0

(* ****** ****** *)

fun{a:t0p}
matrix_set_at_int
  {m,n:int}
(
  M: &matrix (INV(a), m, n)
, i: natLt (m), n: int n, j: natLt (n), x: a
) :<!wrt> void // endfun
overload [] with matrix_set_at_int

fun{a:t0p}
matrix_set_at_size
  {m,n:int}
(
  M: &matrix (INV(a), m, n)
, i: sizeLt (m), n: size_t n, j: sizeLt (n), x: a
) :<!wrt> void // endfun
overload [] with matrix_set_at_size

symintr matrix_set_at
overload matrix_set_at with matrix_set_at_int of 0
overload matrix_set_at with matrix_set_at_size of 0

(* ****** ****** *)

fun{a:vt0p}
matrix_exch_at_int
  {m,n:int}
(
  M: &matrix (INV(a), m, n)
, i: natLt (m), n: int n, j: natLt (n), x: &a>>a
) :<!wrt> void // endfun

fun{a:vt0p}
matrix_exch_at_size
  {m,n:int}
(
  M: &matrix (INV(a), m, n)
, i: sizeLt (m), n: size_t n, j: sizeLt (n), x: &a>>a
) :<!wrt> void // endfun

symintr matrix_exch_at
overload matrix_exch_at with matrix_exch_at_int
overload matrix_exch_at with matrix_exch_at_size

(* ****** ****** *)

fun{a:vt0p}
matrix_ptr_alloc
  {m,n:int}
(
  row: size_t m, col: size_t n
) :<!wrt> [l:agz]
(
  matrix_v (a?, l, m, n), mfree_gc_v (l) | ptr l
) // end of [matrix_ptr_alloc]

fun{}
matrix_ptr_free
  {a:vt0p}{l:addr}{m,n:int}
(
  matrix_v (a?, l, m, n), mfree_gc_v (l) | ptr l
) :<!wrt> void // end of [matrix_ptr_free]

(* ****** ****** *)

fun{a:vt0p}
matrix_tabulate$fopr (i: size_t, j: size_t): (a)
fun{a:vt0p}
matrix_ptr_tabulate
  {m,n:int} (row: size_t m, col: size_t n)
  : [l:addr] (matrix_v (a, l, m, n), mfree_gc_v (l) | ptr l)
// end of [matrixptr_tabulate]

(* ****** ****** *)
//
fun{
} fprint_matrix$sep1 (out: FILEref): void // col separation
fun{
} fprint_matrix$sep2 (out: FILEref): void // row separation
//
fun{a:vt0p}
fprint_matrix_int{m,n:int}
(
  out: FILEref
, M: &matrix (INV(a), m, n), m: int (m), n: int (n)
) : void // end of [fprint_matrix_int]
fun{a:vt0p}
fprint_matrix_size{m,n:int}
(
  out: FILEref
, M: &matrix (INV(a), m, n), m: size_t (m), n: size_t (n)
) : void // end of [fprint_matrix_size]
//
symintr fprint_matrix
overload fprint_matrix with fprint_matrix_int
overload fprint_matrix with fprint_matrix_size
overload fprint with fprint_matrix
//
(* ****** ****** *)

fun{a:vt0p}
fprint_matrix_sep{m,n:int}
(
  out: FILEref
, M: &matrix (INV(a), m, n), m: size_t (m), n: size_t (n)
, sep1: NSH(string), sep2: NSH(string)
) : void // end of [fprint_matrix_sep]

(* ****** ****** *)

fun{a:vt0p}
matrix_ptr_takeout_elt
  {l0:addr}
  {m,n:int}
  {i,j:nat | i < m; j < n} (
  pfmat: matrix_v (INV(a), l0, m, n)
| base: ptr l0, i: size_t i, n: size_t n, j: size_t j
) :<> [l:addr] (
  a @ l
, a @ l -<lin,prf> matrix_v (a, l0, m, n)
| ptr (l)
) // end of [matrix_ptr_takeout_elt]

fun{a:vt0p}
matrix_ptr_takeout_row
  {l0:addr}
  {m,n:int}
  {i:int | i < m}
(
  pfmat: matrix_v (INV(a), l0, m, n)
| base: ptr l0, i: size_t i, n: size_t n
) :<> [l:addr] (
  matrow_v (a, l, m, n)
, matrow_v (a, l, m, n) -<lin,prf> matrix_v (a, l0, m, n)
| ptr (l)
) // end of [matrix_ptr_takeout_row]

fun{a:vt0p}
matrix_ptr_takeout_col
  {l0:addr}
  {m,n:int}
  {i:int | i < m}
(
  pfmat: matrix_v (INV(a), l0, m, n)
| base: ptr l0, i: size_t i, n: size_t n
) :<> [l:addr] (
  matcol_v (a, l, m, n)
, matcol_v (a, l, m, n) -<lin,prf> matrix_v (a, l0, m, n)
| ptr (l)
) // end of [matrix_ptr_takeout_col]

(* ****** ****** *)

fun{
a:vt0p}{env:vt0p
} matrix_foreach$fwork (x: &a >> _, env: &(env) >> _): void
fun{
a:vt0p
} matrix_foreach{m,n:int}
(
  A: &matrix(INV(a), m, n) >> _, m: size_t m, n: size_t n
) : void // end of [matrix_foreach]
fun{
a:vt0p}{env:vt0p
} matrix_foreach_env{m,n:int}
(
  A: &matrix(INV(a), m, n) >> _, m: size_t m, n: size_t n, env: &(env) >> _
) : void // end of [matrix_foreach_env]

(* ****** ****** *)

fun{
a:vt0p}{env:vt0p
} matrix_foreachrow$fwork{n:int}
(
  row: &array (INV(a), n) >> _, n: size_t n, env: &(env) >> _
) : void // end of [matrix_foreachrow$fwork]

fun{
a:vt0p
} matrix_foreachrow{m,n:int}
(
  A: &matrix(INV(a), m, n) >> _, m: size_t (m), n: size_t (n)
) : void // end of [matrix_foreachrow]
fun{
a:vt0p}{env:vt0p
} matrix_foreachrow_env{m,n:int}
(
  A: &matrix(INV(a), m, n) >> _, m: size_t m, n: size_t n, env: &(env) >> _
) : void // end of [matrix_foreachrow_env]

(* ****** ****** *)

fun{a:vt0p}
matrix_initize$init
  (i: size_t, j: size_t, x: &a? >> a): void
fun{a:vt0p}
matrix_initize{m,n:int}
(
  A: &matrix (a?, m, n) >> matrix (a, m, n), row: size_t m, col: size_t n
) : void // end of [matrix_initize]

macdef matrix_initialize = matrix_initize

(* ****** ****** *)

fun
{a:vt0p}
{b:vt0p}
matrix_mapto$fwork
  (x: &a, y: &b? >> b): void
fun
{a:vt0p}
{b:vt0p}
matrix_mapto
  {m,n:int}
(
  A: &matrix (INV(a), m, n)
, B: &matrix (b?, m, n) >> matrix (b, m, n)
, m: size_t m, n: size_t n
) : void // end of [matrix_mapto]

(* ****** ****** *)

fun
{a,b:vt0p}
{c:vt0p}
matrix_map2to$fwork
  (x: &a, y: &b, z: &c? >> c): void
fun
{a,b:vt0p}
{c:vt0p}
matrix_map2to
  {m,n:int}
(
  A: &matrix (INV(a), m, n)
, B: &matrix (INV(b),  m, n)
, C: &matrix (c?, m, n) >> matrix (c, m, n)
, m: size_t m, n: size_t n
) : void // end of [matrix_map2to]

(* ****** ****** *)

(* end of [matrix.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/bool.atxt
** Time of generation: Sat Oct 17 15:19:44 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: September, 2011 *)

(* ****** ****** *)
//
castfn g0ofg1_bool (x: Bool):<> bool
castfn g1ofg0_bool (x: bool):<> Bool
//
overload g0ofg1 with g0ofg1_bool // index-erasing
overload g1ofg0 with g1ofg0_bool // index-inducing
//
(* ****** ****** *)
//
symintr int2bool
//
fun int2bool0 (i: int):<> bool = "mac#%"
fun int2bool1
  {i:int} (i: int i):<> bool (i != 0) = "mac#%"
//
overload int2bool with int2bool0 of 0
overload int2bool with int2bool1 of 10
//
symintr bool2int
//
fun bool2int0 (b: bool):<> natLt(2) = "mac#%"
fun bool2int1
  {b:bool} (b: bool b):<> int (bool2int(b)) = "mac#%"
//
overload bool2int with bool2int0 of 0
overload bool2int with bool2int1 of 10
//
(* ****** ****** *)

(*
//
// HX: declared in [prelude/basics_dyn.sats]
//
val true : bool (true) and false : bool (false)
*)

(* ****** ****** *)

(*
** HX-2012-06:
** shortcut version of disjuction and conjuction
** note that these two cannot be declared as functions
*)
macdef || (b1, b2) = (if ,(b1) then true else ,(b2)): bool
macdef && (b1, b2) = (if ,(b1) then ,(b2) else false): bool

(* ****** ****** *)

typedef boolLte (b: bool) = [a: bool | a <= b] bool (a)
typedef boolGte (b: bool) = [a: bool | a >= b] bool (a)

(* ****** ****** *)

fun neg_bool0
  (b: bool):<> bool = "mac#%"
overload ~ with neg_bool0 of 0
overload not with neg_bool0 of 0

(* ****** ****** *)

fun add_bool0_bool0
  (b1: bool, b2: bool):<> bool = "mac#%"
overload + with add_bool0_bool0 of 0
fun mul_bool0_bool0
  (b1: bool, b2: bool):<> bool = "mac#%"
overload * with mul_bool0_bool0 of 0

(* ****** ****** *)
//
fun xor_bool0_bool0
  (b1: bool, b2: bool):<> bool = "mac#%"
//
(* ****** ****** *)

fun lt_bool0_bool0
  (b1: bool, b2: bool):<> bool = "mac#%"
overload < with lt_bool0_bool0 of 0
fun lte_bool0_bool0
  (b1: bool, b2: bool):<> bool = "mac#%"
overload <= with lte_bool0_bool0 of 0

fun gt_bool0_bool0
  (b1: bool, b2: bool):<> bool = "mac#%"
overload > with gt_bool0_bool0 of 0
fun gte_bool0_bool0
  (b1: bool, b2: bool):<> bool = "mac#%"
overload >= with gte_bool0_bool0 of 0

fun eq_bool0_bool0
  (b1: bool, b2: bool):<> bool = "mac#%"
overload = with eq_bool0_bool0 of 0
fun neq_bool0_bool0
  (b1: bool, b2: bool):<> bool = "mac#%"
overload != with neq_bool0_bool0 of 0
overload <> with neq_bool0_bool0 of 0

(* ****** ****** *)

fun compare_bool0_bool0
  (b1: bool, b2: bool):<> Sgn = "mac#%"
overload compare with compare_bool0_bool0

(* ****** ****** *)
//
// HX:
// return is statically allocated
//
fun
bool2string(b: bool):<> string = "mac#%"
//
(* ****** ****** *)
//
fun print_bool (x: bool): void = "mac#%"
fun prerr_bool (x: bool): void = "mac#%"
fun fprint_bool : fprint_type (bool) = "mac#%"
//
overload print with print_bool
overload prerr with prerr_bool
overload fprint with fprint_bool
//
(* ****** ****** *)

fun neg_bool1 {b:bool}
  (b: bool b):<> bool (~b) = "mac#%"
overload ~ with neg_bool1 of 10
overload not with neg_bool1 of 10

(* ****** ****** *)

fun
add_bool1_bool0 {b1:bool}
  (b1: bool b1, b2: bool):<> boolGte (b1) = "mac#%"
overload + with add_bool1_bool0 of 10

fun
add_bool0_bool1 {b2:bool}
  (b1: bool, b2: bool b2):<> boolGte (b2) = "mac#%"
overload + with add_bool0_bool1 of 10

fun
add_bool1_bool1 {b1,b2:bool}
  (b1: bool b1, b2: bool b2):<> bool (b1 || b2) = "mac#%"
overload + with add_bool1_bool1 of 20

(* ****** ****** *)

fun
mul_bool1_bool0 {b1:bool}
  (b1: bool b1, b2: bool):<> boolLte (b1) = "mac#%"
overload * with mul_bool1_bool0 of 10

fun
mul_bool0_bool1 {b2:bool}
  (b1: bool, b2: bool b2):<> boolLte (b2) = "mac#%"
overload * with mul_bool0_bool1 of 10

fun
mul_bool1_bool1 {b1,b2:bool}
  (b1: bool b1, b2: bool b2):<> bool (b1 && b2) = "mac#%"
overload * with mul_bool1_bool1 of 20

(* ****** ****** *)

//
// (b1 < b2) == (~b1 && b2)
//
fun
lt_bool1_bool1 {b1,b2:bool}
  (b1: bool (b1), b2: bool (b2)) :<> bool (b1 < b2) = "mac#%"
overload < with lt_bool1_bool1 of 20
//
// (b1 <= b2) == (~b1 || b2)
//
fun
lte_bool1_bool1 {b1,b2:bool}
  (b1: bool (b1), b2: bool (b2)) :<> bool (b1 <= b2) = "mac#%"
overload <= with lte_bool1_bool1 of 20
//
// (b1 > b2) == (b1 && ~b2)
//
fun
gt_bool1_bool1 {b1,b2:bool}
  (b1: bool (b1), b2: bool (b2)) :<> bool (b1 > b2) = "mac#%"
overload > with gt_bool1_bool1 of 20
//
// (b1 >= b2) == (b1 || ~b2)
//
fun
gte_bool1_bool1 {b1,b2:bool}
  (b1: bool (b1), b2: bool (b2)) :<> bool (b1 >= b2) = "mac#%"
overload >= with gte_bool1_bool1 of 20

(* ****** ****** *)

fun
eq_bool1_bool1 {b1,b2:bool}
  (b1: bool (b1), b2: bool (b2)) :<> bool (b1 == b2) = "mac#%"
overload = with eq_bool1_bool1 of 20
fun
neq_bool1_bool1 {b1,b2:bool}
  (b1: bool (b1), b2: bool (b2)) :<> bool (b1 != b2) = "mac#%"
overload != with neq_bool1_bool1 of 20
overload <> with neq_bool1_bool1 of 20

(* ****** ****** *)

fun
compare_bool1_bool1
  {b1,b2:bool} // HX: this one is a function
(
 b1: bool b1, b2: bool b2
) :<> int (bool2int(b1) - bool2int(b2)) = "mac#%"
overload compare with compare_bool1_bool1 of 20

(* ****** ****** *)

(* end of [bool.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/reference.atxt
** Time of generation: Sat Oct 17 15:19:45 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2012 *)

(* ****** ****** *)

sortdef t0p = t@ype and vt0p = viewt@ype

(* ****** ****** *)

castfn ref_get_ptr
  {a:vt0p} (r: ref a):<> [l:agz] ptr (l)
castfn ref_get_viewptr
  {a:vt0p} (r: ref a):<> [l:agz] (vbox (a @ l) | ptr l)
// end of [ref_get_viewptr]

(* ****** ****** *)

(*
macdef ptr_of_ref = ref_get_ptr
*)

(* ****** ****** *)

fun{a:vt0p} ref (x: a):<!wrt> ref a
fun{a:vt0p} ref_make_elt (x: a):<!wrt> ref a

castfn ref_make_viewptr
  {a:vt0p}{l:addr} (pf: a @ l | p: ptr l):<> ref (a)
// end of [ref_make_viewptr]

(* ****** ****** *)
//
fun{a:t0p} ref_get_elt (r: ref a):<!ref> a
fun{a:t0p} ref_set_elt (r: ref a, x: a):<!refwrt> void
//
(* ****** ****** *)
//
fun{a:vt0p} ref_exch_elt (r: ref a, x: &a>>a):<!refwrt> void
//
(* ****** ****** *)

(*
** HX-2012-05:
** this is not particularly useful except for the purpose
** of avoiding using the [vbox] pattern
*)

fun{}
ref_app_fun{a:vt0p}
(
  r: ref a, f: (&(a)>>_) -<0,!wrt> void
) :<!refwrt> void // end of [ref_app_fun]

fun{}
ref_app_funenv{a:vt0p}
  {v:view}{vt:viewtype}
(
  pfv: !v
| r: ref a, f: (!v | &(a)>>_, !vt) -<0,!wrt> void, env: !vt
) :<!refwrt> void // end of [ref_app_funenv]

(* ****** ****** *)
//
// HX-2013-10: unsafe but convenient
//
fun{}
ref_vtakeout
  {a:vt0p}
(
  ref: ref (a)
) :<!ref> [l:addr] (a @ l, (a @ l) -<lin,prf> void | ptr(l))
//
(* ****** ****** *)
//
// overloading for certain symbols
//
(* ****** ****** *)

overload [] with ref_get_elt // ref[]
overload [] with ref_set_elt // ref[] := (val)

(* ****** ****** *)

(* end of [reference.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/gprint.atxt
** Time of generation: Sat Oct 17 15:19:50 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: August, 2012 *)

(* ****** ****** *)

#define NSH (x) x // for commenting: no sharing
#define SHR (x) x // for commenting: it is shared

(* ****** ****** *)

sortdef t0p = t@ype

(* ****** ****** *)

fun{}
gprint$out(): FILEref

(* ****** ****** *)

fun{}
gprint_newline(): void

(* ****** ****** *)

fun{a:t0p}
gprint_val (x: a): void
fun{a:vt0p}
gprint_ref (x: &INV(a)): void

(* ****** ****** *)

fun{}
gprint_int (x: int): void
fun{}
gprint_char (x: char): void
fun{}
gprint_float (x: float): void
fun{}
gprint_double (x: double): void
fun{}
gprint_string (x: string): void

(* ****** ****** *)

fun{} gprint_list$beg(): void
fun{} gprint_list$end(): void
fun{} gprint_list$sep(): void
//
fun{a:t0p}
gprint_list (xs: List(a)): void

(* ****** ****** *)

fun{} gprint_listlist$beg1(): void
fun{} gprint_listlist$end1(): void
fun{} gprint_listlist$sep1(): void
//
fun{} gprint_listlist$beg2(): void
fun{} gprint_listlist$end2(): void
fun{} gprint_listlist$sep2(): void
//
fun{a:t0p}
gprint_listlist (xss: List(List(a))): void

(* ****** ****** *)
//
fun{} gprint_array$beg(): void
fun{} gprint_array$end(): void
fun{} gprint_array$sep(): void
//
fun{a:t0p}
gprint_array
  {n:int}
  (A: &(@[INV(a)][n]), n: size_t(n)): void
// end of [gprint_array]
fun{a:t0p}
gprint_arrayptr
  {n:int}
  (A: !arrayptr(INV(a), n), n: size_t(n)): void
// end of [gprint_arrayptr]
fun{a:t0p}
gprint_arrayref
  {n:int}(A: arrayref(a, n), n: size_t(n)): void
// end of [gprint_arrayref]
//
fun{a:t0p} gprint_arrszref(ASZ: arrszref(a)): void
//
(* ****** ****** *)

(* end of [gprint.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/arrayref.atxt
** Time of generation: Sat Oct 17 15:19:49 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2012 *)

(* ****** ****** *)

#define NSH (x) x // for commenting: no sharing
#define SHR (x) x // for commenting: it is shared

(* ****** ****** *)

sortdef tk = tkind

(* ****** ****** *)

sortdef t0p = t@ype and vt0p = viewt@ype

(* ****** ****** *)
//
// arrayref: a reference to an array with no size information attached
//
(* ****** ****** *)

#if(0)
//
// HX-2013-06:
// it is declared in [basic_dyn.sats]
//
abstype
arrayref_vt0ype_int_type
  (a: vt@ype(*elt*), n: int(*size*)) = ptr
stadef arrayref = arrayref_vt0ype_int_type
#endif

(* ****** ****** *)

praxi
lemma_arrayref_param
  {a:vt0p}{n:int} (A: arrayref (a, n)): [n >= 0] void
// end of [lemma_arrayref_param]

(* ****** ****** *)

castfn
arrayref2ptr{a:vt0p}{n:int} (A: arrayref(a, n)):<> Ptr0

(* ****** ****** *)

(*
** HX-2012-06:
** this function essentially passes the proof of array-view
** to GC (leaks it if GC is unavailable)
*)
castfn
arrayptr_refize
  {a:vt0p}
  {l:addr}
  {n:int} (
  A: arrayptr (INV(a), l, n)
) :<!wrt> arrayref (a, n) // end of [arrayptr_refize]

castfn
arrayref_get_viewptr
  {a:vt0p}
  {n:int} (
  A: arrayref (a, n)
) :<> [l:addr] (vbox (array_v (a, l, n)) | ptr l)

(* ****** ****** *)
//
symintr arrayref
//
fun
arrayref_make_arrpsz
  {a:vt0p}{n:int}
  (psz: arrpsz (INV(a), n)):<!wrt> arrayref (a, n) = "mac#%"
overload arrayref with arrayref_make_arrpsz
//
(* ****** ****** *)

fun{a:t0p}
arrayref_make_elt
  {n:int} (asz: size_t n, x: a):<!wrt> arrayref (a, n)
// end of [arrayref_make_elt]

(* ****** ****** *)

fun{
} arrayref_make_intrange
  {l,r:int | l <= r} (l: int l, r: int r):<!wrt> arrayref (int, r-l)
// end of [arrayref_make_intrange]

(* ****** ****** *)

fun{a:t0p}
arrayref_make_list{n:int}
  (asz: int n, xs: list (INV(a), n)):<!wrt> arrayref (a, n)
// end of [arrayref_make_list]

fun{a:t0p}
arrayref_make_rlist{n:int}
  (asz: int n, xs: list (INV(a), n)):<!wrt> arrayref (a, n)
// end of [arrayref_make_rlist]

(* ****** ****** *)
//
// HX-2014-02:
// [A] must survive [arrayref_tail(A)]
// in order to support proper garbage-collection
//
fun{a:t0p}
arrayref_head
  {n:pos} (A: arrayref (a, n)):<!ref> (a) // A[0]
fun{a:t0p}
arrayref_tail
  {n:pos} (A: arrayref (a, n)):<!ref> arrayref (a, n-1)
//
(* ****** ****** *)
//
fun{
a:t0p}{tk:tk
} arrayref_get_at_gint
  {n:int}{i:nat | i < n}
(
  A: arrayref (a, n), i: g1int (tk, i)
) :<!ref> a // end of [arrayref_get_at_gint]
//
fun{
a:t0p}{tk:tk
} arrayref_get_at_guint
  {n:int}{i:nat | i < n}
(
  A: arrayref (a, n), i: g1uint (tk, i)
) :<!ref> a // end of [arrayref_get_at_guint]
//
symintr arrayref_get_at
overload arrayref_get_at with arrayref_get_at_gint of 0
overload arrayref_get_at with arrayref_get_at_guint of 0
//
(* ****** ****** *)
//
fun{
a:t0p}{tk:tk
} arrayref_set_at_gint
  {n:int}{i:nat | i < n} (
  A: arrayref (a, n), i: g1int (tk, i), x: a
) :<!refwrt> void // end of [arrayref_set_at_gint]
//
fun{
a:t0p}{tk:tk
} arrayref_set_at_guint
  {n:int}{i:nat | i < n} (
  A: arrayref (a, n), i: g1uint (tk, i), x: a
) :<!refwrt> void // end of [arrayref_set_at_guint]
//
symintr arrayref_set_at
overload arrayref_set_at with arrayref_set_at_gint of 0
overload arrayref_set_at with arrayref_set_at_guint of 0
//
(* ****** ****** *)

fun{
a:vt0p}{tk:tk
} arrayref_exch_at_gint
  {n:int}{i:nat | i < n} (
  A: arrayref (a, n), i: g1int (tk, i), x: &a >> _
) :<!refwrt> void // end of [arrayref_exch_at_gint]

fun{
a:vt0p}{tk:tk
} arrayref_exch_at_guint
  {n:int}{i:nat | i < n} (
  A: arrayref (a, n), i: g1uint (tk, i), x: &a >> _
) :<!refwrt> void // end of [arrayref_exch_at_guint]

symintr arrayref_exch_at
overload arrayref_exch_at with arrayref_exch_at_gint of 0
overload arrayref_exch_at with arrayref_exch_at_guint of 0

(* ****** ****** *)

fun{a:vt0p}
arrayref_interchange
  {n:int} (A: arrayref (a, n), i: sizeLt n, j: sizeLt n):<!refwrt> void
// end of [arrayref_interchange]

(* ****** ****** *)

fun{a:vt0p}
arrayref_subcirculate
  {n:int} (A: arrayref (a, n), i: sizeLt n, j: sizeLt n):<!refwrt> void
// end of [arrayref_subcirculate]

(* ****** ****** *)

(*
fun{}
fprint_array$sep (out: FILEref): void
*)
fun{a:vt0p}
fprint_arrayref
  {n:int} (
  out: FILEref, A: arrayref (INV(a), n), n: size_t n
) : void // end of [fprint_arrayref]
fun{a:vt0p}
fprint_arrayref_sep
  {n:int} (
  out: FILEref
, A: arrayref (a, n), asz: size_t n, sep: NSH(string)
) : void // end of [fprint_arrayref_sep]

(* ****** ****** *)

fun{a:t0p}
arrayref_copy{n:int}
  (A: arrayref (a, n), n: size_t (n)): arrayptr (a, n)
// end of [arrayref_copy]

(* ****** ****** *)
//
(*
fun{a:vt0p}
array_tabulate$fopr (index: size_t): (a)
*)
fun{a:vt0p}
arrayref_tabulate
  {n:int} (asz: size_t n): arrayref (a, n)
//
fun{a:vt0p}
arrayref_tabulate_cloref
  {n:int} (size_t n, (sizeLt(n)) -<cloref> a): arrayref (a, n)
//
(* ****** ****** *)

(*
fun{a:vt0p}{env:vt0p}
array_foreach$cont (x: &a, env: &env): void
fun{a:vt0p}{env:vt0p}
array_foreach$fwork (x: &a >> a, env: &(env) >> _): void
*)
fun{
a:vt0p
} arrayref_foreach{n:int} (
  A: arrayref (a, n), asz: size_t (n)
) : sizeLte(n) // end of [arrayref_foreach]
fun{
a:vt0p}{env:vt0p
} arrayref_foreach_env{n:int} (
  A: arrayref (a, n), asz: size_t (n), env: &(env)>>env
) : sizeLte(n) // end of [arrayref_foreach_env]

(* ****** ****** *)

(*
fun{a:vt0p}{env:vt0p}
array_iforeach$cont (i: size_t, x: &a, env: &env): void
fun{a:vt0p}{env:vt0p}
array_iforeach$fwork (i: size_t, x: &a >> a, env: &(env) >> _): void
*)
fun{
a:vt0p
} arrayref_iforeach{n:int} (
  A: arrayref (INV(a), n), asz: size_t (n)
) : sizeLte(n) // end of [arrayref_iforeach]
fun{
a:vt0p}{env:vt0p
} arrayref_iforeach_env{n:int} (
  A: arrayref (INV(a), n), asz: size_t (n), env: &(env)>>env
) : sizeLte(n) // end of [arrayref_iforeach_env]

(* ****** ****** *)

(*
fun{a:vt0p}{env:vt0p}
array_rforeach$cont (x: &a, env: &env): void
fun{a:vt0p}{env:vt0p}
array_rforeach$fwork (x: &a >> a, env: &(env) >> _): void
*)
fun{
a:vt0p
} arrayref_rforeach{n:int} (
  A: arrayref (a, n), asz: size_t (n)
) : sizeLte(n) // end of [arrayref_rforeach]
fun{
a:vt0p}{env:vt0p
} arrayref_rforeach_env{n:int} (
  A: arrayref (a, n), asz: size_t (n), env: &(env)>>env
) : sizeLte(n) // end of [arrayref_rforeach_env]

(* ****** ****** *)
//
fun
{a:vt0p}
arrayref_quicksort
  {n:int}(A: arrayref(a, n), asz: size_t(n)): void
//
(* ****** ****** *)
//
// arrszref: a reference to an array with size information attached
//
(* ****** ****** *)

#if(0)
//
// HX-2013-06:
// it is declared in [basic_dyn.sats]
//
abstype
arrszref_vt0ype_type (a: vt@ype) = ptr
stadef arrszref = arrszref_vt0ype_type
//
#endif

(* ****** ****** *)

symintr arrszref

(* ****** ****** *)

fun{}
arrszref_make_arrpsz
  {a:vt0p}{n:int}
  (arrpsz (INV(a), n)):<!wrt> arrszref(a)
//
overload arrszref with arrszref_make_arrpsz
//
(* ****** ****** *)

fun{}
arrszref_make_arrayref
  {a:vt0p}{n:int}
  (A: SHR(arrayref(a, n)), n: size_t n):<!wrt> arrszref (a)
// end of [arrszref_make_arrayref]

(* ****** ****** *)

fun{
} arrszref_get_ref{a:vt0p} (A: arrszref (a)):<> Ptr1
fun{
} arrszref_get_size{a:vt0p} (A: arrszref (a)):<> size_t

(* ****** ****** *)

fun{}
arrszref_get_refsize{a:vt0p}
  (A: arrszref (a), asz: &size_t? >> size_t n):<!wrt> #[n:nat] arrayref (a, n)
// end of [arrszref_get_refsize]

(* ****** ****** *)

fun{a:t0p}
arrszref_make_elt (asz: size_t, x: a):<!wrt> arrszref (a)
// end of [arrszref_make_elt]

(* ****** ****** *)

fun{a:t0p}
arrszref_make_list (xs: List (INV(a))):<!wrt> arrszref (a)
// end of [arrszref_make_list]

fun{a:t0p}
arrszref_make_rlist (xs: List (INV(a))):<!wrt> arrszref (a)
// end of [arrszref_make_rlist]

(* ****** ****** *)

(*
fun{}
fprint_array$sep (out: FILEref): void
*)
fun{a:vt0p}
fprint_arrszref
  (out: FILEref, A: arrszref (a)): void
// end of [fprint_arrszref]
fun{a:vt0p}
fprint_arrszref_sep (
  out: FILEref, A: arrszref (a), sep: NSH(string)
) : void // end of [fprint_arrszref_sep]

(* ****** ****** *)
//
fun{a:t0p}
arrszref_get_at_size
  (A: arrszref (a), i: size_t):<!exnref> a
//
fun{
a:t0p}{tk:tk
} arrszref_get_at_gint
  (A: arrszref (a), i: g0int (tk)):<!exnref> a
//
fun{
a:t0p}{tk:tk
} arrszref_get_at_guint
  (A: arrszref (a), i: g0uint (tk)):<!exnref> a
//
symintr arrszref_get_at
overload arrszref_get_at with arrszref_get_at_gint of 0
overload arrszref_get_at with arrszref_get_at_guint of 0
//
(* ****** ****** *)
//
fun{a:t0p}
arrszref_set_at_size
  (A: arrszref (a), i: size_t, x: a):<!exnrefwrt> void
//
fun{
a:t0p}{tk:tk
} arrszref_set_at_gint
  (A: arrszref (a), i: g0int (tk), x: a):<!exnrefwrt> void
//
fun{
a:t0p}{tk:tk
} arrszref_set_at_guint
  (A: arrszref (a), i: g0uint (tk), x: a):<!exnrefwrt> void
//
symintr arrszref_set_at
overload arrszref_set_at with arrszref_set_at_gint of 0
overload arrszref_set_at with arrszref_set_at_guint of 0
//
(* ****** ****** *)

fun{a:vt0p}
arrszref_exch_at_size
  (A: arrszref (a), i: size_t, x: &a >> _):<!exnrefwrt> void
// end of [arrszref_exch_at_size]

fun{
a:vt0p}{tk:tk
} arrszref_exch_at_gint
  (A: arrszref (a), i: g0int (tk), x: &a >> _):<!exnrefwrt> void
// end of [arrszref_exch_at_gint]

fun{
a:vt0p}{tk:tk
} arrszref_exch_at_guint
  (A: arrszref (a), i: g0uint (tk), x: &a >> _):<!exnrefwrt> void
// end of [arrszref_exch_at_guint]

symintr arrszref_exch_at
overload arrszref_exch_at with arrszref_exch_at_gint of 0
overload arrszref_exch_at with arrszref_exch_at_guint of 0

(* ****** ****** *)

fun{a:vt0p}
arrszref_interchange
  (A: arrszref (a), i: size_t, j: size_t):<!exnrefwrt> void
// end of [arrszref_interchange]

(* ****** ****** *)

fun{a:vt0p}
arrszref_subcirculate
  (A: arrszref (a), i: size_t, j: size_t):<!exnrefwrt> void
// end of [arrszref_subcirculate]

(* ****** ****** *)
//
(*
fun{a:vt0p}
array_tabulate$fopr (index: size_t): (a)
*)
fun{a:vt0p}
arrszref_tabulate (asz: size_t): arrszref (a)
//
fun{a:vt0p}
arrszref_tabulate_cloref
  {n:int} (size_t n, (sizeLt(n)) -<cloref> a): arrszref (a)
//
(* ****** ****** *)
//
// overloading for certain symbols
//
(* ****** ****** *)

overload [] with arrayref_get_at_gint of 0
overload [] with arrayref_get_at_guint of 0
overload [] with arrayref_set_at_gint of 0
overload [] with arrayref_set_at_guint of 0
overload [] with arrszref_get_at_gint of 0
overload [] with arrszref_get_at_guint of 0
overload [] with arrszref_set_at_gint of 0
overload [] with arrszref_set_at_guint of 0

(* ****** ****** *)

overload .head with arrayref_head
overload .tail with arrayref_tail

(* ****** ****** *)

overload .size with arrszref_get_size

(* ****** ****** *)

overload fprint with fprint_arrayref
overload fprint with fprint_arrayref_sep
overload fprint with fprint_arrszref
overload fprint with fprint_arrszref_sep

(* ****** ****** *)

overload ptrcast with arrayref2ptr

(* ****** ****** *)

(* end of [arrayref.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/tuple.atxt
** Time of generation: Sat Oct 17 15:19:45 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: December, 2012 *)

(* ****** ****** *)

sortdef t0p = t@ype and vt0p = viewt@ype

(* ****** ****** *)

typedef SHR(a:type) = a // for commenting purpose
typedef NSH(a:type) = a // for commenting purpose

(* ****** ****** *)

typedef tup2
  (a0:t0p, a1:t0p) = @(a0, a1)
stadef tup = tup2
typedef tup3
  (a0:t0p, a1:t0p, a2:t0p) = @(a0, a1, a2)
stadef tup = tup3
typedef tup4
  (a0:t0p, a1:t0p, a2:t0p, a3:t0p) = @(a0, a1, a2, a3)
stadef tup = tup4

(* ****** ****** *)

fun{} fprint_tup$beg (out: FILEref): void
fun{} fprint_tup$end (out: FILEref): void
fun{} fprint_tup$sep (out: FILEref): void

(* ****** ****** *)

fun{
a0,a1:t0p
} fprint_tupval2 (out: FILEref, x: @(a0, a1)): void
fun{
a0,a1,a2:t0p
} fprint_tupval3 (out: FILEref, x: @(a0, a1, a2)): void
fun{
a0,a1,a2,a3:t0p
} fprint_tupval4 (out: FILEref, x: @(a0, a1, a2, a3)): void

(* ****** ****** *)

fun{
a0,a1:vt0p
} fprint_tupref2 (out: FILEref, x: &(a0, a1)): void
fun{
a0,a1,a2:vt0p
} fprint_tupref3 (out: FILEref, x: &(a0, a1, a2)): void
fun{
a0,a1,a2,a3:vt0p
} fprint_tupref4 (out: FILEref, x: &(a0, a1, a2, a3)): void

(* ****** ****** *)

fun{
a0,a1:t0p
} tupval2_compare
  (x: @(a0, a1), y: @(a0, a1)):<> int
// end of [tupval2_compare]

fun{
a0,a1,a2:t0p
} tupval3_compare
  (x: @(a0, a1, a2), y: @(a0, a1, a2)):<> int
// end of [tupval3_compare]

fun{
a0,a1,a2,a3:t0p
} tupval4_compare
  (x: @(a0, a1, a2, a3), y: @(a0, a1, a2, a3)):<> int
// end of [tupval4_compare]

(* ****** ****** *)

fun{
a0,a1:vt0p
} tupref2_compare
  (x: &(a0, a1), y: &(a0, a1)):<> int
// end of [tupref2_compare]

fun{
a0,a1,a2:vt0p
} tupref3_compare
  (x: &(a0, a1, a2), y: &(a0, a1, a2)):<> int
// end of [tupref3_compare]

fun{
a0,a1,a2,a3:vt0p
} tupref4_compare
  (x: &(a0, a1, a2, a3), y: &(a0, a1, a2, a3)):<> int
// end of [tupref4_compare]

(* ****** ****** *)

(* end of [tuple.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** Source:
** $PATSHOME/prelude/SATS/CODEGEN/list_vt.atxt
** Time of generation: Sat Oct 17 15:19:48 2015
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2012 *)

(* ****** ****** *)

vtypedef
RD(a:vt0p) = a // for commenting: read-only
#define NSH (x) x // for commenting: no sharing
#define SHR (x) x // for commenting: it is shared

(* ****** ****** *)

#if(0)
//
// HX: these decls are available in [basic_dyn.sats]
//
datavtype // vt@ype+: covariant
list_vt0ype_int_vtype (a:vt@ype+, int) =
  | {n:int | n >= 0}
    list_vt_cons (a, n+1) of (a, list_vt0ype_int_vtype (a, n))
  | list_vt_nil (a, 0) of ((*void*))
// end of [list_vt0ype_int_vtype]
//
stadef list_vt = list_vt0ype_int_vtype
vtypedef
List_vt (a:vt0p) = [n:int] list_vt (a, n)
vtypedef
List0_vt (a:vt0p) = [n:int | n >= 0] list_vt (a, n)
vtypedef
List1_vt (a:vt0p) = [n:int | n >= 1] list_vt (a, n)
vtypedef listLt_vt
  (a:vt0p, n:int) = [k:nat | k < n] list_vt (a, k)
vtypedef listLte_vt
  (a:vt0p, n:int) = [k:nat | k <= n] list_vt (a, k)
vtypedef listGt_vt
  (a:vt0p, n:int) = [k:int | k > n] list_vt (a, k)
vtypedef listGte_vt
  (a:vt0p, n:int) = [k:int | k >= n] list_vt (a, k)
vtypedef listBtw_vt
  (a:vt0p, m:int, n:int) = [k:int | m <= k; k < n] list_vt (a, k)
vtypedef listBtwe_vt
  (a:vt0p, m:int, n:int) = [k:int | m <= k; k <= n] list_vt (a, k)
//
#endif

(* ****** ****** *)

#define nil_vt list_vt_nil
#define cons_vt list_vt_cons

(* ****** ****** *)

prfun
lemma_list_vt_param
  {x:vt0p}{n:int}
  (xs: !list_vt (INV(x), n)): [n >= 0] void
// end of [lemma_list_vt_param]

(* ****** ****** *)

castfn
list_vt_cast
  {x:vt0p}{n:int}
  (xs: list_vt (INV(x), n)):<> list_vt (x, n)
// end of [list_vt_cast]

(* ****** ****** *)

#define list_vt_sing(x)
  list_vt_cons(x, list_vt_nil())
#define list_vt_pair(x1, x2)
  list_vt_cons(x1, list_vt_cons (x2, list_vt_nil()))

(* ****** ****** *)

fun{x:vt0p}
list_vt_make_sing (x: x):<!wrt> list_vt (x, 1)
fun{x:vt0p}
list_vt_make_pair (x1: x, x2: x):<!wrt> list_vt (x, 2)

(* ****** ****** *)
//
fun{x:vt0p}
print_list_vt (xs: !List_vt (INV(x))): void
fun{x:vt0p}
prerr_list_vt (xs: !List_vt (INV(x))): void
//
fun{x:vt0p}
fprint_list_vt
  (out: FILEref, xs: !List_vt (INV(x))): void
fun{} fprint_list_vt$sep (out: FILEref): void
//
fun{x:vt0p}
fprint_list_vt_sep (
  out: FILEref, xs: !List_vt (INV(x)), sep: NSH(string)
) : void // end of [fprint_list_vt_sep]
//
(* ****** ****** *)
//
fun{x:vt0p}
list_vt_is_nil
  {n:int} (xs: !list_vt (INV(x), n)):<> bool (n==0)
//
fun{x:vt0p}
list_vt_is_cons
  {n:int} (xs: !list_vt (INV(x), n)):<> bool (n > 0)
//
(* ****** ****** *)

fun{x:vt0p}
list_vt_is_sing
  {n:int} (xs: !list_vt (INV(x), n)):<> bool (n==1)
// end of [list_vt_is_sing]

fun{x:vt0p}
list_vt_is_pair
  {n:int} (xs: !list_vt (INV(x), n)):<> bool (n==2)
// end of [list_vt_is_pair]

(* ****** ****** *)

fun{}
list_vt_unnil{x:vt0p} (xs: list_vt (x, 0)):<> void

(* ****** ****** *)

fun{x:vt0p}
list_vt_uncons{n:pos}
  (xs: &list_vt (INV(x), n) >> list_vt (x, n-1)):<!wrt> x
// end of [list_vt_uncons]

(* ****** ****** *)

fun{x:vt0p}
list_vt_length{n:int} (xs: !list_vt (INV(x), n)):<> int n

(* ****** ****** *)

fun{x:vt0p}
list_vt_getref_at
  {n:int}{i:nat | i <= n}
  (xs: &list_vt (INV(x), n), i: int i):<> cPtr1 (list_vt (x, n-i))
// end of [list_vt_getref_at]

(* ****** ****** *)
//
fun{x:t0p}
list_vt_get_at{n:int}
  (xs: !list_vt (INV(x), n), i: natLt n):<> x
//
fun{x:t0p}
list_vt_set_at{n:int}
  (xs: !list_vt (INV(x), n), i: natLt n, x: x):<!wrt> void
//
(* ****** ****** *)

fun{x:vt0p}
list_vt_exch_at{n:int}
  (xs: !list_vt (INV(x), n), i: natLt n, x: &x >> _):<!wrt> void
// end of [list_vt_exch_at]

(* ****** ****** *)

fun{x:vt0p}
list_vt_insert_at{n:int}
(
  xs: &list_vt (INV(x), n) >> list_vt (x, n+1), i: natLte n, x: x
) :<!wrt> void // end of [list_vt_insert_at]

fun{x:vt0p}
list_vt_takeout_at{n:int}
  (xs: &list_vt (INV(x), n) >> list_vt (x, n-1), i: natLt n):<!wrt> x
// end of [list_vt_takeout_at]

(* ****** ****** *)

fun{x:t0p}
list_vt_copy{n:int}
  (xs: !list_vt (INV(x), n)):<!wrt> list_vt (x, n)
// end of [list_vt_copy]

(* ****** ****** *)
//
fun{x:vt0p}
list_vt_copylin{n:int}
  (xs: !list_vt (INV(x), n)):<!wrt> list_vt (x, n)
fun{x:vt0p}
list_vt_copylin$copy (x: &RD(x)): (x)
//
fun{x:vt0p}
list_vt_copylin_fun{n:int}{fe:eff}
  (xs: !list_vt (INV(x), n), f: (&RD(x)) -<fe> x):<!wrt,fe> list_vt (x, n)
//
(* ****** ****** *)

fun{x:t0p}
list_vt_free (xs: List_vt (INV(x))):<!wrt> void

(* ****** ****** *)
//
fun{x:vt0p}
list_vt_freelin
  (xs: List_vt (INV(x))):<!wrt> void
fun{x:vt0p}
list_vt_freelin$clear (x: &x >> x?):<!wrt> void
//
fun{x:vt0p}
list_vt_freelin_fun{fe:eff}
  (xs: List_vt (INV(x)), f: (&x>>x?) -<fe> void):<!wrt,fe> void
//
(* ****** ****** *)
//
fun{
x:vt0p
} list_vt_uninitize
  {n:int} (
  xs: !list_vt (INV(x), n) >> list_vt (x?, n)
) :<!wrt> void // end of [list_vt_uninitize]
//
fun{x:vt0p}
list_vt_uninitize$clear (x: &(x) >> x?):<!wrt> void
//
fun{
x:vt0p
} list_vt_uninitize_fun
  {n:int}{fe:eff}
(
  xs: !list_vt (INV(x), n) >> list_vt (x?, n), f: (&x>>x?) -<fe> void
) :<!wrt,fe> void // end of [list_vt_uninitize_fun]
//
(* ****** ****** *)

fun{
a:vt0p
} list_vt_append
  {n1,n2:int} (
  xs1: list_vt (INV(a), n1), xs2: list_vt (a, n2)
) :<!wrt> list_vt (a, n1+n2) // endfun

(* ****** ****** *)

fun{
x:vt0p
} list_vt_extend{n:int}
  (xs1: list_vt (INV(x), n), x2: x):<!wrt> list_vt (x, n+1)
// end of [list_vt_extend]

fun{x:vt0p}
list_vt_unextend{n:pos}
  (xs: &list_vt (INV(x), n) >> list_vt (x, n-1)):<!wrt> (x)
// end of [list_vt_unextend]

(* ****** ****** *)

macdef list_vt_snoc = list_vt_extend
macdef list_vt_unsnoc = list_vt_unextend

(* ****** ****** *)

fun{x:vt0p}
list_vt_reverse{n:int}
  (xs: list_vt (INV(x), n)):<!wrt> list_vt (x, n)
// end of [list_vt_reverse]

fun{a:vt0p}
list_vt_reverse_append{m,n:int}
  (list_vt (INV(a), m), list_vt (a, n)):<!wrt> list_vt (a, m+n)
// end of [list_vt_reverse_append]

(* ****** ****** *)

fun{x:vt0p}
list_vt_split_at
  {n:int}{i:nat | i <= n}
  (list_vt (INV(x), n), int i):<!wrt> (list_vt (x, i), list_vt (x, n-i))
// end of [list_vt_split_at]

(* ****** ****** *)

fun{x:vt0p}
list_vt_concat
  (xss: List_vt (List_vt (INV(x)))):<!wrt> List0_vt (x)
// end of [list_vt_concat]

(* ****** ****** *)

fun{x:vt0p}
list_vt_separate{n:int}
(
  xs: &list_vt (INV(x), n) >> list_vt (x, n1)
) : #[n1:nat|n1 <= n] list_vt (x, n-n1)

fun{x:vt0p}
list_vt_separate$pred (x: &RD(x)): bool

(* ****** ****** *)

fun{x:t0p}
list_vt_filter{n:int}
  (x: list_vt (INV(x), n)):<!wrt> listLte_vt (x, n)
// end of [list_vt_filter]

fun{x:t0p}
list_vt_filter$pred (x: &RD(x)):<> bool

(* ****** ****** *)
//
fun{x:vt0p}
list_vt_filterlin
  {n:int} (list_vt (INV(x), n)):<!wrt> listLte_vt (x, n)
//
fun{x:vt0p}
list_vt_filterlin$pred (x: &RD(x)):<> bool
fun{x:vt0p}
list_vt_filterlin$clear (x: &x >> x?):<!wrt> void
//
(* ****** ****** *)

fun{x:vt0p}
list_vt_app (xs: !List_vt (INV(x))): void
fun{x:vt0p}
list_vt_app$fwork (x: &x >> _): void

(* ****** ****** *)

fun{x:vt0p}
list_vt_appfree (xs: List_vt (INV(x))): void
fun{x:vt0p}
list_vt_appfree$fwork (x: &x >> x?): void

(* ****** ****** *)
//
fun{
x:vt0p}{y:vt0p
} list_vt_map{n:int}
(
  xs: !list_vt (INV(x), n)
) : list_vt (y, n)
//
fun{
x:vt0p}{y:vt0p
} list_vt_map$fopr (x: &x >> _): (y)
//
(* ****** ****** *)

fun{
x:vt0p}{y:vt0p
} list_vt_map_fun{n:int}
  (xs: !list_vt (INV(x), n), f: (&x) -<fun1> y): list_vt(y, n)
fun{
x:vt0p}{y:vt0p
} list_vt_map_clo{n:int}
  (xs: !list_vt (INV(x), n), f: &(&x) -<clo1> y): list_vt(y, n)
fun{
x:vt0p}{y:vt0p
} list_vt_map_cloref{n:int}
  (xs: !list_vt (INV(x), n), f: (&x) -<cloref1> y): list_vt(y, n)

(* ****** ****** *)
//
fun{
x:vt0p}{y:vt0p
} list_vt_mapfree{n:int}
(
  xs: list_vt (INV(x), n)
) : list_vt (y, n)
//
fun{
x:vt0p}{y:vt0p
} list_vt_mapfree$fopr (x: &(x) >> x?): (y)
//
(* ****** ****** *)

fun{
x:vt0p}{y:vt0p
} list_vt_mapfree_fun{n:int}
  (xs: list_vt (INV(x), n), f: (&x>>_?) -<fun1> y): list_vt(y, n)
fun{
x:vt0p}{y:vt0p
} list_vt_mapfree_clo{n:int}
  (xs: list_vt (INV(x), n), f: &(&x>>_?) -<clo1> y): list_vt(y, n)
fun{
x:vt0p}{y:vt0p
} list_vt_mapfree_cloref{n:int}
  (xs: list_vt (INV(x), n), f: (&x>>_?) -<cloref1> y): list_vt(y, n)

(* ****** ****** *)
//
fun{
x:vt0p
} list_vt_foreach (xs: !List_vt (INV(x))): void
//
fun{
x:vt0p}{env:vt0p
} list_vt_foreach_env (xs: !List_vt (INV(x)), env: &(env) >> _): void
//
fun{
x:vt0p}{env:vt0p
} list_vt_foreach$cont (x: &x, env: &env): bool
fun{
x:vt0p}{env:vt0p
} list_vt_foreach$fwork (x: &x >> _, env: &(env) >> _): void
//
(* ****** ****** *)

fun{
x:vt0p
} list_vt_foreach_fun
  {fe:eff} (
  xs: !List_vt (INV(x)), f: (&x) -<fe> void
) :<fe> void // end of [list_vt_foreach_fun]
fun{
x:vt0p
} list_vt_foreach_funenv
  {v:view}{vt:viewtype}{fe:eff} (
  pfv: !v
| xs: !List_vt (INV(x)), f: (!v | &x, !vt) -<fe> void, env: !vt
) :<fe> void // end of [list_vt_foreach_funenv]

(* ****** ****** *)
//
fun{
x:vt0p
} list_vt_iforeach
  {n:int} (xs: !list_vt (INV(x), n)): natLte(n)
//
fun{
x:vt0p}{env:vt0p
} list_vt_iforeach_env
  {n:int} (xs: !list_vt (INV(x), n), env: &(env) >> _): natLte(n)
//
fun{
x:vt0p}{env:vt0p
} list_vt_iforeach$cont
  (i: intGte(0), x: &x, env: &env): bool
fun{
x:vt0p}{env:vt0p
} list_vt_iforeach$fwork
  (i: intGte(0), x: &x >> _, env: &(env) >> _): void
//
(* ****** ****** *)
//
fun{
a:vt0p
} list_vt_mergesort
  {n:int} (xs: list_vt (INV(a), n)):<!wrt> list_vt (a, n)
fun{
a:vt0p
} list_vt_mergesort$cmp (x1: &RD(a), x2: &RD(a)):<> int(*sgn*)
//
fun{
a:vt0p
} list_vt_mergesort_fun
  {n:int} (
  xs: list_vt (INV(a), n), cmp: cmpref (a)
) :<!wrt> list_vt (a, n) // end of [list_vt_mergesort_fun]
//
(* ****** ****** *)
//
fun{
a:vt0p
} list_vt_quicksort
  {n:int} (xs: list_vt (INV(a), n)):<!wrt> list_vt (a, n)
fun{
a:vt0p
} list_vt_quicksort$cmp (x1: &RD(a), x2: &RD(a)):<> int(*sgn*)
//
fun{
a:vt0p
} list_vt_quicksort_fun
  {n:int} (
  xs: list_vt (INV(a), n), cmp: cmpref (a)
) :<!wrt> list_vt (a, n) // end of [list_vt_quicksort_fun]
//
(* ****** ****** *)
//
// overloading for certain symbols
//
(* ****** ****** *)
//
overload [] with list_vt_get_at
overload [] with list_vt_set_at
//
overload iseqz with list_vt_is_nil
overload isneqz with list_vt_is_cons
//
overload length with list_vt_length
//
overload copy with list_vt_free
overload free with list_vt_free
//
overload print with print_list_vt
overload prerr with prerr_list_vt
overload fprint with fprint_list_vt
overload fprint with fprint_list_vt_sep
//
(* ****** ****** *)

(* end of [list_vt.sats] *)
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/list.atxt
** Time of generation: Sat Oct 17 15:20:03 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: January, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_LIST
#define ATSLIB_PRELUDE_CATS_LIST

/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_LIST

/* ****** ****** */

/* end of [list.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/strptr.atxt
** Time of generation: Sat Oct 17 15:20:03 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_STRPTR
#define ATSLIB_PRELUDE_CATS_STRPTR

/* ****** ****** */
//
// [string.h]
//
extern
int // (sign)
strcmp (const char *x1, const char *x2) ;

/* ****** ****** */

#define atspre_strptr_null() atsptr_null

/* ****** ****** */

#define atspre_strptr_free atspre_mfree_gc
#define atspre_strnptr_free atspre_mfree_gc

/* ****** ****** */

ATSinline()
atstype_int
atspre_compare_strptr_strptr
(
  atstype_strptr x1, atstype_strptr x2
) {
  if (x1==0) {
    return (x2==0 ? 0 : -1) ;
  } else {
    return (x2==0 ? 1 : strcmp((char*)x1, (char*)x2)) ;
  } // end of [if]
} // end of [atspre_compare_strptr_strptr]

/* ****** ****** */

#define atspre_eq_strptr_string atspre_eq_string_string 
#define atspre_neq_strptr_string atspre_neq_string_string 
#define atspre_compare_strptr_string atspre_compare_string_string 

/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_STRPTR

/* ****** ****** */

/* end of [strptr.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/basics.atxt
** Time of generation: Sat Oct 17 15:20:01 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: January, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_BASICS
#define ATSLIB_PRELUDE_CATS_BASICS

/* ****** ****** */

#include <stdio.h>
#include <stdlib.h>

/* ****** ****** */

ATSinline()
atstype_int
atspre_lor_int_int
(
  atstype_int x1
, atstype_int x2
) {
  return ((x1)|(x2)) ;
} /* [atspre_lor_int_int] */

ATSinline()
atstype_int
atspre_land_int_int
(
  atstype_int x1
, atstype_int x2
) {
  return ((x1)&(x2)) ;
} /* [atspre_land_int_int] */

ATSinline()
atstype_int
atspre_lxor_int_int
(
  atstype_int x1
, atstype_int x2
) {
  return ((x1)^(x2)) ;
} /* [atspre_lxor_int_int] */

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_cloptr_free
(
  atstype_cloptr pclo
) {
  ATS_MFREE (pclo) ; return ;
} /* [atspre_cloptr_free] */

/* ****** ****** */

ATSinline()
atstype_string
atspre_argv_get_at
(
  atstype_arrptr argv, atstype_int i
)
{
  return (((atstype_string*)argv)[i]) ;
} /* end of [atspre_argv_get_at] */

ATSinline()
atsvoid_t0ype
atspre_argv_set_at
(
  atstype_arrptr argv
, atstype_int i, atstype_string x
)
{
  ((atstype_string*)argv)[i] = x ; return ;
} /* end of [atspre_argv_set_at] */

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_exit
 (atstype_int ecode) { exit(ecode) ; return ; }
// end of [atspre_exit]

ATSinline()
atsvoid_t0ype
atspre_exit_errmsg
(
  atstype_int ecode, atstype_string msg
)
{
  fprintf(stderr, "exit(ATS): %s", (char*)msg); exit(ecode); return;
} // end of [atspre_exit_errmsg]

/* ****** ****** */

#define atspre_exit_void atspre_exit
#define atspre_exit_errmsg_void atspre_exit_errmsg

/* ****** ****** */
//
ATSinline()
atsvoid_t0ype
atspre_assert_bool
  (atstype_bool b)
{
  if (!b) exit(1) ; return ;
} /* endfun */
//
#define atspre_assert_bool0 atspre_assert_bool
#define atspre_assert_bool1 atspre_assert_bool
//
/* ****** ****** */
//
ATSinline()
atsvoid_t0ype
atspre_assert_errmsg_bool
(
  atstype_bool b, atstype_string msg
)
{
  if (!b) {
    fprintf(stderr, "%s", (char*)msg) ; exit(1) ;
  } // end of [if]
  return ;
} /* endfun */
//
#define atspre_assert_errmsg_bool0 atspre_assert_errmsg_bool
#define atspre_assert_errmsg_bool1 atspre_assert_errmsg_bool
//
/* ****** ****** */
//
ATSinline()
atsvoid_t0ype
atspre_assert_errmsg2_bool
(
  atstype_bool b
, atstype_string msg1, atstype_string msg2
)
{
  if (!b) {
    fprintf(stderr, "%s%s", (char*)msg1, (char*)msg2) ; exit(1) ;
  } // end of [if]
  return ;
} /* endfun */
//
#define atspre_assert_errmsg2_bool0 atspre_assert_errmsg2_bool
#define atspre_assert_errmsg2_bool1 atspre_assert_errmsg2_bool
//
/* ****** ****** */
//
ATSinline()
atsvoid_t0ype
atspre_fprint_newline
  (atstype_ref out)
{
  int n ;
  int err = -1 ;
  n = fprintf((FILE*)out, "\n") ;
  if (n > 0) err = fflush((FILE*)out) ;
  if (err < 0) {
    fprintf(stderr, "exit(ATS): [fprint_newline] failed.") ; exit(1) ;
  } // end of [if]
  return ;
} /* endfun */
//
#define atspre_print_newline() atspre_fprint_newline(stdout)
#define atspre_prerr_newline() atspre_fprint_newline(stderr)
//
/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_BASICS

/* ****** ****** */

/* end of [basics.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/char.atxt
** Time of generation: Sat Oct 17 15:20:02 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2012 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_CHAR
#define ATSLIB_PRELUDE_CATS_CHAR

/* ****** ****** */

#include <ctype.h>

/* ****** ****** */

#ifdef __CYGWIN__
//
#ifndef isascii
extern int isascii (int c) ; // _XOPEN_SOURCE
#endif // end of [isascii]

#ifndef isblank
extern int isblank (int c) ; // _XOPEN_SOURCE >= 600
#endif // end of [isblank]

#ifndef toascii
extern int toascii (int c) ; // _XOPEN_SOURCE
#endif // end of [toascii]
//
#endif // end of [#ifdef(__CYGWIN__)]

/* ****** ****** */
//
ATSinline()
atstype_char
atspre_int2char
  (atstype_int i) { return ((atstype_char)i) ; }
ATSinline()
atstype_schar
atspre_int2schar
  (atstype_int i) { return ((atstype_schar)i) ; }
ATSinline()
atstype_uchar
atspre_int2uchar
  (atstype_int i) { return ((atstype_uchar)i) ; }
//
#define atspre_int2char0 atspre_int2char
#define atspre_int2schar0 atspre_int2schar
#define atspre_int2uchar0 atspre_int2uchar
//
/* ****** ****** */
//
ATSinline()
atstype_int
atspre_char2int
  (atstype_char c) { return ((atstype_int)c) ; }
ATSinline()
atstype_int
atspre_schar2int
  (atstype_schar c) { return ((atstype_int)c) ; }
ATSinline()
atstype_int
atspre_uchar2int
  (atstype_uchar c) { return ((atstype_int)c) ; }
//
#define atspre_char2int0 atspre_char2int
#define atspre_schar2int0 atspre_schar2int
#define atspre_uchar2int0 atspre_uchar2int
//
/* ****** ****** */
//
ATSinline()
atstype_uint
atspre_char2uint
  (atstype_char c) { return ((atstype_uint)c) ; }
ATSinline()
atstype_uint
atspre_schar2uint
  (atstype_schar c) { return ((atstype_uint)c) ; }
ATSinline()
atstype_uint
atspre_uchar2uint
  (atstype_uchar c) { return ((atstype_uint)c) ; }
//
#define atspre_char2uint0 atspre_char2uint
#define atspre_schar2uint0 atspre_schar2uint
#define atspre_uchar2uint0 atspre_uchar2uint
//
/* ****** ****** */
//
ATSinline()
atstype_int
atspre_char2u2int
  (atstype_char c)
  { return ((atstype_int)((atstype_uchar)c)) ; }
ATSinline()
atstype_uint
atspre_char2u2uint
  (atstype_char c)
  { return ((atstype_uint)((atstype_uchar)c)) ; }
//
#define atspre_char2u2int0 atspre_char2u2int
#define atspre_char2u2uint0 atspre_char2u2uint
//
/* ****** ****** */

ATSinline()
atstype_bool
atspre_char_iseqz
  (atstype_char c)
{
  return ((c == 0) ? atsbool_true : atsbool_false) ;
} // end of [atspre_char_iseqz]
#define atspre_char0_iseqz(c) atspre_char_iseqz(c) 
#define atspre_char1_iseqz(c) atspre_char_iseqz(c) 

ATSinline()
atstype_bool
atspre_char_isneqz
  (atstype_char c)
{
  return ((c != 0) ? atsbool_true : atsbool_false) ;
} // end of [atspre_char_isneqz]
#define atspre_char0_isneqz(c) atspre_char_isneqz(c) 
#define atspre_char1_isneqz(c) atspre_char_isneqz(c) 

/* ****** ****** */
//
ATSinline()
atstype_char
atspre_add_char_int
(
  atstype_char c1, atstype_int i2
) { return (c1 + i2) ; }
//
#define atspre_add_char0_int0 atspre_add_char_int
//
/* ****** ****** */
//
ATSinline()
atstype_char
atspre_sub_char_int
(
  atstype_char c1, atstype_int i2
) { return (c1 - i2) ; }
//
#define atspre_sub_char0_int0 atspre_sub_char_int
//
/* ****** ****** */
//
ATSinline()
atstype_int
atspre_sub_char_char
(
  atstype_char c1, atstype_char c2
) { return (c1 - c2) ; }
//
#define atspre_sub_char0_char0 atspre_sub_char_char
//
/* ****** ****** */

ATSinline()
atstype_bool
atspre_lt_int_int
  (atstype_int i1, atstype_int i2) {
  return (i1 < i2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_lt_int_int]
#define atspre_lt_char0_char0 atspre_lt_int_int
#define atspre_lt_char1_char1 atspre_lt_int_int

ATSinline()
atstype_bool
atspre_lte_int_int
  (atstype_int i1, atstype_int i2) {
  return (i1 <= i2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_lte_int_int]
#define atspre_lte_char0_char0 atspre_lte_int_int
#define atspre_lte_char1_char1 atspre_lte_int_int

ATSinline()
atstype_bool
atspre_gt_int_int
  (atstype_int i1, atstype_int i2) {
  return (i1 > i2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_gt_int_int]
#define atspre_gt_char0_char0 atspre_gt_int_int
#define atspre_gt_char1_char1 atspre_gt_int_int

ATSinline()
atstype_bool
atspre_gte_int_int
  (atstype_int i1, atstype_int i2) {
  return (i1 >= i2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_gte_int_int]
#define atspre_gte_char0_char0 atspre_gte_int_int
#define atspre_gte_char1_char1 atspre_gte_int_int

ATSinline()
atstype_bool
atspre_eq_int_int
  (atstype_int i1, atstype_int i2) {
  return (i1 == i2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_eq_int_int]
#define atspre_eq_char0_char0 atspre_eq_int_int
#define atspre_eq_char1_char1 atspre_eq_int_int

ATSinline()
atstype_bool
atspre_neq_int_int
  (atstype_int i1, atstype_int i2) {
  return (i1 != i2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_neq_int_int]
#define atspre_neq_char0_char0 atspre_neq_int_int
#define atspre_neq_char1_char1 atspre_neq_int_int


/* ****** ****** */

ATSinline()
atstype_int
atspre_compare_int_int
  (atstype_int i1, atstype_int i2)
{
  return (i1 - i2) ;
} // end of [atspre_compare_int_int]
#define atspre_compare_char0_char0(c1, c2) atspre_compare_int_int(c1, c2)
#define atspre_compare_char1_char1(c1, c2) atspre_compare_int_int(c1, c2)

/* ****** ****** */

#define atspre_eq_char0_int0(c, i) atspre_eq_int_int(c, i)
#define atspre_eq_int0_char0(i, c) atspre_eq_int_int(i, c)
#define atspre_neq_char0_int0(c, i) atspre_neq_int_int(c, i)
#define atspre_neq_int0_char0(i, c) atspre_neq_int_int(i, c)

/* ****** ****** */

#define atspre_compare_char0_int0(c, i) atspre_compare_int_int(c, i)
#define atspre_compare_int0_char0(i, c) atspre_compare_int_int(i, c)

/* ****** ****** */
//
// unsigned characters
//
/* ****** ****** */

ATSinline()
atstype_bool
atspre_lt_uchar_uchar
  (atstype_uchar c1, atstype_uchar c2) {
  return (c1 < c2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_lt_uchar_uchar]
#define atspre_lt_uchar0_uchar0 atspre_lt_uchar_uchar
#define atspre_lt_uchar1_uchar1 atspre_lt_uchar_uchar

ATSinline()
atstype_bool
atspre_lte_uchar_uchar
  (atstype_uchar c1, atstype_uchar c2) {
  return (c1 <= c2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_lte_uchar_uchar]
#define atspre_lte_uchar0_uchar0 atspre_lte_uchar_uchar
#define atspre_lte_uchar1_uchar1 atspre_lte_uchar_uchar

ATSinline()
atstype_bool
atspre_gt_uchar_uchar
  (atstype_uchar c1, atstype_uchar c2) {
  return (c1 > c2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_gt_uchar_uchar]
#define atspre_gt_uchar0_uchar0 atspre_gt_uchar_uchar
#define atspre_gt_uchar1_uchar1 atspre_gt_uchar_uchar

ATSinline()
atstype_bool
atspre_gte_uchar_uchar
  (atstype_uchar c1, atstype_uchar c2) {
  return (c1 >= c2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_gte_uchar_uchar]
#define atspre_gte_uchar0_uchar0 atspre_gte_uchar_uchar
#define atspre_gte_uchar1_uchar1 atspre_gte_uchar_uchar

ATSinline()
atstype_bool
atspre_eq_uchar_uchar
  (atstype_uchar c1, atstype_uchar c2) {
  return (c1 == c2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_eq_uchar_uchar]
#define atspre_eq_uchar0_uchar0 atspre_eq_uchar_uchar
#define atspre_eq_uchar1_uchar1 atspre_eq_uchar_uchar

ATSinline()
atstype_bool
atspre_neq_uchar_uchar
  (atstype_uchar c1, atstype_uchar c2) {
  return (c1 != c2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_neq_uchar_uchar]
#define atspre_neq_uchar0_uchar0 atspre_neq_uchar_uchar
#define atspre_neq_uchar1_uchar1 atspre_neq_uchar_uchar


/* ****** ****** */

ATSinline()
atstype_int
atspre_compare_uchar_uchar
  (atstype_uchar c1, atstype_uchar c2) {
  return ((atstype_int)c1 - (atstype_int)c2) ;
} // end of [atspre_compare_uchar_uchar]
#define atspre_compare_uchar0_uchar0 atspre_compare_uchar_uchar
#define atspre_compare_uchar1_uchar1 atspre_compare_uchar_uchar

/* ****** ****** */

ATSinline()
atstype_bool
atspre_isalpha_int
  (atstype_int c) {
  return (isalpha(c) ? atsbool_true : atsbool_false) ;
} // end of [atspre_isalpha_int]
#define atspre_isalpha_char(c) atspre_isalpha_int((atstype_int)(c))
ATSinline()
atstype_bool
atspre_isalnum_int
  (atstype_int c) {
  return (isalnum(c) ? atsbool_true : atsbool_false) ;
} // end of [atspre_isalnum_int]
#define atspre_isalnum_char(c) atspre_isalnum_int((atstype_int)(c))

ATSinline()
atstype_bool
atspre_isascii_int
  (atstype_int c) {
  return (isascii(c) ? atsbool_true : atsbool_false) ;
} // end of [atspre_isascii_int]
#define atspre_isascii_char(c) atspre_isascii_int((atstype_int)(c))

ATSinline()
atstype_bool
atspre_isblank_int
  (atstype_int c) {
  return (isblank(c) ? atsbool_true : atsbool_false) ;
} // end of [atspre_isblank_int]
#define atspre_isblank_char(c) atspre_isblank_int((atstype_int)(c))
ATSinline()
atstype_bool
atspre_isspace_int
  (atstype_int c) {
  return (isspace(c) ? atsbool_true : atsbool_false) ;
} // end of [atspre_isspace_int]
#define atspre_isspace_char(c) atspre_isspace_int((atstype_int)(c))

ATSinline()
atstype_bool
atspre_iscntrl_int
  (atstype_int c) {
  return (iscntrl(c) ? atsbool_true : atsbool_false) ;
} // end of [atspre_iscntrl_int]
#define atspre_iscntrl_char(c) atspre_iscntrl_int((atstype_int)(c))

ATSinline()
atstype_bool
atspre_isdigit_int
  (atstype_int c) {
  return (isdigit(c) ? atsbool_true : atsbool_false) ;
} // end of [atspre_isdigit_int]
#define atspre_isdigit_char(c) atspre_isdigit_int((atstype_int)(c))
ATSinline()
atstype_bool
atspre_isxdigit_int
  (atstype_int c) {
  return (isxdigit(c) ? atsbool_true : atsbool_false) ;
} // end of [atspre_isxdigit_int]
#define atspre_isxdigit_char(c) atspre_isxdigit_int((atstype_int)(c))

ATSinline()
atstype_bool
atspre_isgraph_int
  (atstype_int c) {
  return (isgraph(c) ? atsbool_true : atsbool_false) ;
} // end of [atspre_isgraph_int]
#define atspre_isgraph_char(c) atspre_isgraph_int((atstype_int)(c))
ATSinline()
atstype_bool
atspre_isprint_int
  (atstype_int c) {
  return (isprint(c) ? atsbool_true : atsbool_false) ;
} // end of [atspre_isprint_int]
#define atspre_isprint_char(c) atspre_isprint_int((atstype_int)(c))
ATSinline()
atstype_bool
atspre_ispunct_int
  (atstype_int c) {
  return (ispunct(c) ? atsbool_true : atsbool_false) ;
} // end of [atspre_ispunct_int]
#define atspre_ispunct_char(c) atspre_ispunct_int((atstype_int)(c))

ATSinline()
atstype_bool
atspre_islower_int
  (atstype_int c) {
  return (islower(c) ? atsbool_true : atsbool_false) ;
} // end of [atspre_islower_int]
#define atspre_islower_char(c) atspre_islower_int((atstype_int)(c))
ATSinline()
atstype_bool
atspre_isupper_int
  (atstype_int c) {
  return (isupper(c) ? atsbool_true : atsbool_false) ;
} // end of [atspre_isupper_int]
#define atspre_isupper_char(c) atspre_isupper_int((atstype_int)(c))

/* ****** ****** */

#define atspre_toascii toascii

/* ****** ****** */

ATSinline()
atstype_int
atspre_tolower_int
  (atstype_int c) { return tolower(c) ; }
ATSinline()
atstype_char
atspre_tolower_char
  (atstype_char c) { return tolower(c) ; }
//
ATSinline()
atstype_int
atspre_toupper_int
  (atstype_int c) { return toupper(c) ; }
ATSinline()
atstype_char
atspre_toupper_char
  (atstype_char c) { return toupper(c) ; }
//
/* ****** ****** */

ATSinline()
atstype_char
atspre_int2digit
  (atstype_int i) { return ('0' + i) ; }
// end of [atspre_int2digit]
ATSinline()
atstype_char
atspre_int2xdigit
  (atstype_int i) {
  return (i < 10) ? ('0' + i) : ('a' + (i - 10)) ;
} // end of [atspre_int2xdigit]
ATSinline()
atstype_char
atspre_int2xxdigit
  (atstype_int i) {
  return (i < 10) ? ('0' + i) : ('A' + (i - 10)) ;
} // end of [atspre_int2xxdigit]

/* ****** ****** */

ATSinline()
atstype_int
atspre_byte2int (atstype_byte b) { return ((atstype_int)b) ; }
ATSinline()
atstype_byte
atspre_int2byte (atstype_int i) { return ((atstype_byte)i) ; }

ATSinline()
atstype_uint
atspre_byte2uint (atstype_byte b) { return ((atstype_uint)b) ; }
ATSinline()
atstype_byte
atspre_uint2byte (atstype_uint u) { return ((atstype_byte)u) ; }

/* ****** ****** */

#define atspre_byte2int0 atspre_byte2int
#define atspre_int2byte0 atspre_int2byte
#define atspre_byte2uint0 atspre_byte2uint
#define atspre_uint2byte0 atspre_uint2byte

/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_CHAR

/* ****** ****** */

/* end of [char.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/memory.atxt
** Time of generation: Sat Oct 17 15:20:02 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: January, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_MEMORY
#define ATSLIB_PRELUDE_CATS_MEMORY

/* ****** ****** */

#define atspre_minit_gc ATS_MINIT

/* ****** ****** */

#define atspre_mfree_gc ATS_MFREE

/* ****** ****** */

#define atspre_malloc_gc ATS_MALLOC

/* ****** ****** */

#define atspre_calloc_gc ATS_CALLOC
#define atspre_realloc_gc ATS_REALLOC

/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_MEMORY

/* ****** ****** */

/* end of [memory.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/bool.atxt
** Time of generation: Sat Oct 17 15:20:01 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2012 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_BOOL
#define ATSLIB_PRELUDE_CATS_BOOL

/* ****** ****** */

ATSinline()
atstype_bool
atspre_int2bool (atstype_int x)
{
  return (x != 0 ? atsbool_true : atsbool_false) ;
}
#define atspre_int2bool0 atspre_int2bool
#define atspre_int2bool1 atspre_int2bool

/* ****** ****** */

#define atspre_bool2int0(x) x
#define atspre_bool2int1(x) x

/* ****** ****** */

ATSinline()
atstype_bool
atspre_neg_bool
  (atstype_bool b) {
  return (b) ? atsbool_false : atsbool_true ;
} // end of [atspre_neg_bool]
#define atspre_neg_bool0 atspre_neg_bool
#define atspre_neg_bool1 atspre_neg_bool

ATSinline()
atstype_bool
atspre_add_bool_bool (
  atstype_bool b1, atstype_bool b2
) {
  return (b1) ? atsbool_true : (b2) ;
} // end of [atspre_add_bool_bool]
#define atspre_add_bool0_bool0 atspre_add_bool_bool
#define atspre_add_bool1_bool1 atspre_add_bool_bool

ATSinline()
atstype_bool
atspre_mul_bool_bool (
  atstype_bool b1, atstype_bool b2
) {
  return (b1) ? (b2) : atsbool_false ;
} // end of [atspre_mul_bool_bool]
#define atspre_mul_bool0_bool0 atspre_mul_bool_bool
#define atspre_mul_bool1_bool1 atspre_mul_bool_bool

/* ****** ****** */

ATSinline()
atstype_bool
atspre_xor_bool_bool (
  atstype_bool b1, atstype_bool b2
) {
  return (b1) ? (!b2) : (b2) ;
} // end of [atspre_xor_bool_bool]
#define atspre_xor_bool0_bool0 atspre_xor_bool_bool
#define atspre_xor_bool1_bool1 atspre_xor_bool_bool

/* ****** ****** */

ATSinline()
atstype_bool
atspre_lt_bool_bool (
  atstype_bool b1, atstype_bool b2
) {
  return (b1) ? atsbool_false : (b2) ;
} // end of [atspre_lt_bool_bool]
#define atspre_lt_bool0_bool0 atspre_lt_bool_bool
#define atspre_lt_bool1_bool1 atspre_lt_bool_bool
ATSinline()
atstype_bool
atspre_lte_bool_bool (
  atstype_bool b1, atstype_bool b2
) {
  return (b1) ? (b2) : atsbool_true ;
} // end of [atspre_lte_bool_bool]
#define atspre_lte_bool0_bool0 atspre_lte_bool_bool
#define atspre_lte_bool1_bool1 atspre_lte_bool_bool

ATSinline()
atstype_bool
atspre_gt_bool_bool (
  atstype_bool b1, atstype_bool b2
) {
  return (b2) ? atsbool_false : (b1) ;
} // end of [atspre_gt_bool_bool]
#define atspre_gt_bool0_bool0 atspre_gt_bool_bool
#define atspre_gt_bool1_bool1 atspre_gt_bool_bool
ATSinline()
atstype_bool
atspre_gte_bool_bool (
  atstype_bool b1, atstype_bool b2
) {
  return (b2) ? (b1) : atsbool_true ;
} // end of [atspre_gte_bool_bool]
#define atspre_gte_bool0_bool0 atspre_gte_bool_bool
#define atspre_gte_bool1_bool1 atspre_gte_bool_bool

ATSinline()
atstype_bool
atspre_eq_bool_bool (
  atstype_bool b1, atstype_bool b2
) {
  return (b1 == b2) ;
} // end of [atspre_eq_bool_bool]
#define atspre_eq_bool0_bool0 atspre_eq_bool_bool
#define atspre_eq_bool1_bool1 atspre_eq_bool_bool
ATSinline()
atstype_bool
atspre_neq_bool_bool (
  atstype_bool b1, atstype_bool b2
) {
  return (b1 != b2) ;
} // end of [atspre_neq_bool_bool]
#define atspre_neq_bool0_bool0 atspre_neq_bool_bool
#define atspre_neq_bool1_bool1 atspre_neq_bool_bool

/* ****** ****** */

ATSinline()
atstype_int
atspre_compare_bool_bool (
  atstype_bool b1, atstype_bool b2
) {
  return (b1 - b2) ;
} // end of [atspre_compare_bool_bool]
#define atspre_compare_bool0_bool0 atspre_compare_bool_bool
#define atspre_compare_bool1_bool1 atspre_compare_bool_bool

/* ****** ****** */

ATSinline()
atstype_string
atspre_bool2string (
  atstype_bool x
) {
  return (x) ? "true" : "false" ;
} // end of [atspre_bool2string]

/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_BOOL

/* ****** ****** */

/* end of [bool.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/integer_ptr.atxt
** Time of generation: Sat Oct 17 15:20:02 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: January, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_INTEGER_PTR
#define ATSLIB_PRELUDE_CATS_INTEGER_PTR

/* ****** ****** */

#include <stdint.h>

/* ****** ****** */

typedef intptr_t atstype_intptr ;
typedef uintptr_t atstype_uintptr ;

/* ****** ****** */
//
#define atspre_g0int2int_int_intptr(x) ((atstype_intptr)(x))
#define atspre_g0int2int_lint_intptr(x) ((atstype_intptr)(x))
//
#define atspre_g0int2uint_int_uintptr(x) ((atstype_uintptr)(x))
//
#define atspre_g0uint2uint_uint_uintptr(x) ((atstype_uintptr)(x))
#define atspre_g0uint2uint_ulint_uintptr(x) ((atstype_uintptr)(x))
//
/* ****** ****** */
//
#define atspre_g1int2int_int_intptr atspre_g0int2int_int_intptr
#define atspre_g1int2int_lint_intptr atspre_g0int2int_lint_intptr
//
#define atspre_g1int2uint_int_uintptr atspre_g0int2uint_int_uintptr
//
#define atspre_g1uint2uint_uint_uintptr atspre_g0uint2uint_uint_uintptr
#define atspre_g1uint2uint_ulint_uintptr atspre_g0uint2uint_ulint_uintptr
//
/* ****** ****** */

ATSinline()
atstype_intptr
atspre_g0int_neg_intptr
  (atstype_intptr x) { return (-x) ; }
// end of [atspre_g0int_neg_intptr]
ATSinline()
atstype_intptr
atspre_g0int_succ_intptr
  (atstype_intptr x) { return (x + 1) ; }
// end of [atspre_g0int_succ_intptr]
ATSinline()
atstype_intptr
atspre_g0int_pred_intptr
  (atstype_intptr x) { return (x - 1) ; }
// end of [atspre_g0int_pred_intptr]
ATSinline()
atstype_intptr
atspre_g0int_half_intptr
  (atstype_intptr x) { return (x / 2) ; }
// end of [atspre_g0int_half_intptr]
ATSinline()
atstype_intptr
atspre_g0int_add_intptr
  (atstype_intptr x1, atstype_intptr x2) { return (x1 + x2) ; }
// end of [atspre_g0int_add_intptr]
ATSinline()
atstype_intptr
atspre_g0int_sub_intptr
  (atstype_intptr x1, atstype_intptr x2) { return (x1 - x2) ; }
// end of [atspre_g0int_sub_intptr]
ATSinline()
atstype_intptr
atspre_g0int_mul_intptr
  (atstype_intptr x1, atstype_intptr x2) { return (x1 * x2) ; }
// end of [atspre_g0int_mul_intptr]
ATSinline()
atstype_intptr
atspre_g0int_div_intptr
  (atstype_intptr x1, atstype_intptr x2) { return (x1 / x2) ; }
// end of [atspre_g0int_div_intptr]
ATSinline()
atstype_intptr
atspre_g0int_mod_intptr
  (atstype_intptr x1, atstype_intptr x2) { return (x1 % x2) ; }
// end of [atspre_g0int_mod_intptr]
ATSinline()
atstype_bool
atspre_g0int_isltz_intptr (atstype_intptr x)
{
  return (x < 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isltz_intptr]
ATSinline()
atstype_bool
atspre_g0int_isltez_intptr (atstype_intptr x)
{
  return (x <= 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isltez_intptr]
ATSinline()
atstype_bool
atspre_g0int_isgtz_intptr (atstype_intptr x)
{
  return (x > 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isgtz_intptr]
ATSinline()
atstype_bool
atspre_g0int_isgtez_intptr (atstype_intptr x)
{
  return (x >= 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isgtez_intptr]
ATSinline()
atstype_bool
atspre_g0int_iseqz_intptr (atstype_intptr x)
{
  return (x == 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_iseqz_intptr]
ATSinline()
atstype_bool
atspre_g0int_isneqz_intptr (atstype_intptr x)
{
  return (x != 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isneqz_intptr]
ATSinline()
atstype_bool
atspre_g0int_lt_intptr
(
  atstype_intptr x1, atstype_intptr x2
) {
  return (x1 < x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_lt_intptr]
ATSinline()
atstype_bool
atspre_g0int_lte_intptr
(
  atstype_intptr x1, atstype_intptr x2
) {
  return (x1 <= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_lte_intptr]
ATSinline()
atstype_bool
atspre_g0int_gt_intptr
(
  atstype_intptr x1, atstype_intptr x2
) {
  return (x1 > x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_gt_intptr]
ATSinline()
atstype_bool
atspre_g0int_gte_intptr
(
  atstype_intptr x1, atstype_intptr x2
) {
  return (x1 >= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_gte_intptr]
ATSinline()
atstype_bool
atspre_g0int_eq_intptr
(
  atstype_intptr x1, atstype_intptr x2
) {
  return (x1 == x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_eq_intptr]
ATSinline()
atstype_bool
atspre_g0int_neq_intptr
(
  atstype_intptr x1, atstype_intptr x2
) {
  return (x1 != x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_neq_intptr]
//
/* ****** ****** */

ATSinline()
atstype_uintptr
atspre_g0uint_succ_uintptr
  (atstype_uintptr x) { return (x + 1) ; }
// end of [atspre_g0uint_succ_uintptr]
ATSinline()
atstype_uintptr
atspre_g0uint_pred_uintptr
  (atstype_uintptr x) { return (x - 1) ; }
// end of [atspre_g0uint_pred_uintptr]
ATSinline()
atstype_uintptr
atspre_g0uint_half_uintptr
  (atstype_uintptr x) { return (x >> 1) ; }
// end of [atspre_g0uint_pred_uintptr]
ATSinline()
atstype_uintptr
atspre_g0uint_add_uintptr
  (atstype_uintptr x1, atstype_uintptr x2) { return (x1 + x2) ; }
// end of [atspre_g0uint_add_uintptr]
ATSinline()
atstype_uintptr
atspre_g0uint_sub_uintptr
  (atstype_uintptr x1, atstype_uintptr x2) { return (x1 - x2) ; }
// end of [atspre_g0uint_sub_uintptr]
ATSinline()
atstype_uintptr
atspre_g0uint_mul_uintptr
  (atstype_uintptr x1, atstype_uintptr x2) { return (x1 * x2) ; }
// end of [atspre_g0uint_mul_uintptr]
ATSinline()
atstype_uintptr
atspre_g0uint_div_uintptr
  (atstype_uintptr x1, atstype_uintptr x2) { return (x1 / x2) ; }
// end of [atspre_g0uint_div_uintptr]
ATSinline()
atstype_uintptr
atspre_g0uint_mod_uintptr
  (atstype_uintptr x1, atstype_uintptr x2) { return (x1 % x2) ; }
// end of [atspre_g0uint_mod_uintptr]
ATSinline()
atstype_uintptr
atspre_g0uint_lsl_uintptr
  (atstype_uintptr x, atstype_int n) { return (x << n) ; }
// end of [atspre_g0uint_lsl_uintptr]
ATSinline()
atstype_uintptr
atspre_g0uint_lsr_uintptr
  (atstype_uintptr x, atstype_int n) { return (x >> n) ; }
// end of [atspre_g0uint_lsr_uintptr]
ATSinline()
atstype_uintptr
atspre_g0uint_lnot_uintptr
  (atstype_uintptr x) { return ~(x) ; }
// end of [atspre_g0uint_lnot_uintptr]
ATSinline()
atstype_uintptr
atspre_g0uint_lor_uintptr
  (atstype_uintptr x, atstype_uintptr y) { return (x | y) ; }
// end of [atspre_g0uint_uintptr_uintptr]
ATSinline()
atstype_uintptr
atspre_g0uint_land_uintptr
  (atstype_uintptr x, atstype_uintptr y) { return (x & y) ; }
// end of [atspre_g0uint_uintptr_uintptr]
ATSinline()
atstype_uintptr
atspre_g0uint_lxor_uintptr
  (atstype_uintptr x, atstype_uintptr y) { return (x ^ y) ; }
// end of [atspre_g0uint_uintptr_uintptr]
ATSinline()
atstype_bool
atspre_g0uint_isgtz_uintptr (atstype_uintptr x)
{
  return (x > 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_isgtz_uintptr]
ATSinline()
atstype_bool
atspre_g0uint_iseqz_uintptr (atstype_uintptr x)
{
  return (x == 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_iseqz_uintptr]
ATSinline()
atstype_bool
atspre_g0uint_isneqz_uintptr (atstype_uintptr x)
{
  return (x != 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_isneqz_uintptr]
ATSinline()
atstype_bool
atspre_g0uint_lt_uintptr
(
  atstype_uintptr x1, atstype_uintptr x2
) {
  return (x1 < x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_lt_uintptr]
ATSinline()
atstype_bool
atspre_g0uint_lte_uintptr
(
  atstype_uintptr x1, atstype_uintptr x2
) {
  return (x1 <= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_lte_uintptr]
ATSinline()
atstype_bool
atspre_g0uint_gt_uintptr
(
  atstype_uintptr x1, atstype_uintptr x2
) {
  return (x1 > x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_gt_uintptr]
ATSinline()
atstype_bool
atspre_g0uint_gte_uintptr
(
  atstype_uintptr x1, atstype_uintptr x2
) {
  return (x1 >= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_gte_uintptr]
ATSinline()
atstype_bool
atspre_g0uint_eq_uintptr
(
  atstype_uintptr x1, atstype_uintptr x2
) {
  return (x1 == x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_eq_uintptr]
ATSinline()
atstype_bool
atspre_g0uint_neq_uintptr
(
  atstype_uintptr x1, atstype_uintptr x2
) {
  return (x1 != x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_neq_uintptr]
//
/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_INTEGER_PTR

/* ****** ****** */

/* end of [integer_ptr.cats] */

/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/matrixptr.atxt
** Time of generation: Sat Oct 17 15:20:04 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: January, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_MATRIXPTR
#define ATSLIB_PRELUDE_CATS_MATRIXPTR

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_matrixptr_free
  (atstype_arrptr ptr) { ATS_MFREE (ptr) ; return ; }
// end of [atspre_matrixptr_free]

/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_MATRIXPTR

/* ****** ****** */

/* end of [matrixptr.cats] */

/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/fprintf.atxt
** Time of generation: Sat Oct 17 15:20:03 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: September, 2015 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_FPRINTF
#define ATSLIB_PRELUDE_CATS_FPRINTF

/* ****** ****** */
//
// HX-2013-09: declared in [stdio.h]
//
#ifndef fprintf
extern
int fprintf (FILE *stream, const char *format, ...) ;
#endif // end of [ifndef]
//
/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_fprint_bool (
  atstype_ref out, atstype_bool x
) {
  int err = 0 ;
  err += fprintf((FILE*)out, "%s", atspre_bool2string(x)) ;
/*
  if (err < 0) {
    fprintf(stderr, "exit(ATS): [fprint_bool] failed.") ; exit(1) ;
  } // end of [if]
*/
  return ;
} // end [atspre_fprint_bool]
#define atspre_print_bool(x) atspre_fprint_bool(stdout, (x))
#define atspre_prerr_bool(x) atspre_fprint_bool(stderr, (x))

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_fprint_char
(
  atstype_ref out, atstype_char c
) {
  int err = 0 ;
  err += fprintf ((FILE*)out, "%c", c) ;
/*
  if (err < 0) {
    fprintf(stderr, "exit(ATS): [fprint_char] failed.") ; exit(1) ;
  } // end of [if]
*/
  return ;
} // end of [atspre_fprint_char]
#define atspre_print_char(c) atspre_fprint_char(stdout, (c))
#define atspre_prerr_char(c) atspre_fprint_char(stderr, (c))

ATSinline()
atsvoid_t0ype
atspre_fprint_uchar
(
  atstype_ref out, atstype_uchar c
) {
  atspre_fprint_char (out, (atstype_char)c) ; return ;
} // end of [atspre_fprint_uchar]
#define atspre_print_uchar(c) atspre_fprint_uchar(stdout, (c))
#define atspre_prerr_uchar(c) atspre_fprint_uchar(stderr, (c))

ATSinline()
atsvoid_t0ype
atspre_fprint_schar
(
  atstype_ref out, atstype_schar c
) {
  atspre_fprint_char (out, (atstype_char)c) ; return ;
} // end of [atspre_fprint_schar]
#define atspre_print_schar(c) atspre_fprint_schar(stdout, (c))
#define atspre_prerr_schar(c) atspre_fprint_schar(stderr, (c))

/* ****** ****** */
  
ATSinline()
atsvoid_t0ype
atspre_fprint_int
(
  atstype_ref out, atstype_int x
) {
  int err = 0 ;
  err += fprintf((FILE*)out, "%i", x) ;
/*
  if (err < 0) {
    fprintf(stderr, "exit(ATS): [fprint_int] failed.") ; exit(1) ;
  } // end of [if]
*/
  return ;
} // end [atspre_fprint_int]
#define atspre_print_int(x) atspre_fprint_int(stdout, (x))
#define atspre_prerr_int(x) atspre_fprint_int(stderr, (x))

ATSinline()
atsvoid_t0ype
atspre_fprint_lint
(
  atstype_ref out, atstype_lint x
) {
  int err = 0 ;
  err += fprintf((FILE*)out, "%li", x) ;
/*
  if (err < 0) {
    fprintf(stderr, "exit(ATS): [fprint_lint] failed.") ; exit(1) ;
  } // end of [if]
*/
  return ;
} // end [atspre_fprint_lint]
#define atspre_print_lint(x) atspre_fprint_lint(stdout, (x))
#define atspre_prerr_lint(x) atspre_fprint_lint(stderr, (x))

ATSinline()
atsvoid_t0ype
atspre_fprint_llint
(
  atstype_ref out, atstype_llint x
) {
  int err = 0 ;
  err += fprintf((FILE*)out, "%lli", x) ;
/*
  if (err < 0) {
    fprintf(stderr, "exit(ATS): [fprint_llint] failed.") ; exit(1) ;
  } // end of [if]
*/
  return ;
} // end [atspre_fprint_llint]
#define atspre_print_llint(x) atspre_fprint_llint(stdout, (x))
#define atspre_prerr_llint(x) atspre_fprint_llint(stderr, (x))

ATSinline()
atsvoid_t0ype
atspre_fprint_ssize
(
  atstype_ref out, atstype_ssize x
) {
  int err = 0 ;
  err += fprintf((FILE*)out, "%li", x) ;
/*
  if (err < 0) {
    fprintf(stderr, "exit(ATS): [fprint_ssize] failed.") ; exit(1) ;
  } // end of [if]
*/
  return ;
} // end [atspre_fprint_ssize]
#define atspre_print_ssize(x) atspre_fprint_ssize(stdout, (x))
#define atspre_prerr_ssize(x) atspre_fprint_ssize(stderr, (x))

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_fprint_uint
(
  atstype_ref out, atstype_uint x
) {
  int err = 0 ;
  err += fprintf((FILE*)out, "%u", x) ;
/*
  if (err < 0) {
    fprintf(stderr, "exit(ATS): [fprint_uint] failed.") ; exit(1) ;
  } // end of [if]
*/
  return ;
} // end [atspre_fprint_uint]
#define atspre_print_uint(x) atspre_fprint_uint(stdout, (x))
#define atspre_prerr_uint(x) atspre_fprint_uint(stderr, (x))

ATSinline()
atsvoid_t0ype
atspre_fprint_ulint
(
  atstype_ref out, atstype_ulint x
) {
  int err = 0 ;
  err += fprintf((FILE*)out, "%lu", x) ;
/*
  if (err < 0) {
    fprintf(stderr, "exit(ATS): [fprint_ulint] failed.") ; exit(1) ;
  } // end of [if]
*/
  return ;
} // end [atspre_fprint_ulint]
#define atspre_print_ulint(x) atspre_fprint_ulint(stdout, (x))
#define atspre_prerr_ulint(x) atspre_fprint_ulint(stderr, (x))

ATSinline()
atsvoid_t0ype
atspre_fprint_ullint
(
  atstype_ref out, atstype_ullint x
) {
  int err = 0 ;
  err += fprintf((FILE*)out, "%llu", x) ;
/*
  if (err < 0) {
    fprintf(stderr, "exit(ATS): [fprint_ullint] failed.") ; exit(1) ;
  } // end of [if]
*/
  return ;
} // end [atspre_fprint_ullint]
#define atspre_print_ullint(x) atspre_fprint_ullint(stdout, (x))
#define atspre_prerr_ullint(x) atspre_fprint_ullint(stderr, (x))

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_fprint_size
(
  atstype_ref out, atstype_size x
) {
  int err = 0 ;
  atstype_ulint x2 = x ;
  err += fprintf((FILE*)out, "%lu", x2) ;
/*
  if (err < 0) {
    fprintf(stderr, "exit(ATS): [fprint_size] failed.") ; exit(1) ;
  } // end of [if]
*/
  return ;
} // end [atspre_fprint_size]
#define atspre_print_size(x) atspre_fprint_size(stdout, (x))
#define atspre_prerr_size(x) atspre_fprint_size(stderr, (x))

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_fprint_ptr (
  atstype_ref out, atstype_ptr x
) {
  int err ;
  err = fprintf((FILE*)out, "%p", x) ;
  return ;
} // end [atspre_fprint_ptr]
#define atspre_print_ptr(x) atspre_fprint_ptr(stdout, (x))
#define atspre_prerr_ptr(x) atspre_fprint_ptr(stderr, (x))

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_fprint_float (
  atstype_ref r, atstype_float x
) {
  int err = 0 ;
  err += fprintf((FILE*)r, "%f", x) ;
/*
  if (err < 0) {
    fprintf(stderr, "exit(ATS): [fprint_float] failed.") ; exit(1) ;
  } // end of [if]
*/
  return ;
} // end [atspre_fprint_float]
#define atspre_print_float(x) atspre_fprint_float(stdout, (x))
#define atspre_prerr_float(x) atspre_fprint_float(stderr, (x))

ATSinline()
atsvoid_t0ype
atspre_fprint_double (
  atstype_ref r, atstype_double x
) {
  int err = 0 ;
  err += fprintf((FILE*)r, "%f", x) ;
/*
  if (err < 0) {
    fprintf(stderr, "exit(ATS): [fprint_double] failed.") ; exit(1) ;
  } // end of [if]
*/
  return ;
} // end [atspre_fprint_double]
#define atspre_print_double(x) atspre_fprint_double(stdout, (x))
#define atspre_prerr_double(x) atspre_fprint_double(stderr, (x))

ATSinline()
atsvoid_t0ype
atspre_fprint_ldouble (
  atstype_ref r, atstype_ldouble x
) {
  int err = 0 ;
  err += fprintf((FILE*)r, "%Lf", x) ;
/*
  if (err < 0) {
    fprintf(stderr, "exit(ATS): [fprint_ldouble] failed.") ; exit(1) ;
  } // end of [if]
*/
  return ;
} // end [atspre_fprint_ldouble]
#define atspre_print_ldouble(x) atspre_fprint_ldouble(stdout, (x))
#define atspre_prerr_ldouble(x) atspre_fprint_ldouble(stderr, (x))

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_fprint_intptr
(
  atstype_ref r, atstype_intptr x
) {
  int err ;
  err = fprintf((FILE*)r, "%lli", (atstype_llint)x) ;
  return ;
} // end [atspre_fprint_intptr]
#define atspre_print_intptr(x) atspre_fprint_intptr(stdout, (x))
#define atspre_prerr_intptr(x) atspre_fprint_intptr(stderr, (x))

ATSinline()
atsvoid_t0ype
atspre_fprint_uintptr
(
  atstype_ref r, atstype_uintptr x
) {
  int err ;
  err = fprintf((FILE*)r, "%llu", (atstype_ullint)x) ;
  return ;
} // end [atspre_fprint_uintptr]
#define atspre_print_uintptr(x) atspre_fprint_uintptr(stdout, (x))
#define atspre_prerr_uintptr(x) atspre_fprint_uintptr(stderr, (x))

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_fprint_int8
(
  atstype_ref r, atstype_int8 x
) {
  int err ;
  err = fprintf((FILE*)r, "%i", (atstype_int)x) ;
  return ;
} // end [atspre_fprint_int8]
#define atspre_print_int8(x) atspre_fprint_int8(stdout, (x))
#define atspre_prerr_int8(x) atspre_fprint_int8(stderr, (x))

ATSinline()
atsvoid_t0ype
atspre_fprint_int16
(
  atstype_ref r, atstype_int16 x
) {
  int err ;
  err = fprintf((FILE*)r, "%i", (atstype_int)x) ;
  return ;
} // end [atspre_fprint_int16]
#define atspre_print_int16(x) atspre_fprint_int16(stdout, (x))
#define atspre_prerr_int16(x) atspre_fprint_int16(stderr, (x))

ATSinline()
atsvoid_t0ype
atspre_fprint_int32
(
  atstype_ref r, atstype_int32 x
) {
  int err ;
  err = fprintf((FILE*)r, "%li", (atstype_lint)x) ;
  return ;
} // end [atspre_fprint_int32]
#define atspre_print_int32(x) atspre_fprint_int32(stdout, (x))
#define atspre_prerr_int32(x) atspre_fprint_int32(stderr, (x))

ATSinline()
atsvoid_t0ype
atspre_fprint_int64
(
  atstype_ref r, atstype_int64 x
) {
  int err ;
  err = fprintf((FILE*)r, "%lli", (atstype_llint)x) ;
  return ;
} // end [atspre_fprint_int64]
#define atspre_print_int64(x) atspre_fprint_int64(stdout, (x))
#define atspre_prerr_int64(x) atspre_fprint_int64(stderr, (x))

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_fprint_uint8
(
  atstype_ref r, atstype_uint8 x
) {
  int err ;
  err = fprintf((FILE*)r, "%u", (atstype_uint)x) ;
  return ;
} // end [atspre_fprint_uint8]
#define atspre_print_uint8(x) atspre_fprint_uint8(stdout, (x))
#define atspre_prerr_uint8(x) atspre_fprint_uint8(stderr, (x))

ATSinline()
atsvoid_t0ype
atspre_fprint_uint16
(
  atstype_ref r, atstype_uint16 x
) {
  int err ;
  err = fprintf((FILE*)r, "%u", (atstype_uint)x) ;
  return ;
} // end [atspre_fprint_uint16]
#define atspre_print_uint16(x) atspre_fprint_uint16(stdout, (x))
#define atspre_prerr_uint16(x) atspre_fprint_uint16(stderr, (x))

ATSinline()
atsvoid_t0ype
atspre_fprint_uint32
(
  atstype_ref r, atstype_uint32 x
) {
  int err ;
  err = fprintf((FILE*)r, "%lu", (atstype_ulint)x) ;
  return ;
} // end [atspre_fprint_uint32]
#define atspre_print_uint32(x) atspre_fprint_uint32(stdout, (x))
#define atspre_prerr_uint32(x) atspre_fprint_uint32(stderr, (x))

ATSinline()
atsvoid_t0ype
atspre_fprint_uint64
(
  atstype_ref r, atstype_uint64 x
) {
  int err ;
  err = fprintf((FILE*)r, "%llu", (atstype_ullint)x) ;
  return ;
} // end [atspre_fprint_uint64]
#define atspre_print_uint64(x) atspre_fprint_uint64(stdout, (x))
#define atspre_prerr_uint64(x) atspre_fprint_uint64(stderr, (x))

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_fprint_string
(
  atstype_ref out, atstype_string x
) {
  int err = 0 ;
  err += fprintf((FILE*)out, "%s", (char*)x) ;
/*
  if (err < 0) {
    fprintf(stderr, "exit(ATS): [fprint_string] failed.") ; exit(1) ;
  } // end of [if]
*/
  return ;
} // end of [atspre_fprint_string]
#define atspre_print_string(x) atspre_fprint_string(stdout, (x))
#define atspre_prerr_string(x) atspre_fprint_string(stderr, (x))

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_fprint_substring
(
  atstype_ref out
, atstype_string x
, atstype_size st, atstype_size ln  
) {
  int err = 0 ;
  err += fwrite(((char*)x)+st, 1, ln, out) ;
/*
  if (err < 0) {
    fprintf(stderr, "exit(ATS): [fprint_substring] failed.") ; exit(1) ;
  } // end of [if]
*/
  return ;
} // end of [atspre_fprint_substring]

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_fprint_stropt
(
  atstype_ref out, atstype_stropt x
) {
  int err = 0 ;
  if (!x)
  {
    err += fprintf((FILE*)out, "strnone()") ;
  } else {
    err += fprintf((FILE*)out, "strsome(%s)", (char*)x) ;
  }
/*
  if (err < 0) {
    fprintf(stderr, "exit(ATS): [fprint_stropt] failed.") ; exit(1) ;
  } // end of [if]
*/
  return ;
} // end of [atspre_fprint_stropt]
#define atspre_print_stropt(x) atspre_fprint_stropt(stdout, (x))
#define atspre_prerr_stropt(x) atspre_fprint_stropt(stderr, (x))

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_fprint_strptr
(
  atstype_ref out, atstype_strptr x
) {
  int err = 0 ;
  if (x != 0) {
    err += fprintf((FILE*)out, "%s", (char*)x) ;
  } else {
    err += fprintf((FILE*)out, "%s", "(strnull)") ;
  } // end of [if]
/*
  if (err < 0) {
    fprintf(stderr, "exit(ATS): [fprint_strptr] failed.") ; exit(1) ;
  } // end of [if]
*/
  return ;
} // end of [atspre_fprint_strptr]
#define atspre_print_strptr(x) atspre_fprint_strptr(stdout, (x))
#define atspre_prerr_strptr(x) atspre_fprint_strptr(stderr, (x))

/* ****** ****** */

#define atspre_fprint_strbuf atspre_fprint_strptr
#define atspre_print_strbuf(x) atspre_fprint_strbuf(stdout, (x))
#define atspre_prerr_strbuf(x) atspre_fprint_strbuf(stderr, (x))

/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_FPRINTF

/* ****** ****** */

/* end of [fprintf.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/arrayptr.atxt
** Time of generation: Sat Oct 17 15:20:04 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: January, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_ARRAYPTR
#define ATSLIB_PRELUDE_CATS_ARRAYPTR

/* ****** ****** */

ATSinline()
atstype_arrptr
atspre_arrpsz_get_ptrsize
(
  atstype_arrpsz psz, atstype_ref asz
) {
  *(size_t*)asz = psz.size ; return (psz.ptr) ;
} // en of [atspre_arrpsz_get_ptrsize]

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_arrayptr_free
  (atstype_arrptr p0) { ATS_MFREE (p0) ; return ; }
// end of [atspre_arrayptr_free]

/* ****** ****** */

ATSinline()
atstype_arrptr
atspre_arrayptr_make_arrpsz
  (atstype_arrpsz psz) { return (psz).ptr ; }
// end of [atspre_arrayptr_make_arrpsz]

/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_ARRAYPTR

/* ****** ****** */

/* end of [arrayptr.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/pointer.atxt
** Time of generation: Sat Oct 17 15:20:01 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2012 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_POINTER
#define ATSLIB_PRELUDE_CATS_POINTER

/* ****** ****** */

#ifndef memset
extern
void *memset(void *bufp, int c, size_t n) ;
#endif // #ifndef

/* ****** ****** */

ATSinline()
atstype_ptr
atspre_ptr_null () { return (void*)0 ; }

/* ****** ****** */

ATSinline()
atstype_bool
atspre_ptr_is_null
  (atstype_ptr p) {
  return (p == (void*)0) ? atsbool_true : atsbool_false ;
} // end of [atspre_ptr_is_null]
#define atspre_ptr0_is_null atspre_ptr_is_null
#define atspre_ptr1_is_null atspre_ptr_is_null

ATSinline()
atstype_bool
atspre_ptr_isnot_null
  (atstype_ptr p) {
  return (p != (void*)0) ? atsbool_true : atsbool_false ;
} // end of [atspre_ptr_isnot_null]
#define atspre_ptr0_isnot_null atspre_ptr_isnot_null
#define atspre_ptr1_isnot_null atspre_ptr_isnot_null

/* ****** ****** */

ATSinline()
atstype_ptr
atspre_add_ptr_bsz
  (atstype_ptr p, atstype_size ofs) { return ((char*)p + ofs) ; }
// end of [atspre_add_ptr_bsz]
#define atspre_add_ptr0_bsz atspre_add_ptr_bsz
#define atspre_add_ptr1_bsz atspre_add_ptr_bsz

ATSinline()
atstype_ptr
atspre_sub_ptr_bsz
  (atstype_ptr p, atstype_size ofs) { return ((char*)p - ofs) ; }
// end of [atspre_sub_ptr_bsz]
#define atspre_sub_ptr0_bsz atspre_sub_ptr_bsz
#define atspre_sub_ptr1_bsz atspre_sub_ptr_bsz

/* ****** ****** */

ATSinline()
atstype_ssize
atspre_sub_ptr_ptr
  (atstype_ptr p1, atstype_ptr p2) { return ((char*)p1 - (char*)p2) ; }
// end of [atspre_sub_ptr_ptr]
#define atspre_sub_ptr0_ptr0 atspre_sub_ptr_ptr
#define atspre_sub_ptr1_ptr1 atspre_sub_ptr_ptr

/* ****** ****** */

ATSinline()
atstype_bool
atspre_lt_ptr_ptr
  (atstype_ptr p1, atstype_ptr p2) {
  return (p1 < p2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_lt_ptr_ptr]
#define atspre_lt_ptr0_ptr0 atspre_lt_ptr_ptr
#define atspre_lt_ptr1_ptr1 atspre_lt_ptr_ptr

ATSinline()
atstype_bool
atspre_lte_ptr_ptr
  (atstype_ptr p1, atstype_ptr p2) {
  return (p1 <= p2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_lte_ptr_ptr]
#define atspre_lte_ptr0_ptr0 atspre_lte_ptr_ptr
#define atspre_lte_ptr1_ptr1 atspre_lte_ptr_ptr

ATSinline()
atstype_bool
atspre_gt_ptr_ptr
  (atstype_ptr p1, atstype_ptr p2) {
  return (p1 > p2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_gt_ptr_ptr]
#define atspre_gt_ptr0_ptr0 atspre_gt_ptr_ptr
#define atspre_gt_ptr1_ptr1 atspre_gt_ptr_ptr

ATSinline()
atstype_bool
atspre_gte_ptr_ptr
  (atstype_ptr p1, atstype_ptr p2) {
  return (p1 >= p2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_gte_ptr_ptr]
#define atspre_gte_ptr0_ptr0 atspre_gte_ptr_ptr
#define atspre_gte_ptr1_ptr1 atspre_gte_ptr_ptr

ATSinline()
atstype_bool
atspre_eq_ptr_ptr
  (atstype_ptr p1, atstype_ptr p2) {
  return (p1 == p2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_eq_ptr_ptr]
#define atspre_eq_ptr0_ptr0 atspre_eq_ptr_ptr
#define atspre_eq_ptr1_ptr1 atspre_eq_ptr_ptr

ATSinline()
atstype_bool
atspre_neq_ptr_ptr
  (atstype_ptr p1, atstype_ptr p2) {
  return (p1 != p2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_neq_ptr_ptr]
#define atspre_neq_ptr0_ptr0 atspre_neq_ptr_ptr
#define atspre_neq_ptr1_ptr1 atspre_neq_ptr_ptr


ATSinline()
atstype_int
atspre_compare_ptr_ptr
(
  atstype_ptr p1, atstype_ptr p2
) {
  if (p1 >= p2) {
    if (p1 > p2) return 1 ; else return 0 ;
  } else return (-1) ;
} // end of [atspre_compare_ptr_ptr]
#define atspre_compare_ptr0_ptr0 atspre_compare_ptr_ptr
#define atspre_compare_ptr1_ptr1 atspre_compare_ptr_ptr

/* ****** ****** */

ATSinline()
atstype_bool
atspre_gt_ptr_intz
  (atstype_ptr p, atstype_int _)
{
  return (p > 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_gt_ptr_intz]
#define atspre_gt_ptr0_intz atspre_gt_ptr_intz
#define atspre_gt_ptr1_intz atspre_gt_ptr_intz

ATSinline()
atstype_bool
atspre_eq_ptr_intz
  (atstype_ptr p, atstype_int _)
{
  return (p == 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_eq_ptr_intz]
#define atspre_eq_ptr0_intz atspre_eq_ptr_intz
#define atspre_eq_ptr1_intz atspre_eq_ptr_intz

ATSinline()
atstype_bool
atspre_neq_ptr_intz
  (atstype_ptr p, atstype_int _)
{
  return (p != 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_neq_ptr_intz]
#define atspre_neq_ptr0_intz atspre_neq_ptr_intz
#define atspre_neq_ptr1_intz atspre_neq_ptr_intz

/* ****** ****** */
//
#define atspre_cptr_null() atsptr_null
//
#define atspre_cptr_is_null atspre_ptr_is_null
#define atspre_cptr_isnot_null atspre_ptr_isnot_null
//
/* ****** ****** */
//
#define atspre_ptr_free atspre_mfree_gc
#define atspre_ptr_alloc_tsz atspre_malloc_gc
//
/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_ptr_nullize_tsz
(
  atstype_ptr p, atstype_size tsz
) {
  memset (p, 0, tsz) ; return /*void*/ ;
} // end of [atspre_ptr_nullize_tsz]

/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_POINTER

/* ****** ****** */

/* end of [pointer.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/matrix.atxt
** Time of generation: Sat Oct 17 15:20:04 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: January, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_MATRIX
#define ATSLIB_PRELUDE_CATS_MATRIX

/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_MATRIX

/* ****** ****** */

/* end of [matrix.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/integer.atxt
** Time of generation: Sat Oct 17 15:20:01 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: January, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_INTEGER
#define ATSLIB_PRELUDE_CATS_INTEGER

/* ****** ****** */
//
#define atspre_g0int2int_int_int(x) ((atstype_int)(x))
#define atspre_g0int2int_int_lint(x) ((atstype_lint)(x))
#define atspre_g0int2int_int_llint(x) ((atstype_llint)(x))
#define atspre_g0int2int_int_ssize(x) ((atstype_ssize)(x))
#define atspre_g1int2int_int_int atspre_g0int2int_int_int
#define atspre_g1int2int_int_lint atspre_g0int2int_int_lint
#define atspre_g1int2int_int_llint atspre_g0int2int_int_llint
#define atspre_g1int2int_int_ssize atspre_g0int2int_int_ssize
//
#define atspre_g0int2int_lint_int(x) ((atstype_int)(x))
#define atspre_g0int2int_lint_lint(x) ((atstype_lint)(x))
#define atspre_g0int2int_lint_llint(x) ((atstype_llint)(x))
#define atspre_g0int2int_lint_ssize(x) ((atstype_ssize)(x))
#define atspre_g1int2int_lint_int atspre_g0int2int_lint_int
#define atspre_g1int2int_lint_lint atspre_g0int2int_lint_lint
#define atspre_g1int2int_lint_llint atspre_g0int2int_lint_llint
#define atspre_g1int2int_lint_ssize atspre_g0int2int_lint_ssize
//
#define atspre_g0int2int_ssize_int(x) ((atstype_int)(x))
#define atspre_g0int2int_ssize_lint(x) ((atstype_lint)(x))
#define atspre_g0int2int_ssize_llint(x) ((atstype_llint)(x))
#define atspre_g0int2int_ssize_ssize(x) ((atstype_ssize)(x))
#define atspre_g1int2int_ssize_int atspre_g0int2int_ssize_int
#define atspre_g1int2int_ssize_lint atspre_g0int2int_ssize_lint
#define atspre_g1int2int_ssize_llint atspre_g0int2int_ssize_llint
#define atspre_g1int2int_ssize_ssize atspre_g0int2int_ssize_ssize
//
/* ****** ****** */
//
#define atspre_g0int2int_sint_int(x) ((atstype_int)(x))
//
/* ****** ****** */
//
#define atspre_g0int2uint_int_uint(x) ((atstype_uint)(x))
#define atspre_g0int2uint_int_ulint(x) ((atstype_ulint)(x))
#define atspre_g0int2uint_int_ullint(x) ((atstype_ullint)(x))
#define atspre_g0int2uint_int_size(x) ((atstype_size)(x))
#define atspre_g1int2uint_int_uint atspre_g0int2uint_int_uint
#define atspre_g1int2uint_int_ulint atspre_g0int2uint_int_ulint
#define atspre_g1int2uint_int_ullint atspre_g0int2uint_int_ullint
#define atspre_g1int2uint_int_size atspre_g0int2uint_int_size
//
#define atspre_g0int2uint_lint_ulint(x) ((atstype_ulint)(x))
#define atspre_g0int2uint_lint_ullint(x) ((atstype_ullint)(x))
#define atspre_g0int2uint_lint_size(x) ((atstype_size)(x))
#define atspre_g1int2uint_lint_ulint atspre_g0int2uint_lint_ulint
#define atspre_g1int2uint_lint_ullint atspre_g0int2uint_lint_ullint
#define atspre_g1int2uint_lint_size atspre_g0int2uint_lint_size
//
#define atspre_g0int2uint_llint_ullint(x) ((atstype_ullint)(x))
#define atspre_g1int2uint_llint_ullint atspre_g0int2uint_llint_ullint
//
#define atspre_g0int2uint_ssize_size(x) ((atstype_size)(x))
#define atspre_g1int2uint_ssize_size atspre_g0int2uint_ssize_size
//
/* ****** ****** */
//
#define atspre_g0uint2int_uint_int(x) ((atstype_int)(x))
#define atspre_g0uint2int_uint_lint(x) ((atstype_lint)(x))
#define atspre_g0uint2int_uint_llint(x) ((atstype_llint)(x))
#define atspre_g0uint2int_uint_ssize(x) ((atstype_ssize)(x))
#define atspre_g1uint2int_uint_int atspre_g0uint2int_uint_int
#define atspre_g1uint2int_uint_lint atspre_g0uint2int_uint_lint
#define atspre_g1uint2int_uint_llint atspre_g0uint2int_uint_llint
#define atspre_g1uint2int_uint_ssize atspre_g0uint2int_uint_ssize
//
/* ****** ****** */
//
#define atspre_g0uint2int_size_int(x) ((atstype_int)(x))
#define atspre_g0uint2int_size_lint(x) ((atstype_lint)(x))
#define atspre_g0uint2int_size_llint(x) ((atstype_llint)(x))
#define atspre_g0uint2int_size_ssize(x) ((atstype_ssize)(x))
#define atspre_g1uint2int_size_int atspre_g0uint2int_size_int
#define atspre_g1uint2int_size_lint atspre_g0uint2int_size_lint
#define atspre_g1uint2int_size_llint atspre_g0uint2int_size_llint
#define atspre_g1uint2int_size_ssize atspre_g0uint2int_size_ssize
//
/* ****** ****** */
//
#define atspre_g0uint2uint_uint_uint(x) (x)
#define atspre_g0uint2uint_uint_ulint(x) ((atstype_ulint)(x))
#define atspre_g0uint2uint_uint_ullint(x) ((atstype_ullint)(x))
#define atspre_g0uint2uint_uint_size(x) ((atstype_size)(x))
#define atspre_g1uint2uint_uint_uint atspre_g0uint2uint_uint_uint
#define atspre_g1uint2uint_uint_ulint atspre_g0uint2uint_uint_ulint
#define atspre_g1uint2uint_uint_ullint atspre_g0uint2uint_uint_ullint
#define atspre_g1uint2uint_uint_size atspre_g0uint2uint_uint_size
//
/* ****** ****** */
//
#define atspre_g0uint2uint_ulint_uint(x) ((atstype_uint)(x))
#define atspre_g0uint2uint_ulint_ulint(x) (x)
#define atspre_g0uint2uint_ulint_ullint(x) ((atstype_ullint)(x))
#define atspre_g0uint2uint_ulint_size(x) ((atstype_size)(x))
#define atspre_g1uint2uint_ulint_uint atspre_g0uint2uint_ulint_uint
#define atspre_g1uint2uint_ulint_ulint atspre_g0uint2uint_ulint_ulint
#define atspre_g1uint2uint_ulint_ullint atspre_g0uint2uint_ulint_ullint
#define atspre_g1uint2uint_ulint_size atspre_g0uint2uint_ulint_size
//
/* ****** ****** */
//
#define atspre_g0uint2uint_size_uint(x) ((atstype_uint)(x))
#define atspre_g0uint2uint_size_ulint(x) ((atstype_ulint)(x))
#define atspre_g0uint2uint_size_ullint(x) ((atstype_ullint)(x))
#define atspre_g0uint2uint_size_size(x) (x)
#define atspre_g1uint2uint_size_uint atspre_g0uint2uint_size_uint
#define atspre_g1uint2uint_size_ulint atspre_g0uint2uint_size_ulint
#define atspre_g1uint2uint_size_ullint atspre_g0uint2uint_size_ullint
#define atspre_g1uint2uint_size_size atspre_g0uint2uint_size_size
//
/* ****** ****** */
//
#define atspre_g0uint2uint_usint_uint(x) ((atstype_uint)(x))
//
/* ****** ****** */
//
extern int atoi (const char *inp) ;
extern long int atol (const char *inp) ;
extern long long int atoll (const char *inp) ;
//
ATSinline()
atstype_int
atspre_g0string2int_int
  (atstype_string inp) { return atoi((char*)inp) ; }
ATSinline()
atstype_lint
atspre_g0string2int_lint
  (atstype_string inp) { return atol((char*)inp) ; }
ATSinline()
atstype_llint
atspre_g0string2int_llint
  (atstype_string inp) { return atoll((char*)inp) ; }
ATSinline()
atstype_ssize
atspre_g0string2int_ssize
  (atstype_string inp) { return atol((char*)inp) ; }
//
/* ****** ****** */
//
extern
unsigned long int
strtoul(const char *nptr, char **endptr, int base);
extern
unsigned long long int
strtoull(const char *nptr, char **endptr, int base);
//
ATSinline()
atstype_uint
atspre_g0string2uint_uint
  (atstype_string inp) { return strtoul((char*)inp, NULL, 10) ; }
ATSinline()
atstype_ulint
atspre_g0string2uint_ulint
  (atstype_string inp) { return strtoul((char*)inp, NULL, 10) ; }
ATSinline()
atstype_ullint
atspre_g0string2uint_ullint
  (atstype_string inp) { return strtoull((char*)inp, NULL, 10) ; }
ATSinline()
atstype_size
atspre_g0string2uint_size
  (atstype_string inp) { return strtoul((char*)inp, NULL, 10) ; }
//
/* ****** ****** */

ATSinline()
atstype_int
atspre_g0int_neg_int
  (atstype_int x) { return (-x) ; }
// end of [atspre_g0int_neg_int]
ATSinline()
atstype_int
atspre_g0int_abs_int
  (atstype_int x) { return (x >= 0 ? x : -x) ; }
// end of [atspre_g0int_abs_int]
ATSinline()
atstype_int
atspre_g0int_succ_int
  (atstype_int x) { return (x + 1) ; }
// end of [atspre_g0int_succ_int]
ATSinline()
atstype_int
atspre_g0int_pred_int
  (atstype_int x) { return (x - 1) ; }
// end of [atspre_g0int_pred_int]
ATSinline()
atstype_int
atspre_g0int_half_int
  (atstype_int x) { return (x / 2) ; }
// end of [atspre_g0int_half_int]
ATSinline()
atstype_int
atspre_g0int_add_int
  (atstype_int x1, atstype_int x2) { return (x1 + x2) ; }
// end of [atspre_g0int_add_int]
ATSinline()
atstype_int
atspre_g0int_sub_int
  (atstype_int x1, atstype_int x2) { return (x1 - x2) ; }
// end of [atspre_g0int_sub_int]
ATSinline()
atstype_int
atspre_g0int_mul_int
  (atstype_int x1, atstype_int x2) { return (x1 * x2) ; }
// end of [atspre_g0int_mul_int]
ATSinline()
atstype_int
atspre_g0int_div_int
  (atstype_int x1, atstype_int x2) { return (x1 / x2) ; }
// end of [atspre_g0int_div_int]
ATSinline()
atstype_int
atspre_g0int_mod_int
  (atstype_int x1, atstype_int x2) { return (x1 % x2) ; }
// end of [atspre_g0int_mod_int]
ATSinline()
atstype_int
atspre_g0int_nmod_int
  (atstype_int x1, atstype_int x2) { return (x1 % x2) ; }
// end of [atspre_g0int_nmod_int]
ATSinline()
atstype_int
atspre_g0int_asl_int
  (atstype_int x, atstype_int n) { return (x << n) ; }
// end of [atspre_g0int_asl_int]
ATSinline()
atstype_int
atspre_g0int_asr_int
  (atstype_int x, atstype_int n) { return (x >> n) ; }
// end of [atspre_g0int_asr_int]
ATSinline()
atstype_bool
atspre_g0int_isltz_int (atstype_int x)
{
  return (x < 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isltz_int]
ATSinline()
atstype_bool
atspre_g0int_isltez_int (atstype_int x)
{
  return (x <= 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isltez_int]
ATSinline()
atstype_bool
atspre_g0int_isgtz_int (atstype_int x)
{
  return (x > 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isgtz_int]
ATSinline()
atstype_bool
atspre_g0int_isgtez_int (atstype_int x)
{
  return (x >= 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isgtez_int]
ATSinline()
atstype_bool
atspre_g0int_iseqz_int (atstype_int x)
{
  return (x == 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_iseqz_int]
ATSinline()
atstype_bool
atspre_g0int_isneqz_int (atstype_int x)
{
  return (x != 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isneqz_int]
ATSinline()
atstype_bool
atspre_g0int_lt_int
(
  atstype_int x1, atstype_int x2
) {
  return (x1 < x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_lt_int]
ATSinline()
atstype_bool
atspre_g0int_lte_int
(
  atstype_int x1, atstype_int x2
) {
  return (x1 <= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_lte_int]
ATSinline()
atstype_bool
atspre_g0int_gt_int
(
  atstype_int x1, atstype_int x2
) {
  return (x1 > x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_gt_int]
ATSinline()
atstype_bool
atspre_g0int_gte_int
(
  atstype_int x1, atstype_int x2
) {
  return (x1 >= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_gte_int]
ATSinline()
atstype_bool
atspre_g0int_eq_int
(
  atstype_int x1, atstype_int x2
) {
  return (x1 == x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_eq_int]
ATSinline()
atstype_bool
atspre_g0int_neq_int
(
  atstype_int x1, atstype_int x2
) {
  return (x1 != x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_neq_int]
ATSinline()
atstype_int
atspre_g0int_compare_int
(
  atstype_int x1, atstype_int x2
) {
  if (x1 < x2) return -1 ; else if (x1 > x2) return 1 ; else return 0 ;
} // end of [atspre_g0int_compare_int]
ATSinline()
atstype_int
atspre_g0int_max_int
  (atstype_int x1, atstype_int x2) { return (x1 >= x2 ? x1 : x2) ; }
// end of [atspre_g0int_max_int]
ATSinline()
atstype_int
atspre_g0int_min_int
  (atstype_int x1, atstype_int x2) { return (x1 <= x2 ? x1 : x2) ; }
// end of [atspre_g0int_min_int]
//
ATSinline()
atstype_lint
atspre_g0int_neg_lint
  (atstype_lint x) { return (-x) ; }
// end of [atspre_g0int_neg_lint]
ATSinline()
atstype_lint
atspre_g0int_abs_lint
  (atstype_lint x) { return (x >= 0 ? x : -x) ; }
// end of [atspre_g0int_abs_lint]
ATSinline()
atstype_lint
atspre_g0int_succ_lint
  (atstype_lint x) { return (x + 1) ; }
// end of [atspre_g0int_succ_lint]
ATSinline()
atstype_lint
atspre_g0int_pred_lint
  (atstype_lint x) { return (x - 1) ; }
// end of [atspre_g0int_pred_lint]
ATSinline()
atstype_lint
atspre_g0int_half_lint
  (atstype_lint x) { return (x / 2) ; }
// end of [atspre_g0int_half_lint]
ATSinline()
atstype_lint
atspre_g0int_add_lint
  (atstype_lint x1, atstype_lint x2) { return (x1 + x2) ; }
// end of [atspre_g0int_add_lint]
ATSinline()
atstype_lint
atspre_g0int_sub_lint
  (atstype_lint x1, atstype_lint x2) { return (x1 - x2) ; }
// end of [atspre_g0int_sub_lint]
ATSinline()
atstype_lint
atspre_g0int_mul_lint
  (atstype_lint x1, atstype_lint x2) { return (x1 * x2) ; }
// end of [atspre_g0int_mul_lint]
ATSinline()
atstype_lint
atspre_g0int_div_lint
  (atstype_lint x1, atstype_lint x2) { return (x1 / x2) ; }
// end of [atspre_g0int_div_lint]
ATSinline()
atstype_lint
atspre_g0int_mod_lint
  (atstype_lint x1, atstype_lint x2) { return (x1 % x2) ; }
// end of [atspre_g0int_mod_lint]
ATSinline()
atstype_lint
atspre_g0int_nmod_lint
  (atstype_lint x1, atstype_lint x2) { return (x1 % x2) ; }
// end of [atspre_g0int_nmod_lint]
ATSinline()
atstype_lint
atspre_g0int_asl_lint
  (atstype_lint x, atstype_int n) { return (x << n) ; }
// end of [atspre_g0int_asl_lint]
ATSinline()
atstype_lint
atspre_g0int_asr_lint
  (atstype_lint x, atstype_int n) { return (x >> n) ; }
// end of [atspre_g0int_asr_lint]
ATSinline()
atstype_bool
atspre_g0int_isltz_lint (atstype_lint x)
{
  return (x < 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isltz_lint]
ATSinline()
atstype_bool
atspre_g0int_isltez_lint (atstype_lint x)
{
  return (x <= 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isltez_lint]
ATSinline()
atstype_bool
atspre_g0int_isgtz_lint (atstype_lint x)
{
  return (x > 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isgtz_lint]
ATSinline()
atstype_bool
atspre_g0int_isgtez_lint (atstype_lint x)
{
  return (x >= 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isgtez_lint]
ATSinline()
atstype_bool
atspre_g0int_iseqz_lint (atstype_lint x)
{
  return (x == 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_iseqz_lint]
ATSinline()
atstype_bool
atspre_g0int_isneqz_lint (atstype_lint x)
{
  return (x != 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isneqz_lint]
ATSinline()
atstype_bool
atspre_g0int_lt_lint
(
  atstype_lint x1, atstype_lint x2
) {
  return (x1 < x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_lt_lint]
ATSinline()
atstype_bool
atspre_g0int_lte_lint
(
  atstype_lint x1, atstype_lint x2
) {
  return (x1 <= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_lte_lint]
ATSinline()
atstype_bool
atspre_g0int_gt_lint
(
  atstype_lint x1, atstype_lint x2
) {
  return (x1 > x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_gt_lint]
ATSinline()
atstype_bool
atspre_g0int_gte_lint
(
  atstype_lint x1, atstype_lint x2
) {
  return (x1 >= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_gte_lint]
ATSinline()
atstype_bool
atspre_g0int_eq_lint
(
  atstype_lint x1, atstype_lint x2
) {
  return (x1 == x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_eq_lint]
ATSinline()
atstype_bool
atspre_g0int_neq_lint
(
  atstype_lint x1, atstype_lint x2
) {
  return (x1 != x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_neq_lint]
ATSinline()
atstype_int
atspre_g0int_compare_lint
(
  atstype_lint x1, atstype_lint x2
) {
  if (x1 < x2) return -1 ; else if (x1 > x2) return 1 ; else return 0 ;
} // end of [atspre_g0int_compare_lint]
ATSinline()
atstype_lint
atspre_g0int_max_lint
  (atstype_lint x1, atstype_lint x2) { return (x1 >= x2 ? x1 : x2) ; }
// end of [atspre_g0int_max_lint]
ATSinline()
atstype_lint
atspre_g0int_min_lint
  (atstype_lint x1, atstype_lint x2) { return (x1 <= x2 ? x1 : x2) ; }
// end of [atspre_g0int_min_lint]
//
ATSinline()
atstype_llint
atspre_g0int_neg_llint
  (atstype_llint x) { return (-x) ; }
// end of [atspre_g0int_neg_llint]
ATSinline()
atstype_llint
atspre_g0int_abs_llint
  (atstype_llint x) { return (x >= 0 ? x : -x) ; }
// end of [atspre_g0int_abs_llint]
ATSinline()
atstype_llint
atspre_g0int_succ_llint
  (atstype_llint x) { return (x + 1) ; }
// end of [atspre_g0int_succ_llint]
ATSinline()
atstype_llint
atspre_g0int_pred_llint
  (atstype_llint x) { return (x - 1) ; }
// end of [atspre_g0int_pred_llint]
ATSinline()
atstype_llint
atspre_g0int_half_llint
  (atstype_llint x) { return (x / 2) ; }
// end of [atspre_g0int_half_llint]
ATSinline()
atstype_llint
atspre_g0int_add_llint
  (atstype_llint x1, atstype_llint x2) { return (x1 + x2) ; }
// end of [atspre_g0int_add_llint]
ATSinline()
atstype_llint
atspre_g0int_sub_llint
  (atstype_llint x1, atstype_llint x2) { return (x1 - x2) ; }
// end of [atspre_g0int_sub_llint]
ATSinline()
atstype_llint
atspre_g0int_mul_llint
  (atstype_llint x1, atstype_llint x2) { return (x1 * x2) ; }
// end of [atspre_g0int_mul_llint]
ATSinline()
atstype_llint
atspre_g0int_div_llint
  (atstype_llint x1, atstype_llint x2) { return (x1 / x2) ; }
// end of [atspre_g0int_div_llint]
ATSinline()
atstype_llint
atspre_g0int_mod_llint
  (atstype_llint x1, atstype_llint x2) { return (x1 % x2) ; }
// end of [atspre_g0int_mod_llint]
ATSinline()
atstype_llint
atspre_g0int_nmod_llint
  (atstype_llint x1, atstype_llint x2) { return (x1 % x2) ; }
// end of [atspre_g0int_nmod_llint]
ATSinline()
atstype_llint
atspre_g0int_asl_llint
  (atstype_llint x, atstype_int n) { return (x << n) ; }
// end of [atspre_g0int_asl_llint]
ATSinline()
atstype_llint
atspre_g0int_asr_llint
  (atstype_llint x, atstype_int n) { return (x >> n) ; }
// end of [atspre_g0int_asr_llint]
ATSinline()
atstype_bool
atspre_g0int_isltz_llint (atstype_llint x)
{
  return (x < 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isltz_llint]
ATSinline()
atstype_bool
atspre_g0int_isltez_llint (atstype_llint x)
{
  return (x <= 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isltez_llint]
ATSinline()
atstype_bool
atspre_g0int_isgtz_llint (atstype_llint x)
{
  return (x > 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isgtz_llint]
ATSinline()
atstype_bool
atspre_g0int_isgtez_llint (atstype_llint x)
{
  return (x >= 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isgtez_llint]
ATSinline()
atstype_bool
atspre_g0int_iseqz_llint (atstype_llint x)
{
  return (x == 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_iseqz_llint]
ATSinline()
atstype_bool
atspre_g0int_isneqz_llint (atstype_llint x)
{
  return (x != 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isneqz_llint]
ATSinline()
atstype_bool
atspre_g0int_lt_llint
(
  atstype_llint x1, atstype_llint x2
) {
  return (x1 < x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_lt_llint]
ATSinline()
atstype_bool
atspre_g0int_lte_llint
(
  atstype_llint x1, atstype_llint x2
) {
  return (x1 <= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_lte_llint]
ATSinline()
atstype_bool
atspre_g0int_gt_llint
(
  atstype_llint x1, atstype_llint x2
) {
  return (x1 > x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_gt_llint]
ATSinline()
atstype_bool
atspre_g0int_gte_llint
(
  atstype_llint x1, atstype_llint x2
) {
  return (x1 >= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_gte_llint]
ATSinline()
atstype_bool
atspre_g0int_eq_llint
(
  atstype_llint x1, atstype_llint x2
) {
  return (x1 == x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_eq_llint]
ATSinline()
atstype_bool
atspre_g0int_neq_llint
(
  atstype_llint x1, atstype_llint x2
) {
  return (x1 != x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_neq_llint]
ATSinline()
atstype_int
atspre_g0int_compare_llint
(
  atstype_llint x1, atstype_llint x2
) {
  if (x1 < x2) return -1 ; else if (x1 > x2) return 1 ; else return 0 ;
} // end of [atspre_g0int_compare_llint]
ATSinline()
atstype_llint
atspre_g0int_max_llint
  (atstype_llint x1, atstype_llint x2) { return (x1 >= x2 ? x1 : x2) ; }
// end of [atspre_g0int_max_llint]
ATSinline()
atstype_llint
atspre_g0int_min_llint
  (atstype_llint x1, atstype_llint x2) { return (x1 <= x2 ? x1 : x2) ; }
// end of [atspre_g0int_min_llint]
//
ATSinline()
atstype_ssize
atspre_g0int_neg_ssize
  (atstype_ssize x) { return (-x) ; }
// end of [atspre_g0int_neg_ssize]
ATSinline()
atstype_ssize
atspre_g0int_abs_ssize
  (atstype_ssize x) { return (x >= 0 ? x : -x) ; }
// end of [atspre_g0int_abs_ssize]
ATSinline()
atstype_ssize
atspre_g0int_succ_ssize
  (atstype_ssize x) { return (x + 1) ; }
// end of [atspre_g0int_succ_ssize]
ATSinline()
atstype_ssize
atspre_g0int_pred_ssize
  (atstype_ssize x) { return (x - 1) ; }
// end of [atspre_g0int_pred_ssize]
ATSinline()
atstype_ssize
atspre_g0int_half_ssize
  (atstype_ssize x) { return (x / 2) ; }
// end of [atspre_g0int_half_ssize]
ATSinline()
atstype_ssize
atspre_g0int_add_ssize
  (atstype_ssize x1, atstype_ssize x2) { return (x1 + x2) ; }
// end of [atspre_g0int_add_ssize]
ATSinline()
atstype_ssize
atspre_g0int_sub_ssize
  (atstype_ssize x1, atstype_ssize x2) { return (x1 - x2) ; }
// end of [atspre_g0int_sub_ssize]
ATSinline()
atstype_ssize
atspre_g0int_mul_ssize
  (atstype_ssize x1, atstype_ssize x2) { return (x1 * x2) ; }
// end of [atspre_g0int_mul_ssize]
ATSinline()
atstype_ssize
atspre_g0int_div_ssize
  (atstype_ssize x1, atstype_ssize x2) { return (x1 / x2) ; }
// end of [atspre_g0int_div_ssize]
ATSinline()
atstype_ssize
atspre_g0int_mod_ssize
  (atstype_ssize x1, atstype_ssize x2) { return (x1 % x2) ; }
// end of [atspre_g0int_mod_ssize]
ATSinline()
atstype_ssize
atspre_g0int_nmod_ssize
  (atstype_ssize x1, atstype_ssize x2) { return (x1 % x2) ; }
// end of [atspre_g0int_nmod_ssize]
ATSinline()
atstype_ssize
atspre_g0int_asl_ssize
  (atstype_ssize x, atstype_int n) { return (x << n) ; }
// end of [atspre_g0int_asl_ssize]
ATSinline()
atstype_ssize
atspre_g0int_asr_ssize
  (atstype_ssize x, atstype_int n) { return (x >> n) ; }
// end of [atspre_g0int_asr_ssize]
ATSinline()
atstype_bool
atspre_g0int_isltz_ssize (atstype_ssize x)
{
  return (x < 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isltz_ssize]
ATSinline()
atstype_bool
atspre_g0int_isltez_ssize (atstype_ssize x)
{
  return (x <= 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isltez_ssize]
ATSinline()
atstype_bool
atspre_g0int_isgtz_ssize (atstype_ssize x)
{
  return (x > 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isgtz_ssize]
ATSinline()
atstype_bool
atspre_g0int_isgtez_ssize (atstype_ssize x)
{
  return (x >= 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isgtez_ssize]
ATSinline()
atstype_bool
atspre_g0int_iseqz_ssize (atstype_ssize x)
{
  return (x == 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_iseqz_ssize]
ATSinline()
atstype_bool
atspre_g0int_isneqz_ssize (atstype_ssize x)
{
  return (x != 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isneqz_ssize]
ATSinline()
atstype_bool
atspre_g0int_lt_ssize
(
  atstype_ssize x1, atstype_ssize x2
) {
  return (x1 < x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_lt_ssize]
ATSinline()
atstype_bool
atspre_g0int_lte_ssize
(
  atstype_ssize x1, atstype_ssize x2
) {
  return (x1 <= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_lte_ssize]
ATSinline()
atstype_bool
atspre_g0int_gt_ssize
(
  atstype_ssize x1, atstype_ssize x2
) {
  return (x1 > x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_gt_ssize]
ATSinline()
atstype_bool
atspre_g0int_gte_ssize
(
  atstype_ssize x1, atstype_ssize x2
) {
  return (x1 >= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_gte_ssize]
ATSinline()
atstype_bool
atspre_g0int_eq_ssize
(
  atstype_ssize x1, atstype_ssize x2
) {
  return (x1 == x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_eq_ssize]
ATSinline()
atstype_bool
atspre_g0int_neq_ssize
(
  atstype_ssize x1, atstype_ssize x2
) {
  return (x1 != x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_neq_ssize]
ATSinline()
atstype_int
atspre_g0int_compare_ssize
(
  atstype_ssize x1, atstype_ssize x2
) {
  if (x1 < x2) return -1 ; else if (x1 > x2) return 1 ; else return 0 ;
} // end of [atspre_g0int_compare_ssize]
ATSinline()
atstype_ssize
atspre_g0int_max_ssize
  (atstype_ssize x1, atstype_ssize x2) { return (x1 >= x2 ? x1 : x2) ; }
// end of [atspre_g0int_max_ssize]
ATSinline()
atstype_ssize
atspre_g0int_min_ssize
  (atstype_ssize x1, atstype_ssize x2) { return (x1 <= x2 ? x1 : x2) ; }
// end of [atspre_g0int_min_ssize]
//
/* ****** ****** */

#define atspre_g1int_neg_int atspre_g0int_neg_int
#define atspre_g1int_abs_int atspre_g0int_abs_int
#define atspre_g1int_succ_int atspre_g0int_succ_int
#define atspre_g1int_pred_int atspre_g0int_pred_int
#define atspre_g1int_half_int atspre_g0int_half_int
#define atspre_g1int_add_int atspre_g0int_add_int
#define atspre_g1int_sub_int atspre_g0int_sub_int
#define atspre_g1int_mul_int atspre_g0int_mul_int
#define atspre_g1int_div_int atspre_g0int_div_int
#define atspre_g1int_nmod_int atspre_g0int_nmod_int
#define atspre_g1int_isltz_int atspre_g0int_isltz_int
#define atspre_g1int_isltez_int atspre_g0int_isltez_int
#define atspre_g1int_isgtz_int atspre_g0int_isgtz_int
#define atspre_g1int_isgtez_int atspre_g0int_isgtez_int
#define atspre_g1int_iseqz_int atspre_g0int_iseqz_int
#define atspre_g1int_isneqz_int atspre_g0int_isneqz_int
#define atspre_g1int_lt_int atspre_g0int_lt_int
#define atspre_g1int_lte_int atspre_g0int_lte_int
#define atspre_g1int_gt_int atspre_g0int_gt_int
#define atspre_g1int_gte_int atspre_g0int_gte_int
#define atspre_g1int_eq_int atspre_g0int_eq_int
#define atspre_g1int_neq_int atspre_g0int_neq_int
#define atspre_g1int_compare_int atspre_g0int_compare_int
#define atspre_g1int_max_int atspre_g0int_max_int
#define atspre_g1int_min_int atspre_g0int_min_int

/* ****** ****** */

#define atspre_g1int_neg_lint atspre_g0int_neg_lint
#define atspre_g1int_succ_lint atspre_g0int_succ_lint
#define atspre_g1int_pred_lint atspre_g0int_pred_lint
#define atspre_g1int_half_lint atspre_g0int_half_lint
#define atspre_g1int_add_lint atspre_g0int_add_lint
#define atspre_g1int_sub_lint atspre_g0int_sub_lint
#define atspre_g1int_mul_lint atspre_g0int_mul_lint
#define atspre_g1int_div_lint atspre_g0int_div_lint
#define atspre_g1int_nmod_lint atspre_g0int_nmod_lint
#define atspre_g1int_isltz_lint atspre_g0int_isltz_lint
#define atspre_g1int_isltez_lint atspre_g0int_isltez_lint
#define atspre_g1int_isgtz_lint atspre_g0int_isgtz_lint
#define atspre_g1int_isgtez_lint atspre_g0int_isgtez_lint
#define atspre_g1int_iseqz_lint atspre_g0int_iseqz_lint
#define atspre_g1int_isneqz_lint atspre_g0int_isneqz_lint
#define atspre_g1int_lt_lint atspre_g0int_lt_lint
#define atspre_g1int_lte_lint atspre_g0int_lte_lint
#define atspre_g1int_gt_lint atspre_g0int_gt_lint
#define atspre_g1int_gte_lint atspre_g0int_gte_lint
#define atspre_g1int_eq_lint atspre_g0int_eq_lint
#define atspre_g1int_neq_lint atspre_g0int_neq_lint
#define atspre_g1int_compare_lint atspre_g0int_compare_lint
#define atspre_g1int_max_lint atspre_g0int_max_lint
#define atspre_g1int_min_lint atspre_g0int_min_lint

/* ****** ****** */

#define atspre_g1int_neg_llint atspre_g0int_neg_llint
#define atspre_g1int_succ_llint atspre_g0int_succ_llint
#define atspre_g1int_pred_llint atspre_g0int_pred_llint
#define atspre_g1int_half_llint atspre_g0int_half_llint
#define atspre_g1int_add_llint atspre_g0int_add_llint
#define atspre_g1int_sub_llint atspre_g0int_sub_llint
#define atspre_g1int_mul_llint atspre_g0int_mul_llint
#define atspre_g1int_div_llint atspre_g0int_div_llint
#define atspre_g1int_nmod_llint atspre_g0int_nmod_llint
#define atspre_g1int_isltz_llint atspre_g0int_isltz_llint
#define atspre_g1int_isltez_llint atspre_g0int_isltez_llint
#define atspre_g1int_isgtz_llint atspre_g0int_isgtz_llint
#define atspre_g1int_isgtez_llint atspre_g0int_isgtez_llint
#define atspre_g1int_iseqz_llint atspre_g0int_iseqz_llint
#define atspre_g1int_isneqz_llint atspre_g0int_isneqz_llint
#define atspre_g1int_lt_llint atspre_g0int_lt_llint
#define atspre_g1int_lte_llint atspre_g0int_lte_llint
#define atspre_g1int_gt_llint atspre_g0int_gt_llint
#define atspre_g1int_gte_llint atspre_g0int_gte_llint
#define atspre_g1int_eq_llint atspre_g0int_eq_llint
#define atspre_g1int_neq_llint atspre_g0int_neq_llint
#define atspre_g1int_compare_llint atspre_g0int_compare_llint
#define atspre_g1int_max_llint atspre_g0int_max_llint
#define atspre_g1int_min_llint atspre_g0int_min_llint

/* ****** ****** */

#define atspre_g1int_neg_ssize atspre_g0int_neg_ssize
#define atspre_g1int_succ_ssize atspre_g0int_succ_ssize
#define atspre_g1int_pred_ssize atspre_g0int_pred_ssize
#define atspre_g1int_half_ssize atspre_g0int_half_ssize
#define atspre_g1int_add_ssize atspre_g0int_add_ssize
#define atspre_g1int_sub_ssize atspre_g0int_sub_ssize
#define atspre_g1int_mul_ssize atspre_g0int_mul_ssize
#define atspre_g1int_div_ssize atspre_g0int_div_ssize
#define atspre_g1int_nmod_ssize atspre_g0int_nmod_ssize
#define atspre_g1int_isltz_ssize atspre_g0int_isltz_ssize
#define atspre_g1int_isltez_ssize atspre_g0int_isltez_ssize
#define atspre_g1int_isgtz_ssize atspre_g0int_isgtz_ssize
#define atspre_g1int_isgtez_ssize atspre_g0int_isgtez_ssize
#define atspre_g1int_iseqz_ssize atspre_g0int_iseqz_ssize
#define atspre_g1int_isneqz_ssize atspre_g0int_isneqz_ssize
#define atspre_g1int_lt_ssize atspre_g0int_lt_ssize
#define atspre_g1int_lte_ssize atspre_g0int_lte_ssize
#define atspre_g1int_gt_ssize atspre_g0int_gt_ssize
#define atspre_g1int_gte_ssize atspre_g0int_gte_ssize
#define atspre_g1int_eq_ssize atspre_g0int_eq_ssize
#define atspre_g1int_neq_ssize atspre_g0int_neq_ssize
#define atspre_g1int_compare_ssize atspre_g0int_compare_ssize
#define atspre_g1int_max_ssize atspre_g0int_max_ssize
#define atspre_g1int_min_ssize atspre_g0int_min_ssize

/* ****** ****** */

ATSinline()
atstype_uint
atspre_g0uint_succ_uint
  (atstype_uint x) { return (x + 1) ; }
// end of [atspre_g0uint_succ_uint]
ATSinline()
atstype_uint
atspre_g0uint_pred_uint
  (atstype_uint x) { return (x - 1) ; }
// end of [atspre_g0uint_pred_uint]
ATSinline()
atstype_uint
atspre_g0uint_half_uint
  (atstype_uint x) { return (x >> 1) ; }
// end of [atspre_g0uint_half_uint]
ATSinline()
atstype_uint
atspre_g0uint_add_uint
  (atstype_uint x1, atstype_uint x2) { return (x1 + x2) ; }
// end of [atspre_g0uint_add_uint]
ATSinline()
atstype_uint
atspre_g0uint_sub_uint
  (atstype_uint x1, atstype_uint x2) { return (x1 - x2) ; }
// end of [atspre_g0uint_sub_uint]
ATSinline()
atstype_uint
atspre_g0uint_mul_uint
  (atstype_uint x1, atstype_uint x2) { return (x1 * x2) ; }
// end of [atspre_g0uint_mul_uint]
ATSinline()
atstype_uint
atspre_g0uint_div_uint
  (atstype_uint x1, atstype_uint x2) { return (x1 / x2) ; }
// end of [atspre_g0uint_div_uint]
ATSinline()
atstype_uint
atspre_g0uint_mod_uint
  (atstype_uint x1, atstype_uint x2) { return (x1 % x2) ; }
// end of [atspre_g0uint_mod_uint]
ATSinline()
atstype_uint
atspre_g0uint_lsl_uint
  (atstype_uint x, atstype_int n) { return (x << n) ; }
// end of [atspre_g0uint_lsl_uint]
ATSinline()
atstype_uint
atspre_g0uint_lsr_uint
  (atstype_uint x, atstype_int n) { return (x >> n) ; }
// end of [atspre_g0uint_lsr_uint]
ATSinline()
atstype_uint
atspre_g0uint_lnot_uint
  (atstype_uint x) { return ~(x) ; }
// end of [atspre_g0uint_lnot_uint]
ATSinline()
atstype_uint
atspre_g0uint_lor_uint
  (atstype_uint x, atstype_uint y) { return (x | y) ; }
// end of [atspre_g0uint_uint_uint]
ATSinline()
atstype_uint
atspre_g0uint_land_uint
  (atstype_uint x, atstype_uint y) { return (x & y) ; }
// end of [atspre_g0uint_uint_uint]
ATSinline()
atstype_uint
atspre_g0uint_lxor_uint
  (atstype_uint x, atstype_uint y) { return (x ^ y) ; }
// end of [atspre_g0uint_uint_uint]
ATSinline()
atstype_bool
atspre_g0uint_isgtz_uint (atstype_uint x)
{
  return (x > 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_isgtz_uint]
ATSinline()
atstype_bool
atspre_g0uint_iseqz_uint (atstype_uint x)
{
  return (x == 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_iseqz_uint]
ATSinline()
atstype_bool
atspre_g0uint_isneqz_uint (atstype_uint x)
{
  return (x != 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_isneqz_uint]
ATSinline()
atstype_bool
atspre_g0uint_lt_uint
(
  atstype_uint x1, atstype_uint x2
) {
  return (x1 < x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_lt_uint]
ATSinline()
atstype_bool
atspre_g0uint_lte_uint
(
  atstype_uint x1, atstype_uint x2
) {
  return (x1 <= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_lte_uint]
ATSinline()
atstype_bool
atspre_g0uint_gt_uint
(
  atstype_uint x1, atstype_uint x2
) {
  return (x1 > x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_gt_uint]
ATSinline()
atstype_bool
atspre_g0uint_gte_uint
(
  atstype_uint x1, atstype_uint x2
) {
  return (x1 >= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_gte_uint]
ATSinline()
atstype_bool
atspre_g0uint_eq_uint
(
  atstype_uint x1, atstype_uint x2
) {
  return (x1 == x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_eq_uint]
ATSinline()
atstype_bool
atspre_g0uint_neq_uint
(
  atstype_uint x1, atstype_uint x2
) {
  return (x1 != x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_neq_uint]
ATSinline()
atstype_int
atspre_g0uint_compare_uint
(
  atstype_uint x1, atstype_uint x2
) {
  if (x1 < x2) return -1 ; else if (x1 > x2) return 1 ; else return 0 ;
} // end of [atspre_g0uint_compare_uint]
ATSinline()
atstype_uint
atspre_g0uint_max_uint
  (atstype_uint x1, atstype_uint x2) { return (x1 >= x2 ? x1 : x2) ; }
// end of [atspre_g0uint_max_uint]
ATSinline()
atstype_uint
atspre_g0uint_min_uint
  (atstype_uint x1, atstype_uint x2) { return (x1 <= x2 ? x1 : x2) ; }
// end of [atspre_g0uint_min_uint]
//
ATSinline()
atstype_ulint
atspre_g0uint_succ_ulint
  (atstype_ulint x) { return (x + 1) ; }
// end of [atspre_g0uint_succ_ulint]
ATSinline()
atstype_ulint
atspre_g0uint_pred_ulint
  (atstype_ulint x) { return (x - 1) ; }
// end of [atspre_g0uint_pred_ulint]
ATSinline()
atstype_ulint
atspre_g0uint_half_ulint
  (atstype_ulint x) { return (x >> 1) ; }
// end of [atspre_g0uint_half_ulint]
ATSinline()
atstype_ulint
atspre_g0uint_add_ulint
  (atstype_ulint x1, atstype_ulint x2) { return (x1 + x2) ; }
// end of [atspre_g0uint_add_ulint]
ATSinline()
atstype_ulint
atspre_g0uint_sub_ulint
  (atstype_ulint x1, atstype_ulint x2) { return (x1 - x2) ; }
// end of [atspre_g0uint_sub_ulint]
ATSinline()
atstype_ulint
atspre_g0uint_mul_ulint
  (atstype_ulint x1, atstype_ulint x2) { return (x1 * x2) ; }
// end of [atspre_g0uint_mul_ulint]
ATSinline()
atstype_ulint
atspre_g0uint_div_ulint
  (atstype_ulint x1, atstype_ulint x2) { return (x1 / x2) ; }
// end of [atspre_g0uint_div_ulint]
ATSinline()
atstype_ulint
atspre_g0uint_mod_ulint
  (atstype_ulint x1, atstype_ulint x2) { return (x1 % x2) ; }
// end of [atspre_g0uint_mod_ulint]
ATSinline()
atstype_ulint
atspre_g0uint_lsl_ulint
  (atstype_ulint x, atstype_int n) { return (x << n) ; }
// end of [atspre_g0uint_lsl_ulint]
ATSinline()
atstype_ulint
atspre_g0uint_lsr_ulint
  (atstype_ulint x, atstype_int n) { return (x >> n) ; }
// end of [atspre_g0uint_lsr_ulint]
ATSinline()
atstype_ulint
atspre_g0uint_lnot_ulint
  (atstype_ulint x) { return ~(x) ; }
// end of [atspre_g0uint_lnot_ulint]
ATSinline()
atstype_ulint
atspre_g0uint_lor_ulint
  (atstype_ulint x, atstype_ulint y) { return (x | y) ; }
// end of [atspre_g0uint_ulint_ulint]
ATSinline()
atstype_ulint
atspre_g0uint_land_ulint
  (atstype_ulint x, atstype_ulint y) { return (x & y) ; }
// end of [atspre_g0uint_ulint_ulint]
ATSinline()
atstype_ulint
atspre_g0uint_lxor_ulint
  (atstype_ulint x, atstype_ulint y) { return (x ^ y) ; }
// end of [atspre_g0uint_ulint_ulint]
ATSinline()
atstype_bool
atspre_g0uint_isgtz_ulint (atstype_ulint x)
{
  return (x > 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_isgtz_ulint]
ATSinline()
atstype_bool
atspre_g0uint_iseqz_ulint (atstype_ulint x)
{
  return (x == 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_iseqz_ulint]
ATSinline()
atstype_bool
atspre_g0uint_isneqz_ulint (atstype_ulint x)
{
  return (x != 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_isneqz_ulint]
ATSinline()
atstype_bool
atspre_g0uint_lt_ulint
(
  atstype_ulint x1, atstype_ulint x2
) {
  return (x1 < x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_lt_ulint]
ATSinline()
atstype_bool
atspre_g0uint_lte_ulint
(
  atstype_ulint x1, atstype_ulint x2
) {
  return (x1 <= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_lte_ulint]
ATSinline()
atstype_bool
atspre_g0uint_gt_ulint
(
  atstype_ulint x1, atstype_ulint x2
) {
  return (x1 > x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_gt_ulint]
ATSinline()
atstype_bool
atspre_g0uint_gte_ulint
(
  atstype_ulint x1, atstype_ulint x2
) {
  return (x1 >= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_gte_ulint]
ATSinline()
atstype_bool
atspre_g0uint_eq_ulint
(
  atstype_ulint x1, atstype_ulint x2
) {
  return (x1 == x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_eq_ulint]
ATSinline()
atstype_bool
atspre_g0uint_neq_ulint
(
  atstype_ulint x1, atstype_ulint x2
) {
  return (x1 != x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_neq_ulint]
ATSinline()
atstype_int
atspre_g0uint_compare_ulint
(
  atstype_ulint x1, atstype_ulint x2
) {
  if (x1 < x2) return -1 ; else if (x1 > x2) return 1 ; else return 0 ;
} // end of [atspre_g0uint_compare_ulint]
ATSinline()
atstype_ulint
atspre_g0uint_max_ulint
  (atstype_ulint x1, atstype_ulint x2) { return (x1 >= x2 ? x1 : x2) ; }
// end of [atspre_g0uint_max_ulint]
ATSinline()
atstype_ulint
atspre_g0uint_min_ulint
  (atstype_ulint x1, atstype_ulint x2) { return (x1 <= x2 ? x1 : x2) ; }
// end of [atspre_g0uint_min_ulint]
//
ATSinline()
atstype_ullint
atspre_g0uint_succ_ullint
  (atstype_ullint x) { return (x + 1) ; }
// end of [atspre_g0uint_succ_ullint]
ATSinline()
atstype_ullint
atspre_g0uint_pred_ullint
  (atstype_ullint x) { return (x - 1) ; }
// end of [atspre_g0uint_pred_ullint]
ATSinline()
atstype_ullint
atspre_g0uint_half_ullint
  (atstype_ullint x) { return (x >> 1) ; }
// end of [atspre_g0uint_half_ullint]
ATSinline()
atstype_ullint
atspre_g0uint_add_ullint
  (atstype_ullint x1, atstype_ullint x2) { return (x1 + x2) ; }
// end of [atspre_g0uint_add_ullint]
ATSinline()
atstype_ullint
atspre_g0uint_sub_ullint
  (atstype_ullint x1, atstype_ullint x2) { return (x1 - x2) ; }
// end of [atspre_g0uint_sub_ullint]
ATSinline()
atstype_ullint
atspre_g0uint_mul_ullint
  (atstype_ullint x1, atstype_ullint x2) { return (x1 * x2) ; }
// end of [atspre_g0uint_mul_ullint]
ATSinline()
atstype_ullint
atspre_g0uint_div_ullint
  (atstype_ullint x1, atstype_ullint x2) { return (x1 / x2) ; }
// end of [atspre_g0uint_div_ullint]
ATSinline()
atstype_ullint
atspre_g0uint_mod_ullint
  (atstype_ullint x1, atstype_ullint x2) { return (x1 % x2) ; }
// end of [atspre_g0uint_mod_ullint]
ATSinline()
atstype_ullint
atspre_g0uint_lsl_ullint
  (atstype_ullint x, atstype_int n) { return (x << n) ; }
// end of [atspre_g0uint_lsl_ullint]
ATSinline()
atstype_ullint
atspre_g0uint_lsr_ullint
  (atstype_ullint x, atstype_int n) { return (x >> n) ; }
// end of [atspre_g0uint_lsr_ullint]
ATSinline()
atstype_ullint
atspre_g0uint_lnot_ullint
  (atstype_ullint x) { return ~(x) ; }
// end of [atspre_g0uint_lnot_ullint]
ATSinline()
atstype_ullint
atspre_g0uint_lor_ullint
  (atstype_ullint x, atstype_ullint y) { return (x | y) ; }
// end of [atspre_g0uint_ullint_ullint]
ATSinline()
atstype_ullint
atspre_g0uint_land_ullint
  (atstype_ullint x, atstype_ullint y) { return (x & y) ; }
// end of [atspre_g0uint_ullint_ullint]
ATSinline()
atstype_ullint
atspre_g0uint_lxor_ullint
  (atstype_ullint x, atstype_ullint y) { return (x ^ y) ; }
// end of [atspre_g0uint_ullint_ullint]
ATSinline()
atstype_bool
atspre_g0uint_isgtz_ullint (atstype_ullint x)
{
  return (x > 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_isgtz_ullint]
ATSinline()
atstype_bool
atspre_g0uint_iseqz_ullint (atstype_ullint x)
{
  return (x == 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_iseqz_ullint]
ATSinline()
atstype_bool
atspre_g0uint_isneqz_ullint (atstype_ullint x)
{
  return (x != 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_isneqz_ullint]
ATSinline()
atstype_bool
atspre_g0uint_lt_ullint
(
  atstype_ullint x1, atstype_ullint x2
) {
  return (x1 < x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_lt_ullint]
ATSinline()
atstype_bool
atspre_g0uint_lte_ullint
(
  atstype_ullint x1, atstype_ullint x2
) {
  return (x1 <= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_lte_ullint]
ATSinline()
atstype_bool
atspre_g0uint_gt_ullint
(
  atstype_ullint x1, atstype_ullint x2
) {
  return (x1 > x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_gt_ullint]
ATSinline()
atstype_bool
atspre_g0uint_gte_ullint
(
  atstype_ullint x1, atstype_ullint x2
) {
  return (x1 >= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_gte_ullint]
ATSinline()
atstype_bool
atspre_g0uint_eq_ullint
(
  atstype_ullint x1, atstype_ullint x2
) {
  return (x1 == x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_eq_ullint]
ATSinline()
atstype_bool
atspre_g0uint_neq_ullint
(
  atstype_ullint x1, atstype_ullint x2
) {
  return (x1 != x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_neq_ullint]
ATSinline()
atstype_int
atspre_g0uint_compare_ullint
(
  atstype_ullint x1, atstype_ullint x2
) {
  if (x1 < x2) return -1 ; else if (x1 > x2) return 1 ; else return 0 ;
} // end of [atspre_g0uint_compare_ullint]
ATSinline()
atstype_ullint
atspre_g0uint_max_ullint
  (atstype_ullint x1, atstype_ullint x2) { return (x1 >= x2 ? x1 : x2) ; }
// end of [atspre_g0uint_max_ullint]
ATSinline()
atstype_ullint
atspre_g0uint_min_ullint
  (atstype_ullint x1, atstype_ullint x2) { return (x1 <= x2 ? x1 : x2) ; }
// end of [atspre_g0uint_min_ullint]
//
ATSinline()
atstype_size
atspre_g0uint_succ_size
  (atstype_size x) { return (x + 1) ; }
// end of [atspre_g0uint_succ_size]
ATSinline()
atstype_size
atspre_g0uint_pred_size
  (atstype_size x) { return (x - 1) ; }
// end of [atspre_g0uint_pred_size]
ATSinline()
atstype_size
atspre_g0uint_half_size
  (atstype_size x) { return (x >> 1) ; }
// end of [atspre_g0uint_half_size]
ATSinline()
atstype_size
atspre_g0uint_add_size
  (atstype_size x1, atstype_size x2) { return (x1 + x2) ; }
// end of [atspre_g0uint_add_size]
ATSinline()
atstype_size
atspre_g0uint_sub_size
  (atstype_size x1, atstype_size x2) { return (x1 - x2) ; }
// end of [atspre_g0uint_sub_size]
ATSinline()
atstype_size
atspre_g0uint_mul_size
  (atstype_size x1, atstype_size x2) { return (x1 * x2) ; }
// end of [atspre_g0uint_mul_size]
ATSinline()
atstype_size
atspre_g0uint_div_size
  (atstype_size x1, atstype_size x2) { return (x1 / x2) ; }
// end of [atspre_g0uint_div_size]
ATSinline()
atstype_size
atspre_g0uint_mod_size
  (atstype_size x1, atstype_size x2) { return (x1 % x2) ; }
// end of [atspre_g0uint_mod_size]
ATSinline()
atstype_size
atspre_g0uint_lsl_size
  (atstype_size x, atstype_int n) { return (x << n) ; }
// end of [atspre_g0uint_lsl_size]
ATSinline()
atstype_size
atspre_g0uint_lsr_size
  (atstype_size x, atstype_int n) { return (x >> n) ; }
// end of [atspre_g0uint_lsr_size]
ATSinline()
atstype_size
atspre_g0uint_lnot_size
  (atstype_size x) { return ~(x) ; }
// end of [atspre_g0uint_lnot_size]
ATSinline()
atstype_size
atspre_g0uint_lor_size
  (atstype_size x, atstype_size y) { return (x | y) ; }
// end of [atspre_g0uint_size_size]
ATSinline()
atstype_size
atspre_g0uint_land_size
  (atstype_size x, atstype_size y) { return (x & y) ; }
// end of [atspre_g0uint_size_size]
ATSinline()
atstype_size
atspre_g0uint_lxor_size
  (atstype_size x, atstype_size y) { return (x ^ y) ; }
// end of [atspre_g0uint_size_size]
ATSinline()
atstype_bool
atspre_g0uint_isgtz_size (atstype_size x)
{
  return (x > 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_isgtz_size]
ATSinline()
atstype_bool
atspre_g0uint_iseqz_size (atstype_size x)
{
  return (x == 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_iseqz_size]
ATSinline()
atstype_bool
atspre_g0uint_isneqz_size (atstype_size x)
{
  return (x != 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_isneqz_size]
ATSinline()
atstype_bool
atspre_g0uint_lt_size
(
  atstype_size x1, atstype_size x2
) {
  return (x1 < x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_lt_size]
ATSinline()
atstype_bool
atspre_g0uint_lte_size
(
  atstype_size x1, atstype_size x2
) {
  return (x1 <= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_lte_size]
ATSinline()
atstype_bool
atspre_g0uint_gt_size
(
  atstype_size x1, atstype_size x2
) {
  return (x1 > x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_gt_size]
ATSinline()
atstype_bool
atspre_g0uint_gte_size
(
  atstype_size x1, atstype_size x2
) {
  return (x1 >= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_gte_size]
ATSinline()
atstype_bool
atspre_g0uint_eq_size
(
  atstype_size x1, atstype_size x2
) {
  return (x1 == x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_eq_size]
ATSinline()
atstype_bool
atspre_g0uint_neq_size
(
  atstype_size x1, atstype_size x2
) {
  return (x1 != x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_neq_size]
ATSinline()
atstype_int
atspre_g0uint_compare_size
(
  atstype_size x1, atstype_size x2
) {
  if (x1 < x2) return -1 ; else if (x1 > x2) return 1 ; else return 0 ;
} // end of [atspre_g0uint_compare_size]
ATSinline()
atstype_size
atspre_g0uint_max_size
  (atstype_size x1, atstype_size x2) { return (x1 >= x2 ? x1 : x2) ; }
// end of [atspre_g0uint_max_size]
ATSinline()
atstype_size
atspre_g0uint_min_size
  (atstype_size x1, atstype_size x2) { return (x1 <= x2 ? x1 : x2) ; }
// end of [atspre_g0uint_min_size]
//
/* ****** ****** */

#define atspre_g1uint_succ_uint atspre_g0uint_succ_uint
#define atspre_g1uint_pred_uint atspre_g0uint_pred_uint
#define atspre_g1uint_half_uint atspre_g0uint_half_uint
#define atspre_g1uint_add_uint atspre_g0uint_add_uint
#define atspre_g1uint_sub_uint atspre_g0uint_sub_uint
#define atspre_g1uint_mul_uint atspre_g0uint_mul_uint
#define atspre_g1uint_div_uint atspre_g0uint_div_uint
#define atspre_g1uint_mod_uint atspre_g0uint_mod_uint
#define atspre_g1uint_isgtz_uint atspre_g0uint_isgtz_uint
#define atspre_g1uint_iseqz_uint atspre_g0uint_iseqz_uint
#define atspre_g1uint_isneqz_uint atspre_g0uint_isneqz_uint
#define atspre_g1uint_lt_uint atspre_g0uint_lt_uint
#define atspre_g1uint_lte_uint atspre_g0uint_lte_uint
#define atspre_g1uint_gt_uint atspre_g0uint_gt_uint
#define atspre_g1uint_gte_uint atspre_g0uint_gte_uint
#define atspre_g1uint_eq_uint atspre_g0uint_eq_uint
#define atspre_g1uint_neq_uint atspre_g0uint_neq_uint
#define atspre_g1uint_compare_uint atspre_g0uint_compare_uint
#define atspre_g1uint_max_uint atspre_g0uint_max_uint
#define atspre_g1uint_min_uint atspre_g0uint_min_uint

/* ****** ****** */

#define atspre_g1uint_succ_ulint atspre_g0uint_succ_ulint
#define atspre_g1uint_pred_ulint atspre_g0uint_pred_ulint
#define atspre_g1uint_half_ulint atspre_g0uint_half_ulint
#define atspre_g1uint_add_ulint atspre_g0uint_add_ulint
#define atspre_g1uint_sub_ulint atspre_g0uint_sub_ulint
#define atspre_g1uint_mul_ulint atspre_g0uint_mul_ulint
#define atspre_g1uint_div_ulint atspre_g0uint_div_ulint
#define atspre_g1uint_mod_ulint atspre_g0uint_mod_ulint
#define atspre_g1uint_isgtz_ulint atspre_g0uint_isgtz_ulint
#define atspre_g1uint_iseqz_ulint atspre_g0uint_iseqz_ulint
#define atspre_g1uint_isneqz_ulint atspre_g0uint_isneqz_ulint
#define atspre_g1uint_lt_ulint atspre_g0uint_lt_ulint
#define atspre_g1uint_lte_ulint atspre_g0uint_lte_ulint
#define atspre_g1uint_gt_ulint atspre_g0uint_gt_ulint
#define atspre_g1uint_gte_ulint atspre_g0uint_gte_ulint
#define atspre_g1uint_eq_ulint atspre_g0uint_eq_ulint
#define atspre_g1uint_neq_ulint atspre_g0uint_neq_ulint
#define atspre_g1uint_compare_ulint atspre_g0uint_compare_ulint
#define atspre_g1uint_max_ulint atspre_g0uint_max_ulint
#define atspre_g1uint_min_ulint atspre_g0uint_min_ulint

/* ****** ****** */

#define atspre_g1uint_succ_ullint atspre_g0uint_succ_ullint
#define atspre_g1uint_pred_ullint atspre_g0uint_pred_ullint
#define atspre_g1uint_half_ullint atspre_g0uint_half_ullint
#define atspre_g1uint_add_ullint atspre_g0uint_add_ullint
#define atspre_g1uint_sub_ullint atspre_g0uint_sub_ullint
#define atspre_g1uint_mul_ullint atspre_g0uint_mul_ullint
#define atspre_g1uint_div_ullint atspre_g0uint_div_ullint
#define atspre_g1uint_mod_ullint atspre_g0uint_mod_ullint
#define atspre_g1uint_isgtz_ullint atspre_g0uint_isgtz_ullint
#define atspre_g1uint_iseqz_ullint atspre_g0uint_iseqz_ullint
#define atspre_g1uint_isneqz_ullint atspre_g0uint_isneqz_ullint
#define atspre_g1uint_lt_ullint atspre_g0uint_lt_ullint
#define atspre_g1uint_lte_ullint atspre_g0uint_lte_ullint
#define atspre_g1uint_gt_ullint atspre_g0uint_gt_ullint
#define atspre_g1uint_gte_ullint atspre_g0uint_gte_ullint
#define atspre_g1uint_eq_ullint atspre_g0uint_eq_ullint
#define atspre_g1uint_neq_ullint atspre_g0uint_neq_ullint
#define atspre_g1uint_compare_ullint atspre_g0uint_compare_ullint
#define atspre_g1uint_max_ullint atspre_g0uint_max_ullint
#define atspre_g1uint_min_ullint atspre_g0uint_min_ullint

/* ****** ****** */

#define atspre_g1uint_succ_size atspre_g0uint_succ_size
#define atspre_g1uint_pred_size atspre_g0uint_pred_size
#define atspre_g1uint_half_size atspre_g0uint_half_size
#define atspre_g1uint_add_size atspre_g0uint_add_size
#define atspre_g1uint_sub_size atspre_g0uint_sub_size
#define atspre_g1uint_mul_size atspre_g0uint_mul_size
#define atspre_g1uint_div_size atspre_g0uint_div_size
#define atspre_g1uint_mod_size atspre_g0uint_mod_size
#define atspre_g1uint_isgtz_size atspre_g0uint_isgtz_size
#define atspre_g1uint_iseqz_size atspre_g0uint_iseqz_size
#define atspre_g1uint_isneqz_size atspre_g0uint_isneqz_size
#define atspre_g1uint_lt_size atspre_g0uint_lt_size
#define atspre_g1uint_lte_size atspre_g0uint_lte_size
#define atspre_g1uint_gt_size atspre_g0uint_gt_size
#define atspre_g1uint_gte_size atspre_g0uint_gte_size
#define atspre_g1uint_eq_size atspre_g0uint_eq_size
#define atspre_g1uint_neq_size atspre_g0uint_neq_size
#define atspre_g1uint_compare_size atspre_g0uint_compare_size
#define atspre_g1uint_max_size atspre_g0uint_max_size
#define atspre_g1uint_min_size atspre_g0uint_min_size

/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_INTEGER

/* ****** ****** */

/* end of [integer.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/list_vt.atxt
** Time of generation: Sat Oct 17 15:20:03 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: January, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_LIST_VT
#define ATSLIB_PRELUDE_CATS_LIST_VT

/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_LIST_VT

/* ****** ****** */

/* end of [list_vt.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/array.atxt
** Time of generation: Sat Oct 17 15:20:04 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: January, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_ARRAY
#define ATSLIB_PRELUDE_CATS_ARRAY

/* ****** ****** */
//
// [stdlib.h]
//
extern
void qsort
(
  void *base, size_t nmemb, size_t size
, int(*compar)(const void *, const void *)
) ; // end of [qsort]
extern
void *bsearch
(
  const void *key
, const void *base
, size_t nmemb, size_t size
, int (*compar)(const void *, const void *)
) ; // end of [bsearch]
//
#define atspre_array_qsort qsort
#define atspre_array_bsearch bsearch
//
/* ****** ****** */
//
// [string.h]
//
#ifndef memcpy
extern
void *memcpy(void *dst, const void *src, size_t n) ;
#endif // #ifndef
#ifndef memmove
extern
void *memmove(void *dst, const void *src, size_t n) ;
#endif // #ifndef
//
#define atspre_array_memcpy memcpy
#define atspre_array_memmove memmove
//
/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_array_foreach_funenv_tsz
(
  atstype_ptr A
, atstype_size n
, atstype_size tsz
, atstype_funptr f
, atstype_boxed env
) {
  char *p ;
  size_t i ;
  p = (char*)A ;
  for (i = 0 ; i < n ; i += 1)
  {
    ((void(*)(void*, void*))(f))(p, env) ; p += tsz ;
  }
  return ;
} // end of [atspre_array_foreach_funenv_tsz]

/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_ARRAY

/* ****** ****** */

/* end of [array.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/integer_fixed.atxt
** Time of generation: Sat Oct 17 15:20:02 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: January, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_INTEGER_FIXED
#define ATSLIB_PRELUDE_CATS_INTEGER_FIXED

/* ****** ****** */

#include <stdint.h>

/* ****** ****** */

typedef int8_t atstype_int8 ;
typedef int16_t atstype_int16 ;
typedef int32_t atstype_int32 ;
typedef int64_t atstype_int64 ;

typedef uint8_t atstype_uint8 ;
typedef uint16_t atstype_uint16 ;
typedef uint32_t atstype_uint32 ;
typedef uint64_t atstype_uint64 ;

/* ****** ****** */

#define atspre_g0int2int_int8_int(x) ((atstype_int)(x))
#define atspre_g0int2int_int16_int(x) ((atstype_int)(x))
#define atspre_g0int2int_int32_int(x) ((atstype_int)(x))
#define atspre_g0int2int_int64_int(x) ((atstype_int)(x))

/* ****** ****** */

ATSinline()
atstype_int8
atspre_g0int_neg_int8
  (atstype_int8 x) { return (-x) ; }
// end of [atspre_g0int_neg_int8]
ATSinline()
atstype_int8
atspre_g0int_succ_int8
  (atstype_int8 x) { return (x + 1) ; }
// end of [atspre_g0int_succ_int8]
ATSinline()
atstype_int8
atspre_g0int_pred_int8
  (atstype_int8 x) { return (x - 1) ; }
// end of [atspre_g0int_pred_int8]
ATSinline()
atstype_int8
atspre_g0int_half_int8
  (atstype_int8 x) { return (x / 2) ; }
// end of [atspre_g0int_half_int8]
ATSinline()
atstype_int8
atspre_g0int_add_int8
  (atstype_int8 x1, atstype_int8 x2) { return (x1 + x2) ; }
// end of [atspre_g0int_add_int8]
ATSinline()
atstype_int8
atspre_g0int_sub_int8
  (atstype_int8 x1, atstype_int8 x2) { return (x1 - x2) ; }
// end of [atspre_g0int_sub_int8]
ATSinline()
atstype_int8
atspre_g0int_mul_int8
  (atstype_int8 x1, atstype_int8 x2) { return (x1 * x2) ; }
// end of [atspre_g0int_mul_int8]
ATSinline()
atstype_int8
atspre_g0int_div_int8
  (atstype_int8 x1, atstype_int8 x2) { return (x1 / x2) ; }
// end of [atspre_g0int_div_int8]
ATSinline()
atstype_int8
atspre_g0int_mod_int8
  (atstype_int8 x1, atstype_int8 x2) { return (x1 % x2) ; }
// end of [atspre_g0int_mod_int8]
ATSinline()
atstype_bool
atspre_g0int_isltz_int8 (atstype_int8 x)
{
  return (x < 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isltz_int8]
ATSinline()
atstype_bool
atspre_g0int_isltez_int8 (atstype_int8 x)
{
  return (x <= 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isltez_int8]
ATSinline()
atstype_bool
atspre_g0int_isgtz_int8 (atstype_int8 x)
{
  return (x > 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isgtz_int8]
ATSinline()
atstype_bool
atspre_g0int_isgtez_int8 (atstype_int8 x)
{
  return (x >= 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isgtez_int8]
ATSinline()
atstype_bool
atspre_g0int_iseqz_int8 (atstype_int8 x)
{
  return (x == 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_iseqz_int8]
ATSinline()
atstype_bool
atspre_g0int_isneqz_int8 (atstype_int8 x)
{
  return (x != 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isneqz_int8]
ATSinline()
atstype_bool
atspre_g0int_lt_int8
(
  atstype_int8 x1, atstype_int8 x2
) {
  return (x1 < x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_lt_int8]
ATSinline()
atstype_bool
atspre_g0int_lte_int8
(
  atstype_int8 x1, atstype_int8 x2
) {
  return (x1 <= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_lte_int8]
ATSinline()
atstype_bool
atspre_g0int_gt_int8
(
  atstype_int8 x1, atstype_int8 x2
) {
  return (x1 > x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_gt_int8]
ATSinline()
atstype_bool
atspre_g0int_gte_int8
(
  atstype_int8 x1, atstype_int8 x2
) {
  return (x1 >= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_gte_int8]
ATSinline()
atstype_bool
atspre_g0int_eq_int8
(
  atstype_int8 x1, atstype_int8 x2
) {
  return (x1 == x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_eq_int8]
ATSinline()
atstype_bool
atspre_g0int_neq_int8
(
  atstype_int8 x1, atstype_int8 x2
) {
  return (x1 != x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_neq_int8]
ATSinline()
atstype_int16
atspre_g0int_neg_int16
  (atstype_int16 x) { return (-x) ; }
// end of [atspre_g0int_neg_int16]
ATSinline()
atstype_int16
atspre_g0int_succ_int16
  (atstype_int16 x) { return (x + 1) ; }
// end of [atspre_g0int_succ_int16]
ATSinline()
atstype_int16
atspre_g0int_pred_int16
  (atstype_int16 x) { return (x - 1) ; }
// end of [atspre_g0int_pred_int16]
ATSinline()
atstype_int16
atspre_g0int_half_int16
  (atstype_int16 x) { return (x / 2) ; }
// end of [atspre_g0int_half_int16]
ATSinline()
atstype_int16
atspre_g0int_add_int16
  (atstype_int16 x1, atstype_int16 x2) { return (x1 + x2) ; }
// end of [atspre_g0int_add_int16]
ATSinline()
atstype_int16
atspre_g0int_sub_int16
  (atstype_int16 x1, atstype_int16 x2) { return (x1 - x2) ; }
// end of [atspre_g0int_sub_int16]
ATSinline()
atstype_int16
atspre_g0int_mul_int16
  (atstype_int16 x1, atstype_int16 x2) { return (x1 * x2) ; }
// end of [atspre_g0int_mul_int16]
ATSinline()
atstype_int16
atspre_g0int_div_int16
  (atstype_int16 x1, atstype_int16 x2) { return (x1 / x2) ; }
// end of [atspre_g0int_div_int16]
ATSinline()
atstype_int16
atspre_g0int_mod_int16
  (atstype_int16 x1, atstype_int16 x2) { return (x1 % x2) ; }
// end of [atspre_g0int_mod_int16]
ATSinline()
atstype_bool
atspre_g0int_isltz_int16 (atstype_int16 x)
{
  return (x < 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isltz_int16]
ATSinline()
atstype_bool
atspre_g0int_isltez_int16 (atstype_int16 x)
{
  return (x <= 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isltez_int16]
ATSinline()
atstype_bool
atspre_g0int_isgtz_int16 (atstype_int16 x)
{
  return (x > 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isgtz_int16]
ATSinline()
atstype_bool
atspre_g0int_isgtez_int16 (atstype_int16 x)
{
  return (x >= 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isgtez_int16]
ATSinline()
atstype_bool
atspre_g0int_iseqz_int16 (atstype_int16 x)
{
  return (x == 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_iseqz_int16]
ATSinline()
atstype_bool
atspre_g0int_isneqz_int16 (atstype_int16 x)
{
  return (x != 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isneqz_int16]
ATSinline()
atstype_bool
atspre_g0int_lt_int16
(
  atstype_int16 x1, atstype_int16 x2
) {
  return (x1 < x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_lt_int16]
ATSinline()
atstype_bool
atspre_g0int_lte_int16
(
  atstype_int16 x1, atstype_int16 x2
) {
  return (x1 <= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_lte_int16]
ATSinline()
atstype_bool
atspre_g0int_gt_int16
(
  atstype_int16 x1, atstype_int16 x2
) {
  return (x1 > x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_gt_int16]
ATSinline()
atstype_bool
atspre_g0int_gte_int16
(
  atstype_int16 x1, atstype_int16 x2
) {
  return (x1 >= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_gte_int16]
ATSinline()
atstype_bool
atspre_g0int_eq_int16
(
  atstype_int16 x1, atstype_int16 x2
) {
  return (x1 == x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_eq_int16]
ATSinline()
atstype_bool
atspre_g0int_neq_int16
(
  atstype_int16 x1, atstype_int16 x2
) {
  return (x1 != x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_neq_int16]
ATSinline()
atstype_int32
atspre_g0int_neg_int32
  (atstype_int32 x) { return (-x) ; }
// end of [atspre_g0int_neg_int32]
ATSinline()
atstype_int32
atspre_g0int_succ_int32
  (atstype_int32 x) { return (x + 1) ; }
// end of [atspre_g0int_succ_int32]
ATSinline()
atstype_int32
atspre_g0int_pred_int32
  (atstype_int32 x) { return (x - 1) ; }
// end of [atspre_g0int_pred_int32]
ATSinline()
atstype_int32
atspre_g0int_half_int32
  (atstype_int32 x) { return (x / 2) ; }
// end of [atspre_g0int_half_int32]
ATSinline()
atstype_int32
atspre_g0int_add_int32
  (atstype_int32 x1, atstype_int32 x2) { return (x1 + x2) ; }
// end of [atspre_g0int_add_int32]
ATSinline()
atstype_int32
atspre_g0int_sub_int32
  (atstype_int32 x1, atstype_int32 x2) { return (x1 - x2) ; }
// end of [atspre_g0int_sub_int32]
ATSinline()
atstype_int32
atspre_g0int_mul_int32
  (atstype_int32 x1, atstype_int32 x2) { return (x1 * x2) ; }
// end of [atspre_g0int_mul_int32]
ATSinline()
atstype_int32
atspre_g0int_div_int32
  (atstype_int32 x1, atstype_int32 x2) { return (x1 / x2) ; }
// end of [atspre_g0int_div_int32]
ATSinline()
atstype_int32
atspre_g0int_mod_int32
  (atstype_int32 x1, atstype_int32 x2) { return (x1 % x2) ; }
// end of [atspre_g0int_mod_int32]
ATSinline()
atstype_bool
atspre_g0int_isltz_int32 (atstype_int32 x)
{
  return (x < 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isltz_int32]
ATSinline()
atstype_bool
atspre_g0int_isltez_int32 (atstype_int32 x)
{
  return (x <= 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isltez_int32]
ATSinline()
atstype_bool
atspre_g0int_isgtz_int32 (atstype_int32 x)
{
  return (x > 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isgtz_int32]
ATSinline()
atstype_bool
atspre_g0int_isgtez_int32 (atstype_int32 x)
{
  return (x >= 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isgtez_int32]
ATSinline()
atstype_bool
atspre_g0int_iseqz_int32 (atstype_int32 x)
{
  return (x == 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_iseqz_int32]
ATSinline()
atstype_bool
atspre_g0int_isneqz_int32 (atstype_int32 x)
{
  return (x != 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isneqz_int32]
ATSinline()
atstype_bool
atspre_g0int_lt_int32
(
  atstype_int32 x1, atstype_int32 x2
) {
  return (x1 < x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_lt_int32]
ATSinline()
atstype_bool
atspre_g0int_lte_int32
(
  atstype_int32 x1, atstype_int32 x2
) {
  return (x1 <= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_lte_int32]
ATSinline()
atstype_bool
atspre_g0int_gt_int32
(
  atstype_int32 x1, atstype_int32 x2
) {
  return (x1 > x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_gt_int32]
ATSinline()
atstype_bool
atspre_g0int_gte_int32
(
  atstype_int32 x1, atstype_int32 x2
) {
  return (x1 >= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_gte_int32]
ATSinline()
atstype_bool
atspre_g0int_eq_int32
(
  atstype_int32 x1, atstype_int32 x2
) {
  return (x1 == x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_eq_int32]
ATSinline()
atstype_bool
atspre_g0int_neq_int32
(
  atstype_int32 x1, atstype_int32 x2
) {
  return (x1 != x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_neq_int32]
ATSinline()
atstype_int64
atspre_g0int_neg_int64
  (atstype_int64 x) { return (-x) ; }
// end of [atspre_g0int_neg_int64]
ATSinline()
atstype_int64
atspre_g0int_succ_int64
  (atstype_int64 x) { return (x + 1) ; }
// end of [atspre_g0int_succ_int64]
ATSinline()
atstype_int64
atspre_g0int_pred_int64
  (atstype_int64 x) { return (x - 1) ; }
// end of [atspre_g0int_pred_int64]
ATSinline()
atstype_int64
atspre_g0int_half_int64
  (atstype_int64 x) { return (x / 2) ; }
// end of [atspre_g0int_half_int64]
ATSinline()
atstype_int64
atspre_g0int_add_int64
  (atstype_int64 x1, atstype_int64 x2) { return (x1 + x2) ; }
// end of [atspre_g0int_add_int64]
ATSinline()
atstype_int64
atspre_g0int_sub_int64
  (atstype_int64 x1, atstype_int64 x2) { return (x1 - x2) ; }
// end of [atspre_g0int_sub_int64]
ATSinline()
atstype_int64
atspre_g0int_mul_int64
  (atstype_int64 x1, atstype_int64 x2) { return (x1 * x2) ; }
// end of [atspre_g0int_mul_int64]
ATSinline()
atstype_int64
atspre_g0int_div_int64
  (atstype_int64 x1, atstype_int64 x2) { return (x1 / x2) ; }
// end of [atspre_g0int_div_int64]
ATSinline()
atstype_int64
atspre_g0int_mod_int64
  (atstype_int64 x1, atstype_int64 x2) { return (x1 % x2) ; }
// end of [atspre_g0int_mod_int64]
ATSinline()
atstype_bool
atspre_g0int_isltz_int64 (atstype_int64 x)
{
  return (x < 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isltz_int64]
ATSinline()
atstype_bool
atspre_g0int_isltez_int64 (atstype_int64 x)
{
  return (x <= 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isltez_int64]
ATSinline()
atstype_bool
atspre_g0int_isgtz_int64 (atstype_int64 x)
{
  return (x > 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isgtz_int64]
ATSinline()
atstype_bool
atspre_g0int_isgtez_int64 (atstype_int64 x)
{
  return (x >= 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isgtez_int64]
ATSinline()
atstype_bool
atspre_g0int_iseqz_int64 (atstype_int64 x)
{
  return (x == 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_iseqz_int64]
ATSinline()
atstype_bool
atspre_g0int_isneqz_int64 (atstype_int64 x)
{
  return (x != 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_isneqz_int64]
ATSinline()
atstype_bool
atspre_g0int_lt_int64
(
  atstype_int64 x1, atstype_int64 x2
) {
  return (x1 < x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_lt_int64]
ATSinline()
atstype_bool
atspre_g0int_lte_int64
(
  atstype_int64 x1, atstype_int64 x2
) {
  return (x1 <= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_lte_int64]
ATSinline()
atstype_bool
atspre_g0int_gt_int64
(
  atstype_int64 x1, atstype_int64 x2
) {
  return (x1 > x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_gt_int64]
ATSinline()
atstype_bool
atspre_g0int_gte_int64
(
  atstype_int64 x1, atstype_int64 x2
) {
  return (x1 >= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_gte_int64]
ATSinline()
atstype_bool
atspre_g0int_eq_int64
(
  atstype_int64 x1, atstype_int64 x2
) {
  return (x1 == x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_eq_int64]
ATSinline()
atstype_bool
atspre_g0int_neq_int64
(
  atstype_int64 x1, atstype_int64 x2
) {
  return (x1 != x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0int_neq_int64]
//
/* ****** ****** */
//
#define atspre_g0int2uint_int8_uint(x) ((atstype_uint)(x))
#define atspre_g0int2uint_int16_uint(x) ((atstype_uint)(x))
#define atspre_g0int2uint_int32_uint(x) ((atstype_uint)(x))
#define atspre_g0int2uint_int64_uint(x) ((atstype_uint)(x))
//
#define atspre_g0uint2int_uint8_int(x) ((atstype_int)(x))
#define atspre_g0uint2int_uint16_int(x) ((atstype_int)(x))
#define atspre_g0uint2int_uint32_int(x) ((atstype_int)(x))
#define atspre_g0uint2int_uint64_int(x) ((atstype_int)(x))
//
#define atspre_g0uint2uint_uint8_uint(x) ((atstype_uint)(x))
#define atspre_g0uint2uint_uint16_uint(x) ((atstype_uint)(x))
#define atspre_g0uint2uint_uint32_uint(x) ((atstype_uint)(x))
#define atspre_g0uint2uint_uint64_uint(x) ((atstype_uint)(x))
//
/* ****** ****** */

ATSinline()
atstype_uint8
atspre_g0uint_succ_uint8
  (atstype_uint8 x) { return (x + 1) ; }
// end of [atspre_g0uint_succ_uint8]
ATSinline()
atstype_uint8
atspre_g0uint_pred_uint8
  (atstype_uint8 x) { return (x - 1) ; }
// end of [atspre_g0uint_pred_uint8]
ATSinline()
atstype_uint8
atspre_g0uint_half_uint8
  (atstype_uint8 x) { return (x >> 1) ; }
// end of [atspre_g0uint_pred_uint8]
ATSinline()
atstype_uint8
atspre_g0uint_add_uint8
  (atstype_uint8 x1, atstype_uint8 x2) { return (x1 + x2) ; }
// end of [atspre_g0uint_add_uint8]
ATSinline()
atstype_uint8
atspre_g0uint_sub_uint8
  (atstype_uint8 x1, atstype_uint8 x2) { return (x1 - x2) ; }
// end of [atspre_g0uint_sub_uint8]
ATSinline()
atstype_uint8
atspre_g0uint_mul_uint8
  (atstype_uint8 x1, atstype_uint8 x2) { return (x1 * x2) ; }
// end of [atspre_g0uint_mul_uint8]
ATSinline()
atstype_uint8
atspre_g0uint_div_uint8
  (atstype_uint8 x1, atstype_uint8 x2) { return (x1 / x2) ; }
// end of [atspre_g0uint_div_uint8]
ATSinline()
atstype_uint8
atspre_g0uint_mod_uint8
  (atstype_uint8 x1, atstype_uint8 x2) { return (x1 % x2) ; }
// end of [atspre_g0uint_mod_uint8]
ATSinline()
atstype_uint8
atspre_g0uint_lsl_uint8
  (atstype_uint8 x, atstype_int n) { return (x << n) ; }
// end of [atspre_g0uint_lsl_uint8]
ATSinline()
atstype_uint8
atspre_g0uint_lsr_uint8
  (atstype_uint8 x, atstype_int n) { return (x >> n) ; }
// end of [atspre_g0uint_lsr_uint8]
ATSinline()
atstype_uint8
atspre_g0uint_lnot_uint8
  (atstype_uint8 x) { return ~(x) ; }
// end of [atspre_g0uint_lnot_uint8]
ATSinline()
atstype_uint8
atspre_g0uint_lor_uint8
  (atstype_uint8 x, atstype_uint8 y) { return (x | y) ; }
// end of [atspre_g0uint_uint8_uint8]
ATSinline()
atstype_uint8
atspre_g0uint_land_uint8
  (atstype_uint8 x, atstype_uint8 y) { return (x & y) ; }
// end of [atspre_g0uint_uint8_uint8]
ATSinline()
atstype_uint8
atspre_g0uint_lxor_uint8
  (atstype_uint8 x, atstype_uint8 y) { return (x ^ y) ; }
// end of [atspre_g0uint_uint8_uint8]
ATSinline()
atstype_bool
atspre_g0uint_isgtz_uint8 (atstype_uint8 x)
{
  return (x > 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_isgtz_uint8]
ATSinline()
atstype_bool
atspre_g0uint_iseqz_uint8 (atstype_uint8 x)
{
  return (x == 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_iseqz_uint8]
ATSinline()
atstype_bool
atspre_g0uint_isneqz_uint8 (atstype_uint8 x)
{
  return (x != 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_isneqz_uint8]
ATSinline()
atstype_bool
atspre_g0uint_lt_uint8
(
  atstype_uint8 x1, atstype_uint8 x2
) {
  return (x1 < x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_lt_uint8]
ATSinline()
atstype_bool
atspre_g0uint_lte_uint8
(
  atstype_uint8 x1, atstype_uint8 x2
) {
  return (x1 <= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_lte_uint8]
ATSinline()
atstype_bool
atspre_g0uint_gt_uint8
(
  atstype_uint8 x1, atstype_uint8 x2
) {
  return (x1 > x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_gt_uint8]
ATSinline()
atstype_bool
atspre_g0uint_gte_uint8
(
  atstype_uint8 x1, atstype_uint8 x2
) {
  return (x1 >= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_gte_uint8]
ATSinline()
atstype_bool
atspre_g0uint_eq_uint8
(
  atstype_uint8 x1, atstype_uint8 x2
) {
  return (x1 == x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_eq_uint8]
ATSinline()
atstype_bool
atspre_g0uint_neq_uint8
(
  atstype_uint8 x1, atstype_uint8 x2
) {
  return (x1 != x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_neq_uint8]
ATSinline()
atstype_uint16
atspre_g0uint_succ_uint16
  (atstype_uint16 x) { return (x + 1) ; }
// end of [atspre_g0uint_succ_uint16]
ATSinline()
atstype_uint16
atspre_g0uint_pred_uint16
  (atstype_uint16 x) { return (x - 1) ; }
// end of [atspre_g0uint_pred_uint16]
ATSinline()
atstype_uint16
atspre_g0uint_half_uint16
  (atstype_uint16 x) { return (x >> 1) ; }
// end of [atspre_g0uint_pred_uint16]
ATSinline()
atstype_uint16
atspre_g0uint_add_uint16
  (atstype_uint16 x1, atstype_uint16 x2) { return (x1 + x2) ; }
// end of [atspre_g0uint_add_uint16]
ATSinline()
atstype_uint16
atspre_g0uint_sub_uint16
  (atstype_uint16 x1, atstype_uint16 x2) { return (x1 - x2) ; }
// end of [atspre_g0uint_sub_uint16]
ATSinline()
atstype_uint16
atspre_g0uint_mul_uint16
  (atstype_uint16 x1, atstype_uint16 x2) { return (x1 * x2) ; }
// end of [atspre_g0uint_mul_uint16]
ATSinline()
atstype_uint16
atspre_g0uint_div_uint16
  (atstype_uint16 x1, atstype_uint16 x2) { return (x1 / x2) ; }
// end of [atspre_g0uint_div_uint16]
ATSinline()
atstype_uint16
atspre_g0uint_mod_uint16
  (atstype_uint16 x1, atstype_uint16 x2) { return (x1 % x2) ; }
// end of [atspre_g0uint_mod_uint16]
ATSinline()
atstype_uint16
atspre_g0uint_lsl_uint16
  (atstype_uint16 x, atstype_int n) { return (x << n) ; }
// end of [atspre_g0uint_lsl_uint16]
ATSinline()
atstype_uint16
atspre_g0uint_lsr_uint16
  (atstype_uint16 x, atstype_int n) { return (x >> n) ; }
// end of [atspre_g0uint_lsr_uint16]
ATSinline()
atstype_uint16
atspre_g0uint_lnot_uint16
  (atstype_uint16 x) { return ~(x) ; }
// end of [atspre_g0uint_lnot_uint16]
ATSinline()
atstype_uint16
atspre_g0uint_lor_uint16
  (atstype_uint16 x, atstype_uint16 y) { return (x | y) ; }
// end of [atspre_g0uint_uint16_uint16]
ATSinline()
atstype_uint16
atspre_g0uint_land_uint16
  (atstype_uint16 x, atstype_uint16 y) { return (x & y) ; }
// end of [atspre_g0uint_uint16_uint16]
ATSinline()
atstype_uint16
atspre_g0uint_lxor_uint16
  (atstype_uint16 x, atstype_uint16 y) { return (x ^ y) ; }
// end of [atspre_g0uint_uint16_uint16]
ATSinline()
atstype_bool
atspre_g0uint_isgtz_uint16 (atstype_uint16 x)
{
  return (x > 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_isgtz_uint16]
ATSinline()
atstype_bool
atspre_g0uint_iseqz_uint16 (atstype_uint16 x)
{
  return (x == 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_iseqz_uint16]
ATSinline()
atstype_bool
atspre_g0uint_isneqz_uint16 (atstype_uint16 x)
{
  return (x != 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_isneqz_uint16]
ATSinline()
atstype_bool
atspre_g0uint_lt_uint16
(
  atstype_uint16 x1, atstype_uint16 x2
) {
  return (x1 < x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_lt_uint16]
ATSinline()
atstype_bool
atspre_g0uint_lte_uint16
(
  atstype_uint16 x1, atstype_uint16 x2
) {
  return (x1 <= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_lte_uint16]
ATSinline()
atstype_bool
atspre_g0uint_gt_uint16
(
  atstype_uint16 x1, atstype_uint16 x2
) {
  return (x1 > x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_gt_uint16]
ATSinline()
atstype_bool
atspre_g0uint_gte_uint16
(
  atstype_uint16 x1, atstype_uint16 x2
) {
  return (x1 >= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_gte_uint16]
ATSinline()
atstype_bool
atspre_g0uint_eq_uint16
(
  atstype_uint16 x1, atstype_uint16 x2
) {
  return (x1 == x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_eq_uint16]
ATSinline()
atstype_bool
atspre_g0uint_neq_uint16
(
  atstype_uint16 x1, atstype_uint16 x2
) {
  return (x1 != x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_neq_uint16]
ATSinline()
atstype_uint32
atspre_g0uint_succ_uint32
  (atstype_uint32 x) { return (x + 1) ; }
// end of [atspre_g0uint_succ_uint32]
ATSinline()
atstype_uint32
atspre_g0uint_pred_uint32
  (atstype_uint32 x) { return (x - 1) ; }
// end of [atspre_g0uint_pred_uint32]
ATSinline()
atstype_uint32
atspre_g0uint_half_uint32
  (atstype_uint32 x) { return (x >> 1) ; }
// end of [atspre_g0uint_pred_uint32]
ATSinline()
atstype_uint32
atspre_g0uint_add_uint32
  (atstype_uint32 x1, atstype_uint32 x2) { return (x1 + x2) ; }
// end of [atspre_g0uint_add_uint32]
ATSinline()
atstype_uint32
atspre_g0uint_sub_uint32
  (atstype_uint32 x1, atstype_uint32 x2) { return (x1 - x2) ; }
// end of [atspre_g0uint_sub_uint32]
ATSinline()
atstype_uint32
atspre_g0uint_mul_uint32
  (atstype_uint32 x1, atstype_uint32 x2) { return (x1 * x2) ; }
// end of [atspre_g0uint_mul_uint32]
ATSinline()
atstype_uint32
atspre_g0uint_div_uint32
  (atstype_uint32 x1, atstype_uint32 x2) { return (x1 / x2) ; }
// end of [atspre_g0uint_div_uint32]
ATSinline()
atstype_uint32
atspre_g0uint_mod_uint32
  (atstype_uint32 x1, atstype_uint32 x2) { return (x1 % x2) ; }
// end of [atspre_g0uint_mod_uint32]
ATSinline()
atstype_uint32
atspre_g0uint_lsl_uint32
  (atstype_uint32 x, atstype_int n) { return (x << n) ; }
// end of [atspre_g0uint_lsl_uint32]
ATSinline()
atstype_uint32
atspre_g0uint_lsr_uint32
  (atstype_uint32 x, atstype_int n) { return (x >> n) ; }
// end of [atspre_g0uint_lsr_uint32]
ATSinline()
atstype_uint32
atspre_g0uint_lnot_uint32
  (atstype_uint32 x) { return ~(x) ; }
// end of [atspre_g0uint_lnot_uint32]
ATSinline()
atstype_uint32
atspre_g0uint_lor_uint32
  (atstype_uint32 x, atstype_uint32 y) { return (x | y) ; }
// end of [atspre_g0uint_uint32_uint32]
ATSinline()
atstype_uint32
atspre_g0uint_land_uint32
  (atstype_uint32 x, atstype_uint32 y) { return (x & y) ; }
// end of [atspre_g0uint_uint32_uint32]
ATSinline()
atstype_uint32
atspre_g0uint_lxor_uint32
  (atstype_uint32 x, atstype_uint32 y) { return (x ^ y) ; }
// end of [atspre_g0uint_uint32_uint32]
ATSinline()
atstype_bool
atspre_g0uint_isgtz_uint32 (atstype_uint32 x)
{
  return (x > 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_isgtz_uint32]
ATSinline()
atstype_bool
atspre_g0uint_iseqz_uint32 (atstype_uint32 x)
{
  return (x == 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_iseqz_uint32]
ATSinline()
atstype_bool
atspre_g0uint_isneqz_uint32 (atstype_uint32 x)
{
  return (x != 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_isneqz_uint32]
ATSinline()
atstype_bool
atspre_g0uint_lt_uint32
(
  atstype_uint32 x1, atstype_uint32 x2
) {
  return (x1 < x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_lt_uint32]
ATSinline()
atstype_bool
atspre_g0uint_lte_uint32
(
  atstype_uint32 x1, atstype_uint32 x2
) {
  return (x1 <= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_lte_uint32]
ATSinline()
atstype_bool
atspre_g0uint_gt_uint32
(
  atstype_uint32 x1, atstype_uint32 x2
) {
  return (x1 > x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_gt_uint32]
ATSinline()
atstype_bool
atspre_g0uint_gte_uint32
(
  atstype_uint32 x1, atstype_uint32 x2
) {
  return (x1 >= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_gte_uint32]
ATSinline()
atstype_bool
atspre_g0uint_eq_uint32
(
  atstype_uint32 x1, atstype_uint32 x2
) {
  return (x1 == x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_eq_uint32]
ATSinline()
atstype_bool
atspre_g0uint_neq_uint32
(
  atstype_uint32 x1, atstype_uint32 x2
) {
  return (x1 != x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_neq_uint32]
ATSinline()
atstype_uint64
atspre_g0uint_succ_uint64
  (atstype_uint64 x) { return (x + 1) ; }
// end of [atspre_g0uint_succ_uint64]
ATSinline()
atstype_uint64
atspre_g0uint_pred_uint64
  (atstype_uint64 x) { return (x - 1) ; }
// end of [atspre_g0uint_pred_uint64]
ATSinline()
atstype_uint64
atspre_g0uint_half_uint64
  (atstype_uint64 x) { return (x >> 1) ; }
// end of [atspre_g0uint_pred_uint64]
ATSinline()
atstype_uint64
atspre_g0uint_add_uint64
  (atstype_uint64 x1, atstype_uint64 x2) { return (x1 + x2) ; }
// end of [atspre_g0uint_add_uint64]
ATSinline()
atstype_uint64
atspre_g0uint_sub_uint64
  (atstype_uint64 x1, atstype_uint64 x2) { return (x1 - x2) ; }
// end of [atspre_g0uint_sub_uint64]
ATSinline()
atstype_uint64
atspre_g0uint_mul_uint64
  (atstype_uint64 x1, atstype_uint64 x2) { return (x1 * x2) ; }
// end of [atspre_g0uint_mul_uint64]
ATSinline()
atstype_uint64
atspre_g0uint_div_uint64
  (atstype_uint64 x1, atstype_uint64 x2) { return (x1 / x2) ; }
// end of [atspre_g0uint_div_uint64]
ATSinline()
atstype_uint64
atspre_g0uint_mod_uint64
  (atstype_uint64 x1, atstype_uint64 x2) { return (x1 % x2) ; }
// end of [atspre_g0uint_mod_uint64]
ATSinline()
atstype_uint64
atspre_g0uint_lsl_uint64
  (atstype_uint64 x, atstype_int n) { return (x << n) ; }
// end of [atspre_g0uint_lsl_uint64]
ATSinline()
atstype_uint64
atspre_g0uint_lsr_uint64
  (atstype_uint64 x, atstype_int n) { return (x >> n) ; }
// end of [atspre_g0uint_lsr_uint64]
ATSinline()
atstype_uint64
atspre_g0uint_lnot_uint64
  (atstype_uint64 x) { return ~(x) ; }
// end of [atspre_g0uint_lnot_uint64]
ATSinline()
atstype_uint64
atspre_g0uint_lor_uint64
  (atstype_uint64 x, atstype_uint64 y) { return (x | y) ; }
// end of [atspre_g0uint_uint64_uint64]
ATSinline()
atstype_uint64
atspre_g0uint_land_uint64
  (atstype_uint64 x, atstype_uint64 y) { return (x & y) ; }
// end of [atspre_g0uint_uint64_uint64]
ATSinline()
atstype_uint64
atspre_g0uint_lxor_uint64
  (atstype_uint64 x, atstype_uint64 y) { return (x ^ y) ; }
// end of [atspre_g0uint_uint64_uint64]
ATSinline()
atstype_bool
atspre_g0uint_isgtz_uint64 (atstype_uint64 x)
{
  return (x > 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_isgtz_uint64]
ATSinline()
atstype_bool
atspre_g0uint_iseqz_uint64 (atstype_uint64 x)
{
  return (x == 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_iseqz_uint64]
ATSinline()
atstype_bool
atspre_g0uint_isneqz_uint64 (atstype_uint64 x)
{
  return (x != 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_isneqz_uint64]
ATSinline()
atstype_bool
atspre_g0uint_lt_uint64
(
  atstype_uint64 x1, atstype_uint64 x2
) {
  return (x1 < x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_lt_uint64]
ATSinline()
atstype_bool
atspre_g0uint_lte_uint64
(
  atstype_uint64 x1, atstype_uint64 x2
) {
  return (x1 <= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_lte_uint64]
ATSinline()
atstype_bool
atspre_g0uint_gt_uint64
(
  atstype_uint64 x1, atstype_uint64 x2
) {
  return (x1 > x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_gt_uint64]
ATSinline()
atstype_bool
atspre_g0uint_gte_uint64
(
  atstype_uint64 x1, atstype_uint64 x2
) {
  return (x1 >= x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_gte_uint64]
ATSinline()
atstype_bool
atspre_g0uint_eq_uint64
(
  atstype_uint64 x1, atstype_uint64 x2
) {
  return (x1 == x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_eq_uint64]
ATSinline()
atstype_bool
atspre_g0uint_neq_uint64
(
  atstype_uint64 x1, atstype_uint64 x2
) {
  return (x1 != x2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0uint_neq_uint64]
//
/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_INTEGER_FIXED

/* ****** ****** */

/* end of [integer_fixed.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/option.atxt
** Time of generation: Sat Oct 17 15:20:04 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: January, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_OPTION
#define ATSLIB_PRELUDE_CATS_OPTION

/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_OPTION

/* ****** ****** */

/* end of [option.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/string.atxt
** Time of generation: Sat Oct 17 15:20:03 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: April, 2012 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_STRING
#define ATSLIB_PRELUDE_CATS_STRING

/* ****** ****** */
//
// [string.h]
//
extern
size_t strlen (const char *str) ;
extern
int // (sign)
strcmp (const char *x1, const char *x2) ;
//
extern
char *strchr(const char *str1, int c2) ;
extern
char *strrchr(const char *str1, int c2) ;
extern
char *strstr(const char *str1, const char *str2) ;
//
extern
size_t strspn(const char *str1, const char *acc2) ;
extern
size_t strcspn(const char *str1, const char *rej2) ;
//
#ifndef memcpy
extern
void *memcpy(void *dest, const void *src, size_t n) ;
#endif // #ifndef
//
/* ****** ****** */

#define atspre_stropt_none() atsptr_null

/* ****** ****** */

ATSinline()
atstype_bool
atspre_lt_string_string (
  atstype_string x1, atstype_string x2
) {
  return (strcmp((char*)x1, (char*)x2) < 0 ? atsbool_true : atsbool_false) ;
} // [atspre_lt_string_string]

ATSinline()
atstype_bool
atspre_lte_string_string (
  atstype_string x1, atstype_string x2
) {
  return (strcmp((char*)x1, (char*)x2) <= 0 ? atsbool_true : atsbool_false) ;
} // [atspre_lte_string_string]

ATSinline()
atstype_bool
atspre_gt_string_string(
  atstype_string x1, atstype_string x2
) {
  return (strcmp((char*)x1, (char*)x2) > 0 ? atsbool_true : atsbool_false) ;
} // [atspre_gt_string_string]

ATSinline()
atstype_bool
atspre_gte_string_string (
  atstype_string x1, atstype_string x2
) {
  return (strcmp((char*)x1, (char*)x2) >= 0 ? atsbool_true : atsbool_false) ;
} // [atspre_gte_string_string]

ATSinline()
atstype_bool
atspre_eq_string_string (
  atstype_string x1, atstype_string x2
) {
  return (strcmp((char*)x1, (char*)x2)==0 ? atsbool_true : atsbool_false) ;
} // [atspre_eq_string_string]

ATSinline()
atstype_bool
atspre_neq_string_string (
  atstype_string x1, atstype_string x2
) {
  return (strcmp((char*)x1, (char*)x2)!=0 ? atsbool_true : atsbool_false) ;
} // [atspre_neq_string_string]

/* ****** ****** */

#define atspre_string_equal atspre_eq_string_string
#define atspre_string_noteq atspre_neq_string_string

/* ****** ****** */

ATSinline()
atstype_int
atspre_compare_string_string
  (atstype_string x1, atstype_string x2) { return strcmp((char*)x1, (char*)x2) ; }
// [atspre_compare_string_string]

/* ****** ****** */

#define atspre_strlen strlen
#define atspre_strchr strchr
#define atspre_strrchr strrchr
#define atspre_strstr strstr
#define atspre_strspn strspn
#define atspre_strcspn strcspn

#define atspre_string_memcpy memcpy

/* ****** ****** */
//
// HX-2013-09: declared in [stdio.h]
//
#ifndef snprintf
extern
int snprintf (char *str, size_t size, const char *format, ...) ;
#endif // end of [ifndef]
//
/* ****** ****** */
//
ATSinline()
atstype_string
atspre_g0int2string_int
  (atstype_int x)
{
  size_t n0 ;
  char *res ;
  size_t ntot ;
  n0 = 4 ;
  res = ATS_MALLOC(n0) ;
  ntot = snprintf(res, n0, "%i", x) ;
  if (ntot >= n0)
  {
    ATS_MFREE(res) ;
    res = (char*)ATS_MALLOC(ntot+1) ;
    ntot = snprintf(res, ntot+1, "%i", x) ;
  }
  return res ;
}
//
ATSinline()
atstype_string
atspre_g0int2string_lint
  (atstype_lint x)
{
  size_t n0 ;
  char *res ;
  size_t ntot ;
  n0 = 4 ;
  res = ATS_MALLOC(n0) ;
  ntot = snprintf(res, n0, "%li", x) ;
  if (ntot >= n0)
  {
    ATS_MFREE(res) ;
    res = (char*)ATS_MALLOC(ntot+1) ;
    ntot = snprintf(res, ntot+1, "%li", x) ;
  }
  return res ;
}
//
ATSinline()
atstype_string
atspre_g0int2string_llint
  (atstype_llint x)
{
  size_t n0 ;
  char *res ;
  size_t ntot ;
  n0 = 8 ;
  res = ATS_MALLOC(n0) ;
  ntot = snprintf(res, n0, "%lli", x) ;
  if (ntot >= n0)
  {
    ATS_MFREE(res) ;
    res = (char*)ATS_MALLOC(ntot+1) ;
    ntot = snprintf(res, ntot+1, "%lli", x) ;
  }
  return res ;
}
//
/* ****** ****** */
//
#include <stdarg.h>
//
// HX-2013-11:
// these are implemented in [string.dats]
//
extern
atstype_string // Strptr0
atspre_string_make_snprintf(atstype_string fmt, ...) ;
extern
atstype_string // Strptr0
atspre_string_make_vsnprintf
  (atstype_size bsz0, atstype_string fmt, va_list ap0) ;
//
/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_STRING

/* ****** ****** */

/* end of [string.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/filebas.atxt
** Time of generation: Sat Oct 17 15:20:03 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: January, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_FILEBAS
#define ATSLIB_PRELUDE_CATS_FILEBAS

/* ****** ****** */

#include <stdio.h>
#include <string.h>
#include <sys/stat.h>

/* ****** ****** */

#define atspre_FILE_stdin stdin
#define atspre_FILE_stdout stdout
#define atspre_FILE_stderr stderr

/* ****** ****** */

#define atspre_file_mode_r "r"
#define atspre_file_mode_rr "r+"
#define atspre_file_mode_w "w"
#define atspre_file_mode_ww "w+"
#define atspre_file_mode_a "a"
#define atspre_file_mode_aa "a+"

/* ****** ****** */

ATSinline()
atstype_bool
atspre_test_file_exists
  (atstype_string path)
{
  int err;
  struct stat st ;
  err = stat ((const char*)path, &st) ;
  return (err==0) ? atsbool_true : atsbool_false ;
} // end of [atspre_test_file_exists]

/* ****** ****** */

ATSinline()
atstype_int
atspre_test_file_mode_fun
(
  atstype_string path, atstype_funptr pred
)
{
  int err;
  struct stat st ;
  err = stat ((const char*)path, &st) ;
  if (err < 0) return -1 ;
  return ((atstype_bool(*)(atstype_uint))(pred))(st.st_mode) ? 1 : 0 ;
}

/* ****** ****** */

ATSinline()
atstype_bool
atspre_test_file_isreg
  (atstype_string path)
{
  int err;
  struct stat st ;
  err = stat ((const char*)path, &st) ;
  if (err < 0) return -1 ;
  return (S_ISREG(st.st_mode)) ? 1 : 0 ;
} // end of [atspre_test_file_isreg]

/* ****** ****** */

ATSinline()
atstype_int
atspre_test_file_isdir
  (atstype_string path)
{
  int err;
  struct stat st ;
  err = stat ((const char*)path, &st) ;
  if (err < 0) return -1 ;
  return (S_ISDIR(st.st_mode)) ? 1 : 0 ;
} // end of [atspre_test_file_isdir]

/* ****** ****** */

ATSinline()
atstype_int
atspre_test_file_isblk
  (atstype_string path)
{
  int err;
  struct stat st ;
  err = stat ((const char*)path, &st) ;
  if (err < 0) return -1 ;
  return (S_ISBLK(st.st_mode)) ? 1 : 0 ;
} // end of [atspre_test_file_isblk]

/* ****** ****** */

ATSinline()
atstype_int
atspre_test_file_ischr
  (atstype_string path)
{
  int err;
  struct stat st ;
  err = stat ((const char*)path, &st) ;
  if (err < 0) return -1 ;
  return (S_ISCHR(st.st_mode)) ? 1 : 0 ;
} // end of [atspre_test_file_ischr]

/* ****** ****** */

ATSinline()
atstype_int
atspre_test_file_isfifo
  (atstype_string path)
{
  int err;
  struct stat st ;
  err = stat ((const char*)path, &st) ;
  if (err < 0) return -1 ;
  return (S_ISFIFO(st.st_mode)) ? 1 : 0 ;
} // end of [atspre_test_file_isfifo]

/* ****** ****** */

ATSinline()
atstype_ref
atspre_fileref_open_exn
  (atstype_string path, atstype_string fm)
{
  FILE* filr ;
  filr = fopen((char*)path, (char*)fm) ;
  if (!filr) {
    fprintf(
      stderr
    , "exit(ATS): [atspre_fileref_open_exn(%s, %s)] failed.\n"
    , (char*)path, (char*)fm
    ) ;
    exit(1) ;
  }
  return filr ;
} // end of [atspre_fileref_open]

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_fileref_close
  (atstype_ref filr)
{
  int err ;
  err = fclose((FILE*)filr) ;
  if (err < 0) {
    fprintf(
      stderr
    , "exit(ATS): [atspre_fileref_close] failed.\n"
    ) ;
    exit(1) ;
  }
  return ;
} // end of [atspre_fileref_close]

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_fileref_flush
  (atstype_ref filr)
{
  int err ;
  err = fflush((FILE*)filr) ;
  if (err < 0) {
    fprintf(
      stderr
    , "exit(ATS): [atspre_fileref_fflush] failed.\n"
    ) ;
    exit(1) ;
  }
  return ;
} // end of [atspre_fileref_flush]

/* ****** ****** */

ATSinline()
atstype_int
atspre_fileref_getc
  (atstype_ref filr) { return fgetc((FILE*)filr) ; }
// end of [atspre_fileref_getc]

/* ****** ****** */
//
ATSinline()
atsvoid_t0ype
atspre_fileref_putc
(
  atstype_ref filr, atstype_int c
) {
  fputc (c, (FILE*)filr) ; return ;
} // end of [atspre_fileref_putc]
//
#define atspre_fileref_putc_int atspre_fileref_putc
#define atspre_fileref_putc_char atspre_fileref_putc
//
/* ****** ****** */

ATSinline()
atsvoid_t0ype
atspre_fileref_puts
(
  atstype_ref filr, atstype_ptr cs
) {
  fputs ((char*)cs, (FILE*)filr) ; return ;
} // end of [atspre_fileref_puts]

/* ****** ****** */

ATSinline()
atstype_bool
atspre_fileref_is_eof
  (atstype_ref filr)
{
  int eof ;
  eof = feof ((FILE*)filr) ;
  return (eof != 0 ? atsbool_true : atsbool_false) ;
} // end of [atspre_fileref_is_eof]

/* ****** ****** */

ATSinline()
atstype_bool
atspre_fileref_load_int
  (atstype_ref inp, atstype_ref x)
{
  int n ;
  n = fscanf((FILE*)inp, "%i", (atstype_int*)x) ;
  return (n == 1 ? atsbool_true : atsbool_false) ;
} // end of [atspre_fileref_load_int]

ATSinline()
atstype_bool
atspre_fileref_load_lint
  (atstype_ref inp, atstype_ref x)
{
  int n ;
  n = fscanf((FILE*)inp, "%li", (atstype_lint*)x) ;
  return (n == 1 ? atsbool_true : atsbool_false) ;
} // end of [atspre_fileref_load_lint]

/* ****** ****** */

ATSinline()
atstype_bool
atspre_fileref_load_uint
  (atstype_ref inp, atstype_ref x)
{
  int n ;
  n = fscanf((FILE*)inp, "%u", (atstype_uint*)x) ;
  return (n == 1 ? atsbool_true : atsbool_false) ;
} // end of [atspre_fileref_load_uint]

ATSinline()
atstype_bool
atspre_fileref_load_ulint
  (atstype_ref inp, atstype_ref x)
{
  int n ;
  n = fscanf((FILE*)inp, "%lu", (atstype_ulint*)x) ;
  return (n == 1 ? atsbool_true : atsbool_false) ;
} // end of [atspre_fileref_load_ulint]

/* ****** ****** */

ATSinline()
atstype_bool
atspre_fileref_load_float
  (atstype_ref inp, atstype_ref x)
{
  int n ;
  n = fscanf((FILE*)inp, "%f", (atstype_float*)x) ;
  return (n == 1 ? atsbool_true : atsbool_false) ;
} // end of [atspre_fileref_load_float]

ATSinline()
atstype_bool
atspre_fileref_load_double
  (atstype_ref inp, atstype_ref x)
{
  int n ;
  n = fscanf((FILE*)inp, "%lf", (atstype_double*)x) ;
  return (n == 1 ? atsbool_true : atsbool_false) ;
} // end of [atspre_fileref_load_double]

/* ****** ****** */

extern
atstype_ptr
atspre_fileref_get_line_string_main2
(
  atstype_int bsz // int bsz
, atstype_ptr filp // FILE* filp
, atstype_ref nlen // int *nlen
) ; // endfun

/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_FILEBAS

/* ****** ****** */

/* end of [filebas.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/matrixref.atxt
** Time of generation: Sat Oct 17 15:20:05 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: January, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_MATRIXREF
#define ATSLIB_PRELUDE_CATS_MATRIXREF

/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_MATRIXREF

/* ****** ****** */

/* end of [matrixref.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/arrayref.atxt
** Time of generation: Sat Oct 17 15:20:04 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: January, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_ARRAYREF
#define ATSLIB_PRELUDE_CATS_ARRAYREF

/* ****** ****** */

ATSinline()
atstype_arrptr
atspre_arrayref_make_arrpsz
  (atstype_arrpsz psz) { return (psz).ptr ; }
// end of [atspre_arrayref_make_arrpsz]

/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_ARRAYREF

/* ****** ****** */

/* end of [arrayref.cats] */
/***********************************************************************/
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/***********************************************************************/

/* (*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*) */

/* ****** ****** */

/*
** Source:
** $PATSHOME/prelude/CATS/CODEGEN/float.atxt
** Time of generation: Sat Oct 17 15:20:02 2015
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: April, 2012 *)
*/

/* ****** ****** */

#ifndef ATSLIB_PRELUDE_CATS_FLOAT
#define ATSLIB_PRELUDE_CATS_FLOAT

/* ****** ****** */

ATSinline()
atstype_float
atspre_g0int2float_int_float
  (atstype_int x) { return ((atstype_float)x) ; }
// end of [atspre_g0int2float_int_float]

ATSinline()
atstype_double
atspre_g0int2float_int_double
  (atstype_int x) { return ((atstype_double)x) ; }
// end of [atspre_g0int2float_int_double]

ATSinline()
atstype_double
atspre_g0int2float_lint_double
  (atstype_lint x) { return ((atstype_double)x) ; }
// end of [atspre_g0int2float_lint_double]

/* ****** ****** */

ATSinline()
atstype_int
atspre_g0float2int_float_int
  (atstype_float x) { return ((atstype_int)x) ; }
ATSinline()
atstype_lint
atspre_g0float2int_float_lint
  (atstype_float x) { return ((atstype_lint)x) ; }
ATSinline()
atstype_llint
atspre_g0float2int_float_llint
  (atstype_float x) { return ((atstype_llint)x) ; }

ATSinline()
atstype_int
atspre_g0float2int_double_int
  (atstype_double x) { return ((atstype_int)x) ; }
ATSinline()
atstype_lint
atspre_g0float2int_double_lint
  (atstype_double x) { return ((atstype_lint)x) ; }
ATSinline()
atstype_llint
atspre_g0float2int_double_llint
  (atstype_double x) { return ((atstype_llint)x) ; }

/* ****** ****** */

ATSinline()
atstype_float
atspre_g0float2float_float_float (atstype_float x) { return (x) ; }

ATSinline()
atstype_double
atspre_g0float2float_double_double (atstype_double x) { return (x) ; }

ATSinline()
atstype_double
atspre_g0float2float_float_double
(
atstype_float x
)
{
 return ((atstype_double)x) ;
}

ATSinline()
atstype_float
atspre_g0float2float_double_float
(
atstype_double x
)
{
 return ((atstype_float)x) ;
}

/* ****** ****** */
//
extern double atof (const char *inp) ;
//
ATSinline()
atstype_int
atspre_g0string2float_double
  (atstype_string inp) { return atof((char*)inp) ; }
//
/* ****** ****** */

ATSinline()
atstype_float
atspre_g0float_neg_float (atstype_float f) { return (-f) ; }
ATSinline()
atstype_double
atspre_g0float_neg_double (atstype_double f) { return (-f) ; }
ATSinline()
atstype_ldouble
atspre_g0float_neg_ldouble (atstype_ldouble f) { return (-f) ; }

ATSinline()
atstype_float
atspre_g0float_abs_float (atstype_float f) { return (f >= 0 ? f : -f) ; }
ATSinline()
atstype_double
atspre_g0float_abs_double (atstype_double f) { return (f >= 0 ? f : -f) ; }
ATSinline()
atstype_ldouble
atspre_g0float_abs_ldouble (atstype_ldouble f) { return (f >= 0 ? f : -f) ; }

ATSinline()
atstype_float
atspre_g0float_succ_float (atstype_float f) { return (f+1) ; }
ATSinline()
atstype_double
atspre_g0float_succ_double (atstype_double f) { return (f+1) ; }
ATSinline()
atstype_ldouble
atspre_g0float_succ_ldouble (atstype_ldouble f) { return (f+1) ; }

ATSinline()
atstype_float
atspre_g0float_pred_float (atstype_float f) { return (f-1) ; }
ATSinline()
atstype_double
atspre_g0float_pred_double (atstype_double f) { return (f-1) ; }
ATSinline()
atstype_ldouble
atspre_g0float_pred_ldouble (atstype_ldouble f) { return (f-1) ; }

/* ****** ****** */

//
ATSinline()
atstype_float
atspre_g0float_add_float
  (atstype_float f1, atstype_float f2) { return (f1 + f2) ; }
// end of [atspre_g0float_add_float]
ATSinline()
atstype_float
atspre_g0float_sub_float
  (atstype_float f1, atstype_float f2) { return (f1 - f2) ; }
// end of [atspre_g0float_sub_float]
ATSinline()
atstype_float
atspre_g0float_mul_float
  (atstype_float f1, atstype_float f2) { return (f1 * f2) ; }
// end of [atspre_g0float_mul_float]
ATSinline()
atstype_float
atspre_g0float_div_float
  (atstype_float f1, atstype_float f2) { return (f1 / f2) ; }
// end of [atspre_g0float_div_float]
//
ATSinline()
atstype_double
atspre_g0float_add_double
  (atstype_double f1, atstype_double f2) { return (f1 + f2) ; }
// end of [atspre_g0float_add_double]
ATSinline()
atstype_double
atspre_g0float_sub_double
  (atstype_double f1, atstype_double f2) { return (f1 - f2) ; }
// end of [atspre_g0float_sub_double]
ATSinline()
atstype_double
atspre_g0float_mul_double
  (atstype_double f1, atstype_double f2) { return (f1 * f2) ; }
// end of [atspre_g0float_mul_double]
ATSinline()
atstype_double
atspre_g0float_div_double
  (atstype_double f1, atstype_double f2) { return (f1 / f2) ; }
// end of [atspre_g0float_div_double]
//
ATSinline()
atstype_ldouble
atspre_g0float_add_ldouble
  (atstype_ldouble f1, atstype_ldouble f2) { return (f1 + f2) ; }
// end of [atspre_g0float_add_ldouble]
ATSinline()
atstype_ldouble
atspre_g0float_sub_ldouble
  (atstype_ldouble f1, atstype_ldouble f2) { return (f1 - f2) ; }
// end of [atspre_g0float_sub_ldouble]
ATSinline()
atstype_ldouble
atspre_g0float_mul_ldouble
  (atstype_ldouble f1, atstype_ldouble f2) { return (f1 * f2) ; }
// end of [atspre_g0float_mul_ldouble]
ATSinline()
atstype_ldouble
atspre_g0float_div_ldouble
  (atstype_ldouble f1, atstype_ldouble f2) { return (f1 / f2) ; }
// end of [atspre_g0float_div_ldouble]
//
extern atstype_float fmodf (atstype_float, atstype_float) ;
extern atstype_double fmod (atstype_double, atstype_double) ;
extern atstype_ldouble fmodl (atstype_ldouble, atstype_ldouble) ;
//
ATSinline()
atstype_float
atspre_g0float_mod_float
  (atstype_float f1, atstype_float f2) { return fmodf(f1, f2) ; }
ATSinline()
atstype_double
atspre_g0float_mod_double
  (atstype_double f1, atstype_double f2) { return fmod(f1, f2) ; }
ATSinline()
atstype_ldouble
atspre_g0float_mod_ldouble
  (atstype_ldouble f1, atstype_ldouble f2) { return fmodl(f1, f2) ; }
//
/* ****** ****** */

//
ATSinline()
atstype_bool
atspre_g0float_lt_float
  (atstype_float f1, atstype_float f2) {
  return (f1 < f2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0float_lt_float]
ATSinline()
atstype_bool
atspre_g0float_lte_float
  (atstype_float f1, atstype_float f2) {
  return (f1 <= f2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0float_lte_float]
ATSinline()
atstype_bool
atspre_g0float_gt_float
  (atstype_float f1, atstype_float f2) {
  return (f1 > f2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0float_gt_float]
ATSinline()
atstype_bool
atspre_g0float_gte_float
  (atstype_float f1, atstype_float f2) {
  return (f1 >= f2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0float_gte_float]
ATSinline()
atstype_bool
atspre_g0float_eq_float
  (atstype_float f1, atstype_float f2) {
  return (f1 == f2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0float_eq_float]
ATSinline()
atstype_bool
atspre_g0float_neq_float
  (atstype_float f1, atstype_float f2) {
  return (f1 != f2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0float_neq_float]
//
ATSinline()
atstype_bool
atspre_g0float_lt_double
  (atstype_double f1, atstype_double f2) {
  return (f1 < f2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0float_lt_double]
ATSinline()
atstype_bool
atspre_g0float_lte_double
  (atstype_double f1, atstype_double f2) {
  return (f1 <= f2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0float_lte_double]
ATSinline()
atstype_bool
atspre_g0float_gt_double
  (atstype_double f1, atstype_double f2) {
  return (f1 > f2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0float_gt_double]
ATSinline()
atstype_bool
atspre_g0float_gte_double
  (atstype_double f1, atstype_double f2) {
  return (f1 >= f2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0float_gte_double]
ATSinline()
atstype_bool
atspre_g0float_eq_double
  (atstype_double f1, atstype_double f2) {
  return (f1 == f2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0float_eq_double]
ATSinline()
atstype_bool
atspre_g0float_neq_double
  (atstype_double f1, atstype_double f2) {
  return (f1 != f2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0float_neq_double]
//
ATSinline()
atstype_bool
atspre_g0float_lt_ldouble
  (atstype_ldouble f1, atstype_ldouble f2) {
  return (f1 < f2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0float_lt_ldouble]
ATSinline()
atstype_bool
atspre_g0float_lte_ldouble
  (atstype_ldouble f1, atstype_ldouble f2) {
  return (f1 <= f2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0float_lte_ldouble]
ATSinline()
atstype_bool
atspre_g0float_gt_ldouble
  (atstype_ldouble f1, atstype_ldouble f2) {
  return (f1 > f2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0float_gt_ldouble]
ATSinline()
atstype_bool
atspre_g0float_gte_ldouble
  (atstype_ldouble f1, atstype_ldouble f2) {
  return (f1 >= f2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0float_gte_ldouble]
ATSinline()
atstype_bool
atspre_g0float_eq_ldouble
  (atstype_ldouble f1, atstype_ldouble f2) {
  return (f1 == f2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0float_eq_ldouble]
ATSinline()
atstype_bool
atspre_g0float_neq_ldouble
  (atstype_ldouble f1, atstype_ldouble f2) {
  return (f1 != f2 ? atsbool_true : atsbool_false) ;
} // end of [atspre_g0float_neq_ldouble]
//
/* ****** ****** */

ATSinline()
atstype_int
atspre_g0float_compare_float
(
  atstype_float f1, atstype_float f2
)
{
  if (f1 > f2) return 1 ; else if (f1 < f2) return -1 ; else return 0 ;
} // end of [atspre_g0float_compare_float]

ATSinline()
atstype_int
atspre_g0float_compare_double
(
  atstype_double f1, atstype_double f2
)
{
  if (f1 > f2) return 1 ; else if (f1 < f2) return -1 ; else return 0 ;
} // end of [atspre_g0float_compare_double]

ATSinline()
atstype_int
atspre_g0float_compare_ldouble
(
  atstype_ldouble f1, atstype_ldouble f2
)
{
  if (f1 > f2) return 1 ; else if (f1 < f2) return -1 ; else return 0 ;
} // end of [atspre_g0float_compare_ldouble]

/* ****** ****** */

ATSinline()
atstype_float
atspre_g0float_min_float
  (atstype_float f1, atstype_float f2) { return (f1 <= f2 ? f1 : f2) ; }
// end of [atspre_g0float_min_float]
ATSinline()
atstype_double
atspre_g0float_min_double
  (atstype_double f1, atstype_double f2) { return (f1 <= f2 ? f1 : f2) ; }
// end of [atspre_g0float_min_double]
ATSinline()
atstype_ldouble
atspre_g0float_min_ldouble
  (atstype_ldouble f1, atstype_ldouble f2) { return (f1 <= f2 ? f1 : f2) ; }
// end of [atspre_g0float_min_ldouble]

ATSinline()
atstype_float
atspre_g0float_max_float
  (atstype_float f1, atstype_float f2) { return (f1 >= f2 ? f1 : f2) ; }
// end of [atspre_g0float_max_float]
ATSinline()
atstype_double
atspre_g0float_max_double
  (atstype_double f1, atstype_double f2) { return (f1 >= f2 ? f1 : f2) ; }
// end of [atspre_g0float_max_double]
ATSinline()
atstype_ldouble
atspre_g0float_max_ldouble
  (atstype_ldouble f1, atstype_ldouble f2) { return (f1 >= f2 ? f1 : f2) ; }
// end of [atspre_g0float_max_ldouble]

/* ****** ****** */

//
ATSinline()
atstype_float
atspre_add_int_float
  (atstype_int i1, atstype_float f2) { return (((atstype_float)i1) + f2) ; }
// end of [atspre_add_int_float]
ATSinline()
atstype_float
atspre_sub_int_float
  (atstype_int i1, atstype_float f2) { return (((atstype_float)i1) - f2) ; }
// end of [atspre_sub_int_float]
ATSinline()
atstype_float
atspre_mul_int_float
  (atstype_int i1, atstype_float f2) { return (((atstype_float)i1) * f2) ; }
// end of [atspre_mul_int_float]
ATSinline()
atstype_float
atspre_div_int_float
  (atstype_int i1, atstype_float f2) { return (((atstype_float)i1) / f2) ; }
// end of [atspre_div_int_float]
//
ATSinline()
atstype_double
atspre_add_int_double
  (atstype_int i1, atstype_double f2) { return (((atstype_double)i1) + f2) ; }
// end of [atspre_add_int_double]
ATSinline()
atstype_double
atspre_sub_int_double
  (atstype_int i1, atstype_double f2) { return (((atstype_double)i1) - f2) ; }
// end of [atspre_sub_int_double]
ATSinline()
atstype_double
atspre_mul_int_double
  (atstype_int i1, atstype_double f2) { return (((atstype_double)i1) * f2) ; }
// end of [atspre_mul_int_double]
ATSinline()
atstype_double
atspre_div_int_double
  (atstype_int i1, atstype_double f2) { return (((atstype_double)i1) / f2) ; }
// end of [atspre_div_int_double]
//
ATSinline()
atstype_ldouble
atspre_add_int_ldouble
  (atstype_int i1, atstype_ldouble f2) { return (((atstype_ldouble)i1) + f2) ; }
// end of [atspre_add_int_ldouble]
ATSinline()
atstype_ldouble
atspre_sub_int_ldouble
  (atstype_int i1, atstype_ldouble f2) { return (((atstype_ldouble)i1) - f2) ; }
// end of [atspre_sub_int_ldouble]
ATSinline()
atstype_ldouble
atspre_mul_int_ldouble
  (atstype_int i1, atstype_ldouble f2) { return (((atstype_ldouble)i1) * f2) ; }
// end of [atspre_mul_int_ldouble]
ATSinline()
atstype_ldouble
atspre_div_int_ldouble
  (atstype_int i1, atstype_ldouble f2) { return (((atstype_ldouble)i1) / f2) ; }
// end of [atspre_div_int_ldouble]
//
/* ****** ****** */

//
ATSinline()
atstype_float
atspre_add_float_int
  (atstype_float f1, atstype_int i2) { return (f1 + ((atstype_float)i2)) ; }
// end of [atspre_add_float_int]
ATSinline()
atstype_float
atspre_sub_float_int
  (atstype_float f1, atstype_int i2) { return (f1 - ((atstype_float)i2)) ; }
// end of [atspre_sub_float_int]
ATSinline()
atstype_float
atspre_mul_float_int
  (atstype_float f1, atstype_int i2) { return (f1 * ((atstype_float)i2)) ; }
// end of [atspre_mul_float_int]
ATSinline()
atstype_float
atspre_div_float_int
  (atstype_float f1, atstype_int i2) { return (f1 / ((atstype_float)i2)) ; }
// end of [atspre_div_float_int]
//
ATSinline()
atstype_double
atspre_add_double_int
  (atstype_double f1, atstype_int i2) { return (f1 + ((atstype_double)i2)) ; }
// end of [atspre_add_double_int]
ATSinline()
atstype_double
atspre_sub_double_int
  (atstype_double f1, atstype_int i2) { return (f1 - ((atstype_double)i2)) ; }
// end of [atspre_sub_double_int]
ATSinline()
atstype_double
atspre_mul_double_int
  (atstype_double f1, atstype_int i2) { return (f1 * ((atstype_double)i2)) ; }
// end of [atspre_mul_double_int]
ATSinline()
atstype_double
atspre_div_double_int
  (atstype_double f1, atstype_int i2) { return (f1 / ((atstype_double)i2)) ; }
// end of [atspre_div_double_int]
//
ATSinline()
atstype_ldouble
atspre_add_ldouble_int
  (atstype_ldouble f1, atstype_int i2) { return (f1 + ((atstype_ldouble)i2)) ; }
// end of [atspre_add_ldouble_int]
ATSinline()
atstype_ldouble
atspre_sub_ldouble_int
  (atstype_ldouble f1, atstype_int i2) { return (f1 - ((atstype_ldouble)i2)) ; }
// end of [atspre_sub_ldouble_int]
ATSinline()
atstype_ldouble
atspre_mul_ldouble_int
  (atstype_ldouble f1, atstype_int i2) { return (f1 * ((atstype_ldouble)i2)) ; }
// end of [atspre_mul_ldouble_int]
ATSinline()
atstype_ldouble
atspre_div_ldouble_int
  (atstype_ldouble f1, atstype_int i2) { return (f1 / ((atstype_ldouble)i2)) ; }
// end of [atspre_div_ldouble_int]
//
/* ****** ****** */

#endif // ifndef ATSLIB_PRELUDE_CATS_FLOAT

/* ****** ****** */

/* end of [float.cats] */

(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: May, 2012 *)

(* ****** ****** *)

#define
ATS_PACKNAME "ATSLIB.libats.funralist_nested"
#define
ATS_DYNLOADFLAG 0 // no dynamic loading at run-time

(* ****** ****** *)

staload
_(*anon*) = "prelude/DATS/integer.dats"

(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"
staload
_(*anon*) = "prelude/DATS/unsafe.dats"

(* ****** ****** *)

staload "libats/SATS/linralist_nested.sats"

(* ****** ****** *)
//
// HX-2013-01:
//
// this data structure is essentially based on
// Chris Okasaki's random-access list (formulated
// as a nested datatype). However, unlike Okasaki's
// formulation, [ralist] is *not* a nested datatype.
//
(* ****** ****** *)

datavtype node
  (a:vt@ype+, int(*d*)) =
  | N1 (a, 0) of (a) // singleton
  | {d:nat}
    N2 (a, d+1) of (node (a, d), node (a, d))
// end of [node]

datavtype myralist
  (a:vt@ype+, int(*d*), int(*n*)) =
  | {d:nat}
    RAnil (a, d, 0) of ()
  | {d:nat}{n:pos}
    RAevn (a, d, n+n) of myralist (a, d+1, n)
  | {d:nat}{n:nat}
    RAodd (a, d, n+n+1) of (node (a, d), myralist (a, d+1, n))
// end of [myralist]

(* ****** ****** *)

assume
ralist_vtype
  (a:vt0p, n:int) = myralist (a, 0, n)
// end of [ralist_vtype]

(* ****** ****** *)

primplmnt
lemma_ralist_param (xs) = let
in
//
case+ xs of
| RAevn _ => () | RAodd _ => () | RAnil () => ()
//
end // end of [lemma_ralist_param]

(* ****** ****** *)

implement{}
linralist_nil{a} () = RAnil{a}{0}((*void*))
implement{}
linralist_make_nil{a} () = RAnil{a}{0}((*void*))

(* ****** ****** *)

local

extern
fun cons
  {a:vt0p}{d:nat}{n:nat}
(
  x0: node (a, d), xs: myralist (a, d, n)
) :<> myralist (a, d, n+1)
implement
cons{a}{d}{n} (x0, xs) = let
in
//
case+ xs of
| ~RAevn (xxs) => RAodd (x0, xxs)
| ~RAodd (x1, xxs) => let
    val x0x1 = N2 (x0, x1) in RAevn (cons (x0x1, xxs))
  end // end of [RAodd]
| ~RAnil () => RAodd (x0, RAnil)
//
end // end of [cons]

in (* in of [local] *)

implement{a}
linralist_cons
  (x, xs) = let
//
prval () = lemma_ralist_param (xs)
//
in
  cons{a} (N1{a}(x), xs)
end // end of [linralist_cons]

end // end of [local]

(* ****** ****** *)

implement{}
linralist_is_nil (xs) =
  case+ xs of RAnil () => true | _ =>> false
// end of [linralist_is_nil]

implement{}
linralist_is_cons (xs) =
  case+ xs of RAnil () => false | _ =>> true
// end of [linralist_is_cons]

(* ****** ****** *)

local

extern
fun length
  {a:vt0p}{d:nat}{n:nat}
  (xs: !myralist (a, d, n)):<> int (n)
implement
length{a}{d}{n} (xs) = let
in
//
case+ xs of
| RAevn (xxs) =>
    let val n2 = length (xxs) in 2 * n2 end
  // end of [RAevn]
| RAodd (_, xxs) =>
    let val n2 = length (xxs) in 2 * n2 + 1 end
  // end of [RAodd]
| RAnil ((*void*)) => (0)
//
end // end of [length]

in (* in of [local] *)

implement
linralist_length {a} (xs) = let
//
prval () = lemma_ralist_param (xs)
//
in
  length{a} (xs)
end // end of [linralist_length]

end // end of [local]

(* ****** ****** *)

implement{a}
linralist_head (xs) = linralist_get_at (xs, 0)

(* ****** ****** *)

implement{a}
linralist_tail
  (xs) = xs1 where {
  var xs1 = xs
  val _(*hd*) = linralist_uncons (xs1)
} // end of [linralist_tail]

(* ****** ****** *)

local

extern fun
uncons{a:vt0p}{d:nat}{n:pos}
(
  xs: myralist (a, d, n), x: &ptr? >> node (a, d)
) :<!wrt> myralist (a, d, n-1)
implement
uncons{a}{d}{n} (xs, x) = let
in
//
case+ xs of
| ~RAevn
    (xxs) => let
    var nxx: ptr
    val xxs =
      uncons (xxs, nxx)
    // end of [val]
    val+ ~N2 (x0, x1) = nxx
    val () = x := x0
  in
    RAodd (x1, xxs)
  end // end of [RAevn]
| ~RAodd
    (x0, xxs) => let
    val () = x := x0
  in
    case+ xxs of ~RAnil () => RAnil () | _ =>> RAevn (xxs)
  end // end of [RAodd]
//
end // end of [uncons]

in (* in of [local] *)

implement{a}
linralist_uncons
  (xs) = let
//
var nx: ptr // unintialized
val () = (xs := uncons{a} (xs, nx))
val+ ~N1 (x0) = nx
//
in
  x0
end // end of [linralist_uncons]

end // end of [local]

(* ****** ****** *)

local

extern fun
getref_at {a:vt0p}{d:nat}{n:nat}
(
  xs: !myralist (a, d, n), i: natLt n
) :<> Ptr1 // end of [getref_at]
implement
getref_at
  {a}{d}{n} (xs, i) = let
//
extern praxi __vfree : node (a,d+1) -<prf> void
//
in
//
case+ xs of
| RAevn (xxs) => let
    val p_x01 = getref_at (xxs, half i)
    val x01 = $UN.ptr1_get<node(a,d+1)>(p_x01)
  in
    if i mod 2 = 0 then let
      val+ @N2 (x0, _) = x01
      val p_x0 = addr@ (x0)
      prval () = fold@ (x01)
      prval () = __vfree (x01)
    in
      p_x0
    end else let
      val+ @N2 (_, x1) = x01
      val p_x1 = addr@ (x1)
      prval () = fold@ (x01)
      prval () = __vfree (x01)
    in
      p_x1
    end // end of [if]
  end // end of [RAevn]
| @RAodd (x, xxs) => (
    if i = 0 then let
      val p_x = addr@ (x)
      prval () = fold@ (xs)
    in
      p_x
    end else let
      val i1 = i - 1
      val p_x01 = getref_at (xxs, half i1)
      prval () = fold@ (xs)
      val x01 = $UN.ptr1_get<node(a,d+1)>(p_x01)
    in
      if i mod 2 = 0 then let
        val+ @N2 (_, x1) = x01
        val p_x1 = addr@ (x1)
        prval () = fold@ (x01)
        prval () = __vfree (x01)
      in
        p_x1
      end else let
        val+ @N2 (x0, _) = x01
        val p_x0 = addr@ (x0)
        prval () = fold@ (x01)
        prval () = __vfree (x01)
      in
        p_x0
      end // end of [if]
    end // end of [if]
  ) // end of [RAodd]
//
end // end of [getref_at]

in (* in of [local] *)

implement{a}
linralist_getref_at (xs, i) = let
  val p_i = getref_at {a} (xs, i) in $UN.cast{cPtr1(a)}(p_i)
end // end of [linralist_getref_at]

end // end of [local]

(* ****** ****** *)

implement{a}
linralist_get_at
  (xs, i) = let
  val p = linralist_getref_at (xs, i) in $UN.cptr_get<a> (p)
end // end of [linralist_get_at]

implement{a}
linralist_set_at
  (xs, i, x) = let
  val p = linralist_getref_at (xs, i) in $UN.cptr_set<a> (p, x)
end // end of [linralist_set_at]

(* ****** ****** *)

(* end of [linralist_nested.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2015 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: June, 2015 *)

(* ****** ****** *)
//
#define
ATS_PACKNAME "ATSLIB.libats.funmap_rbtree"
//
#define
ATS_DYNLOADFLAG 0 // no need for dynloading at run-time
//
(* ****** ****** *)
//
staload
UN = "prelude/SATS/unsafe.sats"
//
(* ****** ****** *)

staload "libats/SATS/funmap_rbtree.sats"

(* ****** ****** *)

implement
{key}
compare_key_key
  (k1, k2) = gcompare_val_val<key> (k1, k2)
// end of [compare_key_key]

(* ****** ****** *)
//
#define BLK 0; #define RED 1
//
sortdef two = {c:nat | c < 2}
sortdef clr = {c:nat | c < 2}
//
typedef color(c:int) = int(c)
typedef color = [c:clr] color(c)
//
(* ****** ****** *)
//
// HX-2012-12-26:
// the file should be included here
// before [map_type] is assumed
//
#include "./SHARE/funmap.hats" // code reuse
//
(* ****** ****** *)
//
datatype rbtree
(
  key:t@ype, itm: t@ype
, int(*color*), int(*bheight*), int(*violation*)
) =
  | E (key, itm, BLK, 0, 0)
  | {c,cl,cr:clr}{bh:nat}{v:int}
    {c == BLK && v == 0 ||
     c == RED && v == cl+cr}
    T (key, itm, c, bh+1-c, v) of
    (
      color c, key, itm
    , rbtree0 (key, itm, cl, bh), rbtree0 (key, itm, cr, bh)
    ) (* end of [T] *)
// end of [datatype rbtree]
//
where
rbtree0
(
  key:t@ype, itm:t@ype, c:int, bh:int
) =
  rbtree (key, itm, c, bh, 0(*violation*))
// end of [rbtree0]
//
(* ****** ****** *)
//
assume
map_type
(
  key:t0p, itm:t0p
) = [c:clr;bh:nat] rbtree0 (key, itm, c, bh)
// end of [map_type]
//
(* ****** ****** *)

implement{} funmap_nil () = E ()
implement{} funmap_make_nil () = E ()

(* ****** ****** *)

implement
{}(*tmp*)
funmap_is_nil (map) =
  case+ map of E _ => true | T _ => false
// end of [funmap_is_nil]

implement
{}(*tmp*)
funmap_isnot_nil (map) =
  case+ map of T _ => true | E _ => false
// end of [funmap_isnot_nil]

(* ****** ****** *)

implement
{key,itm}
funmap_size
  (map) = let
//
typedef
rbtree0
(
  c:int, bh:int
) = rbtree0(key, itm, c, bh)
//
fun
aux
{c:clr}
{bh:nat}
(
  t0: rbtree0(c, bh), res: size_t
) : size_t = let
in
//
case+ t0 of
| E((*void*)) => res
| T(_, _, _, tl, tr) => let
    val res = succ(res)
    val res = aux (tl, res)
    val res = aux (tr, res)
  in
    res
  end // end of [T]
//
end // end of [aux]
//
in
  $effmask_all (aux (map, i2sz(0)))
end // end of [funmap_size]

(* ****** ****** *)

implement
{key,itm}
funmap_search
  (map, k0, res) = let
//
typedef
rbtree0
(
  c:int, bh:int
) = rbtree0(key, itm, c, bh)
//
fun
search
{c:clr}
{bh:nat} .<bh,c>.
(
  t0: rbtree0(c, bh)
, res: &itm? >> opt (itm, b)
) :<!wrt> #[b:bool] bool(b) = let
in
//
case+ t0 of
| E (
  ) => let
    prval () = opt_none{itm}(res)
  in
    false
  end // end of [E]
| T (
    _(*h*), k, x, tl, tr
  ) => let
    val sgn =
      compare_key_key<key> (k0, k)
    // end of [val]
  in
    case+ 0 of
    | _ when sgn < 0 => search (tl, res)
    | _ when sgn > 0 => search (tr, res)
    | _ => let
        val () = res := x
        prval () = opt_some{itm}(res) in true
      end // end of [_]
  end // end of [T]
//
end // end of [search]
//
in
  search (map, res)
end // end of [funmap_search]

(* ****** ****** *)
//
// HX: right rotation
//
fn{
key,
itm:t0p
} insfix_l
  {cl,cr:clr}
  {bh:nat}{v:nat}
(
  k: key, x: itm
, tl: rbtree (key, itm, cl, bh, v)
, tr: rbtree (key, itm, cr, bh, 0)
) :<> [c:clr] rbtree0 (key, itm, c, bh+1) =
(
//
let
  #define B BLK; #define R RED
in
  case+ (tl) of
  | T (R, kl, xl, T (R, kll, xll, tlll, tllr), tlr) =>
      T (R, kl, xl, T (B, kll, xll, tlll, tllr), T (B, k, x, tlr, tr))
  | T (R, kl, xl, tll, T (R, klr, xlr, tlrl, tlrr)) =>
      T (R, klr, xlr, T (B, kl, xl, tll, tlrl), T (B, k, x, tlrr, tr))
  | _ (*non-R-rooted*) =>> T (B, k, x, tl, tr)
end
//
) (* end of [insfix_l] *)
//
(* ****** ****** *)
//
// HX: left rotation
//
fn{
key,
itm:t0p}
insfix_r
  {cl,cr:clr}
  {bh:nat}{v:nat}
(
  k: key, x: itm
, tl: rbtree (key, itm, cl, bh, 0)
, tr: rbtree (key, itm, cr, bh, v)
) :<> [c:clr] rbtree0 (key, itm, c, bh+1) =
(
//
let
  #define B BLK; #define R RED
in
  case+ (tr) of
  | T (R, kr, xr, trl, T (R, krr, xrr, trrl, trrr)) =>
      T (R, kr, xr, T (B, k, x, tl, trl), T (B, krr, xrr, trrl, trrr))
  | T (R, kr, xr, T (R, krl, xrl, trll, trlr), trr) =>
      T (R, krl, xrl, T (B, k, x, tl, trll), T (B, kr, xr, trlr, trr))
  | _ (*non-R-rooted*) =>> T (B, k, x, tl, tr)
end
//
) (* end of [insfix_r] *)
//
(* ****** ****** *)
  
  
implement
{key,itm}
funmap_insert
(
  map, k0, x0, res2
) = res where {
//
#define B BLK; #define R RED
//
typedef
rbtree0
(
  c:int, bh:int
) = rbtree0(key, itm, c, bh)
//
fun
insert
{c:clr}
{bh:nat} .<bh,c>.
(
  t0: rbtree0 (c, bh)
, res: &bool? >> bool (b)
, res2: &itm? >> opt (itm, b)
) :<!wrt> #[b:bool]
[
  c1:clr; v:nat | v <= c
] rbtree (key, itm, c1, bh, v) =
(
case+ t0 of
//
| E((*void*)) => let
    val () = res := false
    prval () = opt_none{itm}(res2)
  in
    T{..}{..}{..}{0} (R, k0, x0, E, E)
  end // end of [E]
//
| T (c, k, x, tl, tr) => let
    val sgn = compare_key_key<key> (k0, k)
  in
    if sgn < 0 
      then let
        val [cl:int,v:int] tl = insert (tl, res, res2) in
        if c = B
          then insfix_l(k, x, tl, tr) else T{..}{..}{..}{cl}(R, k, x, tl, tr)
        // end of [if]
      end // end of [then]
      else (
        if sgn > 0
          then let
            val [cr:int,v:int] tr = insert (tr, res, res2) in
            if c = B
              then insfix_r(k, x, tl, tr) else T{..}{..}{..}{cr}(R, k, x, tl, tr)
            // end of [if]
          end // end of [then]
          else let
            val () = res := true
            val () = res2 := x;
            prval () = opt_some{itm}(res2)
          in
            T{..}{..}{..}{0}(c, k, x0, tl, tr)
          end // end of [else]
        // end of [if]
      ) (* end of [else] *)
    // end of [if]
  end // end of [let] // end of [T]
//
) (* end of [insert] *)
//
var res: bool
val map1 = insert (map, res, res2)
val () =
(
case+ map1 of
| T (R, k, x, tl, tr) => map := T (B, k, x, tl, tr) | _ =>> map := map1
) (* end of [val] *)
//
} (* end of [funmap_insert] *)
  
(* ****** ****** *)

fn
{key
,itm:t0p
} rbtree_redden
  {bh:pos}
(
  t0: rbtree0 (key, itm, BLK, bh)
) :<>
[
  v:nat | v <= 2
] rbtree (key, itm, RED, bh-1, v) = let
  val+T{..}{c,cl,cr}(_, k, x, tl, tr) = t0 in T{..}{..}{..}{cl+cr} (RED, k, x, tl, tr)
end // end of [let] // end of [rbtree_redden]

(* ****** ****** *)

fn
{key
,itm:t0p
} remfix_l
  {cl,cr:clr}
  {bh:nat}{v:nat}
(
  k: key, x: itm
, tl: rbtree (key, itm, cl, bh  , v)
, tr: rbtree (key, itm, cr, bh+1, 0)
) :<>
[
  c:clr;v:nat | v <= cr
] rbtree (key, itm, c, bh+1, v) = let
  #define B BLK; #define R RED
in
//
case+ tl of
| T(R, kl, xl, tll, tlr) =>
  T{..}{..}{..}{cr}(R, k, x, T (B, kl, xl, tll, tlr), tr)
| _ (*non-red-tree*) =>>
  (
    case+ tr of
    | T{..}{cr,crl,crr}
      (
        B, kr, xr, trl, trr
      ) =>
      insfix_r
      (
        k, x, tl, T{..}{..}{..}{crl+crr}(R, kr, xr, trl, trr)
      ) (* end of [T (B, ...)] *)
    | T(R, kr, xr, trl, trr) => let
        val+T(B, krl, xrl, trll, trlr) = trl
        val [cr2:int] tr2 = insfix_r (kr, xr, trlr, rbtree_redden trr)
      in
        T{..}{..}{..}{cr2}(R, krl, xrl, T (B, k, x, tl, trll), tr2)
      end (* end of [T (R, ...)] *)
  ) (* end of [_(*non-red-tree*)] *)
//
end // end of [remfix_l]

(* ****** ****** *)

fn
{key
,itm:t0p
} remfix_r
  {cl,cr:clr}
  {bh:nat}{v:nat}
(
  k: key, x: itm
, tl: rbtree (key, itm, cl, bh+1, 0)
, tr: rbtree (key, itm, cr, bh  , v)
) :<>
[
  c:clr;v:nat | v <= cl
] rbtree (key, itm, c, bh+1, v) = let
  #define B BLK; #define R RED
in
//
case+ tr of
| T(R, kr, xr, trl, trr) =>
  T{..}{..}{..}{cl}(R, k, x, tl, T (B, kr, xr, trl, trr))
| _(*non-red-tree*) =>>
  (
    case+ tl of
    | T{..}{cl,cll,clr}
      (
        B, kl, xl, tll, tlr
      ) =>
      insfix_l
      (
        k, x, T {..}{..}{..}{cll+clr}(R, kl, xl, tll, tlr), tr
      ) (* end of [T (B, ...)] *)
    | T(R, kl, xl, tll, tlr) => let
        val+ T (B, klr, xlr, tlrl, tlrr) = tlr
        val [cl2:int] tl2 = insfix_l (kl, xl, rbtree_redden tll, tlrl)
      in
        T{..}{..}{..}{cl2}(R, klr, xlr, tl2, T(B, k, x, tlrr, tr))
      end (* end of [T (R, ...)] *)
  ) (* end of [_(*non-red-tree*)] *)
end // end of [remfix_r]

(* ****** ****** *)

fun
{key
,itm:t@ype}
rbtree_remove_min
  {c:clr}
  {bh:nat | bh+c > 0} .<bh,c>.
(
  t0: rbtree0 (key, itm, c, bh)
, k0: &key? >> key, x0: &itm? >> itm
, dfbh: &int? >> int (d)
) :<!wrt>
#[d:two | d <= bh]
 [c1:clr | c1 <= c+d]
 rbtree0 (key, itm, c1, bh-d) =
(
//
let
  #define B BLK; #define R RED
in
  case+ t0 of
  | T (B, k, x, tl, tr) =>
    (
    case+ tl of
    | T _ => let
        val tl =
          rbtree_remove_min(tl, k0, x0, dfbh)
        // end of [val]
      in
        if dfbh = 0
          then
          (
            T{..}{..}{..}{0}(B, k, x, tl, tr)
          ) (* end of [then] *)
          else let
            val t2 = remfix_l (k, x, tl, tr)
          in
            case+ t2 of
            | T (R, k, x, tl, tr) =>
                (dfbh := 0; T (B, k, x, tl, tr))
            | _ (* non-red-tree *) =>> t2
          end (* end of [else] *)
        // end of [if]
      end // end of [T]
    | E _ => (k0 := k; x0 := x; dfbh := 1; tr)
    ) (* end of [T (B, ...)] *) 
  | T (R, k, x, tl, tr) =>
    (
    case+ tl of
    | T _ => let
        val tl =
          rbtree_remove_min(tl, k0, x0, dfbh)
        // end of [val]
      in
        if dfbh = 0
          then
          (
            T{..}{..}{..}{0}(R, k, x, tl, tr)
          ) (* end of [then] *)
          else let // dfbh = 1
            val () = dfbh := 0 in
            insfix_r (k, x, tl, rbtree_redden tr)
          end (* end of [else] *)
        // end of [if]
      end // end of [T (B, ...)]
    | E () => (k0 := k; x0 := x; dfbh := 0; tr)
    ) (* end of [T (R, ...)] *)
end // end of [let]
//
) (* end of [rbtree_remove_min] *)

(* ****** ****** *)

fn
{key
,itm:t@ype
} rbtree_join
  {cl,cr:clr}{bh:nat}
(
  tl: rbtree0 (key, itm, cl, bh)
, tr: rbtree0 (key, itm, cr, bh)
) :<!wrt>
[
  c:clr;v:nat | v <= cl+cr
] rbtree (key, itm, c, bh, v) =
(
//
case+ tr of
| E _ => tl
| T _ => let
    var k0: key
    and x0: itm
    var dfbh: int // uninitialized
    val [cr:int] tr = rbtree_remove_min(tr, k0, x0, dfbh)
  in
    if dfbh = 0
      then T{..}{..}{..}{cl+cr}(RED, k0, x0, tl, tr) else remfix_r(k0, x0, tl, tr)
    // end of [if]
  end // end of [T]
//
) (* end of [rbtree_join] *)

(* ****** ****** *)
//
// HX-2011-09-24:
// the pointer [pres] is assumed to be
// associated with a proof of at-view if non-null
//
extern
fun
{key
,itm:t0p}
funmap_takeout_ref
(
  &map (key, itm) >> _, k0: key, pres: ptr
) :<!wrt> bool // end of [funmap_takeout_ref]

implement
{key,itm}
funmap_takeout_ref
(
  map, k0, pres
) = taken where {
//
#define B BLK; #define R RED
//
fun
takeout
{c:clr}
{bh:nat} .<bh,c>.
(
  t0:
  rbtree0
    (key, itm, c, bh)
  // rbtree0
, pres: ptr
, dfbh: &int? >> int(d)
, taken: &bool? >> bool
) :<!wrt>
#[d:two | d <= bh]
 [c1:clr | c1 <= c+d]
 rbtree0 (key, itm, c1, bh-d) =
(
//
case+ t0 of
//
| E () =>
    (dfbh := 0; taken := false; t0)
//
| T (B, k, x, tl, tr) => let
    val sgn =
      compare_key_key<key> (k0, k)
    // end of [val]
  in
    if sgn < 0 then let
      val tl =
        takeout(tl, pres, dfbh, taken)
      // end of [val]
    in
      if dfbh = 0
        then
        (
          T{..}{..}{..}{0}(B, k, x, tl, tr)
        ) (* end of [then] *)
        else let // dfbh = 1
          val t2 = remfix_l (k, x, tl, tr)
        in
          case+ t2 of
          | T (R, k, x, tl, tr) =>
              (dfbh := 0; T (B, k, x, tl, tr))
          | _ (* non-red-tree *) =>> t2
        end (* end of [else] *)
      // end of [if]
    end else if sgn > 0 then let
      val tr =
        takeout (tr, pres, dfbh, taken)
      // end of [val]
    in
      if dfbh = 0
        then
        (
          T{..}{..}{..}{0}(B, k, x, tl, tr)
        ) (* end of [then] *)
        else let // dfbh = 1
          val t2 = remfix_r (k, x, tl, tr)
        in
          case+ t2 of
          | T (R, k, x, tl, tr) =>
              (dfbh := 0; T (B, k, x, tl, tr))
          | _ (* non-red-tree *) =>> t2
        end (* end of [else] *)
    end else let // x0 = x
      val () =
      if (pres > 0) then $UN.ptr0_set<itm>(pres, x)
      val () = taken := true
      val t2 = rbtree_join (tl, tr)
    in
      case+ t2 of
      | T (R, k, x, tl, tr) =>
          (dfbh := 0; T (B, k, x, tl, tr))
      | _ (* non-red-tree *) =>> (dfbh := 1; t2)
    end (* end of [if] *)
  end // end of [T (B, ...)]
//
| T (R, k, x, tl, tr) => let
    val sgn =
      compare_key_key<key> (k0, k)
    // end of [val]
  in
    if sgn < 0 then let
      val tl =
        takeout(tl, pres, dfbh, taken)
      // end of [val]
    in
      if dfbh = 0
        then
        (
          T{..}{..}{..}{0}(R, k, x, tl, tr)
        ) (* end of [then] *)
        else let // dfbh = 1
          val () = dfbh := 0 in remfix_l (k, x, tl, tr)
        end (* end of [else] *)
      // end of [if]
    end else if sgn > 0 then let
      val tr = takeout(tr, pres, dfbh, taken)
    in
      if dfbh = 0
        then
        (
          T{..}{..}{..}{0}(R, k, x, tl, tr)
        ) (* end of [then] *)
        else let // dfbh = 1
          val () = dfbh := 0 in remfix_r (k, x, tl, tr)
        end (* end of [else] *)
      // end of [if]
    end else let // x0 = x
      val () = dfbh := 0
      val () =
      if (pres > 0) then $UN.ptr0_set<itm> (pres, x)
      val () = taken := true
    in
      rbtree_join (tl, tr)
    end (* end of [if] *)
  end // end of [T (R, ...)]
//
) (* end of [takeout] *)
//
var dfbh: int and taken: bool
//
val () =
(
  map := takeout (map, pres, dfbh, taken)
) (* end of [val] *)
//
} (* end of [funmap_takeout_ref] *)

(* ****** ****** *)

implement
{key,itm}
funmap_takeout
(
  map, k0, res
) = ans where {
//
val ans =
  funmap_takeout_ref<key,itm> (map, k0, addr@res)
//
val [b:bool] ans = g1ofg0(ans)
//
prval
pfres =
__assert
(
  view@ res
) where {
  extern
  praxi __assert{l_res:addr} (pf: itm? @ l_res):<> (opt (itm, b) @ l_res)
} (* end of [prval] *)
//
prval () = view@res := pfres
//
} (* end of [funmap_takeout] *)

(* ****** ****** *)
//
implement
{key,itm}
funmap_remove
  (map, k0) =
  funmap_takeout_ref<key,itm> (map, k0, the_null_ptr)
//
(* ****** ****** *)

implement
{key,itm}{env}
funmap_foreach_env
  (xs, env) = let
//
typedef
rbtree0
(
  c:int, bh:int
) = rbtree0(key, itm, c, bh)
//
val p_env = addr@ (env)
//
fun
foreach
{c:clr}
{bh:nat} .<bh,c>.
(
  t0: rbtree0 (c, bh), p_env: ptr
) : void = let
in
//
case+ t0 of
//
| E ((*void*)) => ()
//
| T (_, k, x, tl, tr) => let
//
    val () = foreach (tl, p_env)
//
    val (
      pf, fpf | p_env
    ) = $UN.ptr_vtake (p_env)
    val ((*void*)) =
      funmap_foreach$fwork<key,itm><env> (k, x, !p_env)
    prval ((*void*)) = fpf (pf)
//
    val () = foreach (tr, p_env)
//
  in
    // nothing
  end // end of [T]
//
end // end of [foreach]
//
in
  foreach (xs, p_env)
end // end of [funmap_foreach_env]

(* ****** ****** *)

implement
{key,itm}
funmap_rbtree_height
  (t0) = let
//
typedef
rbtree0
(
  c:int, bh:int
) = rbtree0(key, itm, c, bh)
//
fun
aux
{c:clr}
{bh:nat} .<bh,c>.
(
  t0: rbtree0 (c, bh)
) :<> intGte(0) = (
//
case+ t0 of
| E ((*void*)) => 0
| T (_, _, _, tl, tr) => 1 + max (aux(tl), aux(tr))
//
) (* end of [aux] *)
//
in
  aux(t0)
end // end of [funmap_rbtree_height]

(* ****** ****** *)

implement
{key,itm}
funmap_rbtree_bheight
  (t0) = let
//
typedef
rbtree0
(
  c:int, bh:int
) = rbtree0(key, itm, c, bh)
//
fun
aux
{c:clr}
{bh,n:nat} .<bh,c>.
(
  t0: rbtree0 (c, bh), n: int(n)
) :<> int(bh+n) = (
//
case+ t0 of
| E ((*void*)) => n
| T (c, _, _, tl, tr) => aux(tl, n+1-c)
//
) (* end of [aux] *)
//
in
  aux(t0, 0)
end // end of [funmap_rbtree_bheight]

(* ****** ****** *)

(* end of [funmap_rbtree.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2015 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmmhwxiATgmailDOTcom
// Start Time: March, 2015
//
(* ****** ****** *)

staload "libats/SATS/typeval.sats"

(* ****** ****** *)
//
implement
tieq2int<Z()>
  (pf | (*void*)) =
  let prval TIEQZ() = pf in 0 end
//
implement
(t)(*tmp*)
tieq2int<S(t)>
  (pf | (*void*)) =
(
  let prval TIEQS(pf) = pf in
    succ(tieq2int<t>(pf | (*void*))) end
  // end of [tieq2int<S(t)>]
)
//
(* ****** ****** *)
//
implement
ti2eq2int<Z()>
  (pf | (*void*)) =
  let prval TI2EQZ() = pf in 0 end
//
implement
(t)(*tmp*)
ti2eq2int<B0(t)>
  (pf | (*void*)) =
(
  let prval TI2EQB0(pf) = pf in
    2*(ti2eq2int<t>(pf | (*void*))) end
  // end of [ti2eq2int<B0(t)>]
)
//
implement
(t)(*tmp*)
ti2eq2int<B1(t)>
  (pf | (*void*)) =
(
  let prval TI2EQB1(pf) = pf in
    2*(ti2eq2int<t>(pf | (*void*)))+1 end
  // end of [ti2eq2int<B1(t)>]
)
//
(* ****** ****** *)
//
implement
(a)(*tmp*)
sarray_foreach<a><Z()>
  (pf | A, env) = ()
//
implement
(a,t)(*tmp*)
sarray_foreach<a><S(t)>
  (pf | A, env) = let
//
val p0 = addr@A
//
prval TIEQS(pf1) = pf
//
prval pfarr = view@(A)
prval
(
  pfat, pfarr1
) = array_v_uncons(pfarr)
//
val () = sarray_foreach$fwork<a> (!p0, env)
//
val p1 = ptr1_succ<a> (p0)
val (pfarr1 | p1) = viewptr_match(pfarr1 | p1)
val () = sarray_foreach<a><t> (pf1 | !p1, env)
//
prval () = view@A := array_v_cons (pfat, pfarr1)
//
in
  ignoret(0) // HX: for circumventing a tail-call bug!
end // end of [sarray_foreach<a><S(t)>]
//
(* ****** ****** *)
//
implement
(a)(*tmp*)
sarray_foreach2<a><Z()>
  (pf | A0, A1, env) = ()
//
implement
(a,t)(*tmp*)
sarray_foreach2<a><S(t)>
  (pf | A0, A1, env) = let
//
val p0 = addr@A0
val p1 = addr@A1
//
prval TIEQS(pf1) = pf
//
prval pf0arr = view@(A0)
prval
(
  pf0at, pf0arr1
) = array_v_uncons(pf0arr)
//
prval pf1arr = view@(A1)
prval
(
  pf1at, pf1arr1
) = array_v_uncons(pf1arr)
//
val () = sarray_foreach2$fwork<a> (!p0, !p1, env)
//
val p0_1 = ptr1_succ<a> (p0)
val (pf0arr1 | p0_1) = viewptr_match(pf0arr1 | p0_1)
val p1_1 = ptr1_succ<a> (p1)
val (pf1arr1 | p1_1) = viewptr_match(pf1arr1 | p1_1)
//
val () = sarray_foreach2<a><t> (pf1 | !p0_1, !p1_1, env)
//
prval () = view@A0 := array_v_cons (pf0at, pf0arr1)
prval () = view@A1 := array_v_cons (pf1at, pf1arr1)
//
in
  ignoret(0) // HX: for circumventing a tail-call bug!
end // end of [sarray_foreach2<a><S(t)>]
//
(* ****** ****** *)

(* end of [typeval.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: May, 2014 *)

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.hashtbl_linprb"
#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload
STRING = "libc/SATS/string.sats"

(* ****** ****** *)

staload "libats/SATS/hashfun.sats"

(* ****** ****** *)

staload "libats/SATS/hashtbl_linprb.sats"

(* ****** ****** *)

#include "./SHARE/hashtbl.hats" // code reuse

(* ****** ****** *)

implement
{key,itm}
hashtbl_linprb_keyitm_nullize (kx) = let
  vtypedef ki = @(key, itm)
  val _(*ptr*) =
  $STRING.memset_unsafe(addr@(kx), 0, sizeof<ki>)
  prval () =
  __assert (kx) where
  { 
    extern praxi __assert (&(ki)? >> _): void
  } (* end of [prval] *)
in
  // nothing
end // end of [hashtbl_linprb_keyitm_nullize]

(* ****** ****** *)

implement(itm)
hashtbl_linprb_keyitm_is_null<string,itm> (kx) = (string2ptr(kx.0) = 0)

(* ****** ****** *)

extern
fun{
key:t0p;
itm:vt0p
} keyitmarr_linprb{m:int}
(
  A: &array((key,itm), m), cap: size_t(m), k0: key, ans: &bool? >> _
) : Ptr0 // end of [keyitmarr_linprb]

(* ****** ****** *)

implement
{key,itm}
keyitmarr_linprb
  {m}(A, cap, k0, ans) = let
//
val p0 = addr@(A)
vtypedef ki = @(key, itm)
val p_end = ptr_add<ki> (p0, cap)
//
fun loop
(
  p: ptr, ans: &bool? >> _
) : ptr =
(
if
p < p_end
then let
  val (pf, fpf | p) =
    $UN.ptr0_vtake{ki}(p)
  val isnul =
    hashtbl_linprb_keyitm_is_null<key,itm> (!p)
  prval ((*void*)) = fpf (pf)
in
  if isnul
    then let
      val () = ans := false in p
    end // end of [then]
    else let
      val (pf, fpf | p) =
        $UN.ptr0_vtake{ki}(p)
      val keq = equal_key_key<key> (k0, p->0)
      prval ((*void*)) = fpf (pf)
    in
      if keq
        then let
          val () = ans := true in p
        end // end of [then]
        else loop (ptr_succ<ki> (p), ans)
      // end of [if]
    end // end of [else]
  // end of [if]
end // end of [then]
else let
  val () = ans := false in the_null_ptr
end // end of [else]
)
//
val p_kx = loop(addr@(A), ans)
//
in
  g1ofg0 (p_kx) // it needs to be of the type [Ptr0]
end // end of [keyitmarr_linprb]

(* ****** ****** *)

extern
fun{
key:t0p;
itm:vt0p
} keyitmarr_linprb2
  {m:int}{ofs:int | ofs <= m}
(
  A: &array((key,itm), m), cap: size_t(m), ofs: size_t(ofs), k0: key, ans: &bool? >> _
) : Ptr0 // end of [keyitmarr_linprb2]

(* ****** ****** *)

implement
{key,itm}
keyitmarr_linprb2
  {m}{ofs}
(
  A, cap, ofs, k0, ans
) = let
//
val p0 = addr@(A)
vtypedef ki = @(key, itm)
val p1 = ptr_add<ki> (p0, ofs)
//
stadef n1 = ofs and n2 = m - ofs
//
val (pf, fpf | p1) = $UN.ptr0_vtake{array(ki,n2)}(p1)
val p_kx = keyitmarr_linprb<key,itm> (!p1, cap - ofs, k0, ans)
prval () = fpf (pf)
//
in
//
if p_kx > 0
  then p_kx
  else let
    val (pf, fpf | p0) = $UN.ptr0_vtake{array(ki,n1)}(p0)
    val p_kx = keyitmarr_linprb<key,itm> (!p0, ofs, k0, ans)
    prval () = fpf (pf)
  in
    p_kx
  end // end of [else]
// end of [if]
//
end // end of [keyitmarr_linprb2]

(* ****** ****** *)

extern
fun{
key:t0p;
itm:vt0p
} keyitmarr_reinserts
  {m:int}
(
  A: &array((key,itm), m) >> _, cap: size_t(m), p_kx: ptr
) : void // end of [keyitmarr_reinserts]

(* ****** ****** *)

implement
{key,itm}
keyitmarr_reinserts
  {m}(A, cap, p_kx) = let
//
val p0 = addr@(A)
vtypedef ki = @(key, itm)
val p_end = ptr_add<ki> (p0, cap)
//
fun
loop
(
  A: &array(ki, m) >> _, cap: size_t(m), p_kx: ptr
) : bool = let
in
//
if
p_kx < p_end
then let
//
val (pf, fpf | p_kx) = $UN.ptr0_vtake{ki}(p_kx)
val isnul =
  hashtbl_linprb_keyitm_is_null<key,itm> (!p_kx)
//
in
  if isnul
    then let
      prval () = fpf (pf) in true(*stopped*)
    end // end of [then]
    else let
      val k = p_kx->0
      val hk = hash_key<key> (k)
      val ofs = g0uint_mod (hk, $UN.cast{ulint}(cap))
      val ofs = $UN.cast{sizeLt(m)}(ofs)
//
      var ans: bool // uninitized
      val p2_kx = keyitmarr_linprb2<key,itm> (A, cap, ofs, k, ans)
//
    in
      if ans
        then let
          prval () = fpf (pf)
        in
          loop (A, cap, ptr_succ<ki> (p_kx))
        end // end of [then]
        else let
          val (pf2, fpf2 | p2_kx) = $UN.ptr0_vtake{ki?}(p2_kx)
          val () = p2_kx->0 := p_kx->0
          val () = p2_kx->1 := p_kx->1
          val () = hashtbl_linprb_keyitm_nullize<key,itm> (!p_kx)
          prval () = $UN.castview0((pf, fpf))
          prval () = $UN.castview0((pf2, fpf2))
        in
          loop (A, cap, ptr_succ<ki> (p_kx))
        end // end of [else]
      // end of [if]
    end // end of [else]
  // end of [if]
end // end of [then]
else false (*~stopped*)
//
end // end of [loop]
//
val stopped = loop (A, cap, p_kx)
val _(*true*) =
(
  if not(stopped) then loop (A, cap, p0) else true
) : bool // end of [val]
//
in
  // nothing
end // end of [keyitmarr_reinserts]

(* ****** ****** *)

datavtype hashtbl
(
  key:t@ype, itm:vt@ype+
) =
  {m:int | m >= 1}
  HASHTBL of (
    arrayptr ((key, itm), m), size_t m, size_t(*ntot*)
  ) (* end of [HASHTBL] *)
// end of [hashtbl]

(* ****** ****** *)

assume
hashtbl_vtype (key:t0p, itm:vt0p) = hashtbl (key, itm)

(* ****** ****** *)

implement
{key,itm}
hashtbl_make_nil
  (cap) = let
//
vtypedef ki = @(key, itm)
//
prval
[m:int]
EQINT () = eqint_make_guint (cap)
//
val A0 =
arrayptr_make_uninitized<ki> (cap)
val p_A0 = ptrcast(A0)
val _(*ptr*) =
$STRING.memset_unsafe (p_A0, 0, cap*sizeof<ki>)
val A0 = $UN.castvwtp0{arrayptr(ki,m)}(A0)
//
in
  HASHTBL (A0, cap, i2sz(0))
end // end of [hashtbl_make_nil]

(* ****** ****** *)
  
implement{
} hashtbl_get_size
  (tbl) = let
//
val+HASHTBL(A, cap, ntot) = tbl in ntot
//
end // end of [hashtbl_get_size]

(* ****** ****** *)

implement{
} hashtbl_get_capacity
  (tbl) = let
//
val+HASHTBL (A, cap, ntot) = tbl in (cap)
//
end // end of [hashtbl_get_capacity]
  
(* ****** ****** *)

implement
{key,itm}
hashtbl_search_ref
  (tbl, k0) = let
//
val+HASHTBL{..}{m}(A, cap, ntot) = tbl
//
val hk = hash_key<key> (k0)
val ofs = g0uint_mod (hk, $UN.cast{ulint}(cap))
val ofs = $UN.cast{sizeLt(m)}(ofs)
//
val p_A = ptrcast(A)
prval pf_A = arrayptr_takeout(A)
var ans: bool // uninitalized
val p_kx = keyitmarr_linprb2<key,itm> (!p_A, cap, ofs, k0, ans)
prval ((*void*)) = arrayptr_addback (pf_A | A)
//
in
//
if ans then let
  vtypedef ki = @(key, itm)
  val (pf, fpf | p_kx) = $UN.ptr0_vtake{ki}(p_kx)
  val p_itm = addr@(p_kx->1)
  prval ((*void*)) = fpf (pf)
in
  $UN.cast{cPtr1(itm)}(p_itm)
end else cptr_null{itm}((*void*))
//
end // end of [hashtbl_search_ref]

(* ****** ****** *)

implement
{key,itm}
hashtbl_insert
  (tbl, k, x, res) = let
//
vtypedef ki = @(key, itm)
//
val+@HASHTBL{..}{m}(A, cap, ntot) = tbl
//
val hk = hash_key<key> (k)
val ofs = g0uint_mod (hk, $UN.cast{ulint}(cap))
val ofs = $UN.cast{sizeLt(m)}(ofs)
//
val p_A = ptrcast(A)
prval pf_A = arrayptr_takeout(A)
var ans: bool // uninitalized
val p_kx = keyitmarr_linprb2<key,itm> (!p_A, cap, ofs, k, ans)
prval ((*void*)) = arrayptr_addback (pf_A | A)
//
in
//
if ans
then let
  val (pf, fpf | p_kx) = $UN.ptr0_vtake{ki}(p_kx)
  val x2 = p_kx->1
  val () = p_kx->1 := x
  prval ((*void*)) = fpf (pf)
  val () = res := x2
  prval () = opt_some{itm}(res)
  prval () = fold@ (tbl)
in
  true
end // end of [then]
else let
//
// HX-2013-05: [k] is not found
//
in
  if p_kx > 0 then let
    val (pf, fpf | p_kx) = $UN.ptr0_vtake{ki?}(p_kx)
    val () = p_kx->0 := k
    val () = p_kx->1 := x
    val () = ntot := succ(ntot)
    prval () = $UN.castview0((pf, fpf))
    prval () = opt_none{itm}(res)
    prval () = fold@ (tbl)
    val () =
    if hashtbl$recapacitize() > 0
      then ignoret(hashtbl_adjust_capacity<key,itm> (tbl))
    // end of [if] // end of [val]
  in
    false
  end else let
    val () = res := x
    prval () = opt_some{itm}(res)
    prval () = fold@ (tbl)
  in
    true
  end // end of [if]
end // end of [else]
//
end // end of [hashtbl_insert]

(* ****** ****** *)

implement
{key,itm}
hashtbl_takeout
  (tbl, k, res) = let
//
val+@HASHTBL{..}{m}(A, cap, ntot) = tbl
//
val hk = hash_key<key> (k)
val ofs = g0uint_mod (hk, $UN.cast{ulint}(cap))
val ofs = $UN.cast{sizeLt(m)}(ofs)
//
val p_A = ptrcast(A)
prval pf_A = arrayptr_takeout(A)
var ans: bool // uninitalized
val p_kx = keyitmarr_linprb2<key,itm> (!p_A, cap, ofs, k, ans)
prval ((*void*)) = arrayptr_addback (pf_A | A)
//
in
//
if ans
then let
  vtypedef ki = @(key, itm)
  val (pf, fpf | p_kx) = $UN.ptr0_vtake{ki}(p_kx)
  val () = res := p_kx->1
  val () = hashtbl_linprb_keyitm_nullize<key,itm> (!p_kx)
  val () = ntot := pred (ntot)
  prval () = $UN.castview0 ((pf, fpf))
  prval pf_A = arrayptr_takeout(A)
  val () = keyitmarr_reinserts<key,itm> (!p_A, cap, ptr_succ<ki> (p_kx))
  prval ((*void*)) = arrayptr_addback (pf_A | A)
  prval () = fold@ (tbl)
  prval () = opt_some{itm}(res)
in
  true
end // end of [then]
else let
  prval () = fold@ (tbl)
  prval () = opt_none{itm}(res)
in
  false
end // end of [else]
//
end // end of [hashtbl_takeout]

(* ****** ****** *)

implement
{key,itm}
hashtbl_reset_capacity
  (tbl, cap2) = let
//
val+@HASHTBL{..}{m}(A, cap, ntot) = tbl
//
in
//
if
ntot <= cap2
then let
//
val p0 = ptrcast(A)
vtypedef ki = @(key, itm)
val p_end = ptr_add<ki> (p0, cap)
//
fun
loop{m2:int}
(
  p_A2: ptr, cap2: size_t(m2), p: ptr
) : void = let
in
//
if
p < p_end
then let
  val (pf, fpf | p) =
    $UN.ptr0_vtake{ki}(p)
  val isnul =
    hashtbl_linprb_keyitm_is_null<key,itm> (!p)
in
  if isnul
    then let
      prval ((*void*)) = fpf (pf)
    in
      loop (p_A2, cap2, ptr_succ<ki> (p))
    end // end of [then]
    else let
      val k = p->0
      val hk = hash_key<key> (k)
      var ans: bool // uninitalized
      val ofs = g0uint_mod (hk, $UN.cast{ulint}(cap2))
      val ofs = $UN.cast{sizeLt(m2)}(ofs)
      val (pf_A2, fpf_A2 | p_A2) = $UN.ptr0_vtake{array(ki,m2)}(p_A2)
      val p_kx = keyitmarr_linprb2<key,itm> (!p_A2, cap2, ofs, k, ans)
      prval ((*void*)) = fpf_A2 (pf_A2)
      val (pf_kx, fpf_kx | p_kx) = $UN.ptr0_vtake{ki?}(p_kx)
      val () = p_kx->0 := k
      val () = p_kx->1 := p->1
      prval () = $UN.castview0((pf, fpf))
      prval () = $UN.castview0((pf_kx, fpf_kx))
    in
      loop (p_A2, cap2, ptr_succ<ki> (p))
    end // end of [else]
end // end of [then]
else () // end of [else]
//
end // end of [loop]
//
prval
[m2:int]
EQINT () = eqint_make_guint (cap2)
//
val A2 =
arrayptr_make_uninitized<ki> (cap2)
val p_A2 = ptrcast(A2)
val _(*ptr*) =
$STRING.memset_unsafe (p_A2, 0, cap2*sizeof<ki>)
val ((*void*)) = loop (p_A2, cap2, p0)
val A2 = $UN.castvwtp0{arrayptr(ki,m2)}(A2)
//
val () =
arrayptr_free ($UN.castvwtp0{arrayptr(ki?,m)}(A))
//
val () = A := A2
val () = cap := cap2
prval () = fold@ (tbl)
//
in
  true
end // end of [then]
else let
  prval () = fold@ (tbl)
in
  false
end // end of [else]
//
end // end of [hashtbl_reset_capacity]

(* ****** ****** *)
//
// HX: please reimplement it if needed
//
implement
{key,itm}
hashtbl_adjust_capacity
  (tbl) = let
//
val+HASHTBL (A, cap, ntot) = tbl
//
in
//
if ntot + ntot >= cap
  then hashtbl_reset_capacity (tbl, cap + cap) else false
//
end // end of [hashtbl_adjust_capacity]

(* ****** ****** *)

implement
{key,itm}{env}
hashtbl_foreach_env
  (tbl, env) = let
//
val+HASHTBL (A, cap, _) = tbl
//
val p0 = ptrcast(A)
vtypedef ki = @(key, itm)
val p_end = ptr_add<ki> (p0, cap)
//
fun
loop
(
  p: ptr, env: &env >> _
) : void = let
in
//
if
p < p_end
then let
  val (pf, fpf | p) =
    $UN.ptr0_vtake{ki}(p)
  val isnul =
    hashtbl_linprb_keyitm_is_null<key,itm> (!p)
in
  if isnul
    then let
      prval () = fpf (pf)
    in
      loop (ptr_succ<ki> (p), env)
    end // end of [then]
    else let
      val () =
        hashtbl_foreach$fwork<key,itm><env> (p->0, p->1, env)
      prval () = fpf (pf)
    in
      loop (ptr_succ<ki> (p), env)
    end // end of [else]
  // end of [if]
end // end of [then]
else ((*exit*)) // end of [else]
//
end // end of [loop]
//
in
  loop (p0, env)
end // end of [hashtbl_foreach_env]

(* ****** ****** *)

implement
{key,itm}
hashtbl_free (tbl) = let
//
typedef ki = @(key, itm)
//
val+~HASHTBL (A, cap, ntot) = tbl in arrayptr_free{ki}(A)
//
end // end of [hashtbl_free]

(* ****** ****** *)

implement
{key,itm}{ki2}
hashtbl_flistize
  (tbl) = let
//
val+~HASHTBL (A, cap, _) = tbl
//
val p0 = ptrcast(A)
vtypedef ki = @(key, itm)
val p_end = ptr_add<ki> (p0, cap)
//
fun
loop
(
  p: ptr
, res: List0_vt(ki2)
) : List0_vt(ki2) = let
in
//
if
p > p0
then let
  val p = ptr_pred<ki> (p)
  val (pf, fpf | p) = $UN.ptr0_vtake{ki}(p)
  val isnul = hashtbl_linprb_keyitm_is_null<key,itm> (!p)
in
  if isnul
    then let
      prval ((*void*)) = fpf (pf)
    in
      loop (p, res)
    end // end of [then]
    else let
      val kx2 =
        hashtbl_flistize$fopr<key,itm><ki2> (p->0, p->1)
      val res = list_vt_cons{ki2}(kx2, res)
      val ((*void*)) = hashtbl_linprb_keyitm_nullize<key,itm> (!p)
      prval ((*void*)) = $UN.castview0 ((pf, fpf))
    in
      loop (p, res)
    end // end of [else]
  // end of [if]
end // end of [then]
else res // end of [else]
//
end // end of [loop]
//
val res = $effmask_all(loop (p_end, list_vt_nil(*void*)))
//
val ((*freed*)) = arrayptr_free($UN.castvwtp0{arrayptr(ki?,0)}(A))
//
in
  res
end // end of [hashtbl_flistize]

(* ****** ****** *)

(* end of [hashtbl_linprb.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: July, 2013 *)

(* ****** ****** *)
//
// HX: For supporting ref-counted resourse.
// HX: This implementation does not support locked counting
//
(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libats/SATS/refcount.sats"

(* ****** ****** *)
//
datavtype
refcnt(a:vt@ype) =
  | REFCNT (a) of (uint, a)
//
(* ****** ****** *)

assume
refcnt_vt0ype_vtype(a) = refcnt(a)

(* ****** ****** *)

implement
{a}(*tmp*)
refcnt (x) = REFCNT (1u, x)
implement
{a}(*tmp*)
refcnt_make_elt (x) = REFCNT (1u, x)

(* ****** ****** *)

implement
{a}(*tmp*)
refcnt_get_count
  (rfc) = let
//
val+REFCNT (u, _) = rfc
//
in
  $UN.cast{intGte(1)}(u)
end // end of [refcnt_get_count]

(* ****** ****** *)

implement
{a}(*tmp*)
refcnt_incref
  (rfc) = let
//
val+@REFCNT (u, _) = rfc
val ((*void*)) = u := succ (u)
prval () = fold@(rfc)
//
in
  $UN.castvwtp1{refcnt(a)}(rfc)
end // end of [refcnt_incref]

(* ****** ****** *)

implement
{a}(*tmp*)
refcnt_decref
  (rfc, x0) = let
//
val+@REFCNT (u, x) = rfc
val u1 = pred (u)
//
in
//
if
isgtz(u1)
then let
  val ((*void*)) = u := u1
  prval () = fold@(rfc)
  prval () = $UN.cast2void (rfc)
  prval () = opt_none{a}(x0)
in
  false
end else let
  val () = x0 := x
  val ((*freed*)) = free@(rfc)
  prval () = opt_some{a}(x0)
in
  true
end // end of [if]
//
end // end of [refcnt_decref]

implement
{a}(*tmp*)
refcnt_decref_opt
  (rfc) = let
//
var x0: a?
val ans = refcnt_decref (rfc, x0)
//
in (* in of [let] *)
//
if ans
then let
  prval () = opt_unsome{a}(x0) in Some_vt{a}(x0)
end else let
  prval () = opt_unnone{a}(x0) in None_vt{a}((*void*))
end // end of [if]
//
end // end of [refcnt_decref_opt]

(* ****** ****** *)

implement
{a}(*tmp*)
refcnt_vtakeout
  (rfc) = let
//
val+@REFCNT (_, x) = rfc
val p_x = addr@x
prval () = fold@(rfc)
//
val (pf, fpf | p_x) = $UN.ptr_vtake{a}(p_x)
//
in
  (pf, fpf | p_x)
end // end of [refcnt_vtakeout]

(* ****** ****** *)

(* end of [refcount.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                       ATS/contrib/libats-hwxi                       *)
(*                                                                     *)
(***********************************************************************)

(*
** Copyright (C) 2014 Hongwei Xi, ATS Trustful Software, Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and associated documentation files (the "Software"),
** to deal in the Software without restriction, including without limitation
** the rights to use, copy, modify, merge, publish, distribute, sublicense,
** and/or sell copies of the Software, and to permit persons to whom the
** Software is furnished to do so, subject to the following stated conditions:
** 
** The above copyright notice and this permission notice shall be included in
** all copies or substantial portions of the Software.
** 
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
** OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
** THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
** LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
** FROM OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
** IN THE SOFTWARE.
*)

(* ****** ****** *)
//
// An abstract thread interface
// implemented on top of pthreads
//
(* ****** ****** *)

%{^
//
#include <pthread.h>
//
%} // end of [%{^]

(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libats/SATS/athread.sats"

(* ****** ****** *)
//
assume
locked_v (l:addr) = unit_v
//
(* ****** ****** *)

implement
{}(*tmp*)
spin_create () = let
//
typedef
pthread_spinlock_t = $extype"pthread_spinlock_t"
//
val (pfat, pfgc | p) = ptr_alloc<pthread_spinlock_t> ()
val err = $extfcall (int, "pthread_spin_init", p, 0(*pshared*))
//
in
//
if err = 0
  then
    $UN.castvwtp0{spin1}((pfat, pfgc | p))
  else let
    val () = ptr_free (pfgc, pfat | p) in $UN.castvwtp0{spin0}(0)
  end // end of [else]
//
end // end of [spin_create]

(* ****** ****** *)

implement
{}(*tmp*)
spin_vt_destroy (spn) = let
//
val p_spn = spin2ptr_vt (spn)
prval () = $UN.castview0 (spn)
//
in
//
if
p_spn > 0
then let
  val err = $extfcall (int, "pthread_spin_destroy", p_spn)
  val ((*freed*)) = $extfcall (void, "atspre_ptr_free", p_spn)
in
  // nothing
end // end of [then]
else () // end of [else]
//
end // end of [spin_vt_destroy]

(* ****** ****** *)

implement
{}(*tmp*)
spin_lock (spn) = let
//
val err = $extfcall
  (int, "pthread_spin_lock", $UN.cast{ptr}(spn))
//
(*
val ((*void*)) = assertloc (err = 0)
*)
//
in
  (unit_v () | ())
end // end of [spin_lock]

(* ****** ****** *)

implement
{}(*tmp*)
spin_unlock
  (pf | spn) = let
//
prval unit_v () = pf
//
val err = $extfcall
  (int, "pthread_spin_unlock", $UN.cast{ptr}(spn))
//
(*
val ((*void*)) = assertloc (err = 0)
*)
//
in
  // nothing
end // end of [spin_unlock]

(* ****** ****** *)

implement
{}(*tmp*)
mutex_create () = let
//
typedef
pthread_mutex_t = $extype"pthread_mutex_t"
//
val (pfat, pfgc | p) = ptr_alloc<pthread_mutex_t> ()
val err = $extfcall (int, "pthread_mutex_init", p, 0(*attr*))
//
in
//
if err = 0
  then
    $UN.castvwtp0{mutex1}((pfat, pfgc | p))
  else let
    val () = ptr_free (pfgc, pfat | p) in $UN.castvwtp0{mutex0}(0)
  end // end of [else]
//
end // end of [mutex_create]
  
(* ****** ****** *)

implement
{}(*tmp*)
mutex_vt_destroy (mtx) = let
//
val p_mtx = mutex2ptr_vt (mtx)
prval () = $UN.castview0 (mtx)
//
in
//
if
p_mtx > 0
then let
  val err = $extfcall (int, "pthread_mutex_destroy", p_mtx)
  val ((*freed*)) = $extfcall (void, "atspre_ptr_free", p_mtx)
in
  // nothing
end // end of [then]
else () // end of [else]
//
end // end of [mutex_vt_destroy]

(* ****** ****** *)

implement
{}(*tmp*)
mutex_lock (mtx) = let
//
val err = $extfcall
  (int, "pthread_mutex_lock", $UN.cast{ptr}(mtx))
//
(*
val ((*void*)) = assertloc (err = 0)
*)
//
in
  (unit_v () | ())
end // end of [mutex_lock]
  
(* ****** ****** *)
  
implement
{}(*tmp*)
mutex_unlock
  (pf | mtx) = let
//
prval unit_v () = pf
//
val err = $extfcall
  (int, "pthread_mutex_unlock", $UN.cast{ptr}(mtx))
//
(*
val ((*void*)) = assertloc (err = 0)
*)
//
in
  // nothing
end // end of [mutex_unlock]

(* ****** ****** *)

implement
{}(*tmp*)
condvar_create () = let
//
typedef
pthread_cond_t = $extype"pthread_cond_t"
//
val (pfat, pfgc | p) = ptr_alloc<pthread_cond_t> ()
val err = $extfcall (int, "pthread_cond_init", p, 0(*attr*))
//
in
//
if err = 0
  then
    $UN.castvwtp0{condvar1}((pfat, pfgc | p))
  else let
    val () = ptr_free (pfgc, pfat | p) in $UN.castvwtp0{condvar0}(0)
  end // end of [else]
//
end // end of [condvar_create]

(* ****** ****** *)

implement
{}(*tmp*)
condvar_vt_destroy (cvr) = let
//
val p_cvr = condvar2ptr_vt (cvr)
prval () = $UN.castview0 (cvr)
//
in
//
if
p_cvr > 0
then let
  val err = $extfcall (int, "pthread_cond_destroy", p_cvr)
  val ((*freed*)) = $extfcall (void, "atspre_ptr_free", p_cvr)
in
  // nothing
end // end of [then]
else () // end of [else]
//
end // end of [condvar_vt_destroy]

(* ****** ****** *)
  
implement
{}(*tmp*)
condvar_signal
  (cvr) = let
//
val err = (
  $extfcall (int, "pthread_cond_signal", $UN.cast{ptr}(cvr))
) (* end of [val] *)
//
(*
val ((*void*)) = assertloc (err = 0)
*)
//
in
  // nothing
end // end of [condvar_signal]

(* ****** ****** *)

implement
{}(*tmp*)
condvar_broadcast
  (cvr) = let
//
val err = (
  $extfcall (int, "pthread_cond_broadcast", $UN.cast{ptr}(cvr))
) (* end of [val] *)
//
(*
val ((*void*)) = assertloc (err = 0)
*)
//
in
  // nothing
end // end of [condvar_broadcast]

(* ****** ****** *)

implement
{}(*tmp*)
condvar_wait
  (pf | cvr, mtx) = let
//
val err = $extfcall
  (int, "pthread_cond_wait", $UN.cast{ptr}(cvr), $UN.cast{ptr}(mtx))
//
(*
val ((*void*)) = assertloc (err = 0)
*)
//
in
  // nothing
end // end of [condvar_wait]
    
(* ****** ****** *)

abst@ype pthread_t = $extype"pthread_t"
abst@ype pthread_attr_t = $extype"pthread_attr_t"

(* ****** ****** *)

implement
{}(*tmp*)
athread_create_funenv
  (tid, fwork, env) = let
//
var tid2: pthread_t
var attr: pthread_attr_t
val
_(*err*) =
$extfcall (int, "pthread_attr_init", addr@attr)
//
val
_(*err*) =
$extfcall (
  int
, "pthread_attr_setdetachstate"
, addr@attr, $extval(int, "PTHREAD_CREATE_DETACHED")
) (* end of [val] *)
//
val err =
$extfcall (
  int, "pthread_create"
, addr@tid2, addr@attr, fwork, $UN.castvwtp0{ptr}(env)
) (* end of [val] *)
val () = tid := $UN.cast2lint(tid2)
//
val _(*err*) = $extfcall (int, "pthread_attr_destroy", addr@attr)
//
in
  err
end // end of [athread_create_funenv]

(* ****** ****** *)

(* end of [athread_posix.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// HX-2014-12:
// ported to ATS/Postitats from ATS/Anairiats
//
(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libats/SATS/bitvec.sats"

(* ****** ****** *)

macdef U0 = $UN.cast{uintptr}(0)
macdef U1 = $UN.cast{uintptr}(1)
macdef U_1 = $UN.cast{uintptr}(~1)

(* ****** ****** *)

macdef
uintptr_p_inc(p) = ptr_succ<uintptr> (,(p))
macdef
uintptr_p_get(p) = $UN.ptr0_get<uintptr> (,(p))
macdef
uintptr_p_set(p, x) = $UN.ptr0_set<uintptr> (,(p), ,(x))

(* ****** ****** *)
//
implement
{}(*tmp*)
bitvec_get_wordsize
(
// argumentless
) = $UN.cast{intGt(0)}(8*sz2i(sizeof<ptr>))
//
implement
{}(*tmp*)
bitvec_get_wordsize_log
(
// argumentless
) = $effmask_all (
let
  val wsz = bitvec_get_wordsize()
in
//
case+ 0 of
| _ when wsz=16 => 4
| _ when wsz=32 => 5
| _ when wsz=64 => 6
| _ (* unsupported *) => let val () = assertloc(false) in 0 end
//
end // end of [let]
) (* end of [$effmask_all] *)
//
(* ****** ****** *)

implement
{}(*tmp*)
bitvecptr_make_none
  {n}(nbit) = let
//
val wsz = bitvec_get_wordsize ()
val log = bitvec_get_wordsize_log ()
val asz =
  $UN.cast{intGte(0)}((nbit + wsz - 1) >> log)
//
in
//
$UN.castvwtp0{bitvecptr(n)}
  (arrayptr_make_elt<uintptr> (i2sz(asz), U0))
//
end // end of [bitvecptr_make_none]

(* ****** ****** *)

implement
{}(*tmp*)
bitvecptr_make_full
  {n}(nbit) = vec where
{
//
val wsz = bitvec_get_wordsize ()
val log = bitvec_get_wordsize_log ()
val asz =
  $UN.cast{intGte(0)}((nbit + wsz - 1) >> log)
//
val extra =
  $UN.cast{intGte(0)}((asz << log) - nbit)
//
val vec =
$UN.castvwtp0{bitvecptr(n)}
  (arrayptr_make_elt<uintptr> (i2sz(asz), U_1))
//
val () =
if extra > 0
  then $UN.ptr0_set_at<uintptr>(ptrcast(vec), asz-1, U_1 >> extra)
// end of [if]
//
} (* end of [bitvecptr_make_full] *)

(* ****** ****** *)
//
implement
{}(*tmp*)
bitvecptr_free (vec) =
  arrayptr_free($UN.castvwtp0{arrayptr(intptr,0)}(vec))
//
(* ****** ****** *)

implement
{}(*tmp*)
bitvec_get_at
  (vec, i) = let
//
val wsz = bitvec_get_wordsize ()
val log = bitvec_get_wordsize_log ()
//
val j = (i >> log)
val k = i - (j << log)
val k = $UN.cast{intGte(0)}(k)
//
val w =
  $UN.ptr0_get_at<uintptr> (addr@vec, j)
//
in
  $UN.cast{bit}((w >> k) land U1)
end // end of [bitvec_get_at]

(* ****** ****** *)

implement
{}(*tmp*)
bitvec_set_at
  (vec, i, b) = let
//
val wsz = bitvec_get_wordsize ()
val log = bitvec_get_wordsize_log ()
//
val j = (i >> log)
val k = i - (j << log)
val k = $UN.cast{intGte(0)}(k)
//
val p = ptr_add<uintptr> (addr@vec, j)
//
val m = U1 << k
val w = uintptr_p_get (p)
//
in
//
if
b > 0
then uintptr_p_set (p, w lor m)
else uintptr_p_set (p, w land ~m)
//
end // end of [bitvec_set_at]

(* ****** ****** *)

implement
{}(*tmp*)
bitvec_flip_at
  (vec, i) = let
//
val wsz = bitvec_get_wordsize ()
val log = bitvec_get_wordsize_log ()
//
val j = (i >> log)
val k = i - (j << log)
val k = $UN.cast{intGte(0)}(k)
//
val p = ptr_add<uintptr> (addr@vec, j)
//
val m = U1 << k
val w = uintptr_p_get (p)
//
in
  uintptr_p_set (p, w lxor m)
end // end of [bitvec_flip_at]

(* ****** ****** *)

implement
{}(*tmp*)
bitvecptr_get_at
  {l}{n}
  (bvp, i) = bit where
{
//
val (pf, fpf | p) =
  $UN.ptr_vtake{bitvec(n)}(ptrcast(bvp))
val bit = bitvec_get_at (!p, i)
prval ((*void*)) = fpf (pf)
//
} (* end of [bitvecptr_get_at] *)

(* ****** ****** *)

implement
{}(*tmp*)
bitvecptr_set_at
  {l}{n}
  (bvp, i, bit) =
{
//
val (pf, fpf | p) =
  $UN.ptr_vtake{bitvec(n)}(ptrcast(bvp))
val bit = bitvec_set_at (!p, i, bit)
prval ((*void*)) = fpf (pf)
//
} (* end of [bitvecptr_set_at] *)

(* ****** ****** *)

implement
{}(*tmp*)
bitvecptr_flip_at
  {l}{n}
  (bvp, i) =
{
//
val (pf, fpf | p) =
  $UN.ptr_vtake{bitvec(n)}(ptrcast(bvp))
val bit = bitvec_flip_at (!p, i)
prval ((*void*)) = fpf (pf)
//
} (* end of [bitvecptr_flip_at] *)

(* ****** ****** *)

implement
{}(*tmp*)
bitvec_is_none
  (vec, nbit) = let
//
val wsz = bitvec_get_wordsize ()
val log = bitvec_get_wordsize_log ()
val asz = $UN.cast{intGte(0)}((nbit + wsz - 1) >> log)
//
fun
loop{n:nat} .<n>.
(
  p: ptr, n: int(n)
) :<> bool =
(
//
if
n > 0
then let
//
val i =
  uintptr_p_get (p)
//
in
  if i = U0
    then loop (uintptr_p_inc (p), n-1) else false
  // end of [if]
end // end of [then]
else true // end of [else]
//
) (* end of [loop] *)
//
in
  loop (addr@vec, asz)
end // end of [bitvec_is_none]

(* ****** ****** *)

implement
{}(*tmp*)
bitvecptr_is_none
  {l}{n}
  (bvp, nbit) = ans where
{
//
val (pf, fpf | p) =
  $UN.ptr_vtake{bitvec(n)}(ptrcast(bvp))
val ans = bitvec_is_none (!p, nbit)
prval ((*void*)) = fpf (pf)
//
} (* end of [bitvecptr_is_none] *)

(* ****** ****** *)

implement
{}(*tmp*)
bitvec_is_full
  (vec, nbit) = let
//
val wsz = bitvec_get_wordsize ()
val log = bitvec_get_wordsize_log ()
val asz = $UN.cast{intGte(0)}((nbit + wsz - 1) >> log)
//
fun
loop{n:nat} .<n>.
(
  p: ptr, n: int(n)
) :<> bool =
(
//
if
n > 1
then let
  val i = uintptr_p_get (p)
in
  if i = U_1 then loop (uintptr_p_inc (p), n-1) else false
end // end of [then]
else true // end of [else]
//
) (* end of [loop] *)
//
in
//
if
nbit > 0
then (
//
if
loop (addr@vec, asz)
then let
  val extra =
    $UN.cast{intGte(0)}((asz << log) - nbit)
  // end of [val]
in
  $UN.ptr0_get_at<uintptr> (addr@vec, asz-1) = (U_1 >> extra)
end // end of [then]
else false // end of [else]
//
) (* end of [then] *)
else true // end of [else]
//
end // end of [bitvec_is_full]

(* ****** ****** *)

implement
{}(*tmp*)
bitvecptr_is_full
  {l}{n}
  (bvp, nbit) = ans where
{
//
val (pf, fpf | p) =
  $UN.ptr_vtake{bitvec(n)}(ptrcast(bvp))
val ans = bitvec_is_full (!p, nbit)
prval ((*void*)) = fpf (pf)
//
} (* end of [bitvecptr_is_full] *)

(* ****** ****** *)

implement
{}(*tmp*)
bitvec_equal
  (vec1, vec2, nbit) = let
//
val wsz = bitvec_get_wordsize ()
val log = bitvec_get_wordsize_log ()
val asz = $UN.cast{intGte(0)}((nbit + wsz - 1) >> log)
//
fun
loop{n:nat} .<n>.
(
  p1: ptr, p2: ptr, n: int(n)
) :<> bool =
(
//
if
n > 0
then let
  val i1 = uintptr_p_get (p1)
  and i2 = uintptr_p_get (p2)
in
  if i1 = i2
    then let
      val p1 = uintptr_p_inc (p1)
      and p2 = uintptr_p_inc (p2)
    in
      loop (p1, p2, n-1)
    end // end of [then]
    else false // end of [else]
  // end of [if]
end else true // end of [if]
//
) (* end of [loop] *)
//
in
  loop (addr@vec1, addr@vec2, asz)
end // end of [bitvec_equal]

(* ****** ****** *)
//
implement
{}(*tmp*)
bitvec_notequal
  (vec1, vec2, nbit) = not(bitvec_equal(vec1, vec2, nbit))
//
(* ****** ****** *)

implement
{}(*tmp*)
bitvecptr_equal
  {l1,l2}{n}
  (bvp1, bvp2, nbit) = ans where
{
//
val (pf1, fpf1 | p1) =
  $UN.ptr_vtake{bitvec(n)}(ptrcast(bvp1))
and (pf2, fpf2 | p2) =
  $UN.ptr_vtake{bitvec(n)}(ptrcast(bvp2))
val ans = bitvec_equal (!p1, !p2, nbit)
//
prval () = fpf1 (pf1) and () = fpf2 (pf2)
//
} (* end of [bitvecptr_equal] *)

(* ****** ****** *)
//
implement
{}(*tmp*)
bitvecptr_notequal
  (bvp1, bvp2, nbit) =
  not(bitvecptr_equal(bvp1, bvp2, nbit))
//
(* ****** ****** *)

implement
{}(*tmp*)
bitvec_copy
  (vec1, vec2, nbit) = let
//
val wsz = bitvec_get_wordsize ()
val log = bitvec_get_wordsize_log ()
val asz = $UN.cast{intGte(0)}((nbit + wsz - 1) >> log)
//
fun
loop{n:nat} .<n>.
(
  p1: ptr, p2: ptr, n: int(n)
) :<!wrt> void =
(
//
if
n > 0
then let
  val i2 = uintptr_p_get (p2)
  val () = uintptr_p_set (p1, i2)
  val p1 = uintptr_p_inc (p1)
  and p2 = uintptr_p_inc (p2)
in
  loop (p1, p2, n-1)
end // end of [then]
else () // end of [else]
//
) (* end of [loop] *)
//
in
  loop (addr@vec1, addr@vec2, asz)
end // end of [bitvec_copy]

(* ****** ****** *)

implement
{}(*tmp*)
bitvec_lnot
  (vec, nbit) = let
//
val wsz = bitvec_get_wordsize ()
val log = bitvec_get_wordsize_log ()
val asz = $UN.cast{intGte(0)}((nbit + wsz - 1) >> log)
//
fun
loop{n:nat} .<n>.
  (p: ptr, n: int(n)):<!wrt> ptr =
(
//
if
n > 1
then let
  val i = uintptr_p_get (p)
  val () = uintptr_p_set (p, lnot(i))
in
  loop (uintptr_p_inc (p), n - 1)
end // end of [then]
else p // end of [else]
//
) (* end of [loop] *)
//
in
//
if
nbit > 0
then let
  val pz = loop (addr@vec, asz)
  val extra =
    $UN.cast{intGte(0)}((asz << log) - nbit)
  // end of [val]
  val i = uintptr_p_get (pz)
  val i2 = lnot(i) land (U_1 >> extra)
  val () = uintptr_p_set (pz, i2)
in
  // nothing
end // end of [then]
else () // end of [else]
//
end // end of [bitvec_lnot]

(* ****** ****** *)

implement
{}(*tmp*)
bitvecptr_lnot
  {l}{n}
  (bvp, nbit) = let
//
val (pf, fpf | p) =
  $UN.ptr_vtake{bitvec(n)}(ptrcast(bvp))
val ((*void*)) = bitvec_lnot (!p, nbit)
prval ((*void*)) = fpf (pf)
//
in
  // nothing
end // end of [bitvecptr_lnot]

(* ****** ****** *)

implement
{}(*tmp*)
bitvec_lor
  (vec1, vec2, nbit) = let
//
val wsz = bitvec_get_wordsize ()
val log = bitvec_get_wordsize_log ()
val asz = $UN.cast{intGte(0)}((nbit + wsz - 1) >> log)
//
fun
loop{n:nat} .<n>.
(
  p1: ptr, p2: ptr, n: int(n)
) :<!wrt> void =
(
//
if
n > 0
then let
  val i1 = uintptr_p_get (p1)
  val i2 = uintptr_p_get (p2)
  val () = uintptr_p_set (p1, i1 lor i2)
  val p1 = uintptr_p_inc (p1)
  and p2 = uintptr_p_inc (p2)
in
  loop (p1, p2, n-1)
end // end of [then]
else () // end of [else]
//
) (* end of [loop] *)
//
in
  loop (addr@vec1, addr@vec2, asz)
end // end of [bitvec_lor]

(* ****** ****** *)

implement
{}(*tmp*)
bitvec_lxor
  (vec1, vec2, nbit) = let
//
val wsz = bitvec_get_wordsize ()
val log = bitvec_get_wordsize_log ()
val asz = $UN.cast{intGte(0)}((nbit + wsz - 1) >> log)
//
fun
loop{n:nat} .<n>.
(
  p1: ptr, p2: ptr, n: int(n)
) :<!wrt> void =
(
//
if
n > 0
then let
  val i1 = uintptr_p_get (p1)
  val i2 = uintptr_p_get (p2)
  val () = uintptr_p_set (p1, i1 lxor i2)
  val p1 = uintptr_p_inc (p1)
  and p2 = uintptr_p_inc (p2)
in
  loop (p1, p2, n-1)
end // end of [then]
else () // end of [else]
//
) (* end of [loop] *)
//
in
  loop (addr@vec1, addr@vec2, asz)
end // end of [bitvec_lxor]

(* ****** ****** *)

implement
{}(*tmp*)
bitvec_land
  (vec1, vec2, nbit) = let
//
val wsz = bitvec_get_wordsize ()
val log = bitvec_get_wordsize_log ()
val asz = $UN.cast{intGte(0)}((nbit + wsz - 1) >> log)
//
fun
loop{n:nat} .<n>.
(
  p1: ptr, p2: ptr, n: int(n)
) :<!wrt> void =
(
//
if
n > 0
then let
  val i1 = uintptr_p_get (p1)
  val i2 = uintptr_p_get (p2)
  val () = uintptr_p_set (p1, i1 land i2)
  val p1 = uintptr_p_inc (p1)
  and p2 = uintptr_p_inc (p2)
in
  loop (p1, p2, n-1)
end // end of [then]
else () // end of [else]
//
) (* end of [loop] *)
//
in
  loop (addr@vec1, addr@vec2, asz)
end // end of [bitvec_land]

(* ****** ****** *)

implement
{}(*tmp*)
bitvecptr_lor
  {l1,l2}{n}(bvp1, bvp2, nbit) = let
//
val (pf1, fpf1 | p1) =
  $UN.ptr_vtake{bitvec(n)}(ptrcast(bvp1))
and (pf2, fpf2 | p2) =
  $UN.ptr_vtake{bitvec(n)}(ptrcast(bvp2))
val ((*void*)) = bitvec_lor (!p1, !p2, nbit)
//
prval () = fpf1 (pf1) and () = fpf2 (pf2)
//
in
  // nothing
end // end of [bitvecptr_lor]

(* ****** ****** *)

implement
{}(*tmp*)
bitvecptr_lxor
  {l1,l2}{n}
  (bvp1, bvp2, nbit) = let
//
val (pf1, fpf1 | p1) =
  $UN.ptr_vtake{bitvec(n)}(ptrcast(bvp1))
and (pf2, fpf2 | p2) =
  $UN.ptr_vtake{bitvec(n)}(ptrcast(bvp2))
val ((*void*)) = bitvec_lxor (!p1, !p2, nbit)
//
prval () = fpf1 (pf1) and () = fpf2 (pf2)
//
in
  // nothing
end // end of [bitvecptr_lxor]

(* ****** ****** *)

implement
{}(*tmp*)
bitvecptr_land
  {l1,l2}{n}
  (bvp1, bvp2, nbit) = let
//
val (pf1, fpf1 | p1) =
  $UN.ptr_vtake{bitvec(n)}(ptrcast(bvp1))
and (pf2, fpf2 | p2) =
  $UN.ptr_vtake{bitvec(n)}(ptrcast(bvp2))
val ((*void*)) = bitvec_land (!p1, !p2, nbit)
//
prval () = fpf1 (pf1) and () = fpf2 (pf2)
//
in
  // nothing
end // end of [bitvecptr_land]

(* ****** ****** *)

implement
{}(*tmp*)
fprint_bitvec$word
  (out, w) = let
//
fun
loop
(
  w: uintptr, n: int
) : void =
(
//
if
n > 0
then let
//
val b = $UN.cast{uint}(w land U1)
//
in
  fprint_uint(out, b); loop (w >> 1, n - 1)
end // end of [then]
else () // end of [else]
//
) (* end of [loop] *)
//
in
  loop (w, bitvec_get_wordsize())
end // end of [fprint_bitvec$word]

(* ****** ****** *)

implement
{}(*tmp*)
fprint_bitvec
  (out, vec, nbit) = let
//
val wsz = bitvec_get_wordsize ()
val log = bitvec_get_wordsize_log ()
val asz = $UN.cast{intGte(0)}((nbit + wsz - 1) >> log)
//
prval [n:int] EQINT() = eqint_make_gint (asz)
//
implement
fprint_val<uintptr> (out, x) = fprint_bitvec$word<> (out, x)
//
implement fprint_array$sep<> (out) = ()
//
in
//
fprint_arrayref
(
  out, $UN.castvwtp1{arrayref(uintptr,n)}(addr@vec), i2sz(asz)
) (* fprint_arrayref *)
//
end // end of [fprint_bitvec]

(* ****** ****** *)

implement
{}(*tmp*)
fprint_bitvecptr
  {l}{n}
  (out, bvp, nbit) = let
//
val (pf, fpf | p) =
  $UN.ptr_vtake{bitvec(n)}(ptrcast(bvp))
val ((*void*)) = fprint_bitvec (out, !p, nbit)
prval ((*void*)) = fpf (pf)
//
in
  // nothing
end // end of [fprint_bitvecptr]

(* ****** ****** *)

implement
{}(*tmp*)
bitvecptr_tabulate
  {n}(nbit) = let
//
val wsz = bitvec_get_wordsize ()
val log = bitvec_get_wordsize_log ()
val asz = $UN.cast{intGte(0)}((nbit + wsz - 1) >> log)
//
val bvp = arrayptr_make_uninitized<uintptr> (i2sz(asz))
//
fun
loop1
(
  p: ptr
, i: intGte(0)
, nbit: intGte(0)
, w: uintptr, i2: intGte(0)
) : void = (
//
if
nbit > 0
then let
//
val b = bitvec_tabulate$fopr(i)
//
in
//
if
b = 0
then (
  loop1 (p, i+1, nbit-1, w, i2+1)
) (* end of [then] *)
else (
  loop1 (p, i+1, nbit-1, w lor (U1 << i2), i2+1)
) (* end of [else] *)
//
end // end of [then]
else (uintptr_p_set (p, w))
//
) (* end of [loop1] *)
//
fun
loop2
(
  p: ptr, i: intGte(0), nbit: intGt(0)
) : void =
(
if
nbit > wsz
then let
//
val () =
  loop1 (p, i, wsz, U0, 0)
//
in
  loop2 (uintptr_p_inc (p), i + wsz, nbit - wsz)
end // end of [then]
else (
  loop1 (p, i, nbit, U0, 0)
) (* end of [else] *)
//
) (* end of [loop2] *)
//
val () =
if nbit > 0
  then loop2 (ptrcast(bvp), 0, nbit)
// end of [if]
//
in
  $UN.castvwtp0{bitvecptr(n)}(bvp)
end // end of [bitvecptr_tabulate]

(* ****** ****** *)

implement
{}(*tmp*)
bitvec_foreach
  (vec, nbit) = let
  var env: void = ()
in
  bitvec_foreach_env<void> (vec, nbit, env)
end // end of [bitvec_foreach]

(* ****** ****** *)

implement
{env}(*tmp*)
bitvec_foreach_env
  (vec, nbit, env) = let
//
val wsz = bitvec_get_wordsize ()
//
fun
loop
(
  p: ptr, nbit: intGt(0), env: &env
) : void = let
//
var w = uintptr_p_get(p)
//
in
//
if
nbit > wsz
then let
val () =
  bitvec_foreach$fwork<env> (w, wsz, env)
//
in
  loop (uintptr_p_inc(p), nbit - wsz, env)
end // end of [then]
else bitvec_foreach$fwork<env> (w, nbit, env)
//
end (* end of [loop] *)
//
in
//
if nbit > 0 then loop (addr@vec, nbit, env) else ()
//
end // end of [bitvec_foreach_env]

(* ****** ****** *)

implement(env)
bitvec_foreach$fwork<env>
  (w, n, env) = let
//
fun loop
(
  w: uintptr, n: int, env: &env >> _
) : void =
(
//
if
n > 0
then let
//
val b = $UN.cast{bit}(w land U1)
val () = bitvec_foreach$fworkbit(b, env)
//
val wsz = bitvec_get_wordsize()
//
in
  loop (w >> 1, n - 1, env)
end // end of [then]
else () // end of [else]
//
) (* end of [loop] *)
//
val wsz = bitvec_get_wordsize()
//
in
  if n <= wsz then loop (w, n, env) else loop (w, wsz, env)
end // end of [bitvec_foreach$fwork]

(* ****** ****** *)

implement
{}(*tmp*)
bitvecptr_foreach
  (bvp, nbit) = let
  var env: void = ()
in
  bitvecptr_foreach_env<void> (bvp, nbit, env)
end // end of [bitvecptr_foreach]

(* ****** ****** *)

implement
{env}(*tmp*)
bitvecptr_foreach_env
  {l}{n}
  (bvp, nbit, env) = let
//
val (pf, fpf | p) =
  $UN.ptr_vtake{bitvec(n)}(ptrcast(bvp))
val ((*void*)) = bitvec_foreach_env (!p, nbit, env)
prval ((*void*)) = fpf (pf)
//
in
  // nothing
end // end of [bitvecptr_foreach_env]

(* ****** ****** *)

(* end of [bitvec.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: December, 2012 *)

(* ****** ****** *)
//
// HX: This implementation is of imperative style;
// it supports mergeable-heap operations and also
// the decrease-key operation.
//
(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.linheap_binomial2"
#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time

(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libats/SATS/gnode.sats"
staload "libats/SATS/linheap_binomial.sats"

(* ****** ****** *)

#define nullp the_null_ptr

(* ****** ****** *)
//
// HX-2012-12-21:
// the file should be included here
// before [heap_vtype] is assumed
//
#include "./SHARE/linheap.hats" // code reuse
//
(* ****** ****** *)

macdef assertloc_debug (x) = ()

(* ****** ****** *)

stadef
mytkind = $extkind"atslib_linheap_binomial2"

(* ****** ****** *)

typedef
g2node (a:vt0p, l:addr) = gnode (mytkind, a, l)
typedef g2node0 (a:vt0p) = gnode0 (mytkind, a)
typedef g2node1 (a:vt0p) = gnode1 (mytkind, a)

(* ****** ****** *)

extern
fun{a:vt0p}
g2node_make_elt (x: a):<!wrt> g2node1 (a)

(* ****** ****** *)

extern
fun{a:t0p}
g2node_free (nx: g2node1 (INV(a))):<!wrt> void

(* ****** ****** *)

extern
fun{a:vt0p}
g2node_free_elt
  (nx: g2node1 (INV(a)), res: &a? >> a):<!wrt> void
// end of [g2node_free_elt]

(* ****** ****** *)

extern
fun{a:vt0p}
g2node_get_rank (nx: g2node1 (INV(a))):<> int
extern
fun{a:vt0p}
g2node_set_rank (nx: g2node1 (INV(a)), r: int):<!wrt> void

extern
fun{a:vt0p}
g2node_get_parent (nx: g2node1 (INV(a))):<> g2node0 (a)
extern
fun{a:vt0p}
g2node_set_parent (nx: g2node1 (INV(a)), par: g2node0 (a)):<!wrt> void
extern
fun{a:vt0p}
g2node_set_parent_null (nx: g2node1 (INV(a))):<!wrt> void

extern
fun{a:vt0p}
g2node_get_children (nx: g2node1 (INV(a))):<> g2node0 (a)
extern
fun{a:vt0p}
g2node_set_children (nx: g2node1 (INV(a)), nxs: g2node0 (a)):<!wrt> void
extern
fun{a:vt0p}
g2node_set_children_null (nx: g2node1 (INV(a))):<!wrt> void

(* ****** ****** *)

extern
fun{a:vt0p}
g2nodelst_cons (nx: g2node1 (INV(a)), nxs: g2node0 (a)):<!wrt> g2node1 (a)

(* ****** ****** *)

extern
fun{a:vt0p}
gnode_compare
  (nx1: g2node1 (a), nx2: g2node1 (a)):<> int
implement{a}
gnode_compare
  (nx1, nx2) = sgn where {
  val p_x1 = gnode_getref_elt (nx1)
  val (
    pf1, fpf1 | p_x1
  ) = $UN.cptr_vtake (p_x1)
  val p_x2 = gnode_getref_elt (nx2)
  val (
    pf2, fpf2 | p_x2
  ) = $UN.cptr_vtake (p_x2)
  val sgn = compare_elt_elt<a> (!p_x1, !p_x2)
  prval () = fpf1 (pf1) and () = fpf2 (pf2)
} // end of [gnode_compare]

(* ****** ****** *)

extern
fun{a:vt0p}
gnode_compare01
  (nx1: g2node0 (a), nx2: g2node1 (a)):<> int
implement{a}
gnode_compare01
  (nx1, nx2) =
  if gnode_isnot_null (nx1) then gnode_compare<a> (nx1, nx2) else 1
// end of [gnode_compare01]

extern
fun{a:vt0p}
gnode_compare10
  (nx1: g2node1 (a), nx2: g2node0 (a)):<> int
implement{a}
gnode_compare10
  (nx1, nx2) =
  if gnode_isnot_null (nx2) then gnode_compare<a> (nx1, nx2) else ~1
// end of [gnode_compare10]

(* ****** ****** *)
//
// HX-2013-08:
// [nx1] and [nx2] are of the same rank
//
extern
fun{a:vt0p}
join_gnode_gnode
  (nx1: g2node1 (a), nx2: g2node1 (a)):<!wrt> void
implement{a}
join_gnode_gnode
  (nx1, nx2) = let
  val r = g2node_get_rank (nx1)
  val () = g2node_set_rank (nx1, r+1)
  val () = g2node_set_parent (nx2, nx1)
  val () = gnode_link10 (nx2, g2node_get_children (nx1))
  val () = g2node_set_children (nx1, nx2)
in
  // nothing
end // end of [join_gnode_gnode]

(* ****** ****** *)

extern
fun{a:vt0p}
merge_gnode_gnode
(
  nx1: g2node1 (a), nx2: g2node1 (a)
) :<!wrt> g2node1 (a) // endfun
implement{a}
merge_gnode_gnode
  (nx1, nx2) = let
  val sgn = gnode_compare<a> (nx1, nx2)
in
  if sgn < 0 then let
    val () = join_gnode_gnode<a> (nx1, nx2) in nx1
  end else let
    val () = join_gnode_gnode<a> (nx2, nx1) in nx2
  end // end of [if]
end // end of [merge_gnode_gnode]

(* ****** ****** *)

extern
fun{a:vt0p}
merge_gnode_gnodelst
(
  nx1: g2node1 (a), r1: int, nxs2: g2node0 (a)
) :<!wrt> g2node1 (a) // endfun
implement{a}
merge_gnode_gnodelst
  (nx1, r1, nxs2) = let
//
val iscons = gnodelst_is_cons (nxs2)
//
in
//
if iscons then let
  val nx2 = nxs2
  val r2 = g2node_get_rank (nx2)
in
  if r1 < r2 then
    g2nodelst_cons (nx1, nxs2)
  else let // HX: r1 = r2
    val nxs2 = gnode_get_next (nx2)
    val nx1 = merge_gnode_gnode<a> (nx1, nx2)
  in
    merge_gnode_gnodelst<a> (nx1, r1+1, nxs2)
  end // end of [if]
end else
  g2nodelst_cons (nx1, nxs2)
// end of [if]
//
end // end of [merge_gnode_gnodelst]

(* ****** ****** *)

(*
** HX-2012-12:
** pre-condition for merging_gnodelst_gnodelst:
** both [nxs1] and [nxs2] are sorted ascendingly
** according to ranks of binomial trees
*)
extern
fun{a:vt0p}
merge_gnodelst_gnodelst
(
  nxs1: g2node0 (a), nxs2: g2node0 (a)
) :<!wrt> g2node0 (a) // endfun
implement{a}
merge_gnodelst_gnodelst
  (nxs1, nxs2) = let
//
fun loop
(
  nxs1: g2node0 (a), nxs2: g2node0 (a), res: Ptr1
) : void = let
in
//
if gnode_isnot_null (nxs1) then (
  if gnode_isnot_null (nxs2) then let
    val nx1 = nxs1
    val r1 = g2node_get_rank (nx1)
    val nx2 = nxs2
    val r2 = g2node_get_rank (nx2)
  in
    if r1 < r2 then let
      val () =
        $UN.ptr1_set<g2node1(a)> (res, nx1)
      val res = gnode_getref_next (nx1)
      val nxs1 = $UN.cptr_get<g2node0(a)> (res)
    in
      loop (nxs1, nxs2, cptr2ptr (res))
    end else if r1 > r2 then let
      val () = 
        $UN.ptr1_set<g2node1(a)> (res, nx2)
      val res = gnode_getref_next (nx2)
      val nxs2 = $UN.cptr_get<g2node0(a)> (res)
    in
      loop (nxs1, nxs2, cptr2ptr (res))
    end else let // r1 = r2
      val nxs1 = gnode_get_next (nx1)
      val nxs2 = gnode_get_next (nx2)
      val nx1 = merge_gnode_gnode<a> (nx1, nx2)
      val nxs1 = merge_gnode_gnodelst<a> (nx1, r1+1, nxs1)
    in
      loop (nxs1, nxs2, res)
    end // end of [if]
  end else $UN.ptr1_set<g2node0(a)> (res, nxs1)
) else $UN.ptr1_set<g2node0(a)> (res, nxs2)
//
end // end of [loop]
//
var res: g2node0(a)
val () = $effmask_all (loop (nxs1, nxs2, addr@(res)))
//
in
  $UN.cast{g2node0(a)} (res)
end // end of [merge_gnodelst_gnodelst]

(* ****** ****** *)

(*
assume
heap_vtype (a:vt0p) = g2node0 (a)
*)

(* ****** ****** *)

implement{}
linheap_nil{a} () =
  $UN.castvwtp1{heap(a)}(gnode_null())
// end of [linheap_nil]

(* ****** ****** *)
//
implement{}
linheap_is_nil{a} (hp) =
  gnodelst_is_nil ($UN.castvwtp1{g2node0(a)}(hp))
implement{}
linheap_isnot_nil{a} (hp) =
  gnodelst_is_cons ($UN.castvwtp1{g2node0(a)}(hp))
//
(* ****** ****** *)

implement{a}
linheap_size (hp) = let
//
fun loop
(
  nxs: g2node0(a), res: size_t
) : size_t = let
//
val iscons = gnodelst_is_cons (nxs)
//
in
//
if iscons then let
  val nx = nxs
  val r = g2node_get_rank (nx)
  val r = $UN.cast{intGte(0)}(r)
  val nsz = g0uint_lsl_size ((i2sz)1, r)
  val nxs = gnode_get_next (nx)
in
  loop (nxs, res + nsz)
end else res // end of [if]
//
end // end of [loop]
//
in
  $effmask_all (loop ($UN.castvwtp1{g2node0(a)}(hp), i2sz(0)))
end // end of [linheap_size]

(* ****** ****** *)
  
implement{a}
linheap_insert
  (hp0, x0) = let
//
val nx = g2node_make_elt<a> (x0)
//
val () = gnode_set_next_null (nx)
//
val () = g2node_set_rank (nx, 0)
val () = g2node_set_parent_null (nx)
val () = g2node_set_children_null (nx)
//
val nxs = $UN.castvwtp0{g2node0(a)}(hp0)
val nxs = merge_gnode_gnodelst<a> (nx, 0, nxs)
val () = hp0 := $UN.castvwtp0{heap(a)}(nxs)
//
in
  // nothing
end // end of [linheap_insert]

(* ****** ****** *)

implement{a}
linheap_getmin_ref (hp0) = let
//
fun loop (
  nx0: g2node1 (a), nxs: g2node0 (a)
) : g2node0 (a) = let
  val iscons = gnodelst_is_cons (nxs)
in
//
if iscons then let
  val nx = nxs
  val nxs = gnode_get_next (nx)
  val sgn = gnode_compare<a> (nx0, nx)
in
  if sgn <= 0 then loop (nx0, nxs) else loop (nx, nxs)
end else nx0 // end of [if]
//
end // end of [loop]
//
var nxs =
  $UN.castvwtp1{g2node0(a)}(hp0)
val iscons = gnodelst_is_cons (nxs)
in
//
if iscons then let
  val nx = nxs
  val nxs = gnode_get_next (nx)
  val nx_min = loop (nx, nxs)
in
  $UN.cast{cPtr1(a)}(nx_min)
end else
  $UN.cast{cPtr0(a)}(the_null_ptr)
// end of [if]
//
end // end of [linheap_getmin_ref]

(* ****** ****** *)

implement{a}
linheap_delmin
  (hp0, res) = let
//
fun loop (
  nxs_ref: Ptr1, nx0_ref: Ptr1, nx0: g2node1 (a)
) : g2node1 (a) = let
  val nxs =
    $UN.ptr1_get<g2node0(a)> (nxs_ref)
  val iscons = gnodelst_is_cons (nxs)
in
//
if iscons then let
  val nx = nxs
  val nx_ref = nxs_ref
  val nxs_ref = gnode_getref_next (nx)
  val nxs_ref = cptr2ptr (nxs_ref)
  val sgn = gnode_compare01<a> (nx0, nx)
in
  if sgn <= 0 then
    loop (nxs_ref, nx0_ref, nx0) else loop (nxs_ref, nx_ref, nx)
  // end of [if]
end else let
  val () = $UN.ptr1_set<g2node0(a)> (nx0_ref, gnode_get_next (nx0))
in
  nx0
end // end of [if]
//
end // end of [loop]
//
fun auxrev
(
  nxs: g2node0 (a)
) : g2node0 (a) = let
//
fun loop (
  nxs: g2node0 (a), res: g2node0 (a)
) : g2node0 (a) = let
  val isnot = gnode_isnot_null (nxs)
in
//
if isnot then let
  val nx = nxs
  val () = g2node_set_parent_null (nx)
  val nxs = gnode_get_next (nx)
in
  loop (nxs, g2nodelst_cons (nx, res))
end else res // end of [if]
//
end // end of [loop]
//
in
  $effmask_all (loop (nxs, gnode_null ()))
end // end of [auxrev]
//
var nxs0 =
  $UN.castvwtp0{g2node0(a)}(hp0)
val iscons = gnodelst_is_cons (nxs0)
//
in
//
if iscons then let
  val nx0 = nxs0
  val nx0_ref = addr@(nxs0)
  val nxs_ref = gnode_getref_next (nx0)
  val nxs_ref = cptr2ptr (nxs_ref)
//
  val nx_min = loop (nxs_ref, nx0_ref, nx0)
//
  val nxs_min = g2node_get_children (nx_min)
  val ((*void*)) = g2node_free_elt (nx_min, res)
//
  val nxs_min = auxrev (nxs_min)
  val nxs0 = merge_gnodelst_gnodelst<a> (nxs0, nxs_min)
  val () = hp0 := $UN.castvwtp0{heap(a)}(nxs0)
//
  prval () = opt_some{a}(res)
//
in
  true
end else let
//
  val () = hp0 := $UN.castvwtp0{heap(a)}(the_null_ptr)
//
  prval () = opt_none{a}(res)
//
in
  false
end // end of [if]
//
end // end of [linheap_delmin]

(* ****** ****** *)

implement
{a}(*tmp*)
linheap_merge
  (hp1, hp2) = let
  val nxs1 = $UN.castvwtp0{g2node0(a)}(hp1)
  val nxs2 = $UN.castvwtp0{g2node0(a)}(hp2)
  val nxs12 = merge_gnodelst_gnodelst<a> (nxs1, nxs2)
in
  $UN.castvwtp0{heap(a)}(nxs12)
end // end of [linheap_merge]

(* ****** ****** *)

implement
{a}(*tmp*)
linheap_freelin
  (hp) = let
//
fun auxfree
(
  nx: g2node0(a)
) : void = let
//
val isnot = gnode_isnot_null (nx)
//
in
//
if isnot then let
  val nxs = g2node_get_children (nx)
  val ((*void*)) = auxfree (nxs)
  val nx2 = gnode_get_next (nx)
  val cp = gnode_getref_elt (nx)
  val (pf, fpf | p) = $UN.cptr_vtake (cp)
  val ((*void*)) = linheap_freelin$clear<a> (!p)
  val ((*void*)) = $extfcall (void, "ATS_MFREE", $UN.castvwtp0{ptr}((pf, fpf | p)))
in
  auxfree (nx2)
end else () // end of [if]
//
end // end of [auxfree]
//
in
  $effmask_all (auxfree ($UN.castvwtp0{g2node0(a)}(hp)))
end // end of [linheap_freelin]

(* ****** ****** *)
//
// HX: functions for processing g2nodes
//
(* ****** ****** *)

vtypedef
hpnode_struct
(
  elt: vt0p
) = // sknode_struct
@{
  elt= elt, rank= int, next= ptr, parent= ptr, children= ptr
} (* end of [hpnode_struct] *)

(* ****** ****** *)

extern
castfn
__cast_hpnode
  {a:vt0p}{l:agz}
(
  nx: g2node (INV(a), l)
) :<> [l:addr]
(
  hpnode_struct (a) @ l
, hpnode_struct (a) @ l -<lin,prf> void
| ptr l
) // end of [__cast_hpnode]

(* ****** ****** *)

implement{a}
g2node_make_elt (x) = let
//
val (
  pf, pfgc | p
) = ptr_alloc<hpnode_struct(a)> ()
//
val () = p->elt := x
//
in
  $UN.castvwtp0{g2node1(a)}((pf, pfgc | p))
end // end of [g2node_make_elt]

(* ****** ****** *)

implement{a}
g2node_free (nx) =
(
  $extfcall (void, "ATS_MFREE", $UN.cast{ptr}(nx))
) // end of [g2node_free]

(* ****** ****** *)

implement{a}
g2node_free_elt (nx, res) = let
//
val (pf, fpf | p) = __cast_hpnode (nx)
val () = res := p->elt
//
in
  $extfcall (void, "ATS_MFREE", $UN.castvwtp0{ptr}((pf, fpf | p)))
end // end of [g2node_free_elt]

(* ****** ****** *)

implement{a}
g2node_get_rank
  (nx) = r where
{
//
val (pf, fpf | p) = __cast_hpnode (nx)
val r = p->rank
prval () = fpf (pf)
} // end of [g2node_get_rank]

implement{a}
g2node_set_rank (nx, r) = let
//
val (pf, fpf | p) = __cast_hpnode (nx)
val () = p->rank := r
prval () = fpf (pf)
//
in
  // nothing
end // end of [g2node_set_rank]

(* ****** ****** *)

implement{a}
g2node_get_parent (nx) = let
val (pf, fpf | p) = __cast_hpnode (nx)
val p_parent = p->parent
prval () = fpf (pf)
//
in
  $UN.cast{g2node0(a)}(p_parent)
end // end of [g2node_get_parent]

implement{a}
g2node_set_parent (nx, nx2) = let
val (pf, fpf | p) = __cast_hpnode (nx)
val () = p->parent := $UN.cast{ptr}(nx2)
prval () = fpf (pf)
//
in
  // nothing
end // end of [g2node_set_parent]

implement{a}
g2node_set_parent_null (nx) = let
val (pf, fpf | p) = __cast_hpnode (nx)
val () = p->parent := $UN.cast{ptr}(the_null_ptr)
prval () = fpf (pf)
//
in
  // nothing
end // end of [g2node_set_parent_null]

(* ****** ****** *)

implement{a}
g2node_get_children (nx) = let
val (pf, fpf | p) = __cast_hpnode (nx)
val p_children = p->children
prval () = fpf (pf)
//
in
  $UN.cast{g2node0(a)}(p_children)
end // end of [g2node_get_children]

implement{a}
g2node_set_children (nx, nx2) = let
val (pf, fpf | p) = __cast_hpnode (nx)
val () = p->children := $UN.cast{ptr}(nx2)
prval () = fpf (pf)
//
in
  // nothing
end // end of [g2node_set_children]

implement{a}
g2node_set_children_null (nx) = let
val (pf, fpf | p) = __cast_hpnode (nx)
val () = p->children := $UN.cast{ptr}(the_null_ptr)
prval () = fpf (pf)
//
in
  // nothing
end // end of [g2node_set_children_null]

(* ****** ****** *)

implement{a}
g2nodelst_cons (nx, nxs) =
  let val () = gnode_link10 (nx, nxs) in nx end
// end of [g2nodelst_cons]

(* ****** ****** *)

implement(a)
gnode_getref_elt<mytkind><a>
  (nx) = let
val (pf, fpf | p) = __cast_hpnode (nx)
val p_elt = addr@(p->elt)
prval () = fpf (pf)
//
in
  $UN.cast{cPtr1(a)}(p_elt)
end // end of [gnode_getref_elt]

(* ****** ****** *)

implement(a)
gnode_getref_next<mytkind><a>
  (nx) = let
val (pf, fpf | p) = __cast_hpnode (nx)
val p_next = addr@(p->next)
prval () = fpf (pf)
//
in
  $UN.cast{cPtr1(g2node0(a))}(p_next)
end // end of [g2node_getref_next]

(* ****** ****** *)

implement(a)
gnode_link10<mytkind><a>
  (nx1, nx2) = gnode_set_next (nx1, nx2)
// end of [gnode_link10]

implement(a)
gnode_link11<mytkind><a>
  (nx1, nx2) = gnode_set_next (nx1, nx2)
// end of [gnode_link11]

(* ****** ****** *)

(* linheap_binomial2.dats *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: July, 2013 *)

(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libats/SATS/gvector.sats"

(* ****** ****** *)

implement{a}
gvector_getref_at
  (V, d, i) = let
  val p = $UN.cast2Ptr1(ptr_add<a> (addr@(V), i*d))
in
  $UN.ptr2cptr{a}(p)
end // end of [gvector_getref_at]

(* ****** ****** *)

implement{}
fprint_gvector$sep
  (out) = fprint_string (out, ", ")
// end of [fprint_gvector$sep]

(* ****** ****** *)

implement{a}
fprint_gvector
  (out, V, n, d) = let
//
typedef tenv = int
implement
gvector_foreach$fwork<a><tenv>
  (x, env) = let
  val i = env
  val () = if i > 0 then fprint_gvector$sep<> (out)
  val () = env := i + 1
in
  fprint_ref<a> (out, x)
end // end of [gvector_foreach$fwork]
//
var env: tenv = 0
val _(*n*) = gvector_foreach_env<a><tenv> (V, n, d, env)
//
in
  // nothing
end // end of [fprint_gvector]

(* ****** ****** *)

implement
{a}(*tmp*)
gvector_copyto
  {n}{d1,d2}
  (V1, V2, n, d1, d2) = let
//
prval (
) = __initize (V2) where
{
extern praxi
__initize (&GVT(a?, n, d2) >> GVT(a, n, d2)): void
} (* end of [where] *) // end of [prval]
//
implement
{a1,a2}{env}
gvector_foreach2$cont (x, y, env) = true
implement(env)
gvector_foreach2$fwork<a,a><env> (x, y, env) = y := x
//
val _(*n*) = gvector_foreach2<a,a> (V1, V2, n, d1, d2)
//
in
  // nothing
end // end of [gvector_copyto]

(* ****** ****** *)

implement{a}
gvector_exchange
  (V1, V2, n, d1, d2) = let
//
implement
{a1,a2}{env}
gvector_foreach2$cont (x, y, env) = true
//
implement(env)
gvector_foreach2$fwork<a,a><env>
  (x, y, env) = let val t = x in x := y; y := t end
//
val _(*n*) = gvector_foreach2<a,a> (V1, V2, n, d1, d2)
//
in
  // nothing
end // end of [gvector_exchange]

(* ****** ****** *)

implement{a}{env}
gvector_foreach$cont (x, env) = true

(*
implement{a}{env}
gvector_foreach$fwork (x, env) = ((*void*))
*)

implement{a}
gvector_foreach
  (V, n, d) = let
  var env: void = () in
  gvector_foreach_env<a><void> (V, n, d, env)
end // end of [gvector_foreach]

implement
{a}{env}
gvector_foreach_env
  {n}{d}(V, n, d, env) = let
//
fun loop
  {i:nat | i <= n}
(
  p: ptr, i: int i, env: &env >> _
) : natLte(n) = let
in
//
if i > 0 then let
  val p = g1ofg0(p)
  val (pf, fpf | p) = $UN.ptr_vtake{a}(p)
  val cont = gvector_foreach$cont<a><env> (!p, env)
  prval () = fpf (pf)
in
  if cont then let
    val (pf, fpf | p) = $UN.ptr_vtake{a}(p)
    val () = gvector_foreach$fwork<a><env> (!p, env)
    prval () = fpf (pf)
  in
    loop (ptr_add<a> (p, d), pred(i), env)
  end else i // end of [if]
end else (0) // end of [if]
//
end // end of [loop]
//
prval (
) = lemma_gvector_param (V)
val i = loop (addr@(V), n, env)
//
in
  (n - i)
end // end of [gvector_foreach_env]

(* ****** ****** *)

implement{a,b}{env}
gvector_foreach2$cont (x, y, env) = true

implement{a,b}
gvector_foreach2
(
  V1, V2, n, d1, d2
) = let
  var env: void = () in
  gvector_foreach2_env<a,b><void> (V1, V2, n, d1, d2, env)
end // end of [gvector_foreach2]

implement
{a,b}{env}
gvector_foreach2_env
  {n}{d1,d2}(V1, V2, n, d1, d2, env) = let
//
fun loop
  {i:nat | i <= n}
(
  p1: ptr, p2: ptr, i: int i, env: &env >> _
) : natLte(n) = let
in
//
if i > 0 then let
  val p1 = g1ofg0(p1)
  val p2 = g1ofg0(p2)
  val (pf1, fpf1 | p1) = $UN.ptr_vtake{a}(p1)
  val (pf2, fpf2 | p2) = $UN.ptr_vtake{b}(p2)
  val cont = gvector_foreach2$cont<a,b><env> (!p1, !p2, env)
  prval () = fpf1 (pf1) and () = fpf2 (pf2)
in
  if cont then let
    val (pf1, fpf1 | p1) = $UN.ptr_vtake{a}(p1)
    val (pf2, fpf2 | p2) = $UN.ptr_vtake{b}(p2)
    val () = gvector_foreach2$fwork<a,b><env> (!p1, !p2, env)
    prval () = fpf1 (pf1) and () = fpf2 (pf2)
  in
    loop (ptr_add<a> (p1, d1), ptr_add<b> (p2, d2), pred(i), env)
  end else i // end of [if]
end else (0) // end of [if]
//
end // end of [loop]
//
prval (
) = lemma_gvector_param (V1)
val i = loop (addr@(V1), addr@(V2), n, env)
//
in
  (n - i)
end // end of [gvector_foreach2_env]

(* ****** ****** *)

(* end of [gvector.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
**
** Functional set based on ordered lists
**
** Contributed by Hongwei Xi (hwxi AT cs DOT bu DOT edu)
** Time: May 18, 2011
**
*)

(* ****** ****** *)
//
// HX-2012-12: ported to ATS/Postitats from ATS/Anairiats
//
(* ****** ****** *)

#define
ATS_PACKNAME "ATSLIB.libats.funset_listord"
#define
ATS_DYNLOADFLAG 0 // no need for dynloading at run-time
#define
ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libats/SATS/funset_listord.sats"

(* ****** ****** *)
//
#include "./SHARE/funset.hats" // code reuse
//
(* ****** ****** *)

assume
set_type (a: t0p) = List0 (a)

(* ****** ****** *)
//
// HX:
// A set is represented as a sorted list in descending order;
// note that descending order is chosen to faciliate set comparison
//
(* ****** ****** *)

implement{
} funset_nil () = list_nil ()
implement{
} funset_make_nil () = list_nil ()

(* ****** ****** *)

implement{a}
funset_sing (x) = list_cons{a}(x, list_nil)
implement{a}
funset_make_sing (x) = list_cons{a}(x, list_nil)

(* ****** ****** *)
(*
** HX-2012-12:
** it supersedes the one in [./SHARE/funset.hats]
*)
implement{a}
funset_make_list
  (xs) = let
//
val xs = let
//
implement
list_mergesort$cmp<a>
  (x, y) = compare_elt_elt<a> (x, y)
//
in
  $effmask_wrt (list_mergesort<a> (xs))
end // end of [let] // [val]
//
fnx loop1
  {m:pos;n:nat} .<m,0>.
(
  xs: list_vt (a, m), ys: list_vt (a, n)
) :<!wrt>
  listLte_vt (a, m+n) = let
//
val-@cons_vt (x, xs1) = xs
val x_ = x
val xs1_ = xs1; val () = (xs1 := ys)
prval () = fold@ (xs)
//
in
  loop2 (x_, xs1_, xs)
end // end of [loop1]
//
and loop2
  {m:nat;n:nat} .<m,1>.
(
  x0: a, xs: list_vt (a, m), ys: list_vt (a, n)
) :<!wrt>
  listLte_vt (a, m+n) = let
in
//
case+ xs of
| @cons_vt (x, xs1) => let
    val sgn = compare_elt_elt<a> (x0, x)
  in
    if (sgn < 0)
      then let // [xs] ascending!
        prval () = fold@ (xs) in loop1 (xs, ys)
      end // end of [then]
      else let
        val xs1_ = xs1
        val () = free@{a}{0}(xs) in loop2 (x0, xs1_, ys)
      end // end of [else]
    // end of [if]
  end (* end of [cons_vt] *)
| ~nil_vt ((*void*)) => ys
//
end // end of [loop2]
//
in (* in of [let] *)
//
case+ xs of
| cons_vt _ =>
  (
    $effmask_wrt (list_of_list_vt(loop1 (xs, nil_vt())))
  ) // end of [cons_vt]
| ~nil_vt () => list_nil ()
//
end // end of [funset_make_list]

(* ****** ****** *)

implement{}
funset_is_nil (xs) = list_is_nil (xs)
implement{}
funset_isnot_nil (xs) = list_is_cons (xs)

(* ****** ****** *)

implement{a}
funset_size (xs) = g1int2uint (list_length<a> (xs))

(* ****** ****** *)

implement{a}
funset_is_member
  (xs, x0) = let
//
fun aux
  {n:nat} .<n>. (
  xs: list (a, n)
) :<> bool = let
in
//
case+ xs of
| list_cons (x, xs) => let
    val sgn = compare_elt_elt<a> (x0, x) in
    if sgn > 0 then false else (if sgn < 0 then aux (xs) else true)
  end // end of [list_cons]
| list_nil () => false
//
end // end of [aux]
in
  aux (xs)
end // end of [funset_is_member]

(* ****** ****** *)

implement{a}
funset_insert
  (xs, x0) = let
//
fun aux
  {n:nat} .<n>.
(
  xs: list (a, n), flag: &int >> _
) :<cloref1> List0 (a) = let
in
//
case+ xs of
| list_cons
    (x, xs1) => let
    val sgn = compare_elt_elt<a> (x0, x)
  in
    if sgn > 0 then let
      val () = flag := flag + 1 in list_cons{a}(x0, xs)
    end else if sgn < 0 then let
      val flag0 = flag
      val xs1 = aux (xs1, flag)
    in
      if flag = flag0 then xs else list_cons{a}(x, xs1)
    end else xs // end of [if]
  end // end of [list_cons]
| list_nil () => let
    val () = flag := flag + 1 in list_cons{a}(x0, list_nil)
  end // end of [val]
//
end // end of [aux]
//
var flag: int = 0
val () = xs := $effmask_all (aux (xs, flag))
//
in
  if flag = 0 then true else false
end // end of [funset_insert]

(* ****** ****** *)

implement{a}
funset_remove
  (xs, x0) = let
//
fun aux {n:nat} .<n>.
(
  xs: list (a, n), flag: &int >> _
) :<cloref1> List0 (a) = let
in
//
case xs of
| list_cons (x, xs1) => let
    val sgn = compare_elt_elt<a> (x0, x)
  in
    if sgn > 0 then xs
    else if sgn < 0 then let
      val flag0 = flag
      val xs1 = aux (xs1, flag)
    in
      if flag = flag0 then xs else list_cons{a}(x, xs1)
    end else let
      val () = flag := flag + 1 in xs1
    end (* end of [if] *)
  end // end of [list_cons]
| list_nil () => list_nil ()
//
end // end of [aux]
//
var flag: int = 0
val () = xs := $effmask_all (aux (xs, flag))
//
in
  if flag > 0 then true else false
end // end of [funset_remove]

(* ****** ****** *)

implement{a}
funset_getmax
  (xs, x0) = let
in
//
case+ xs of
| list_cons
    (x, _) => let
    val () = x0 := x
    prval () = opt_some{a}(x0) in true
  end // end of [list_cons]
| list_nil () => let
    prval () = opt_none{a}(x0) in false
  end // end of [list_nil]
//
end // end of [funset_getmax]

(* ****** ****** *)

implement{a}
funset_getmin
  (xs, x0) = let
in
//
case+ xs of
| list_cons _ => let
    val () = x0 := list_last (xs)
    prval () = opt_some{a}(x0) in true
  end // end of [list_cons]
| list_nil () => let
    prval () = opt_none{a}(x0) in false
  end // end of [list_nil]
//
end // end of [funset_getmin]

(* ****** ****** *)

implement{a}
funset_takeoutmax
  (xs, x0) = let
in
//
case+ xs of
| list_cons
    (x, xs2) => let
    val () = (x0 := x)
    val () = (xs := xs2)
    prval () = opt_some{a}(x0)
  in
    true
  end // end of [list_cons]
| list_nil () => let
    prval () = opt_none{a}(x0)
  in
    false
  end // end of [list_nil]
//
end // end of [funset_takeoutmax]

(* ****** ****** *)

implement{a}
funset_takeoutmin
  (xs, x0) = let
//
fun aux{n:pos} .<n>.
(
  xs: list (a, n), x0: &a? >> a
) :<!wrt> list (a, n-1) = let
//
val+list_cons (x, xs2) = xs
//
in
//
case+ xs2 of
| list_cons _ => let
    val xs2 = aux (xs2, x0)
  in
    list_cons{a}(x, xs2)
  end // end of [list_cons]
| list_nil () => let
    val () = x0 := x in list_nil ()
  end // end of [list_nil]
//
end // end of [aux]
//
in
//
case+ xs of
| list_cons _ => let
    val () = xs := aux (xs, x0)
    prval () = opt_some{a}(x0) in true
  end // end of [list_cons]
| list_nil () => let
    prval () = opt_none{a}(x0) in false
  end // end of [list_nil]
//
end // end of [funset_takeoutmin]

(* ****** ****** *)

implement
{a}(*tmp*)
funset_union
  (xs1, xs2) = let
//
fun aux // non-tail-recursive
  {n1,n2:nat} .<n1+n2>.
(
  xs1: list (a, n1), xs2: list (a, n2)
) :<> List0 (a) = let
in
//
case xs1 of
| list_cons
    (x1, xs11) =>
  (
  case+ xs2 of
  | list_cons (x2, xs21) => let
      val sgn = compare_elt_elt<a> (x1, x2)
    in
      if sgn > 0 then
        list_cons{a}(x1, aux (xs11, xs2))
      else if sgn < 0 then
        list_cons{a}(x2, aux (xs1, xs21))
      else
        list_cons{a}(x1, aux (xs11, xs21))
      // end of [if]
    end // end of [list_cons]
  | list_nil () => xs1
  ) // end of [list_cons]
| list_nil () => xs2
//
end // end of [aux]
//
in
  aux (xs1, xs2)
end // end of [funset_union]

(* ****** ****** *)

implement
{a}(*tmp*)
funset_intersect
  (xs1, xs2) = let
//
fun aux // non-tail-recursive
  {n1,n2:nat} .<n1+n2>.
(
  xs1: list (a, n1), xs2: list (a, n2)
) :<> List0 (a) = let
in
//
case xs1 of
| list_cons
    (x1, xs11) =>
  (
  case+ xs2 of
  | list_cons (x2, xs21) => let
      val sgn = compare_elt_elt<a> (x1, x2)
    in
      if sgn > 0 then
        aux (xs11, xs2)
      else if sgn < 0 then
        aux (xs1, xs21)
      else
        list_cons{a}(x1, aux (xs11, xs21))
      // end of [if]
    end // end of [list_cons]
  | list_nil () => list_nil ()
  ) // end of [list_cons]
| list_nil () => list_nil ()
//
end // end of [aux]
//
in
  aux (xs1, xs2)
end // end of [funset_intersect]

(* ****** ****** *)

implement
{a}(*tmp*)
funset_differ
  (xs1, xs2) = let
//
fun aux // non-tail-recursive
  {n1,n2:nat} .<n1+n2>.
(
  xs1: list (a, n1), xs2: list (a, n2)
) :<cloref0> List0 (a) = let
in
//
case xs1 of
| list_cons
    (x1, xs11) => (
  case+ xs2 of
  | list_cons
      (x2, xs21) => let
      val sgn = compare_elt_elt<a> (x1, x2)
    in
      if sgn > 0
        then list_cons{a}(x1, aux (xs11, xs2))
        else (
          if sgn < 0 then aux (xs1, xs21) else aux (xs11, xs21)
        ) (* end of [else] *)
      // end of [if]
    end // end of [list_cons]
  | list_nil () => xs1
  ) // end of [list_cons]
| list_nil () => xs2
//
end // end of [aux]
//
in
  aux (xs1, xs2)
end // end of [funset_differ]

(* ****** ****** *)

implement
{a}(*tmp*)
funset_symdiff
  (xs1, xs2) = let
//
fun aux // non-tail-recursive
  {n1,n2:nat} .<n1+n2>.
(
  xs1: list (a, n1), xs2: list (a, n2)
) :<> List0 (a) = let
in
//
case xs1 of
| list_cons
    (x1, xs11) => (
  case+ xs2 of
  | list_cons
      (x2, xs21) => let
      val sgn =
        compare_elt_elt<a> (x1, x2)
      // end of [val]
    in
      if sgn > 0 then
        list_cons{a}(x1, aux (xs11, xs2))
      else if sgn < 0 then
        list_cons{a}(x2, aux (xs1, xs21))
      else
        aux (xs11, xs21)
      // end of [if]
    end // end of [list_cons]
  | list_nil () => xs1
  ) // end of [list_cons]
| list_nil () => xs2
//
end // end of [aux]
//
in
  aux (xs1, xs2)
end // end of [funset_symdiff]

(* ****** ****** *)

implement{a}
funset_compare
  (xs1, xs2) = let
//
fun aux // tail-recursive
  {n1,n2:nat} .<n1>.
(
  xs1: list (a, n1), xs2: list (a, n2)
) :<> Sgn = (
  case+ xs1 of
  | list_cons
      (x1, xs1) => (
    case+ xs2 of
    | list_cons (x2, xs2) => let
        val sgn = compare_elt_elt<a> (x1, x2)
      in
        if sgn > 0 then 1 else (
          if sgn < 0 then ~1 else aux (xs1, xs2)
        ) // end of [if]
      end // end of [list_cons]
    | list_nil () => 1
    ) // end of [list_cons]
  | list_nil () => (
    case+ xs2 of list_cons _ => ~1 | list_nil _ => 0
    )
) // end of [aux]
//
in
  aux (xs1, xs2)
end // end of [funset_compare]

(* ****** ****** *)

implement{a}
funset_is_subset
  (xs1, xs2) = let
//
fun aux // tail-recursive
  {n1,n2:nat} .<n1+n2>.
(
  xs1: list (a, n1), xs2: list (a, n2)
) :<> bool = let
in
//
case+ xs1 of
| list_cons
    (x1, xs11) => (
  case+ xs2 of
  | list_cons
      (x2, xs21) => let
      val sgn = compare_elt_elt<a> (x1, x2)
    in
      if sgn > 0 then false else
        (if sgn < 0 then aux (xs1, xs21) else aux (xs11, xs21))
      // end of [if]
    end // end of [list_cons]
  | list_nil () => false
  ) // end of [list_cons]
| list_nil () => true
//
end // end of [aux]
//
in
  aux (xs1, xs2)
end // end of [funset_is_subset]

(* ****** ****** *)

implement
{a}{env}
funset_foreach_env
  (xs, env) = let
//
val xs = list_reverse (xs)
//
implement{a}{env}
list_vt_foreach$cont (x, env) = true
implement
list_vt_foreach$fwork<a><env> (x, env) =
  funset_foreach$fwork<a><env> (x, env)
//
val () = list_vt_foreach_env<a><env> (xs, env)
//
val () = list_vt_free (xs)
//
in
  // nothing
end // end of [funset_foreach_env]

(* ****** ****** *)

implement{a}
funset_listize (xs) = list_reverse<a> (xs)

(* ****** ****** *)

(*
//
// HX: this is now a cast funciton
//
implement{}
funset2list (xs) = xs // HX: [xs] in decending order
*)

(* ****** ****** *)

(* end of [funset_listord.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: December, 2012 *)

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.linmap_avltree"
#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time

(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libats/SATS/linmap_avltree.sats"

(* ****** ****** *)

#include "./SHARE/linmap.hats" // code reuse
#include "./SHARE/linmap_node.hats" // code reuse

(* ****** ****** *)

stadef mytkind = $extkind"atslib_linmap_avltree"

(* ****** ****** *)
//
// HX: maximal height difference of two siblings
//
#define HTDF 1
#define HTDF1 (HTDF+1)
#define HTDF_1 (HTDF-1)
//
(* ****** ****** *)

datavtype avltree
(
  key: t@ype, itm:vt@ype+, int(*height*)
) =
  | {hl,hr:nat |
     hl <= hr+HTDF;
     hr <= hl+HTDF}
    B (key, itm, 1+max(hl,hr)) of
    (
      int (1+max(hl,hr)), key, itm, avltree (key, itm, hl), avltree (key, itm, hr)
    )
  | E (key, itm, 0) of ((*void*))
// end of [datavtype avltree]

(* ****** ****** *)

vtypedef avltree
  (key:t0p, itm:vt0p) = [h:nat] avltree (key, itm, h)
// end of [avltree]

vtypedef avltree_inc
  (key:t0p, itm:vt0p, h:int) =
  [h1:nat | h <= h1; h1 <= h+1] avltree (key, itm, h1)
// end of [avltree_inc]

vtypedef avltree_dec
  (key:t0p, itm:vt0p, h:int) =
  [h1:nat | h1 <= h; h <= h1+1] avltree (key, itm, h1)
// end of [avltree_dec]

(* ****** ****** *)

assume
map_vtype (key:t0p, itm: vt0p) = avltree (key, itm)
// end of [map_vtype]

(* ****** ****** *)

implement{} linmap_nil () = E ()
implement{} linmap_make_nil () = E ()

(* ****** ****** *)

implement{}
linmap_is_nil (map) =
  case+ map of E _ => true | B _ => false
// end of [linmap_is_nil]

implement{}
linmap_isnot_nil (map) =
  case+ map of B _ => true | E _ => false
// end of [linmap_isnot_nil]

(* ****** ****** *)

implement
{key,itm}
linmap_size
  (map) = let
//
fun aux
(
  t0: !avltree (key, itm), res: size_t
) : size_t = let
in
//
case+ t0 of
| B (
    _, _, _, tl, tr
  ) => let
    val res = succ(res)
    val res = aux (tl, res)
    val res = aux (tr, res)
  in
    res
  end // end of [B]
| E ((*void*)) => res
//
end // end of [aux]
//
in
  $effmask_all (aux (map, i2sz(0)))
end // end of [linmap_size]

(* ****** ****** *)

implement
{key,itm}
linmap_search_ref
  (map, k0) = let
//
fun search
  {h:nat} .<h>. (
  t0: !avltree (key, itm, h)
) :<!wrt> cPtr0(itm) = let
in
//
case+ t0 of
//
| @B (
    _(*h*), k, x, tl, tr
  ) => let
    val sgn =
      compare_key_key<key> (k0, k)
    // end of [val]
  in
    case+ 0 of
    | _ when sgn < 0 => let
        val res = search (tl)
        prval () = fold@ (t0) in res
      end // end of [sgn < 0]
    | _ when sgn > 0 => let
        val res = search (tr)
        prval () = fold@ (t0) in res
      end // end of [sgn > 0]
    | _ (*sgn = 0*) => let
        val p_x = addr@x
        prval () = fold@ (t0) in $UN.ptr2cptr(p_x)
      end // end of [sgn = 0]
  end // end of [let] // end of [B]
//
| E ((*void*)) => cptr_null{itm}()
//
end // end of [search]
//
in
  search (map)
end // end of [linmap_search_ref]

(* ****** ****** *)

implement
{key,itm}
linmap_freelin
  (map) = let
//
fun aux
  {h:nat} .<h>.
(
  t: avltree (key, itm, h)
) : void = let
in
//
case+ t of
| @B (
    _, k, x, tl, tr
  ) => let
    val () = linmap_freelin$clear<itm> (x)
    val tl = tl and tr = tr
    val () = free@ {..}{0,0} (t)
    val () = aux (tl) and () = aux (tr)
  in
    // nothing
  end // end of [BSTcons]
| ~E ((*void*)) => ()
//
end // end of [aux]
//
in
  $effmask_all (aux (map))
end // end of [linmap_freelin]

(* ****** ****** *)

macdef
avlht (t) =
(
case+ ,(t) of
| B (h, _, _, _, _) => h | E ((*void*)) => 0
) // end of [avlht]

(* ****** ****** *)

fn{
key:t0p;itm:vt0p
} avltree_height{h:int}
  (t: !avltree (key, itm, h)):<> int (h) = avlht(t)

(* ****** ****** *)

(*
** left rotation for restoring height invariant
*)
fn{
key:t0p;itm:vt0p
} avltree_lrotate
  {hl,hr:nat | hl+HTDF1 == hr}
  {l,l_h,l_k,l_x,l_tl,l_tr:addr}
(
  pf_h: (int?)@l_h
, pf_k: key@l_k, pf_x: itm@l_x
, pf_tl: avltree (key, itm, hl) @ l_tl
, pf_tr: avltree (key, itm, hr) @ l_tr
| p_h: ptr l_h
, hl: int hl, p_tl: ptr l_tl
, hr: int hr, p_tr: ptr l_tr
, t0: B_unfold (l, l_h, l_k, l_x, l_tl, l_tr)
) :<!wrt> avltree_inc (key, itm, hr) = let
  val tr = !p_tr
  val+@B{..}{hrl,hrr}
    (hr2, _, _, trl, trr) = tr
  val hrl = avlht(trl): int(hrl)
  and hrr = avlht(trr): int(hrr)
in
  if hrl <= hrr+HTDF_1 then let
    val hrl1 = hrl + 1
    val () = !p_h := hrl1
    val () = !p_tr := trl
    prval () = fold@ (t0)
    val () = hr2 := 1+max(hrl1, hrr)
    val () = trl := t0
    prval () = fold@ (tr)
  in
    tr // B (1+max(hrl1,hrr), kr, xr, B (hrl1, k, x, tl, trl), trr)
  end else let // [hrl==hrr+HTDF1]: deep rotation
    val trl_ = trl
    val+@B{..}{hrll,hrlr}
      (hrl, _, _, trll, trlr) = trl_
    val hrll = avlht (trll) : int(hrll)
    and hrlr = avlht (trlr) : int(hrlr)
    val () = !p_h := 1+max(hl,hrll)
    val () = !p_tr := trll
    prval () = fold@ (t0)
    val () = hr2 := 1+max(hrlr, hrr)
    val () = trl := trlr
    prval () = fold@ (tr)
    val () = hrl := hr
    val () = trll := t0
    val () = trlr := tr
    prval () = fold@ (trl_)
  in
    trl_ // B (hr, krl, xrl,
         //    B (1+max(hl,hrll), k, x, tl, trll),
         //    B (1+max(hrlr,hrr), kr, xr, trlr, trr))
  end // end of [if]
end // end of [avltree_lrotate]

(* ****** ****** *)

(*
** right rotation for restoring height invariant
*)
fn{
key:t0p;itm:vt0p
} avltree_rrotate
  {hl,hr:nat | hl == hr+HTDF1}
  {l,l_h,l_k,l_x,l_tl,l_tr:addr}
(
  pf_h: (int?)@l_h
, pf_k: key@l_k, pf_x: itm@l_x
, pf_tl: avltree (key, itm, hl) @ l_tl
, pf_tr: avltree (key, itm, hr) @ l_tr
| p_h: ptr l_h
, hl : int hl, p_tl: ptr l_tl
, hr : int hr, p_tr: ptr l_tr
, t0: B_unfold (l, l_h, l_k, l_x, l_tl, l_tr)
) :<!wrt> avltree_inc (key, itm, hl) = let
  val tl = !p_tl
  val+@B{..}{hll,hlr}
    (hl2, _, _, tll, tlr) = tl
  val hll = avlht(tll): int(hll)
  and hlr = avlht(tlr): int(hlr)
in
  if hll+HTDF_1 >= hlr then let
    val hlr1 = hlr + 1
    val () = !p_h := hlr1
    val () = !p_tl := tlr
    prval () = fold@ (t0)
    val () = hl2 := 1+max(hll,hlr1)
    val () = tlr := t0
    prval () = fold@ (tl)
  in
    tl // B (1+max(hll,hlr1), kl, xl, tll, B (hlr1, x, tlr, tr))
  end else let
    val tlr_ = tlr
    val+@B{..}{hlrl,hlrr}
      (hlr, _, _, tlrl, tlrr) = tlr_
    val hlrl = avlht (tlrl): int(hlrl)
    val hlrr = avlht (tlrr): int(hlrr)
    val () = !p_h := 1+max(hlrr,hr)
    val () = !p_tl := tlrr
    prval () = fold@ (t0)
    val () = hl2 := 1+max(hll,hlrl)
    val () = tlr := tlrl
    prval () = fold@ (tl)
    val () = hlr := hl
    val () = tlrl := tl
    val () = tlrr := t0
    prval () = fold@ (tlr_)
  in
    tlr_ // B (hl, klr, xlr,
         //    B (1+max(hll,hlrl), kl, xl, tll, tlrl),
         //    B (1+max(hlrr,hr), k, x, tlrr, tr))
  end // end of [if]
end // end of [avltree_rrotate]

(* ****** ****** *)

implement
{key,itm}
linmap_insert
  (map, k0, x0, res) = let
//
fun insert
  {h:nat} .<h>.
(
  t0: &avltree (key, itm, h) >> avltree_inc (key, itm, h), k0: key, x0: &(itm) >> opt(itm, b)
) :<!wrt> #[b:bool] bool(b) = let
in
//
case+ t0 of
//
| @B{..}{hl,hr}
    (h, k, x, tl, tr) => let
    prval pf_h = view@h
    prval pf_k = view@k
    prval pf_x = view@x
    prval pf_tl = view@tl
    prval pf_tr = view@tr
    val sgn = compare_key_key<key> (k0, k)
  in
    case+ 0 of
    | _ when sgn < 0 => let
        val ans = insert (tl, k0, x0)
        val hl = avltree_height<key,itm> (tl)
        and hr = avltree_height<key,itm> (tr)
      in
        if hl-hr <= HTDF then let
          val () = h := 1+max(hl,hr)
          prval () = fold@ (t0)
        in
          ans // B (1+max(hl,hr), k, x, tl, tr)
        end else let // hl==hr+HTDF1
          val p_h = addr@(h)
          val p_tl = addr@(tl)
          val p_tr = addr@(tr)
          val () = t0 := avltree_rrotate<key,itm> (pf_h, pf_k, pf_x, pf_tl, pf_tr | p_h, hl, p_tl, hr, p_tr, t0)
        in
          ans
        end // end of [if]
      end // end of [sgn < 0]
    | _ when sgn > 0 => let
        val ans = insert (tr, k0, x0)
        val hl = avltree_height<key,itm> (tl)
        and hr = avltree_height<key,itm> (tr)
      in
        if hr-hl <= HTDF then let
          val () = h := 1+max(hl,hr)
          prval () = fold@ (t0)
        in
          ans // B (1+max(hl, hr), k, x, tl, tr)
        end else let // hl+HTDF1==hr
          val p_h = addr@(h)
          val p_tl = addr@(tl)
          val p_tr = addr@(tr)
          val () = t0 := avltree_lrotate<key,itm> (pf_h, pf_k, pf_x, pf_tl, pf_tr | p_h, hl, p_tl, hr, p_tr, t0)
        in
          ans
        end // end of [if]
      end // end of [sgn > 0]
    | _ (*[k0] is found*) => let
        val x_ = x
        val () = x := x0
        val () = x0 := x_
        prval () = fold@ (t0)
        prval () = opt_some{itm}(x0)
      in
        true // B (h, k, x, tl, tr)
      end // end of [sgn = 0]
  end // end of [B]
//
| ~E () => let
    val x0_ = x0
    val () = t0 := B{key,itm}(1, k0, x0_, E (), E ())
    prval () = opt_none{itm}(x0)
  in
    false
  end // end of [E]
//
end // end of [insert]
//
val () = res := x0
//
in
  insert (map, k0, res)
end // end of [linmap_insert]

(* ****** ****** *)

fun
{key:t0p
;itm:vt0p}
avltree_maxout
  {h:pos} .<h>.
(
  t0: &avltree (key, itm, h) >> avltree_dec (key, itm, h)
) :<!wrt> mynode1 (key, itm) = let
  val+@B{..}{hl,hr}(h, k, x, tl, tr) = t0
  prval pf_h = view@h
  prval pf_k = view@k
  prval pf_x = view@x
  prval pf_tl = view@tl
  prval pf_tr = view@tr
in
  case+ tr of
  | B _ => let
      val nx = avltree_maxout<key,itm> (tr)
      val hl = avltree_height<key,itm> (tl)
      and hr = avltree_height<key,itm> (tr)
    in
      if hl-hr <= HTDF then let
        val () = h := 1+max(hl,hr)
        prval () = fold@ (t0) // B (1+max(hl,hr), x, tl, tr)
      in
        nx
      end else let
        val p_h = addr@h
        val p_tl = addr@tl
        val p_tr = addr@tr
        val () = t0 := avltree_rrotate<key,itm> (pf_h, pf_k, pf_x, pf_tl, pf_tr | p_h, hl, p_tl, hr, p_tr, t0)
      in
        nx
      end // end of [if]
    end // end of [B]
  | ~E () => let
      val t0_ = t0
      val () = t0 := tl
    in
      $UN.castvwtp0{mynode1(key,itm)}((pf_h, pf_k, pf_x, pf_tl, pf_tr | t0_))
    end // end of [E]
end // end of [avltree_maxout]

(* ****** ****** *)

fun
{key:t0p
;itm:vt0p}
avltree_minout
  {h:pos} .<h>.
(
  t0: &avltree (key, itm, h) >> avltree_dec (key, itm, h)
) :<!wrt> mynode1 (key, itm) = let
  val+@B{..}{hl,hr}(h, k, x, tl, tr) = t0
  prval pf_h = view@h
  prval pf_k = view@k
  prval pf_x = view@x
  prval pf_tl = view@tl
  prval pf_tr = view@tr
in
  case+ tl of
  | B _ => let
      val nx = avltree_minout<key,itm> (tl)
      val hl = avltree_height<key,itm> (tl)
      and hr = avltree_height<key,itm> (tr)
    in
      if hr-hl <= HTDF then let
        val () = h := 1+max(hl,hr)
        prval () = fold@ (t0) // B (1+max(hl,hr), x, tl, tr)
      in
        nx
      end else let
        val p_h = addr@h
        val p_tl = addr@tl
        val p_tr = addr@tr
        val () = t0 := avltree_lrotate<key,itm> (pf_h, pf_k, pf_x, pf_tl, pf_tr | p_h, hl, p_tl, hr, p_tr, t0)
      in
        nx
      end // end of [if]
    end // end of [B]
  | ~E () => let
      val t0_ = t0
      val () = t0 := tr
    in
      $UN.castvwtp0{mynode1(key,itm)}((pf_h, pf_k, pf_x, pf_tl, pf_tr | t0_))
    end // end of [E]
end // end of [avltree_minout]

(* ****** ****** *)

extern
castfn
mynode_decode
  {key:t0p;itm:vt0p}{l:agz}
  (nx: mynode(key, INV(itm), l)):<> B_pstruct (int?, key, itm, ptr?, ptr?)
// end of [mynode_decode]

(* ****** ****** *)

fn
{key:t0p
;itm:vt0p}
avltree_lrcon
  {hl,hr:nat |
   hl <= hr+HTDF;
   hr <= hl+HTDF}
(
  tl: avltree (key, itm, hl)
, tr: avltree (key, itm, hr)
) :<!wrt> avltree_dec (key, itm, 1+max(hl,hr)) =
(
case+ tr of
| B _ => let
    var tr = tr
    val nx =
      avltree_minout<key,itm> (tr)
    // end of [val]
    val t1 = mynode_decode (nx)
    val+B(h1, k1, x1, tl1, tr1) = t1
    prval pf_h1 = view@h1
    prval pf_k1 = view@k1
    prval pf_x1 = view@x1
    prval pf_tl1 = view@tl1
    prval pf_tr1 = view@tr1
    val hl = avltree_height<key,itm> (tl)
    and hr = avltree_height<key,itm> (tr)
    val () = tl1 := tl and () = tr1 := tr 
  in
    if hl-hr <= HTDF then let
      val () = h1 := 1+max(hl,hr)
      prval () = fold@ (t1)
    in
      t1
    end else let
      val p_h1 = addr@h1
      val p_tl1 = addr@tl1
      val p_tr1 = addr@tr1
    in
      avltree_rrotate<key,itm> (pf_h1, pf_k1, pf_x1, pf_tl1, pf_tr1 | p_h1, hl, p_tl1, hr, p_tr1, t1)
    end // end of [if]
  end // end of [B]
| ~E ((*void*)) => tl
) (* end of [avltree_lrcon] *)

(* ****** ****** *)

implement
{key,itm}
linmap_takeout_ngc
  (xs, k0) = let
//
fun takeout{h:nat} .<h>.
(
  t0: &avltree (key, itm, h) >> avltree_dec (key, itm, h)
) :<!wrt> mynode0(key, itm) = let
//
in
//
case+ t0 of
| @B{..}{hl,hr}
    (h, k, x, tl, tr) => let
    prval pf_h = view@h
    prval pf_k = view@k
    prval pf_x = view@x
    prval pf_tl = view@tl
    prval pf_tr = view@tr
    val sgn = compare_key_key<key> (k0, k)
  in
    case+ 0 of
    | _ when sgn < 0 => let
        val nx = takeout (tl)
        val hl = avltree_height<key,itm> (tl)
        and hr = avltree_height<key,itm> (tr)
      in
        if hr-hl <= HTDF then let
          val () = h := 1+max(hl,hr)
          prval () = fold@ (t0)
        in
          nx
        end else let
          val p_h = addr@(h)
          val p_tl = addr@(tl)
          val p_tr = addr@(tr)
          val () = t0 := avltree_lrotate<key,itm> (pf_h, pf_k, pf_x, pf_tl, pf_tr | p_h, hl, p_tl, hr, p_tr, t0)
        in
          nx
        end // end of [if]
      end // end of [sgn < 0]
    | _ when sgn > 0 => let
        val nx = takeout (tr)
        val hl = avltree_height<key,itm> (tl)
        and hr = avltree_height<key,itm> (tr)
      in
        if hl-hr <= HTDF then let
          val () = h := 1+max(hl,hr)
          prval () = fold@ (t0)
        in
          nx
        end else let
          val p_h = addr@(h)
          val p_tl = addr@(tl)
          val p_tr = addr@(tr)
          val () = t0 := avltree_rrotate<key,itm> (pf_h, pf_k, pf_x, pf_tl, pf_tr | p_h, hl, p_tl, hr, p_tr, t0)
        in
          nx
        end // end of [if]
      end // end of [sgn > 0]
    | _ (*[x0] is found*) => let
        val t0_ = t0
        val () = t0 := avltree_lrcon<key,itm> (tl, tr)
      in
        $UN.castvwtp0{mynode1(key,itm)}((pf_h, pf_k, pf_x, pf_tl, pf_tr | t0_))
      end // end of [sgn = 0]
    // end of [case]
  end // end of [B]
| E ((*void*)) => mynode_null ()
//
end // end of [takeout]
//
in
  takeout (xs)
end // end of [linmap_takeout_ngc]

(* ****** ****** *)

implement
{key,itm}{env}
linmap_foreach_env
  (xs, env) = let
//
val p_env = addr@env
//
fun foreach
  {h:nat} .<h>.
(
  t0: !avltree (key, itm, h), p_env: ptr
) : void = let
in
//
case+ t0 of
| @B (h, k, x, tl, tr) => let
//
    val () = foreach (tl, p_env)
//
    val (
      pf, fpf | p_env
    ) = $UN.ptr_vtake{env}(p_env)
    val () = linmap_foreach$fwork<key,itm><env> (k, x, !p_env)
    prval () = fpf (pf)
//
    val () = foreach (tr, p_env)
//
    prval () = fold@ (t0)
//
  in
    // nothing
  end // end of [B]
| E ((*void*)) => ()
//
end // end of [foreach]
//
in
  foreach (xs, p_env)
end // end of [linmap_foreach_env]

(* ****** ****** *)

implement
{key,itm}{ki2}
linmap_flistize
  (map) = let
//
vtypedef ki = @(key, itm)
//
fun aux
  {h:nat} .<h>. (
  t: avltree (key, itm, h), res: List0_vt (ki2)
) : List0_vt (ki2) = let
in
//
case+ t of
| ~B (
    _, k, x, tl, tr
  ) => res where {
    val res = aux (tl, res)
    val kx2 = linmap_flistize$fopr<key,itm><ki2> (k, x)
    val res = list_vt_cons{ki2}(kx2, res)
    val res = aux (tr, res)
  } // end of [BSTcons]
| ~E ((*void*)) => res
//
end // end of [aux]
//
val res = aux (map, list_vt_nil ())
//
in
  list_vt_reverse (res)
end // end of [linmap_flistize]

(* ****** ****** *)
//
// HX: functions for processing mynodes
//
(* ****** ****** *)

implement{
} mynode_null{key,itm} () =
  $UN.castvwtp0{mynode(key,itm,null)}(the_null_ptr)
// end of [mynode_null]

(* ****** ****** *)

implement
{key,itm}
mynode_getref_itm
  (nx) = let
//
val t0 =
  $UN.castvwtp1{avltree(key,itm,1)}(nx)
val+@B(_, k, x, tl, tr) = t0; val p_x = addr@(x)
prval ((*void*)) = fold@(t0)
prval ((*void*)) = $UN.cast2void (t0)
//
in
  $UN.ptr2cptr{itm}(p_x)
end (* end of [mynode_getfree_itm] *)

(* ****** ****** *)

implement
{key,itm}
mynode_free_keyitm
  (nx, k0, x0) = () where
{
//
val+~B(_, k, x, tl, tr) = $UN.castvwtp0{avltree(key,itm,1)}(nx)
val () = k0 := k and () = x0 := x
prval ((*void*)) = $UN.cast2void (tl)
prval ((*void*)) = $UN.cast2void (tr)
//
} (* end of [mynode_free_keyitm] *)

(* ****** ****** *)

implement
{key,itm}
mynode_getfree_itm (nx) = x where
{
//
val+~B(_, k, x, tl, tr) = $UN.castvwtp0{avltree(key,itm,1)}(nx)
//
prval ((*void*)) = $UN.cast2void (tl)
prval ((*void*)) = $UN.cast2void (tr)
//
} (* end of [mynode_getfree_itm] *)

(* ****** ****** *)

(* end of [linmap_avltree.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: October, 2013 *)

(* ****** ****** *)
  
#define ATS_PACKNAME "ATSLIB.libats.stringbuf"
#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names
  
(* ****** ****** *)
//
staload
_ = "prelude/DATS/integer.dats"
//
staload
_ = "prelude/DATS/array.dats"
staload
_ = "prelude/DATS/arrayptr.dats"
//
(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload
STDIO = "libc/SATS/stdio.sats"

(* ****** ****** *)

staload "libats/SATS/stringbuf.sats"

(* ****** ****** *)

extern
fun
memcpy (ptr, ptr, size_t):<!wrt> ptr = "mac#atslib_stringbuf_memcpy"
extern
fun
memmove (ptr, ptr, size_t):<!wrt> ptr = "mac#atslib_stringbuf_memmove"

(* ****** ****** *)
//
// HX:
// recapacitizing policy
// 0: manual
// 1: automatic doubling
//
implement
{}(*tmp*)
stringbuf$recapacitize () = 1 // default policy
//
(* ****** ****** *)
//
datavtype
stringbuf =
{m:pos}
STRINGBUF of (arrayptr(char, m+1), ptr(*cur*), size_t(m))
//
(* ****** ****** *)

assume stringbuf_vtype = stringbuf

(* ****** ****** *)

implement
{}(*tmp*)
stringbuf_make_nil
  (cap) = (sbf) where
{
//
prval [m:int] EQINT() = g1uint_get_index (cap)
//
val A = arrayptr_make_uninitized<char> (succ(cap))
//
val p_A = ptrcast (A)
//
val sbf = STRINGBUF ($UN.castvwtp0{arrayptr(char,m+1)}(A), p_A, cap)
//
} // end of [stringbuf_make_cap]

(* ****** ****** *)

implement
{}(*tmp*)
stringbuf_free (sbf) =
  let val+~STRINGBUF (A, _, _) = sbf in arrayptr_free (A) end
// end of [stringbuf_free]

(* ****** ****** *)

implement
{}(*tmp*)
stringbuf_getfree_strptr
  (sbf) = let
//
val+~STRINGBUF(A, p, _) = sbf
val () = $UN.ptr0_set<char>(p, '\000')
//
in
  $UN.castvwtp0{Strptr1}(A)
end // end of [stringbuf_getfree_strptr]

(* ****** ****** *)

implement
{}(*tmp*)
stringbuf_getfree_strnptr
  (sbf, n0) = let
//
val+~STRINGBUF(A, p, _) = sbf
val () = $UN.ptr0_set<char>(p, '\000')
val [n:int] n = $UN.cast{sizeGte(0)}(p - ptrcast(A))
val ((*void*)) = n0 := n
//
in
  $UN.castvwtp0{strnptr(n)}(A)
end // end of [stringbuf_getfree_strnptr]

(* ****** ****** *)

implement
{}(*tmp*)
stringbuf_get_size
  (sbf) = let
//
val+STRINGBUF(A, p, _) = sbf
//
in
  $UN.cast{size_t}(p - ptrcast(A))
end // end of [stringbuf_get_size]

implement
{}(*tmp*)
stringbuf_get_capacity
  (sbf) =
  let val+STRINGBUF (_, _, cap) = sbf in cap end
// end of [stringbuf_get_capacity]

(* ****** ****** *)

implement
{}(*tmp*)
stringbuf_get_bufptr
  (sbf) = let
  val+STRINGBUF (A, _, _) = sbf in $UN.castvwtp1{Ptr1}(A)
end // end of [stringbuf_get_bufptr]

implement
{}(*tmp*)
stringbuf_get_strptr
  (sbf) = let
  val+STRINGBUF (A, p, _) = sbf
  val () = $UN.ptr0_set<char> (p, '\000') in $UN.castvwtp1{vStrptr1}(A)
end // end of [stringbuf_get_strptr]

(* ****** ****** *)

implement
{}(*tmp*)
stringbuf_takeout_strbuf
  (sbf, n0) = let
//
val+STRINGBUF(A, p1, _) = sbf
//
val p0 = ptrcast (A)
val n = $UN.cast{size_t}(p1 - p0)
val [n:int] n = g1ofg0_uint (n)
val ((*void*)) = n0 := n
//
prval (pf, fpf) = __assert (p0) where
{
  extern praxi __assert {l:addr} (ptr(l)): vtakeout0(bytes_v (l, n))
} (* end of [prval] *)
//
in
  (pf, fpf | p0)
end // end of [stringbuf_takeout_strbuf]

(* ****** ****** *)

implement
{}(*tmp*)
stringbuf_reset_capacity
  (sbf, m2) = let
//
val n = stringbuf_get_size (sbf)
//
prval [m2:int] EQINT () = g1uint_get_index (m2)
//
in
//
if m2 >= n then let
//
val+@STRINGBUF(A, p, m) = sbf
//
val A2 =
  arrayptr_make_uninitized<char> (succ(m2))
val p_A2 = ptrcast(A2)
val _(*ptr*) = memcpy (p_A2, ptrcast(A), n)
//
val () = arrayptr_free (A)
//
val () = m := m2
val () = p := add_ptr_bsz (p_A2, n)
val () = A := $UN.castvwtp0{arrayptr(char,m2+1)}(A2)
prval () = fold@ (sbf)
//
in
  true
end else
  false
// end of [if]
//
end // end of [stringbuf_reset_capacity]

(* ****** ****** *)

implement
{}(*tmp*)
stringbuf_get_at
  (sbf, i) = let
//
var n: size_t
val (pf, fpf | p) = stringbuf_takeout_strbuf (sbf, n)
//
val i = g1ofg0(i)
val res = (if i < n then $UN.cast2int(p->[i]) else ~1): int
prval () = fpf (pf)
//
in
  res
end // end of [strigbuf_get_at]

(* ****** ****** *)

implement
{}(*tmp*)
stringbuf_rget_at
  (sbf, i) = let
//
var n: size_t
val (pf, fpf | p) = stringbuf_takeout_strbuf (sbf, n)
//
val res = (if i <= n then $UN.cast2int(p->[n-i]) else ~1): int
//
prval () = fpf (pf)
//
in
  res
end // end of [strigbuf_rget_at]

(* ****** ****** *)

implement
{}(*tmp*)
stringbuf_insert_char
  (sbf, x) = let
//
val+@STRINGBUF(A, p, m) = sbf
//
val m = m
val n = $UN.cast{size_t}(p - ptrcast(A))
//
in
//
case+ 0 of
| _ when n < m => let
    val () = $UN.ptr0_set<char> (p, x)
    val () = p := ptr_succ<char> (p)
    prval () = fold@ (sbf)
  in
    1
  end // end of [n < m]
| _ (*n >= m*) => let
    val recap = stringbuf$recapacitize ()
    prval () = fold@ (sbf)
  in
    if recap >= 1 then let
      val _ = stringbuf_reset_capacity (sbf, m+m) in stringbuf_insert_char (sbf, x)
    end else 0(*~inserted*) // end of [if]
  end // end of [n >= m]
//
end // end of [stringbuf_insert_char]

(* ****** ****** *)

implement
{}(*tmp*)
stringbuf_insert_string
  (sbf, x) = let
  val x = g1ofg0(x)
in
  stringbuf_insert_strlen (sbf, x, string_length(x))
end // end of [stringbuf_insert_string]

(* ****** ****** *)
//
extern
fun _stringbuf_pow2min
  (s1: sizeGte(1), s2: size_t): sizeGte(1) = "ext#%"
implement
_stringbuf_pow2min (s1, s2) =
   if s1 >= s2 then s1 else _stringbuf_pow2min (s1+s1, s2)
//
(* ****** ****** *)

implement
{}(*tmp*)
stringbuf_insert_strlen
  (sbf, x, nx) = let
//
val+@STRINGBUF(A, p, m) = sbf
//
val m = m
val n = $UN.cast{size_t}(p - ptrcast(A))
val n2 = n + nx
//
in
//
case+ 0 of
| _ when n2 <= m => let
    val _(*ptr*) =
      memcpy (p, string2ptr(x), nx)
    val () = p := ptr_add<char> (p, nx)
    prval () = fold@ (sbf)
  in
    sz2i(nx)
  end // end of [n2 <= m]
| _ (*n2 >= m*) => let
    val recap = stringbuf$recapacitize ()
    prval () = fold@ (sbf)
  in
    if recap >= 1 then let
      val m2 = _stringbuf_pow2min (m, n2)
      val _ = stringbuf_reset_capacity (sbf, m2) in stringbuf_insert_strlen (sbf, x, nx)
    end else 0(*~inserted*) // end of [if]
  end // end of [n2 >= m]
//
end // end of [stringbuf_insert_char]

(* ****** ****** *)

implement
{}(*tmp*)
stringbuf_insert_bool
  (sbf, x) = let
in
//
if x
  then stringbuf_insert_strlen (sbf, "true", i2sz(4))
  else stringbuf_insert_strlen (sbf, "false", i2sz(5))
// end of [if]
//
end // end of [stringbuf_insert_bool]

(* ****** ****** *)

implement
{}(*tmp*)
stringbuf_insert_int
  (sbf, x) = let
  val sbf = $UN.castvwtp1{ptr}(sbf)
  val recap = stringbuf$recapacitize ()
in
  $extfcall(int, "atslib_stringbuf_insert_snprintf", sbf, recap, "%i", x)
end // end of [stringbuf_insert_int]
implement
{}(*tmp*)
stringbuf_insert_uint
  (sbf, x) = let
  val sbf = $UN.castvwtp1{ptr}(sbf)
  val recap = stringbuf$recapacitize ()
in
  $extfcall(int, "atslib_stringbuf_insert_snprintf", sbf, recap, "%u", x)
end // end of [stringbuf_insert_uint]
implement
{}(*tmp*)
stringbuf_insert_lint
  (sbf, x) = let
  val sbf = $UN.castvwtp1{ptr}(sbf)
  val recap = stringbuf$recapacitize ()
in
  $extfcall(int, "atslib_stringbuf_insert_snprintf", sbf, recap, "%li", x)
end // end of [stringbuf_insert_lint]
implement
{}(*tmp*)
stringbuf_insert_ulint
  (sbf, x) = let
  val sbf = $UN.castvwtp1{ptr}(sbf)
  val recap = stringbuf$recapacitize ()
in
  $extfcall(int, "atslib_stringbuf_insert_snprintf", sbf, recap, "%lu", x)
end // end of [stringbuf_insert_ulint]

(* ****** ****** *)

implement
{}(*tmp*)
stringbuf_insert_fread
  (sbf, inp, nb) = let
//
val+@STRINGBUF(A, p, m) = sbf
//
val n = $UN.cast{size_t}(p - ptrcast(A))
//
val nb = g1ofg0 (nb)
val nb = (
  if nb > 0 then min (i2sz(nb), m - n) else (m - n)
) : size_t
val [nb:int] nb = g1ofg0(nb)
//
val (
  pf, fpf | p1
) = $UN.ptr0_vtake{bytes(nb)}(p)
val nread = $STDIO.fread (!p1, i2sz(1), nb, inp)
val ((*void*)) = p := ptr_add<char> (p, nread)
//
prval () = fpf (pf)
prval () = fold@ (sbf)
//
in
  sz2i(nread)
end // end of [stringbuf_insert_fread]

(* ****** ****** *)

implement
{}(*tmp*)
stringbuf_insert_fgets
  (sbf, inp, last) = let
//
val+@STRINGBUF(A, p, m) = sbf
//
val n =
$UN.cast{size_t}(p-ptrcast(A))
val [nb:int] nb = g1ofg0(m - n)
//
val (
  pf, fpf | p1
) = $UN.ptr0_vtake{bytes(nb+1)}(p)
val p2 = $STDIO.fgets0 (!p1, sz2i(nb)+1, inp)
//
prval pf2 =
assert (view@last) where
{ 
  extern praxi assert{l:addr}(char(0)@l): char@l
}
//
val n2 =
(
if p2 > 0 
  then let
    val n2 =
      length($UN.cast{string}(p2))
    val n2 = g1ofg0(n2)
    val () = p := ptr_add<char> (p, n2)
    val () = if n2 > 0 then last := $UN.ptr0_get<char> (ptr_pred<char> (p))
  in
    sz2i (n2)
  end // end of [then]
  else (~1) // HX: failure
// end of [if]
) : int // end of [val]
//
prval () = view@last := pf2
//
prval () = fpf (pf)
prval () = fold@ (sbf)
//
in
  n2
end // end of [stringbuf_insert_fgets]

(* ****** ****** *)
//
implement
stringbuf_insert_val<int> = stringbuf_insert_int
//
implement
stringbuf_insert_val<bool> = stringbuf_insert_bool
//
implement
stringbuf_insert_val<uint> = stringbuf_insert_uint
implement
stringbuf_insert_val<lint> = stringbuf_insert_lint
implement
stringbuf_insert_val<ulint> = stringbuf_insert_ulint
//
implement
stringbuf_insert_val<string> = stringbuf_insert_string
//
(* ****** ****** *)

implement
{a}(*tmp*)
stringbuf_insert_list
  (sbf, xs) = let
//
fun loop
(
  sbf: !stringbuf, xs: List(a), res: int
) : int = let
in
//
case+ xs of
| list_cons
    (x, xs) => let
    val n = stringbuf_insert_val<a> (sbf, x)
  in
    loop (sbf, xs, res + n)
  end (* end of [list_cons] *)
| list_nil () => res
//
end // end of [loop]
//
in
  loop (sbf, xs, 0)
end // end of [stringbuf_insert_list]

(* ****** ****** *)

implement
{}(*tmp*)
stringbuf_takeout
  (sbf, i) = let
//
val+@STRINGBUF(A, p1, _) = sbf
//
val p0 = ptrcast (A)
val n = $UN.cast{size_t}(p1 - p0)
val [n:int] n = g1ofg0_uint (n)
val [i:int] i = g1ofg0_uint (i)
//
val i = min(i, n)
val str = string_make_substring ($UN.cast{string(n)}(p0), i2sz(0), i)
//
val ni = (n - i)
val p0 = memmove (p0, ptr_add<char> (p0, i), ni)
val () = p1 := ptr_add<char> (p0, ni)
//
prval () = fold@ (sbf)
prval () = lemma_strnptr_param (str)
//
in
  strnptr2strptr(str)
end // end of [stringbuf_takeout]

(* ****** ****** *)

implement
{}(*tmp*)
stringbuf_takeout_all
  (sbf) = let
//
val+@STRINGBUF(A, p1, _) = sbf
//
val p0 = ptrcast (A)
val n = $UN.cast{size_t}(p1 - p0)
val [n:int] n = g1ofg0_uint (n)
//
val str = string_make_substring ($UN.cast{string(n)}(p0), i2sz(0), n)
//
val () = p1 := p0
//
prval () = fold@ (sbf)
prval () = lemma_strnptr_param (str)
//
in
  strnptr2strptr(str)
end // end of [stringbuf_takeout_all]

(* ****** ****** *)
  
implement
{}(*tmp*)
stringbuf_remove
  (sbf, i) = () where
{
//
val+@STRINGBUF(A, p1, _) = sbf
//
val p0 = ptrcast (A)
val n = $UN.cast{size_t}(p1 - p0)
val [n:int] n = g1ofg0_uint (n)
val [i:int] i = g1ofg0_uint (i)
//
val i = min(i, n)
val ni = n - min(i, n)
val p0 = memmove (p0, ptr_add<char> (p0, i), ni)
val () = p1 := ptr_add<char> (p0, ni)
//
prval () = fold@ (sbf)
//
} (* end of [stringbuf_remove] *)
  
(* ****** ****** *)

implement
{}(*tmp*)
stringbuf_remove_all
  (sbf) = () where
{
//
val+@STRINGBUF(A, p1, _) = sbf
val ((*void*)) = p1 := ptrcast(A)
prval ((*void*)) = fold@ (sbf)
//
} (* end of [stringbuf_remove_all] *)

(* ****** ****** *)

implement
{}(*tmp*)
stringbuf_truncate
  (sbf, n2) = let
//
val+@STRINGBUF(A, p1, _) = sbf
//
val p0 = ptrcast(A)
val n1 = $UN.cast{size_t}(p1 - p0)
//
in
//
if n2 < n1
  then let
    val p2 =
      ptr_add<char> (p0, n2)
    val ((*void*)) = (p1 := p2)
    prval () = fold@ (sbf)
  in
    true
  end // end of [then]
  else let
    prval () = fold@ (sbf) in false
  end // end of [else]
// end of [if]
//
end // end of [stringbuf_truncate]

(* ****** ****** *)

implement
{}(*tmp*)
stringbuf_truncout
  (sbf, n2) = let
//
fun aux .<>.
(
  p: ptr, n: size_t
) :<!wrt> Strptr1 = let
  val [n0:int]
    str = $UN.cast{String}(p)
  val n = $UN.cast{sizeLte(n0)}(n)
  val str2 =
    string_make_substring (str, i2sz(0), n)
  // end of [val]
  prval () = lemma_strnptr_param (str2)
in
  strnptr2strptr (str2)
end // end of [aux]
//
val+@STRINGBUF(A, p1, _) = sbf
//
val p0 = ptrcast(A)
val n1 = $UN.cast{size_t}(p1 - p0)
//
in
//
if (
  n1 >= n2
) then let
    val p2 =
      ptr_add<char> (p0, n2)
    val res = aux (p2, n1-n2)
    val ((*void*)) = (p1 := p2)
    prval () = fold@ (sbf)
  in
    res
  end // end of [then]
  else let
    prval () = fold@ (sbf) in strptr_null ()
  end // end of [else]
// end of [if]
//
end // end of [stringbuf_truncout]

(* ****** ****** *)
//
implement
{}(*tmp*)
stringbuf_truncout_all (sbf) =
  $UN.castvwtp0{Strptr1}(stringbuf_truncout (sbf, i2sz(0)))
//  
(* ****** ****** *)
//
extern
fun _stringbuf_get_size (!stringbuf): size_t = "ext#%"
extern
fun _stringbuf_get_capacity (!stringbuf): size_t = "ext#%"
//
extern
fun _stringbuf_get_ptrcur (sbf: !stringbuf): ptr = "ext#%"
extern
fun _stringbuf_set_ptrcur (sbf: !stringbuf, p2: ptr): void = "ext#%"
//
extern
fun _stringbuf_reset_capacity (sbf: !stringbuf, m2: sizeGte(1)): bool = "ext#%"
//
(* ****** ****** *)
//
implement
_stringbuf_get_size (sbf) = stringbuf_get_size<> (sbf)
implement
_stringbuf_get_capacity (sbf) = stringbuf_get_capacity<> (sbf)
//
implement
_stringbuf_get_ptrcur
  (sbf) =
  let val+STRINGBUF(_, p, _) = sbf in p end
implement
_stringbuf_set_ptrcur
  (sbf, p2) =
  let val+@STRINGBUF(_, p, _) = sbf in p := p2; fold@(sbf) end
// end of [_stringbuf_set_ptrcur]
//
implement
_stringbuf_reset_capacity (sbf, m2) = stringbuf_reset_capacity<> (sbf, m2)
//
(* ****** ****** *)

%{$
//
atstype_int
atslib_stringbuf_insert_snprintf
(
  atstype_ptr sbf, atstype_int recap, atstype_string fmt, ...
) {
  int ntot ;
  va_list ap0 ;
  va_start(ap0, fmt) ;
  ntot = atslib_stringbuf_insert_vsnprintf (sbf, recap, fmt, ap0) ;
  va_end(ap0) ;
  return (ntot) ;
} // end of [atslib_stringbuf_insert_snprintf]
//
atstype_int
atslib_stringbuf_insert_vsnprintf
(
  atstype_ptr sbf, atstype_int recap, atstype_string fmt, va_list ap0
) {
  size_t m ;
  size_t n ;
  void *p_cur ;
  int ntot ;
  va_list ap1 ;
//
  m = atslib__stringbuf_get_capacity (sbf) ;
  n = atslib__stringbuf_get_size (sbf) ;
  p_cur = atslib__stringbuf_get_ptrcur (sbf) ;
//
  va_copy(ap1, ap0) ;
  ntot = vsnprintf ((char*)p_cur, m-n+1, (char*)fmt, ap1) ;
  va_end(ap1) ;
//
  if (ntot > m-n && recap >= 1)
  { 
    m = atslib__stringbuf_pow2min (m, n+ntot) ;
    atslib__stringbuf_reset_capacity (sbf, m) ;
    p_cur = atslib__stringbuf_get_ptrcur (sbf) ;
    ntot = vsnprintf ((char*)p_cur, ntot+1, (char*)fmt, ap0) ;
  }
//
  if (ntot >= 0) {
    atslib__stringbuf_set_ptrcur (sbf, (char*)p_cur+ntot) ;
  } // end of [if]
//
  return (ntot) ;
//
} // end of [atslib_stringbuf_insert_snprintf]
//
%} // end of [%{$]

(* ****** ****** *)

(* end of [stringbuf.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                       ATS/contrib/libats-hwxi                       *)
(*                                                                     *)
(***********************************************************************)

(*
** Copyright (C) 2015 Hongwei Xi, ATS Trustful Software, Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and associated documentation files (the "Software"),
** to deal in the Software without restriction, including without limitation
** the rights to use, copy, modify, merge, publish, distribute, sublicense,
** and/or sell copies of the Software, and to permit persons to whom the
** Software is furnished to do so, subject to the following stated conditions:
** 
** The above copyright notice and this permission notice shall be included in
** all copies or substantial portions of the Software.
** 
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
** OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
** THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
** LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
** FROM OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
** IN THE SOFTWARE.
*)

(* ****** ****** *)
//
// HX-2015-09-28:
// Some templates for getters
//
(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libats/SATS/theGetters.sats"

(* ****** ****** *)
//
implement
{}(*tmp*)
the_getall_asz_hint((*void*)) = i2sz(64)
//  
(* ****** ****** *)

implement
{a}(*tmp*)
the_getall_list
  ((*void*)) = let
//
vtypedef
res_vt = List0_vt(a)
//
fun
loop
(
  res: &ptr? >> res_vt
) : void = let
//
val () =
  res :=
  list_vt_cons{a}{0}(_, _)
//
val+list_vt_cons(x, res1) = res
//
val ans = the_get_elt<a>(x)
//
in
//
if
ans
then let
  prval
    () = opt_unsome(x)
  // end of [prval]
  val () = loop(res1)
  prval () = fold@(res)
in
  // nothing
end // end of [then]
else let
  prval
    () = opt_unnone(x)
  // end of [prval]
  val () = free@{a}{0}(res)
  val () = res := list_vt_nil()
in
  // nothing
end // end of [else]
//
end // end of [loop]
//
var res: ptr // uninitized
//
in
  loop(res); res
end // end of [the_getall_list]

(* ****** ****** *)

implement
{a}(*tmp*)
the_getall_arrayptr
  (asz) = let
//
fun
loop
(
  pp: ptr, pa: ptr, pz: ptr, asz: &size_t? >> _
) : ptr = (
//
if
pp < pz
then let
//
val (
  pf, fpf | pp
) = $UN.ptr0_vtake{a?}(pp)
val ans = the_get_elt<a>(!pp)
prval () = $UN.cast2void((fpf, pf | pp))
//
in
//
if ans
  then
    loop(ptr0_succ<a>(pp), pa, pz, asz)
  // end of [then]
  else let
    val () =
    asz := $UN.cast2size(pp-pa)/sizeof<a> in pa
  end // end of [else]
// end of [if]
//
end // end of [then]
else let
//
val n =
$UN.cast2size(pz-pa)/sizeof<a>
val n = $UN.cast{sizeGte(1)}(n)
val n2 = n + n
//
val pa2 =
$UN.castvwtp0{ptr}
(
  arrayptr_make_uninitized<a>(n2)
)
//
extern
fun
memcpy
(
  dst: ptr, src: ptr, bsz: size_t
) : ptr = "atslib_memcpy"
val _ = memcpy(pa2, pa, n*sizeof<a>)
//
val pp2 = ptr_add<a>(pa2, n)
val pz2 = ptr_add<a>(pa2, n2)
//
in
  loop (pp2, pa2, pz2, asz)
end // end of [else]
//
) (* end of [loop] *)
//
val n =
the_getall_asz_hint()
//
val pa =
$UN.castvwtp0{ptr}
  (arrayptr_make_uninitized<a>(n))
//
val pz = ptr_add<a> (pa, n)
//
val pa = loop(pa, pa, pz, asz)
//
val [n:int] n = g1ofg0_uint(asz)
//
prval
[l:addr]
EQADDR() = eqaddr_make_ptr(addr@asz)
prval () = view@asz := $UN.castview0{size_t(n)@l}(view@asz)
//
in
  $UN.castvwtp0{arrayptr(a, n)}(asz)  
end // end of [the_getall_arrayptr]

(* ****** ****** *)

implement
{a}(*tmp*)
the_get_elt_exn
  ((*void*)) = let
//
var x: a? // uninitized
val ans = the_get_elt<a> (x)
//
in
//
if
ans
then let
  prval () = opt_unsome(x) in x
end // end of [then]
else let
  prval () = opt_unnone(x) in $raise Exception_the_get_elt_exn()
end // end of [else]
//
end // end of [the_get_elt_exn]

(* ****** ****** *)

implement
{a}(*tmp*)
the_getall_list_exn
  ((*void*)) =
(
  list_vt_reverse(the_getall_rlist_exn<a>())
) (* end of [the_getall_list_exn] *)

(* ****** ****** *)

implement
{a}(*tmp*)
the_getall_rlist_exn
  ((*void*)) = let
//
vtypedef
res_vt = List0_vt(a)
//
fun
loop
(
  p: ptr
) : void = loop(p) where
{
  val x =
    the_get_elt_exn()
  val xs =
    $UN.ptr0_get<res_vt>(p)
  val () =
    $UN.ptr0_set<res_vt>(p, cons_vt{a}(x, xs))
} (* end of [loop] *)
//
var
res: ptr =
  list_vt_nil()
val
p_res = addr@res
//
val () =
ptr_as_volatile (p_res) // longjmp/setjmp bug
//
val ((*void*)) =
(
  try loop(p_res) with ~Exception_the_get_elt_exn() => ()
) : void // end of [val]
//
in
  res
end // end of [the_getall_rlist_exn]

(* ****** ****** *)

local
//
staload
"libats/SATS/dynarray.sats"
//
(*
staload
_ = "libats/DATS/dynarray.dats"
*)
in (* in-of-local *)
//
implement
{a}(*tmp*)
the_getall_arrayptr_exn
  (asz) = let
//
vtypedef DA = dynarray(a)
//
fun
loop
(
  DA: ptr
) : void = loop(DA) where
{
  val x =
    the_get_elt_exn()
  // end of [val]
  val DA =
    $UN.castvwtp0{DA}(DA)
  // end of [val]
  val () =
    dynarray_insert_atend_exn<a>(DA, x)
  // end of [val]
  val DA = $UN.castvwtp0{ptr}(DA)
} (* end of [loop] *)
//
val n0 = the_getall_asz_hint()
val DA = dynarray_make_nil<a>(n0)
val p_DA = $UN.castvwtp1{ptr}(DA)
//
val () =
ptr_as_volatile (p_DA) // longjmp/setjmp bug
//
val ((*void*)) =
(
  try loop(p_DA) with ~Exception_the_get_elt_exn() => ()
) : void // end of [val]
//
in
  dynarray_getfree_arrayptr{a}(DA, asz)
end // end of [the_getall_arrayptr_exn]
//
end // end of [local]

(* ****** ****** *)

(* end of [theGetters.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: November, 2011 *)

(* ****** ****** *)
//
// HX: Note that this implementation is largely of
// functional-style and only supports mergeable-heap
// operations; it particular it does not support the
// decrease-key operation.
//
(* ****** ****** *)
//
// HX-2012-12: ported to ATS/Postiats
//
(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.linheap_binomial"
#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libats/SATS/linheap_binomial.sats"

(* ****** ****** *)

#define nullp the_null_ptr

(* ****** ****** *)
//
// HX-2012-12-21:
// the file should be included here
// before [heap_vtype] is assumed
//
#include "./SHARE/linheap.hats" // code reuse
//
(* ****** ****** *)
//
// binomial trees:
// btree(a, n) is for a binomial tree of rank(n)
//
datavtype
btree (
a:vt@ype+, int(*rank*)
) = // btree
  | {n:nat}
    btnode (a, n) of (int (n), a, btreelst (a, n))
// end of [btree]

and btreelst
(
  a:vt@ype+, int(*rank*)
) =
  | {n:nat}
    btlst_cons (a, n+1) of (btree (a, n), btreelst (a, n))
  | btlst_nil (a, 0)
// end of [btreelst]

(* ****** ****** *)

datavtype
bheap (
  a:vt@ype+, int(*rank*), int(*size*)
) = // bheap
  | {n:nat}
    bheap_nil (a, n, 0) of ()
  | {n:nat}{p:int}{sz:nat}{n1:int | n1 > n}
    bheap_cons (a, n, p+sz) of (EXP2 (n, p) | btree (a, n), bheap (a, n1, sz))
// end of [bheap]

(* ****** ****** *)

fun{
a:vt0p
} btree_rank
  {n:int} .<>. (
  bt: !btree (a, n)
) :<> int (n) = let
  val btnode (n, _, _) = bt in n
end // end of [btree_rank]

(* ****** ****** *)

extern
fun{
} pow2 {n:nat}
  (n: int n):<> [p:int] (EXP2 (n, p) | size_t p)
// end of [pow2]

implement{}
pow2 {n} (n) = let
  val res =
    g0uint_lsl_size ((i2sz)1, n)
  val [p:int] res = g1ofg0_uint (res)
  prval pf = __assert () where
  {
    extern praxi __assert (): EXP2 (n, p)
  } // end of [where] // end of [prval]
in
  (pf | res)
end // end of [pow2]

(* ****** ****** *)

fun{
a:vt0p
} btree_size
  {n:int} .<>.
(
  bt: !btree (a, n)
) :<> [p:int]
(
  EXP2 (n, p) | size_t (p)
) = let
  val btnode (n, _, _) = bt in pow2 (n)
end // end of [btree_size]

(* ****** ****** *)

fun{
a:vt0p
} bheap_size
  {n:int}{sz:int}
(
  hp: !bheap (a, n, sz)
) : size_t (sz) = let
in
//
case+ hp of
| bheap_cons
    (pf | bt, hp) => let
    val (pf2 | p) = btree_size<a> (bt)
    prval () = exp2_isfun (pf, pf2)
  in
    p + bheap_size<a> (hp)
  end // end of [bheap_cons]
| bheap_nil ((*void*)) => g1int2uint (0)
//
end // end of [bheap_size]

(* ****** ****** *)

fun{
a:t0p
} btree_free
  {n:nat} .<n,1>.
  (bt: btree (a, n)) :<!wrt> void = let 
  val ~btnode (_, _, bts) = bt in btreelst_free<a> (bts)
end // end of [btree_free]

and
btreelst_free
  {n:nat} .<n,0>.
(
  bts: btreelst (a, n)
) :<!wrt> void = let
in
//
case+ bts of
| ~btlst_cons
    (bt, bts) => let
    val () = btree_free<a> (bt) in btreelst_free<a> (bts)
  end // end of [btlst_cons]
|  ~btlst_nil () => ()
end // end of [btreelst_free]

(* ****** ****** *)

fun{a:vt0p}
btree_btree_merge
  {n:nat} .<>. (
  bt1: btree (a, n)
, bt2: btree (a, n)
) :<!wrt> btree (a, n+1) = let
  val @btnode (n1, x1, bts1) = bt1
  val @btnode (n2, x2, bts2) = bt2
  val sgn = compare_elt_elt<a> (x1, x2)
in
  if sgn <= 0 then let
    prval () = fold@ (bt2)
    val () = n1 := n1 + 1
    val () = bts1 := btlst_cons{a}(bt2, bts1)
  in
    fold@ (bt1); bt1
  end else let
    prval () = fold@ (bt1)
    val () = n2 := n2 + 1
    val () = bts2 := btlst_cons{a}(bt1, bts2)
  in
    fold@ (bt2); bt2
  end // end of [if]
end // end of [btree_btree_merge]

(* ****** ****** *)

fun{a:vt0p}
btree_bheap_merge
  {n:nat}
  {n1:int | n <= n1}
  {sz:nat}{p:int} .<sz>.
(
  pf: EXP2 (n, p)
| bt: btree (a, n), n: int (n), hp: bheap (a, n1, sz)
) :<!wrt> [n2:int | n2 >= min(n, n1)] bheap (a, n2, sz+p) =
  case+ hp of
  | ~bheap_nil () =>
      bheap_cons{a}(pf | bt, bheap_nil {a} {n+1} ())
    // end of [bheap_nil]
  | @bheap_cons (pf1 | bt1, hp1) => let
      val n1 = btree_rank<a> (bt1)
    in
      if n < n1 then let
        prval () = fold@ (hp) in bheap_cons{a}(pf | bt, hp)
      end else if n > n1 then let
        val () = hp1 := btree_bheap_merge<a> (pf | bt, n, hp1)
        prval () = fold@ (hp) 
      in
        hp
      end else let
        prval () = exp2_ispos (pf1)
        prval () = exp2_isfun (pf, pf1)
        val bt = btree_btree_merge<a> (bt, bt1)
        val hp1 = hp1
        val () = free@{a}{0}{0}{0}{1}(hp)
      in
        btree_bheap_merge<a> (EXP2ind (pf) | bt, n+1, hp1)
      end // end of [if]
    end (* end of [bheap_cons] *)
// end of [btree_bheap_merge]

(* ****** ****** *)

fun{a:vt0p}
bheap_bheap_merge
  {n1,n2:nat}
  {sz1,sz2:nat} .<sz1+sz2>. (
  hp1: bheap (a, n1, sz1), hp2: bheap (a, n2, sz2)
) :<!wrt>
  [n:int | n >= min(n1, n2)] bheap (a, n, sz1+sz2) = let
in
//
case+ hp1 of
| ~bheap_nil () => hp2
| @bheap_cons (pf1 | bt1, hp11) => (
  case+ hp2 of
  | ~bheap_nil () => (fold@ (hp1); hp1)
  | @bheap_cons (pf2 | bt2, hp21) => let
//
      prval pf1 = pf1 and pf2 = pf2
      prval () = exp2_ispos (pf1) and () = exp2_ispos (pf2)
//
      val n1 = btree_rank<a> (bt1)
      and n2 = btree_rank<a> (bt2)
    in
      if n1 < n2 then let
        prval () = fold@ (hp2)
        val () = hp11 := bheap_bheap_merge<a> (hp11, hp2)
        prval () = fold@ (hp1)
      in
        hp1
      end else if n1 > n2 then let
        prval () = fold@ (hp1)
        val () = hp21 := bheap_bheap_merge<a> (hp1, hp21)
        prval () = fold@ (hp2)
      in
        hp2
      end else let
        prval () = exp2_isfun (pf1, pf2)
        val bt12 = btree_btree_merge<a> (bt1, bt2)
        val hp11 = hp11 and hp21 = hp21
        val () = free@{a}{0}{0}{0}{1}(hp1)
        val () = free@{a}{0}{0}{0}{1}(hp2)
      in
        btree_bheap_merge<a> (EXP2ind (pf1) | bt12, n1+1, bheap_bheap_merge<a> (hp11, hp21))
      end // end of [if]
    end (* end of [bheap_cons] *)
  ) // end of [bheap_cons]
end // end of [bheap_bheap_merge]

(* ****** ****** *)

fun{a:vt0p}
bheap_search_ref
  {n:nat}{sz:pos} .<>.
(
  hp0: !bheap (a, n, sz)
) :<> cPtr1(a) = let
//
fun search
  {n:nat}{sz:nat} .<sz>.
(
  hp0: !bheap (a, n, sz), p_x0: Ptr1
) :<> Ptr1 = let
in
//
case+ hp0 of
| @bheap_cons
    (pf | bt, hp) => let
    prval () = exp2_ispos (pf)
    val @btnode (_, x, _) = bt
    val (
      pf, fpf | p_x0
    ) = $UN.ptr_vtake{a}(p_x0)
    val sgn = compare_elt_elt<a> (!p_x0, x)
    prval () = fpf (pf)
    val res =
    (
      if sgn > 0 then search (hp, addr@(x)) else search (hp, p_x0)
    ) : Ptr1 // end of [val]
    prval () = fold@ (bt)
    prval () = fold@ (hp0)
  in
    res
  end // end of [bheap_cons]
| bheap_nil () => p_x0
//
end (* end of [search] *)
//
val+ @bheap_cons
  (pf0 | bt0, hp1) = hp0
val+ @btnode (_, x0, _) = bt0
prval () = fold@ (bt0)
val res = search (hp1, addr@(x0))
prval () = fold@ (hp0)
//
in
  $UN.ptr2cptr{a}(res)
end // end of [bheap_search_ref]

(* ****** ****** *)

fun{a:vt0p}
bheap_remove
  {n:nat}{sz:pos} .<>.
(
  hp0: &bheap (a, n, sz) >> bheap (a, n1, sz-p)
) :<!wrt> #[
  n1,n2,p:int | n1 >= n; n2 >= n; sz >= p
] (
  EXP2 (n2, p) | btree (a, n2)
) = let
//
// HX: [search] and [remove] can be merged into one
//
fun search
  {n:nat}{sz:nat} .<sz>. (
  hp0: !bheap (a, n, sz), x0: &a, pos: &Nat >> _
) :<!wrt> void = let
in
//
case+ hp0 of
| @bheap_cons
    (pf | bt, hp) => let
    prval () = exp2_ispos (pf)
    val+ @btnode (_, x, _) = bt
    val sgn = compare_elt_elt<a> (x0, x)
    val () =
      if sgn > 0 then let
      val p_x0 = addr@ (x0) and p_x = addr@ (x)
      val () = $UN.ptr0_set<a> (p_x0, $UN.ptr0_get<a>(p_x))
      val () = pos := pos + 1
    in
      // nothing
    end // end of [val]
    prval () = fold@ (bt)
    val () = search (hp, x0, pos)
    prval () = fold@ (hp0)
  in
    // nothing
  end // [bheap_cons]
| bheap_nil () => ()
//
end // end of [search]
//
val+ @bheap_cons
  (pf0 | bt0, hp1) = hp0
val+ @btnode (_, x, _) = bt0
val p_x = addr@ (x); prval () = fold@ {a} (bt0)
var x0: a = $UN.ptr0_get<a> (p_x) and pos: Nat = 0
val () = search (hp1, x0, pos)
prval () =
  __clear (x0) where {
  extern praxi __clear (x: &a >> a?): void
} (* end of [prval] *)
prval () = fold@ {a} (hp0)
//
fun remove
  {n:nat}{sz:nat}
  {pos:nat} .<pos>. (
  hp0: &bheap (a, n, sz) >> bheap (a, n1, sz-p)
, pos: int (pos)
, btmin: &btree(a, 0)? >> btree (a, n2)
) :<!wrt> #[
  n1,n2,p:int | n1 >= n; n2 >= n; sz >= p
] (
  EXP2 (n2, p) | void
) = let
//
  prval (
  ) = __assert () where
  {
    extern praxi __assert (): [sz > 0] void
  } // end of [prval]
//
  val+ @bheap_cons (pf | bt, hp) = hp0
//
  prval pf = pf
  prval () = exp2_ispos (pf)
in
//
if pos > 0 then let
  val (pfmin | ()) = remove (hp, pos-1, btmin)
  prval () = fold@ (hp0)
in
  (pfmin | ())
end else let
  val () = btmin := bt
  val hp = hp
  val () = free@{a}{0}{0}{0}{1}(hp0)
  val () = hp0 := hp
in
  (pf | ())
end // end of [if]
//
end (* end of [remove] *)
//
var btmin: btree (a, 0)?
val (pf | ()) = remove (hp0, pos, btmin)
//
in
  (pf | btmin)
end // end of [bheap_remove]

(* ****** ****** *)

assume
heap_vtype
  (a:vt0p) = [n,sz:nat] bheap (a, n, sz)
// end of [heap_vtype]

(* ****** ****** *)

implement{}
linheap_nil {a} () = bheap_nil{a}{0}()
implement{}
linheap_make_nil {a} () = bheap_nil{a}{0}()

(* ****** ****** *)

implement{}
linheap_is_nil (hp) = let
in
//
case+ hp of
| bheap_cons (_ | _, _) => false | bheap_nil () => true
//
end // end of [linheap_is_nil]

implement{}
linheap_isnot_nil (hp) = let
in
//
case+ hp of
| bheap_cons (_ | _, _) => true | bheap_nil () => false
//
end // end of [linheap_is_cons]

(* ****** ****** *)

implement{a}
linheap_size (hp) = $effmask_all (bheap_size<a> (hp))

(* ****** ****** *)

implement{a}
linheap_insert
  (hp0, x0) = let
  val bt = btnode{a}(0, x0, btlst_nil()) in
  hp0 := btree_bheap_merge<a> (EXP2bas () | bt, 0, hp0)
end // end of [linheap_insert]

(* ****** ****** *)

implement{a}
linheap_getmin_ref (hp0) = let
(*
val () = (
  print ("linheap_getmin_ref: enter"); print_newline ()
) // end of [val]
*)
in
//
case+ hp0 of
| bheap_cons
    (pf | _, _) => let
    prval (
    ) = exp2_ispos (pf)
  in
    bheap_search_ref<a> (hp0)
  end // end of [bheap_cons]
| bheap_nil ((*void*)) => cptr_null{a}((*void*))
//
end // end of [linheap_getmin_ref]

(* ****** ****** *)

implement{a}
linheap_delmin
  (hp0, res) = let
(*
val () = (
  print ("linheap_delmin: enter"); print_newline ()
) // end of [val]
*)
in
//
case+ hp0 of
| bheap_cons
    (pf0 | _, _) => let
    prval () = exp2_ispos (pf0)
    val (_(*pf*) | btmin) = bheap_remove<a> (hp0)
    val ~btnode (_, x, bts) = btmin
    val () = res := x
    prval () = opt_some{a}(res)
    val hp1 = hp1 where {
      fun loop
        {n:nat}{sz:nat} .<n>.
      (
        bts: btreelst (a, n), hp: bheap (a, n, sz)
      ) :<> [sz:nat] bheap (a, 0, sz) =
        case+ bts of
        | ~btlst_cons (bt, bts) => let
            prval pf = exp2_istot () in loop (bts, bheap_cons{a}(pf | bt, hp))
          end // end of [btlst_cons]
        | ~btlst_nil () => hp
      // end of [loop]
      val hp1 = loop (bts, bheap_nil)
    } // end of [val]
    val () = hp0 := bheap_bheap_merge<a> (hp0, hp1)
  in
    true
  end // end of [bheap_cons]
| bheap_nil () => let
    prval () = opt_none{a}(res) in false
  end // end of [bheap_nil]
// end of [case]
//
end // end of [linheap_delmin]

(* ****** ****** *)

implement{a}
linheap_merge
  (hp1, hp2) = bheap_bheap_merge<a> (hp1, hp2)
// end of [linheap_merge]

(* ****** ****** *)

implement{a}
linheap_free (hp0) = let
in
//
case+ hp0 of
| ~bheap_cons
    (_ | bt, hp) => let
    val () = btree_free<a> (bt) in linheap_free (hp)
  end // end of [bheap]
| ~bheap_nil () => ()
//
end // end of [linheap_free]

(* ****** ****** *)

implement{a}
linheap_free_ifnil
  (hp0) = let
  vtypedef hp = heap (a)
in
//
case+ hp0 of
| bheap_cons
    (_ | _, _) => let
    prval () = opt_some{hp}(hp0) in true
  end // end of [bheap_cons]
| bheap_nil () => let
    prval () = __assert (hp0) where
    {
      extern
      praxi __assert {n:int} (hp: !bheap (a, n, 0) >> ptr): void
    } // end of [prval]
    prval () = opt_none{hp}(hp0) in false
  end // end of [bheap_nil]
//
end // end of [linheap_free_vt]

(* ****** ****** *)

(* linheap_binomial.dats *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: August, 2013 *)

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.hashtbl_chain"
#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libats/SATS/hashfun.sats"

(* ****** ****** *)

staload "libats/SATS/hashtbl_chain.sats"

(* ****** ****** *)

#include "./SHARE/hashtbl.hats" // code reuse

(* ****** ****** *)

extern
fun{}
chain_nil
  {key:t0p;itm:vt0p}(): chain(key, itm)
// end of [chain_nil]

extern
fun{
key:t0p;itm:vt0p
} chain_search_ref
  (kxs: !chain(key, itm), k0: key): cPtr0(itm)
// end of [chain_search_ref]

(* ****** ****** *)

extern
fun{
key:t0p;itm:vt0p
} chain_insert (
  &chain(key, INV(itm)) >> _
, k0: key, x0: itm, res: &itm? >> opt(itm, b)
) : #[b:bool] bool (b) // endfun

extern
fun{
key:t0p;itm:vt0p
} chain_insert_any
  (kxs: &chain(key, itm) >> _, key, itm): void
// end of [chain_insert_any]

(* ****** ****** *)

extern
fun{
key:t0p;itm:vt0p
} chain_takeout (
  &chain(key, INV(itm)) >> _, k0: key, res: &itm? >> opt(itm, b)
) : #[b:bool] bool (b) // endfun

(* ****** ****** *)

extern
fun
{key:t0p
;itm:vt0p}
{env:vt0p}
chain_foreach_env
(
  kxs: !chain(key, itm) >> _, env: &env >> _
) : void // end of [chain_foreach_env]

(* ****** ****** *)

extern
fun
{key:t0p
;itm:vt0p}
chain_listize (chain(key, itm)): List_vt @(key, itm)

extern
fun
{key:t0p
;itm:vt0p}
{ki2:vt0p}
chain_flistize (kxs: chain(key, itm)): List_vt (ki2)

(* ****** ****** *)

staload
LM = "libats/SATS/linmap_list.sats"

(* ****** ****** *)

implement
{key}(*tmp*)
$LM.equal_key_key (x, y) = equal_key_key<key> (x, y)

(* ****** ****** *)

local
//
assume
chain_vtype (key:t0p, itm:vt0p) = $LM.map (key, itm)
//
in (* in of [local] *)

(* ****** ****** *)

implement
{}(*tmp*)
chain_nil () = $LM.linmap_nil ()

(* ****** ****** *)

implement
{key,itm}
chain_search_ref = $LM.linmap_search_ref<key,itm>

(* ****** ****** *)

implement
{key,itm}
chain_insert = $LM.linmap_insert<key,itm>
implement
{key,itm}
chain_insert_any = $LM.linmap_insert_any<key,itm>

(* ****** ****** *)

implement
{key,itm}
chain_takeout = $LM.linmap_takeout<key,itm>

(* ****** ****** *)

implement
{key,itm}{env}
chain_foreach_env
  (kxs, env) = let
//
implement
$LM.linmap_foreach$fwork<key,itm><env> = hashtbl_foreach$fwork<key,itm><env>
//
in
  $LM.linmap_foreach_env<key,itm><env> (kxs, env)
end // end of [chain_foreach_env]

(* ****** ****** *)

implement
{key,itm}
chain_listize (kxs) = $LM.linmap_listize (kxs)

implement
{key,itm}{ki2}
chain_flistize (kxs) = let
//
implement
$LM.linmap_flistize$fopr<key,itm><ki2> = hashtbl_flistize$fopr<key,itm><ki2>
//
in
  $LM.linmap_flistize<key,itm><ki2> (kxs)
end // end of [chain_flistize]

end // end of [local]

(* ****** ****** *)

extern
fun{
key:t0p;itm:vt0p
} chainarr_insert_any
  {m:int | m >= 1} (
  A: !arrayptr (chain(key, itm), m), m: size_t m, k: key, x: itm
) : void // end of [chainarr_insert_any]
extern
fun{
key:t0p;itm:vt0p
} chainarr_insert_chain
  {m:int | m >= 1} (
  A: !arrayptr (chain(key, itm), m), m: size_t m, kxs: chain(key, itm)
) : void // end of [chainarr_insert_chain]

(* ****** ****** *)

implement
{key,itm}
chainarr_insert_any
  (A, m, k, x) = let
//
val h = hash_key<key> (k)
val h = g0uint2uint_ulint_size(h)
val i = g1uint_mod (g1ofg0(h), m)
//
val (
  pf0 | p0
) = arrayptr_takeout_viewptr (A)
val (
  pf, fpf | pi
) = array_ptr_takeout (pf0 | p0, i)
val (pf | pi) = viewptr_match (pf | pi)
val () = chain_insert_any<key,itm> (!pi, k, x)
prval () = pf0 := fpf (pf)
prval () = arrayptr_addback (pf0 | A)
//
in
  // nothing
end // end of [chainarr_insert_any]

(* ****** ****** *)

implement
{key,itm}
chainarr_insert_chain
  {m}(A, m, kxs) = let
//
vtypedef
chain = chain(key, itm)
//
fun loop
(
  A: !arrayptr (chain, m), m: size_t m, kxs: List_vt @(key, itm)
) : void = let
in
//
case+ kxs of
| ~list_vt_cons
    ((k, x), kxs) => let
    val () = chainarr_insert_any<key,itm> (A, m, k, x) in loop (A, m, kxs)
  end // end of [list_vt_cons]
| ~list_vt_nil ((*void*)) => ()
//
end // end of [loop]
//
val kxs =
  chain_listize<key,itm> (kxs)
val kxs = list_vt_reverse (kxs)
//
in
  loop (A, m, kxs)
end // end of [chainarr_insert_chain]

(* ****** ****** *)

datavtype hashtbl
(
  key:t@ype, itm:vt@ype+
) =
  {m:int | m >= 1}
  HASHTBL of (
    arrayptr (chain(key, itm), m), size_t m, size_t
  ) (* end of [HASHTBL] *)
// end of [hashtbl]

(* ****** ****** *)

assume
hashtbl_vtype (key:t0p, itm:vt0p) = hashtbl (key, itm)

(* ****** ****** *)

implement
{key,itm}
hashtbl_make_nil
  (cap) = let
//
vtypedef
chain = chain(key, itm)
//
prval [m:int]
  EQINT () = eqint_make_guint (cap)
//
val p0 =
$UN.castvwtp0{ptr}(chain_nil{key,itm}())
val A0 = arrayptr_make_elt<ptr> (cap, p0)
val A0 = $UN.castvwtp0{arrayptr(chain, m)}(A0)
//
in
  HASHTBL(A0, cap, i2sz(0))
end // end of [hashtbl_make_nil]

(* ****** ****** *)

implement{
} hashtbl_get_size
  (tbl) = let
//
val+HASHTBL(A, cap, n) = tbl in (n)
//
end // end of [hashtbl_get_size]

(* ****** ****** *)

implement{
} hashtbl_get_capacity
  (tbl) = let
//
val+HASHTBL(A, cap, n) = tbl in (cap)
//
end // end of [hashtbl_get_capacity]

(* ****** ****** *)

implement
{key,itm}
hashtbl_search_ref
  (tbl, k) = let
//
val+HASHTBL(A, cap, n) = tbl
//
val h = hash_key<key> (k)
val h = g0uint2uint_ulint_size(h)
val i = g1uint_mod (g1ofg0(h), cap)
//
val (
  pf0 | p0
) = arrayptr_takeout_viewptr (A)
val (
  pf, fpf | pi
) = array_ptr_takeout (pf0 | p0, i)
val (pf | pi) = viewptr_match (pf | pi)
val cptr = chain_search_ref<key,itm> (!pi, k)
prval () = pf0 := fpf (pf)
prval () = arrayptr_addback (pf0 | A)
//
in
  cptr
end // end of [hashtbl_search_ref]

(* ****** ****** *)

implement
{key,itm}
hashtbl_insert
  (tbl, k, x, res) = let
//
val+@HASHTBL(A, cap, n) = tbl
//
val h = hash_key<key> (k)
val h = g0uint2uint_ulint_size(h)
val i = g1uint_mod (g1ofg0(h), cap)
//
val (
  pf0 | p0
) = arrayptr_takeout_viewptr (A)
val (
  pf, fpf | pi
) = array_ptr_takeout (pf0 | p0, i)
val (pf | pi) = viewptr_match (pf | pi)
val ans = chain_insert<key,itm> (!pi, k, x, res)
prval () = pf0 := fpf (pf)
prval () = arrayptr_addback (pf0 | A)
//
val () = if not(ans) then n := succ(n) // inserted
//
prval () = fold@ (tbl)
//
val () =
if not(ans) then (
if hashtbl$recapacitize() > 0
  then ignoret(hashtbl_adjust_capacity<key,itm> (tbl))
) (* end of [if] *)
//
in
  ans
end // end of [hashtbl_insert]

(* ****** ****** *)

implement
{key,itm}
hashtbl_insert_any
  (tbl, k, x) = let
//
val+@HASHTBL(A, cap, n) = tbl
//
val h = hash_key<key> (k)
val h = g0uint2uint_ulint_size(h)
val i = g1uint_mod (g1ofg0(h), cap)
//
val (
  pf0 | p0
) = arrayptr_takeout_viewptr (A)
val (
  pf, fpf | pi
) = array_ptr_takeout (pf0 | p0, i)
val (pf | pi) = viewptr_match (pf | pi)
val () = chain_insert_any<key,itm> (!pi, k, x)
prval () = pf0 := fpf (pf)
prval () = arrayptr_addback (pf0 | A)
//
val () = n := succ(n) // insertion is always done
//
prval () = fold@ (tbl)
//
val () =
if hashtbl$recapacitize() > 0
  then ignoret(hashtbl_adjust_capacity<key,itm> (tbl))
//
in
  // nothing
end // end of [hashtbl_insert_any]

(* ****** ****** *)

implement
{key,itm}
hashtbl_takeout
  (tbl, k, res) = let
//
val+@HASHTBL(A, cap, n) = tbl
//
val h = hash_key<key> (k)
val h = g0uint2uint_ulint_size(h)
val i = g1uint_mod (g1ofg0(h), cap)
//
val (
  pf0 | p0
) = arrayptr_takeout_viewptr (A)
val (
  pf, fpf | pi
) = array_ptr_takeout (pf0 | p0, i)
val (pf | pi) = viewptr_match (pf | pi)
val ans = chain_takeout<key,itm> (!pi, k, res)
prval () = pf0 := fpf (pf)
prval () = arrayptr_addback (pf0 | A)
//
val () = if ans then n := pred(n) // removed
//
prval () = fold@ (tbl)
//
in
  ans
end // end of [hashtbl_takeout]

(* ****** ****** *)

implement
{key,itm}
hashtbl_takeout_all
  (tbl) = let
//
vtypedef
chain = chain(key, itm)
//
typedef tenv = ptr
//
vtypedef ki = @(key, itm)
vtypedef tenv2 = List0_vt (ki)
//
val+@HASHTBL(A, cap, n) = tbl
//
local
implement
{a}{env}
array_rforeach$cont(x, env) = true
implement
(a:viewtype)
array_rforeach$fwork<a><tenv>
  (kxs, env) = let
  val kxs2 = $UN.castvwtp0{chain}(kxs)
  val () = kxs := $UN.castvwtp0{a}(chain_nil())
  val kxs2 = chain_listize<key,itm> (kxs2)
  val kxs2 = list_vt_append (kxs2, $UN.castvwtp0{tenv2}(env))
  val () = env := $UN.castvwtp0{ptr}(kxs2)
in
  // nothing
end // end of [array_rforeach$fwork]
in (* in of [local] *)
var env: ptr
val () = env := $UN.castvwtp0{ptr}(list_vt_nil)
val _(*cap*) = $effmask_all
  (arrayptr_rforeach_env<chain><tenv> (A, cap, env))
end // end of [local]
//
val () = n := i2sz(0)
//
prval () = fold@ (tbl)
//
in
  $UN.castvwtp0{tenv2}(env)
end // end of [hashtbl_takeout_all]

(* ****** ****** *)

implement
{key,itm}
hashtbl_reset_capacity
  (tbl, cap2) = let
//
vtypedef
chain = chain(key, itm)
//
val+@HASHTBL(A0, cap0, n) = tbl
//
prval [m2:int]
  EQINT () = eqint_make_guint (cap2)
//
val p0 =
$UN.castvwtp0{ptr}(chain_nil{key,itm}())
val A2 = arrayptr_make_elt<ptr> (cap2, p0)
val A2 = $UN.castvwtp0{arrayptr(chain, m2)}(A2)
//
fun loop
(
  p: ptr, m: size_t
, A2: !arrayptr (chain, m2)
) : void = let
in
//
if m > 0 then let
//
val kxs = $UN.ptr0_get<chain> (p)
val () = chainarr_insert_chain<key,itm> (A2, cap2, kxs)
//
in
  loop (ptr0_succ<chain> (p), pred(m), A2)
end // end of [if]
//
end // end of [loop]
//
val A = A0
val cap = cap0
val () = loop (ptrcast(A), cap, A2)
val () = arrayptr_free ($UN.castvwtp0{arrayptr(ptr,0)}(A))
//
val () = A0 := A2
val () = cap0 := cap2
//
prval () = fold@ (tbl)
//
in
  true(*always*)
end // end of [hashtbl_reset_capacity]

(* ****** ****** *)
//
// HX: please reimplement it if needed
//
implement
{key,itm}
hashtbl_adjust_capacity
  (tbl) = let
//
val+HASHTBL(A, cap, n) = tbl
//
in
//
if i2sz(5) * cap <= n
  then hashtbl_reset_capacity (tbl, cap + cap) else false
//
end // end of [hashtbl_adjust_capacity]

(* ****** ****** *)

implement
{key,itm}{env}
hashtbl_foreach_env
  (tbl, env) = let
//
vtypedef
chain = chain(key, itm)
//
val+HASHTBL(A, cap, _) = tbl
//
local
implement
{a}{env}
array_foreach$cont(kxs, env) = true
implement
array_foreach$fwork<chain><env>
  (kxs, env) =
  chain_foreach_env<key,itm><env> (kxs, env)
in(* in of [local]*)
val _(*asz*) = arrayptr_foreach_env<chain><env> (A, cap, env)
end // end of [local]
//
in
  // nothing
end // end of [hashtbl_foreach_env]

(* ****** ****** *)

implement
{key,itm}
hashtbl_listize
  (tbl) = let
//
vtypedef
chain = chain(key, itm)
//
val+~HASHTBL(A, cap, _) = tbl
//
typedef tenv = ptr
//
vtypedef ki = @(key, itm)
vtypedef tenv2 = List0_vt (ki)
//
local
implement
{a}{env}
array_rforeach$cont(x, env) = true
implement
array_rforeach$fwork<chain><tenv>
  (kxs, env) = let
  val kxs = $UN.castvwtp1{chain}(kxs)
  val kxs2 = chain_listize<key,itm> (kxs)
  val kxs2 = list_vt_append (kxs2, $UN.castvwtp0{tenv2}(env))
  val () = env := $UN.castvwtp0{ptr}(kxs2)
in
  // nothing
end // end of [array_rforeach$fwork]
in(* in of [local] *)
var env: ptr
val () = env := $UN.castvwtp0{ptr}(list_vt_nil)
val _(*cap*) = $effmask_all
  (arrayptr_rforeach_env<chain><tenv> (A, cap, env))
end // end of [local]
//
val () = arrayptr_free ($UN.castvwtp0{arrayptr(ptr,0)}(A))
//
in
  $UN.castvwtp0{tenv2}(env)
end // end of [hashtbl_listize]

(* ****** ****** *)

implement
{key,itm}{ki2}
hashtbl_flistize
  (tbl) = let
//
vtypedef
chain = chain(key, itm)
//
val+~HASHTBL(A, cap, n) = tbl
//
typedef tenv = ptr
//
vtypedef tenv2 = List0_vt (ki2)
//
local
//
implement
{a}{env}
array_rforeach$cont(x, env) = true
implement
array_rforeach$fwork<chain><tenv>
  (kxs, env) = let
  val kxs = $UN.castvwtp1{chain}(kxs)
  val kxs2 =
    chain_flistize<key,itm><ki2> (kxs)
  val kxs2 =
    list_vt_append (kxs2, $UN.castvwtp0{tenv2}(env))
  val ((*void*)) = env := $UN.castvwtp0{ptr}(kxs2)
in
  // nothing
end // end of [array_rforeach$fwork]
//
in(* in of [local] *)
//
var env: ptr
//
val () = (env := $UN.castvwtp0{ptr}(list_vt_nil))
//
val _(*cap*) =
$effmask_all
  (arrayptr_rforeach_env<chain><tenv> (A, cap, env))
//
end // end of [local]
//
val () = arrayptr_free ($UN.castvwtp0{arrayptr(ptr,0)}(A))
//
in
  $UN.castvwtp0{tenv2}(env)
end // end of [hashtbl_flistize]

(* ****** ****** *)

(* end of [hashtbl_chain.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hanwen Wu *)
(* Authoremail: hwwu AT cs DOT bu DOT edu *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: November, 2011 *)

(* ****** ****** *)

#define ATS_DYNLOADFLAG 0 // no static loading at run-time

(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libats/SATS/gnode.sats"
staload "libats/SATS/linheap_fibonacci.sats"

(* ****** ****** *)

#define nullp the_null_ptr

(* ****** ****** *)
//
postfix (~) SZ
//
macdef SZ (i) = g1int2uint<int_kind,size_kind> (,(i))
//
(* ****** ****** *)

stadef
mytkind = $extkind"atslib_linheap_fibonacci"

(* ****** ****** *)

typedef
g2node (a:vt0p, l:addr) = gnode (mytkind, a, l)
typedef g2node0 (a:vt0p) = gnode0 (mytkind, a)
typedef g2node1 (a:vt0p) = gnode1 (mytkind, a)

(* ****** ****** *)

extern
fun{a:vt0p}
g2node_make_elt (x: a):<!wrt> g2node1 (a)
extern
fun{a:vt0p}
g2node_free_elt
  (nx: g2node1 (INV(a)), res: &a? >> a):<!wrt> void
// end of [g2node_free_elt]

extern
fun{a:vt0p}
g2node_get_rank (nx: g2node1 (INV(a))):<> int
extern
fun{a:vt0p}
g2node_set_rank (nx: g2node1 (INV(a)), d: int):<!wrt> void

extern
fun{a:vt0p}
g2node_get_parent (nx: g2node1 (INV(a))):<> g2node0 (a)
extern
fun{a:vt0p}
g2node_set_parent (nx: g2node1 (INV(a)), par: g2node0 (a)):<!wrt> void

extern
fun{a:vt0p}
g2node_get_children (nx: g2node1 (INV(a))):<> g2node0 (a)
extern
fun{a:vt0p}
g2node_set_children (nx: g2node1 (INV(a)), par: g2node0 (a)):<!wrt> void

extern
fun{a:vt0p}
g2node_get_marked (nx: g2node1 (INV(a))):<> bool
extern
fun{a:vt0p}
g2node_set_marked (nx: g2node1 (INV(a)), mark: bool):<!wrt> void

(* ****** ****** *)

datavtype
fibheap_vt (a:vt@ype+) =
  | FIBHEAP (a) of (g2node0 (a), size_t(*size*))
// end of [fibheap]

(* ****** ****** *)

assume heap_vtype (a:vt0p) = fibheap_vt (a)

(* ****** ****** *)

implement{}
linheap_is_nil (hp) = let
in
case+ hp of
| FIBHEAP (nx, _) => gnode_is_null (nx)
//
end // end of [linheap_is_nil]

implement{}
linheap_isnot_nil (hp) = let
in
case+ hp of
| FIBHEAP (nx, _) => gnode_isnot_null (nx)
//
end // end of [linheap_isnot_nil]

(* ****** ****** *)

implement{a}
linheap_size (hp) =
  case+ hp of FIBHEAP (_, N) => N
// end of [linheap_size]

(* ****** ****** *)
//
// HX: implementing mergeable-heap operations
//
(* ****** ****** *)

extern
fun{a:vt0p}
compare_elt_g2node
  (x1: &a, nx2: g2node0 (a)):<> int
implement{a}
compare_elt_g2node
  (x1, nx2) = let
in
//
if gnode2ptr(nx2) > 0 then let
  val p_x2 = gnode_getref_elt (nx2)
  prval (pf, fpf | p_x2) = $UN.cptr_vtake {a} (p_x2)
  val sgn = compare_elt_elt (x1, !p_x2)
  prval () = fpf (pf)
in
  sgn
end else ~1 // end of [if]
//
end // end of [compare_elt_g2node]

extern
fun{a:vt0p}
compare_g2node_g2node
  (nx1: g2node0 (a), nx2: g2node0 (a)):<> int
// end of [compare_g2node_g2node]

(* ****** ****** *)

implement{a}
linheap_insert
  (hp, x0) = let
//
val @FIBHEAP (nx0, N) = hp
//
var x0: a = x0
val sgn = compare_elt_g2node<a> (x0, nx0)
//
val nx2 = g2node_make_elt<a> (x0)
val () =
  if gnode2ptr (nx0) > 0 then
    gnode_insert_next (nx0, nx2) else gnode_link11 (nx2, nx2)
  // end of [if]
//
val () = if :(nx0: g2node0 (a)) => sgn < 0 then nx0 := nx2
val () = N := succ (N)
//
prval () = fold@ (hp)
//
in
  // nothing
end // end of [linheap_insert]

(* ****** ****** *)

implement{a}
linheap_getmin_ref (hp) = let
//
val FIBHEAP (nx, _) = hp in $UN.ptr2cptr{a}(gnode2ptr(nx))
//
end // end of [linheap_getmin_ref]

(* ****** ****** *)

extern
fun{a:vt0p}
g2node_insert_next_circlst
  (nx1: g2node1 (a), nxs2: g2node0 (a)): void
// end of [g2node_insert_prev_circlst]

extern
fun{a:vt0p}
g2node_insert_prev_circlst
  (nx1: g2node1 (a), nxs2: g2node0 (a)): void
// end of [g2node_insert_prev_circlst]

(* ****** ****** *)

implement{a}
linheap_merge
  (hp1, hp2) = hp1 where {
//
val @FIBHEAP (nx1, N1) = hp1
val ~FIBHEAP (nx2, N2) = hp2
//
val sgn = compare_g2node_g2node<a> (nx1, nx2)
val () =
  if gnode2ptr (nx1) > 0 then
    g2node_insert_next_circlst (nx1, nx2) else ()
  // end of [if]
//
val () = if :(nx1: g2node0 (a)) => (sgn > 0) then nx1 := nx2
val () = N1 := N1 + N2
//
prval () = fold@ (hp1)
//
} // end of [linheap_merge]

(* ****** ****** *)

extern
fun{a:vt0p}
g2nodelst_set_parent_null (nxs: g2node0 (a)): void

(* ****** ****** *)

extern
fun{a:vt0p}
g2nodelst_consolidate (nxs: g2node0 (a)): g2node0 (a)

(* ****** ****** *)

extern
fun{a:vt0p}
join_g2node_g2node
  (nx1: g2node1 (a), nx2: g2node1 (a)):<!wrt> void
implement{a}
join_g2node_g2node
  (nx1, nx2) = let
  val r = g2node_get_rank (nx1)
(*
  val () = assertloc_debug (r = g2node_get_rank (nx2))
*)
  val () = g2node_set_rank (nx1, r+1)
  val () = g2node_set_parent (nx2, nx1)
  val () = g2node_set_marked (nx2, false)
  val () = gnode_link10 (nx2, g2node_get_children (nx1))
  val () = g2node_set_children (nx1, nx2)
in
  // nothing
end // end of [join_g2node_g2node]

extern
fun{a:vt0p}
merge_g2node_g2node
  (nx1: g2node1 (a), nx2: g2node1 (a)):<!wrt> g2node1 (a)
implement{a}
merge_g2node_g2node
  (nx1, nx2) = let
//
val sgn = compare_g2node_g2node (nx1, nx2)
//
in
  if sgn < 0 then let
    val () = gnode_link11 (nx1, nx2) in nx1
  end else let
    val () = gnode_link11 (nx2, nx1) in nx2
  end // end of [if]
end // end of [merge_g2node_g2node]

(* ****** ****** *)

local

extern
fun{a:vt0p}
rank2g2node_takeout (r: int): g2node0 (a)

extern
fun{a:vt0p}
rank2g2node_putinto (r: int, nx: g2node0 (a)): void

in // in of [local]

implement{a}
g2nodelst_consolidate (nxs) = let
//
fun aux (
  nx: g2node1 (a), r: int
) : int = let
  val nx2 = rank2g2node_takeout (r)
in
  if gnode2ptr (nx2) > 0 then let
    val nx = merge_g2node_g2node (nx, nx2)
  in
    aux (nx, r+1)
  end else let
    val () = rank2g2node_putinto (r, nx) in r
  end // end of [if]
end // end of [aux]
//
fun auxlst (
  nxs: g2node0 (a), r0: int
) : int = let
  val iscons = gnodelst_is_cons (nxs)
in
//
if iscons then let
  val nx = nxs
  val nxs =
    gnode_get_next (nxs)
  // end of [val]
  val r = g2node_get_rank (nx)
  val r = aux (nx, r)
  val r0 = (if r > r0 then r else r0): int
in
  auxlst (nxs, r0)
end else r0 // end of [if]
//
end // end of [auxlst]
//
fun auxlink (r0: int): g2node1 (a) = let
//
fun loop (
  r0: int, r: int
) : g2node1 (a) = let
  val nx = rank2g2node_takeout (r)
  val isnot = gnode_isnot_null (nx)
in
  if isnot 
    then loop2 (r0, r+1, nx, nx, nx) else loop (r0, r+1)
  // end of [if]
end // end of [loop]

and loop2 (
  r0: int, r: int
, nx1: g2node1 (a), nx2: g2node1 (a), nx_min: g2node1 (a)
) : g2node1 (a) = let
in
  if r > r0 then let
    val () = gnode_link11 (nx2, nx1)
  in
    nx_min
  end else let
    val nx21 = rank2g2node_takeout (r)
    val isnot = gnode_isnot_null (nx21)
  in
    if isnot then let
      val sgn =
        compare_g2node_g2node (nx21, nx_min)
      // end of [val]
      val nx_min =
        (if sgn < 0 then nx21 else nx_min): g2node1 (a)
      // end of [val]
    in
      loop2 (r0, r, nx1, nx21, nx_min)
    end else
      loop2 (r0, r, nx1, nx2, nx_min)
    // end of [if]
  end // end of [if]
end // end of [loop2]
//
in
  loop (r0, 0)
end // end of [auxlink]
//
val iscons = gnodelst_is_cons (nxs)
//
in
//
if iscons then let
  val nx = nxs
  val nx_prev = gnode_get_prev (nx)
  val nx_prev = $UN.cast{g2node1(a)}(nx_prev)
  val () = gnode_set_next_null (nx_prev)
  val r0 = auxlst (nxs, 0)
in
  auxlink (r0)
end else
  gnode_null ()
// end of [if]
//
end // end of [g2nodelst_consolidate]

end // end of [local]

(* ****** ****** *)

implement{a}
linheap_delmin
  (hp0, res) = let
//
val @FIBHEAP (nx0_ref, N) = hp0
//
in
//
if N > 0SZ then let
  val nx0 = nx0_ref
  val nx0 = $UN.cast{g2node1(a)}(nx0)
  val nxs2 = g2node_get_children (nx0)
  val () = g2nodelst_set_parent_null (nxs2)
//
  val () = g2node_insert_next_circlst (nx0, nxs2)
//
  val nx1 = gnode_get_next (nx0)
  val () = g2node_free_elt (nx0, res)
  val nx1 = g2nodelst_consolidate (nx1)
//
  val () = N := pred (N)
  val () = nx0_ref := nx1
//
  prval () = opt_some {a} (res)
  prval () = fold@ (hp0)
//
in
  true (*removed*)
end else let
  prval () = opt_none {a} (res)
  prval () = fold@ (hp0)
in
  false (*~removed*)
end // end of [if]
//
end // end of [linheap_delmin]

(* ****** ****** *)

(* linheap_fibonacci.dats *)
(***********************************************************************)
(*                                                                     *)
(*                       ATS/contrib/libats-hwxi                       *)
(*                                                                     *)
(***********************************************************************)

(*
** Copyright (C) 2014 Hongwei Xi, ATS Trustful Software, Inc.
**
** Permission is hereby granted, free of charge, to any person obtaining a
** copy of this software and associated documentation files (the "Software"),
** to deal in the Software without restriction, including without limitation
** the rights to use, copy, modify, merge, publish, distribute, sublicense,
** and/or sell copies of the Software, and to permit persons to whom the
** Software is furnished to do so, subject to the following stated conditions:
** 
** The above copyright notice and this permission notice shall be included in
** all copies or substantial portions of the Software.
** 
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
** OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
** FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
** THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
** LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
** FROM OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
** IN THE SOFTWARE.
*)

(* ****** ****** *)
//
// An abstract thread interface
//
(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libats/SATS/athread.sats"

(* ****** ****** *)

implement
{}(*tmp*)
spin_create_exn () = let
//
val spn = spin_create ()
val p_spn = spin2ptr (spn)
val () =
if p_spn = the_null_ptr then
{
//
val () =
fprintln! (
  stderr_ref, "libats/athread: [spin_create]: failed."
) (* end of [val] *)
val ((*void*)) = assertloc (false)
//
}
//
in
  $UN.cast{spin1}(spn)
end // end of [spin_create_exn]

(* ****** ****** *)

implement
{}(*tmp*)
mutex_create_exn () = let
//
val mtx = mutex_create ()
val p_mtx = mutex2ptr (mtx)
val () =
if p_mtx = the_null_ptr then
{
//
val () =
fprintln!
(
  stderr_ref, "libats/athread: [mutex_create]: failed."
) (* end of [val] *)
val ((*void*)) = assertloc (false)
//
} (* end of [if] *) // end of [val]
//
in
  $UN.cast{mutex1}(mtx)
end // end of [mutex_create_exn]

(* ****** ****** *)

implement
{}(*tmp*)
condvar_create_exn () = let
//
val cvr = condvar_create ()
//
val p_cvr = condvar2ptr (cvr)
val () =
if p_cvr = the_null_ptr then
{
//
val () =
fprintln! (
  stderr_ref, "libats/athread: [condvar_create]: failed."
) (* end of [val] *)
val ((*void*)) = assertloc (false)
//
}
//
in
  $UN.cast{condvar1}(cvr)
end // end of [condvar_create_exn]

(* ****** ****** *)

implement
{}(*tmp*)
athread_create_cloptr
  (tid, fwork) = err where
{
//
fun app
(
  f: () -<lincloptr1> void
): void = let
  val () = f () in cloptr_free($UN.castvwtp0{cloptr0}(f))
end // end of [app]
//
val f = $UN.castvwtp1{ptr}(fwork)
val err = athread_create_funenv (tid, app, fwork)
val () = if (err != 0) then cloptr_free($UN.castvwtp0{cloptr0}(f))
//
} (* end of [athread_create_cloptr] *)

(* ****** ****** *)

implement
{}(*tmp*)
athread_create_cloptr_exn
  (fwork) = tid where
{
//
var tid: lint
val err =
athread_create_cloptr (tid, fwork)
//
val () =
if (err != 0) then
{
//
val () =
fprintln! (
  stderr_ref, "libats/athread: [athread_create_cloptr_exn]: failed."
) (* end of [val] *)
//
} (* end of [if] *)
//
} (* end of [athread_create_cloptr_exn] *)

(* ****** ****** *)

(* end of [athread.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2013 *)

(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libats/SATS/gnode.sats"

(* ****** ****** *)

staload "libats/SATS/sllist.sats"

(* ****** ****** *)

#define nullp the_null_ptr

(* ****** ****** *)
//
extern
fun{a:vt0p}
g2node_make_elt (x: a):<!wrt> g2node1 (a)
//
extern
fun{a:t0p} // [a] is nonlinear
g2node_free (nx: g2node1 (INV(a))):<!wrt> void
extern
fun{a:vt0p}
g2node_free_elt
  (nx: g2node1 (INV(a)), res: &(a?) >> a):<!wrt> void
//
extern
fun{a:vt0p}
g2node_getfree_elt (nx: g2node1 (INV(a))):<!wrt> (a)
//
(* ****** ****** *)
//
extern
castfn
sllist0_encode
  : {a:vt0p}{n:int} (g2node0 (INV(a))) -<> sllist (a, n)
extern
castfn
sllist0_decode
  : {a:vt0p}{n:int} (sllist (INV(a), n)) -<> g2node0 (a)
//
extern
castfn
sllist1_encode
  : {a:vt0p}{n:int | n > 0} (g2node1 (INV(a))) -<> sllist (a, n)
extern
castfn
sllist1_decode
  : {a:vt0p}{n:int | n > 0} (sllist (INV(a), n)) -<> g2node1 (a)
//
(* ****** ****** *)

implement
{}(*tmp*)
sllist_nil () = sllist0_encode (gnode_null ())

implement
{a}(*tmp*)
sllist_sing (x) = sllist_cons<a> (x, sllist_nil ())

(* ****** ****** *)

implement
{a}(*tmp*)
sllist_cons
  (x, xs) = let
//
val nx = g2node_make_elt<a> (x) in sllist_cons_ngc (nx, xs)
//
end // end of [sllist_cons]

implement{a}
sllist_uncons
  (xs) = let
//
val nx0 = sllist_uncons_ngc (xs) in g2node_getfree_elt<a> (nx0)
//
end // end of [sllist_uncons]

(* ****** ****** *)

implement
{a}(*tmp*)
sllist_snoc
  (xs, x) = let
//
val nx = g2node_make_elt<a> (x) in sllist_snoc_ngc (xs, nx)
//
end // end of [sllist_snoc]

implement{a}
sllist_unsnoc
  (xs) = let
//
val nx0 = sllist_unsnoc_ngc (xs) in g2node_getfree_elt<a> (nx0)
//
end // end of [sllist_unsnoc]

(* ****** ****** *)

implement
{a}(*tmp*)
sllist_make_list
  {n}(xs) = let
//
fun loop (
  nx0: g2node1 (a), xs: List (a)
) : void = let
in
//
case+ xs of
| list_cons
    (x, xs) => let
    val nx1 = g2node_make_elt<a> (x)
    val () = gnode_link11 (nx0, nx1)
  in
    loop (nx1, xs)
  end // end of [loop]
| list_nil () => let
    val () = gnode_set_next_null (nx0)
  in
    // nothing
  end // end of [list_nil]
//
end // end of [loop]
//
in
//
case+ xs of
| list_cons
    (x, xs) => let
    val nx0 = g2node_make_elt<a> (x)
    val () = $effmask_all (loop (nx0, xs))
  in
    sllist0_encode (nx0)
  end // end of [list_cons]
| list_nil () => sllist_nil ()
//
end // end of [sllist_make_list]

(* ****** ****** *)
//
implement
{a}(*tmp*)
sllist_make_list_vt
  {n}(xs) = $UN.castvwtp0{sllist(a,n)}(xs)
//
(* ****** ****** *)

implement
{}(*tmp*)
sllist_is_nil
  {a}{n} (xs) = let
  val nxs = $UN.castvwtp1{g2node0(a)}(xs)
in
  $UN.cast{bool(n==0)}(gnodelst_is_nil (nxs))
end // end of [sllist_is_nil]

implement
{}(*tmp*)
sllist_is_cons
  {a}{n} (xs) = let
  val nxs = $UN.castvwtp1{g2node0(a)}(xs)
in
  $UN.cast{bool(n > 0)}(gnodelst_is_cons (nxs))
end // end of [sllist_is_cons]

(* ****** ****** *)

(*
fun{a:vt0p}
sllist_length
  {n:int} (xs: !sllist (INV(a), n)):<> int (n)
*)
implement
{a}(*tmp*)
sllist_length
  {n} (xs) = let
//
val nxs = $UN.castvwtp1{g2node0(a)}(xs)
//
in
  $UN.cast{int(n)}(gnodelst_length (nxs))
end // end of [sllist_length]

(* ****** ****** *)

implement
{a}(*tmp*)
sllist_get_elt
  (xs) = let
  val p_elt =
    sllist_getref_elt (xs) in $UN.cptr_get<a> (p_elt)
  // end of [val]
end // end of [sllist_get_elt]

implement
{a}(*tmp*)
sllist_set_elt
  (xs, x0) = let
  val p_elt = 
    sllist_getref_elt (xs) in $UN.cptr_set<a> (p_elt, x0)
  // end of [val]
end // end of [sllist_set_elt]

implement
{a}(*tmp*)
sllist_getref_elt (xs) = let
  val nxs =
    $UN.castvwtp1{g2node1(a)}(xs) in gnode_getref_elt (nxs)
  // end of [val]
end // end of [sllist_getref_elt]

(* ****** ****** *)

implement
{a}(*tmp*)
sllist_getref_next (xs) = let
  val nxs =
    $UN.castvwtp1{g2node1(a)}(xs) in cptr2ptr (gnode_getref_next (nxs))
  // end of [val]  
end // end of [sllist_getref_next]

(* ****** ****** *)

implement
{a}(*tmp*)
sllist_get_elt_at
  (xs, i) = let
  val p_elt =
    sllist_getref_elt_at (xs, i) in $UN.cptr_get<a> (p_elt)
  // end of [val]
end // end of [sllist_get_elt_at]

implement
{a}(*tmp*)
sllist_set_elt_at
  (xs, i, x0) = let
  val p_elt = 
    sllist_getref_elt_at (xs, i) in $UN.cptr_set<a> (p_elt, x0)
  // end of [val]
end // end of [sllist_set_elt_at]

implement
{a}(*tmp*)
sllist_getref_elt_at
  (xs, i) = let
//
fun loop
(
  nxs: g2node1 (a), i: int
) : g2node1 (a) =
  if i > 0 then let
    val nxs = gnode_get_next (nxs)
  in
    loop ($UN.cast{g2node1(a)}(nxs), i-1)
  end else nxs // end of [if]
//
val nxs0 = $UN.castvwtp1{g2node1(a)}(xs)
val nxs_i = $effmask_all (loop (nxs0, i))
//
in
  gnode_getref_elt (nxs_i) 
end // end of [sllist_getref_elt_at]

(* ****** ****** *)

implement
{a}(*tmp*)
sllist_getref_at (xs, i) = let
//
fun loop (
  p: Ptr1, i: int
) : Ptr1 = let
in
  if i > 0 then let
    val nx =
      $UN.ptr1_get<g2node1(a)> (p)
    // end of [val]
    val p2 = gnode_getref_next (nx)
  in
    loop (cptr2ptr (p2), i-1)
  end else (p) // end of [if]
end // end of [loop]
//
val p0 = $UN.cast{Ptr1}(addr@(xs))
//
in
  $effmask_all (loop (p0, i))
end // end of [sllist_getref_at]

(* ****** ****** *)

implement
{a}(*tmp*)
sllist_insert_at
  {n} (xs, i, x0) = let
  var xs = xs
  val p_i = sllist_getref_at (xs, i)
  val nx0 = g2node_make_elt<a> (x0)
  val nxs = $UN.ptr1_get<g2node0(a)> (p_i)
  val () = gnode_link10 (nx0, nxs)
  val () = $UN.ptr1_set<g2node1(a)> (p_i, nx0)
in
  $UN.castvwtp0{sllist(a, n+1)}(xs)
end // end of [sllist_insert_at]

(* ****** ****** *)

implement
{a}(*tmp*)
sllist_takeout_at
  {n} (xs, i) = let
  val p_i = sllist_getref_at (xs, i)
  val nxs = $UN.ptr1_get<g2node1(a)> (p_i)
  val nx0 = nxs
  val nxs = gnode_get_next (nx0)
  val () = $UN.ptr1_set<g2node0(a)> (p_i, nxs)
  prval (
  ) = __assert (xs) where {
    extern praxi __assert (xs: &sllist (a, n) >> sllist (a, n-1)): void
  } // end of [where] // end of [prval]
in
  g2node_getfree_elt (nx0)
end // end of [sllist_takeout_at]

(* ****** ****** *)

implement
{a}(*tmp*)
sllist_append
  {n1,n2} (xs1, xs2) = let
//
prval () = lemma_sllist_param (xs1)
prval () = lemma_sllist_param (xs2)
//
val iscons1 = sllist_is_cons (xs1)
//
in
//
if iscons1 then let
  val iscons2 = sllist_is_cons (xs2)
in
//
if iscons2 then let
  val nxs1 = sllist1_decode (xs1)
  val nxs2 = sllist0_decode (xs2)
  val nxs1_end = gnodelst_next_all (nxs1)
  val _void_ = gnode_link10 (nxs1_end, nxs2)
in
  sllist0_encode (nxs1)
end else let
  prval () = sllist_free_nil (xs2) in xs1
end // end of [if]
//
end else let
  prval () = sllist_free_nil (xs1) in xs2
end // end of [if]
//
end // end of [sllist_append]

(* ****** ****** *)

implement
{a}(*tmp*)
sllist_reverse (xs) = let
in
  sllist_reverse_append (xs, sllist_nil ())
end // end of [sllist_reverse]

(* ****** ****** *)

implement
{a}(*tmp*)
sllist_reverse_append
  (xs1, xs2) = let
//
fun loop
(
  nxs: g2node0 (a), res: g2node1 (a)
) : g2node1 (a) = let
  val iscons = gnodelst_is_cons (nxs)
in
//
if iscons then let
  val nx0 = nxs
  val nxs = gnode_get_next (nx0)
  val () = gnode_link11 (nx0, res)
in
  loop (nxs, nx0)
end else res // end of [if]
//
end // end of [loop]
//
prval (
) = lemma_sllist_param (xs1)
//
val iscons = sllist_is_cons (xs1)
//
in
//
if iscons then let
  val nxs1 = sllist1_decode (xs1)
  val nx0 = nxs1
  val nxs1 = gnode_get_next (nx0)
  val () = gnode_link10 (nx0, sllist0_decode (xs2))
in
  sllist0_encode ($effmask_all (loop (nxs1, nx0)))
end else let
  prval () = sllist_free_nil (xs1)
in
  xs2
end // end of [if]
//
end // end of [sllist_reverse_append]

(* ****** ****** *)

implement
{a}(*tmp*)
sllist_free (xs) = let
//
fun loop (
  nxs: g2node0 (a)
) : void = let
//
val iscons = gnodelst_is_cons (nxs)
//
in
//
if iscons then let
  val nxs2 =
    gnode_get_next (nxs)
  // end of [val]
  val () = g2node_free (nxs)
in
  loop (nxs2)
end else () // end of [if]
//
end // end of [loop]
//
val nxs = sllist0_decode (xs)
//
in
  $effmask_all (loop (nxs))
end // end of [sllist_free]

(* ****** ****** *)

implement
{a}{b}
sllist_map{n} (xs) = let
//
fun loop
(
  nxs: g2node0 (a), p_res: ptr
) : void = let
//
val iscons = gnodelst_is_cons (nxs)
//
in
//
if iscons then let
  val nx = nxs
  val nxs = gnode_get_next (nx)
  val p_x = gnode_getref_elt (nx)
  val (pf, fpf | p_x) = $UN.cptr_vtake{a}(p_x)
  val y = sllist_map$fopr<a><b> (!p_x)
  prval () = fpf (pf)
  val ny = g2node_make_elt<b> (y)
  val () = $UN.ptr0_set<g2node1(b)> (p_res, ny)
  val p_res = gnode_getref_next (ny)
in
  loop (nxs, cptr2ptr(p_res))
end else () // end of [if]
//
end (* end of [loop] *)
//
var res: ptr
val () = loop ($UN.castvwtp1{g2node0(a)}(xs), addr@(res))
//
in
  $UN.castvwtp0{sllist(b,n)}(res)
end (* end of [sllist_map] *)

(* ****** ****** *)

(*
fun{
a:vt0p}{env:vt0p
} sllist_foreach_env
  (xs: !Sllist (INV(a)), env: &env >> _): void
*)
implement
{a}{env}
sllist_foreach_env
  (xs, env) = let
//
fun loop (
  nxs: g2node0 (a), env: &env
) : void = let
  val iscons = gnodelst_is_cons (nxs)
in
//
if iscons then let
  val nx0 = nxs
  val nxs = gnode_get_next (nxs)
  val p_elt = gnode_getref_elt (nx0)
  val (pf, fpf | p_elt) = $UN.cptr_vtake {a} (p_elt)
  val test = sllist_foreach$cont (!p_elt, env)
in
  if test then let
    val () = sllist_foreach$fwork (!p_elt, env)
    prval () = fpf (pf)
  in
    loop (nxs, env)
  end else let
    prval () = fpf (pf)
  in
    // nothing
  end // end of [if]
end else () // end of [if]
//
end // end of [loop]
//
val nxs = $UN.castvwtp1{g2node0(a)}(xs)
//
in
  loop (nxs, env)
end // end of [sllist_foreach_env]

(* ****** ****** *)

implement
{}(*tmp*)
fprint_sllist$sep
  (out) = fprint_string (out, "->")
implement
{a}(*tmp*)
fprint_sllist (out, xs) = let
//
fun loop (
  out: FILEref, nxs: g2node0 (a), i: int
) : void = let
  val iscons = gnodelst_is_cons (nxs)
in
//
if iscons then let
  val nx0 = nxs
  val nxs = gnode_get_next (nx0)
  val () =
    if i > 0 then fprint_sllist$sep (out)
  // end of [val]
  val p_elt = gnode_getref_elt (nx0)
  val (pf, fpf | p_elt) = $UN.cptr_vtake {a} (p_elt)
  val () = fprint_ref (out, !p_elt)
  prval () = fpf (pf)
in
  loop (out, nxs, i+1)
end // end of [if]
//
end // end of [loop]
//
val nxs = $UN.castvwtp1{g2node0(a)}(xs)
//
in
  loop (out, nxs, 0)
end // end of [fprint_sllist]

(* ****** ****** *)

datavtype
slnode_vtype
  (a:vt@ype+) = SLNODE of (a, ptr(*next*))
// end of [slnode_vtype]

(* ****** ****** *)

vtypedef slnode (a:vt0p) = slnode_vtype (a)

(* ****** ****** *)

extern
praxi slnode_vfree {a:vt0p} (nx: slnode (a)): void
extern
castfn
g2node_decode {a:vt0p} (nx: g2node1 (INV(a))):<> slnode (a)
extern
castfn
g2node_encode {a:vt0p} (nx: slnode (INV(a))):<> g2node1 (a)

(* ****** ****** *)

implement
{a}(*tmp*)
g2node_make_elt
  (x) = let
in
  $UN.castvwtp0{g2node1(a)}(SLNODE{a}(x, _))
end // end of [g2node_make_elt]

(* ****** ****** *)

implement
{a}(*tmp*)
g2node_free (nx) = let
  val nx = g2node_decode (nx)
  val~SLNODE (_, _) = (nx) in (*nothing*)
end // end of [g2node_free]

implement
{a}(*tmp*)
g2node_free_elt
  (nx, res) = let
  val nx = g2node_decode (nx)
  val~SLNODE (x, _) = (nx); val () = res := x in (*nothing*)
end // end of [g2node_free_elt]

implement
{a}(*tmp*)
g2node_getfree_elt
  (nx) = let
  val nx = g2node_decode (nx)
  val~SLNODE (x, _) = (nx) in x
end // end of [g2node_getfree_elt]

(* ****** ****** *)

implement(a)
gnode_getref_elt<mytkind><a>
  (nx) = let
//
val nx = g2node_decode (nx)
//
val+@SLNODE (elt, _) = nx
val p_elt = addr@ (elt)
prval () = fold@ (nx)
prval () = slnode_vfree (nx)
//
in
  $UN.cast{cPtr1(a)}(p_elt)
end // end of [gnode_getref_elt]

(* ****** ****** *)

implement(a)
gnode_getref_next<mytkind><a>
  (nx) = let
//
val nx = g2node_decode (nx)
//
val+@SLNODE (_, next) = nx
val p_next = addr@ (next)
prval () = fold@ (nx)
prval () = slnode_vfree (nx)
//
in
  $UN.cast{cPtr1(g2node0(a))}(p_next)
end // end of [gnode_getref_next]

(* ****** ****** *)

implement(a)
gnode_link10<mytkind><a>
  (nx1, nx2) = gnode_set_next (nx1, nx2)
// end of [gnode_link10]

implement(a)
gnode_link11<mytkind><a>
  (nx1, nx2) = gnode_set_next (nx1, nx2)
// end of [gnode_link11]

(* ****** ****** *)

implement
{a}(*tmp*)
sllist_cons_ngc
  (nx0, xs) = let
//
val nxs = sllist0_decode (xs)
val _void_ = gnode_link10 (nx0, nxs)
//
in
  sllist0_encode (nx0)
end // end of [sllist_cons_ngc]

implement
{a}(*tmp*)
sllist_uncons_ngc
  (xs) = let
//
val nxs = sllist1_decode (xs)
val nxs2 = gnode_get_next (nxs)
val _void_ = xs := sllist0_encode (nxs2)
//
in
  nxs
end // end of [sllist_uncons_ngc]

(* ****** ****** *)

implement
{a}(*tmp*)
sllist_snoc_ngc
  {n} (xs, nx0) = let
//
vtypedef res = sllist(a,n+1)
//
val () = gnode_set_next_null (nx0)
//
val nxs = sllist0_decode (xs)
val iscons = gnodelst_is_cons (nxs)
//
in
//
if iscons then let
//
val nx_end = gnodelst_next_all (nxs)
val _void_ = gnode_link11 (nx_end, nx0)
//
in
  $UN.castvwtp0{res}(nxs)
end else
  $UN.castvwtp0{res}(nx0)
// end of [if]
//
end // end of [sllist_snoc_ngc]

(* ****** ****** *)

implement
{a}(*tmp*)
sllist_unsnoc_ngc
  {n} (xs) = let
//
fun loop
(
  xs: &Sllist1 (a) >> Sllist0(a)
) : g2node1(a) = let
//
val p = sllist_getref_next (xs)
//
val (pf, fpf | p) = $UN.ptr_vtake{Sllist0(a)}(p)
//
val iscons = sllist_is_cons (!p)
//
in
//
if iscons
  then let
    val res = loop (!p)
    prval () = fpf (pf) in res
  end // end of [then]
  else let
    prval () = fpf (pf)
    val nx = $UN.castvwtp0{g2node1(a)}(xs)
    val () = xs := sllist_nil{a}((*void*)) in nx
  end // end of [else]
// end of [if]
//
end (* end of [loop] *)
//
val res = $effmask_all (loop (xs))
//
prval [l:addr] EQADDR () = eqaddr_make_ptr (addr@xs)
//
prval () = view@xs := $UN.castview0{sllist(a,n-1)@l}(view@xs)
//
in
  res
end // end of [sllist_unsnoc_ngc]

(* ****** ****** *)

(* end of [sllist.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: December, 2012 *)

(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libats/SATS/qlist.sats"

(* ****** ****** *)

implement{}
qlist_make_nil
  () = pq where {
  val (
    pf, pfgc | p
  ) = ptr_alloc<qstruct> ()
  val pq = ptr2ptrlin (p)
  val () = qstruct_initize (!p)
  prval pfngc = qstruct_objfize (pf | pq)
  prval () = mfree_gcngc_v_nullify (pfgc, pfngc)
} // end of [qlist_make]

implement{}
qlist_free_nil
  {a} (pq) = () where
{
//
val () = __mfree (pq) where
{
  extern fun __mfree
    : qlist (a, 0) -<0,!wrt> void = "mac#atspre_mfree_gc"
} // end of [where] // end of [val]
//
} (* end of [qlist_free_nil] *)

(* ****** ****** *)

implement{a}
qlist_insert
  (pq, x) = let
  val nx = mynode_make_elt<a> (x) in qlist_insert_ngc<a> (pq, nx)
end // end of [qlist_insert]

implement{a}
qstruct_insert
  (que, x) = let
//
val pq = addr@(que)
val pq2 = ptr2ptrlin (pq)
prval pfngc = qstruct_objfize (view@(que) | pq2)
val () = qlist_insert<a> (pq2, x)
prval pfat = qstruct_unobjfize (pfngc | pq, pq2)
prval () = view@(que) := pfat
prval () = ptrlin_free (pq2)
//
in
  // nothing
end // end of [qstruct_insert]

(* ****** ****** *)

implement{a}
qlist_takeout (pq) = let
  val nx0 = qlist_takeout_ngc (pq) in mynode_getfree_elt<a> (nx0)
end // end of [qlist_takeout]

implement{a}
qlist_takeout_opt (pq) =
(
if qlist_isnot_nil (pq) then Some_vt{a}(qlist_takeout(pq)) else None_vt{a}()
) // end of [qlist_takeout_opt]

(* ****** ****** *)

implement{a}
qstruct_takeout
  (que) = res where {
//
val pq = addr@(que)
val pq2 = ptr2ptrlin (pq)
prval pfngc = qstruct_objfize (view@(que) | pq2)
val res = qlist_takeout<a> (pq2)
prval pfat = qstruct_unobjfize (pfngc | pq, pq2)
prval () = view@(que) := pfat
prval () = ptrlin_free (pq2)
//
} // end of [qstruct_takeout]

(* ****** ****** *)

stadef mykind = $extkind"atslib_qlist"

(* ****** ****** *)

datavtype
qlist_data (a:vt@ype+) = QLIST of (ptr, ptr)

(* ****** ****** *)

assume
qlist_vtype (a:vt0p, n:int) = qlist_data (a)

(* ****** ****** *)

implement{a}
qlist_is_nil
  {n} (pq) = let
//
val+@QLIST (nxf, p_nxr) = pq
val isnil = (addr@(nxf) = p_nxr)
prval () = fold@ (pq)
//
in
  $UN.cast{bool(n==0)}(isnil)
end // end of [qlist_is_nil]

implement{a}
qlist_isnot_nil
  {n} (pq) = let
//
val+@QLIST (nxf, p_nxr) = pq
val isnot = (addr@(nxf) != p_nxr)
prval ((*prf*)) = fold@ (pq)
//
in
  $UN.cast{bool(n > 0)}(isnot)
end // end of [qlist_isnot_nil]

(* ****** ****** *)

implement{a}
qlist_length
  {n} (pq) = let
//
implement{a}{env}
qlist_foreach$cont (x, env) = true
implement
qlist_foreach$fwork<a><int> (x, env) = env := env+1
//
var env: int = (0)
//
val () = $effmask_all (qlist_foreach_env<a><int> (pq, env))
//
in
  $UN.cast{int(n)}(env)
end // end of [qlist_length]

(* ****** ****** *)

implement{}
fprint_qlist$sep
  (out) = fprint_string (out, "->")
//
implement{a}
fprint_qlist
  (out, pq) = let
//
implement{a}{env}
qlist_foreach$cont (x, env) = true
implement
qlist_foreach$fwork<a><int>
  (x, env) = let
  val () = if env > 0 then fprint_qlist$sep (out)
  val () = fprint_ref<a> (out, x)
  val () = env := env+1
in
end // end of [qlist_foreach$fwork]
//
var env: int = 0
//
in
  qlist_foreach_env<a><int> (pq, env)
end // end of [fprint_qlist]

(* ****** ****** *)

implement{a}
fprint_qlist_sep
  (out, pq, sep) = let
//
implement{}
fprint_qlist$sep (out) = fprint_string (out, sep)
//
in
  fprint_qlist<a> (out, pq)
end // end of [fprint_qlist_sep]

(* ****** ****** *)

implement
{a}{env}
qlist_foreach$cont (x, env) = true

implement{a}
qlist_foreach (pq) = let
  var env: void = () in qlist_foreach_env<a><void> (pq, env)
end // end of [qlist_foreach]

implement
{a}{env}
qlist_foreach_env
  (pq, env) = let
//
fun loop (
  p_nxf: ptr, p_nxr: ptr, env: &env
) : void = let
in
//
if p_nxf != p_nxr then let
//
val xs =
  $UN.ptr0_get<List1_vt(a)> (p_nxf)
// end of [val]
val+@list_vt_cons (x, xs2) = xs
//
val test =
  qlist_foreach$cont<a><env> (x, env)
val () =
(
if test then let
  val () =
    qlist_foreach$fwork<a><env> (x, env) in loop (addr@(xs2), p_nxr, env)
  // end of [val]
end // end of [if]
) : void // end of [val]
//
prval ((*proof*)) = fold@ (xs)
prval ((*proof*)) = $UN.cast2void(xs)
//
in
  // nothing
end else () // end of [if]
//
end // end of [loop]
//
val+@QLIST (nxf, p_nxr) = pq
val () = loop (addr@(nxf), p_nxr, env)
prval ((*proof*)) = fold@ (pq)
//
in
  // nothing
end // end of [qlist_foreach_env]

(* ****** ****** *)

implement{
} qstruct_initize {a} (que) = let
//
val pq =
  $UN.castvwtp0{qlist(a,0)}(addr@(que))
// end of [val]
val+@QLIST (nxf, p_nxr) = pq
val () = (p_nxr := addr@ (nxf))
prval () = fold@ (pq)
prval () = let
  extern praxi
    __assert (que: &qstruct? >> qstruct (a, 0), pq: qlist (a, 0)): void
  // end of [extern]
in
  __assert (que, pq)
end // end of [prval]
//
in
  (* DoNothing *)
end // end of [qstruct_initize]

(* ****** ****** *)

extern
castfn
mynode1_encode
  {a:vt0p} (xs: List1_vt (INV(a))):<> mynode1 (a)
// end of [mynode1_encode]
extern
castfn
mynode1_decode
  {a:vt0p} (nx: mynode1 (INV(a))):<> List1_vt (a)
// end of [mynode1_decode]

(* ****** ****** *)

implement{}
mynode_null {a} () =
  $UN.castvwtp0 {mynode(a,null)} (list_vt_nil)
// end of [mynode_null]

(* ****** ****** *)

implement{a}
mynode_make_elt (x) =
  $UN.castvwtp0{mynode1(a)}(list_vt_cons{a}{0}(x, _))
// end of [mynode_make_elt]

implement{a}
mynode_free_elt
  (nx, res) = () where {
//
val xs = mynode1_decode (nx)
val+~list_vt_cons (x, xs2) = xs
val () = res := x
prval () = __assert (xs2) where {
  extern praxi __assert : {vt:vtype} (vt) -<prf> void
} // end of [where] // end of [prval]
//
} // end of [mynode_free_elt]

implement{a}
mynode_getfree_elt
  (nx) = (x) where {
//
val xs = mynode1_decode (nx)
val+~list_vt_cons (x, xs2) = xs
prval () = __assert (xs2) where {
  extern praxi __assert : {vt:vtype} (vt) -<prf> void
} // end of [where] // end of [prval]
//
} // end of [mynode_getfree_elt]

(* ****** ****** *)

implement{a}
qlist_insert_ngc
  (pq, nx0) = let
//
val+@QLIST (nxf, p_nxr) = pq
//
val xs = mynode1_decode (nx0)
val+@list_vt_cons (_, xs2) = xs
val p2_nxr = addr@ (xs2)
prval ((*prf*)) = fold@ (xs)
val nx0 = mynode1_encode (xs)
//
val () = $UN.ptr0_set<mynode1(a)> (p_nxr, nx0)
val () = p_nxr := p2_nxr
//
prval ((*prf*)) = fold@ (pq)
//  
in
  // nothing
end // end of [qlist_insert_ngc]

(* ****** ****** *)

implement{a}
qlist_takeout_ngc
  (q) = nx0 where {
//
val+@QLIST (nxf, p_nxr) = q
val nx0 = $UN.castvwtp0{mynode1(a)}(nxf)
//
val xs = mynode1_decode (nx0)
val+@list_vt_cons (_, xs2) = xs
val p2_nxr = addr@ (xs2)
prval ((*prf*)) = fold@ (xs)
val nx0 = mynode1_encode (xs)
//
val () = (
  if (p_nxr != p2_nxr)
    then nxf := $UN.ptr0_get<ptr> (p2_nxr)
    else p_nxr := addr@ (nxf)
  // end of [if]
) : void // end of [val]
//
prval ((*prf*)) = fold@ (q)
//
} // end of [qlist_takeout_ngc]

(* ****** ****** *)

implement{}
qlist_takeout_list
  {a}{n}(pq) = xs where
{
//
val+@QLIST (nxf, p_nxr) = pq
val () = $UN.ptr0_set<ptr> (p_nxr, the_null_ptr)
val xs = $UN.castvwtp0{list_vt(a,n)}(nxf)
val () = p_nxr := addr@ (nxf)
prval ((*prf*)) = fold@ (pq)
//
} // end of [qlist_takeout_list]

implement{}
qstruct_takeout_list
  {a}{n}(que) = let
//
val pq = addr@(que)
val pq2 = ptr2ptrlin (pq)
prval pfngc = qstruct_objfize (view@(que) | pq2)
val xs = qlist_takeout_list (pq2)
prval pfat = qstruct_unobjfize (pfngc | pq, pq2)
prval () = view@(que) := pfat
prval () = ptrlin_free (pq2)
//
in
  xs
end // end of [qstruct_takeout_list]

(* ****** ****** *)

(* end of [qlist.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: December, 2012 *)

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.linmap_randbst"
#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload TIME = "libc/SATS/time.sats"
staload STDLIB = "libc/SATS/stdlib.sats"

(* ****** ****** *)

staload "libats/SATS/linmap_randbst.sats"

(* ****** ****** *)

#include "./SHARE/linmap.hats" // code reuse

(* ****** ****** *)

stadef
mytkind = $extkind"atslib_linmap_randbst"

(* ****** ****** *)
//
// HX: for linear binary search trees
//
datavtype
bstree (
  key:t@ype, itm: vt@ype+, int(*size*)
) =
  | BSTnil (
      key, itm, 0
    ) of (
      // argmentless
    ) // end of [BSTnil]
  | {nl,nr:nat}
    BSTcons (
      key, itm, 1+nl+nr
    ) of (
      int (1+nl+nr), key, itm, bstree (key, itm, nl), bstree (key, itm, nr)
    ) // end of [BSTcons]
// end of [bstree]
//
(* ****** ****** *)

vtypedef
bstree0 (k:t0p, i:vt0p) = [n:nat] bstree (k, i, n)

(* ****** ****** *)

assume
map_vtype (key:t0p, itm:vt0p) = bstree0 (key, itm)

(* ****** ****** *)

fun{
key:t0p;itm:vt0p
} bstree_size
  {n:int} .<>.
(
  t: !bstree (key, INV(itm), n)
) :<> int n =
(
  case+ t of BSTcons (n, _, _, _, _) => n | BSTnil _ => 0 
) // end of [bstree_size]

(* ****** ****** *)

implement{
} linmap_nil () = BSTnil ()
implement{
} linmap_make_nil () = BSTnil ()

(* ****** ****** *)

implement{
} linmap_is_nil
  (map) = ans where {
  val ans = (
    case+ map of BSTnil _ => true | BSTcons _ => false
  ) : bool // end of [val]
} // end of [linmap_is_nil]

implement{
} linmap_isnot_nil
  (map) = ans where {
  val ans = (
    case+ map of BSTnil _ => false | BSTcons _ => true
  ) : bool // end of [val]
} // end of [linmap_isnot_nil]

(* ****** ****** *)

implement
{key,itm}
linmap_size (map) = g1int2uint (bstree_size<key,itm> (map))

(* ****** ****** *)

local

fun{
key:t0p;itm:t0p
} auxfree{n:nat} .<n>.
(
  t0: bstree (key, INV(itm), n)
) :<!wrt> void = let
in
//
case+ t0 of
| ~BSTcons (
    _, _, _, tl, tr
  ) => let
    val () = auxfree (tl)
    and () = auxfree (tr) in (*nothing*)
  end // end of [BSTcons]
| ~BSTnil () => ()
//
end // end of [auxfree]

in (* in of [local] *)

implement
{key,itm}
linmap_free (map) = auxfree<key,itm> (map)

end // end of [local]

(* ****** ****** *)

fun{
key:t0p;itm:vt0p
} bstree_search_ref
  {n:nat} .<n>.
(
  t: !bstree (key, INV(itm), n), k0: key
) :<> cPtr0 (itm) = let
in
//
case+ t of
| @BSTcons (
    _(*sz*), k, x, tl, tr
  ) => let
    val sgn = compare_key_key<key> (k0, k)
  in
    case+ 0 of
    | _ when sgn < 0 => let
        val res = bstree_search_ref (tl, k0) in fold@ (t); res
      end // end of [_]
    | _ when sgn > 0 => let
        val res = bstree_search_ref (tr, k0) in fold@ (t); res
      end // end of [_]
    | _ (*sgn = 0*) => let
        val res = addr@ (x) in fold@ (t); $UN.cast{cPtr1(itm)}(res)
      end // end of [_]
  end // end of [BSTcons]
| BSTnil () => cptr_null {itm} ()
//
end // end of [bstree_search_ref]

(* ****** ****** *)

implement
{key,itm}
linmap_search_ref
  (map, k0) = bstree_search_ref<key,itm> (map, k0)
// end of [linmap_search_ref]

(* ****** ****** *)

fun{
key:t0p;itm:vt0p
} bstree_insert_atroot{n:nat} .<n>.
(
  t: &bstree (key, INV(itm), n) >> bstree (key, itm, n+1-i), k0: key, x0: &itm >> opt (itm, i>0)
) :<!wrt> #[i:nat2] int (i) = let
in
//
case+ t of
| @BSTcons (
    n, k, x, tl, tr
  ) => let
    val sgn = compare_key_key<key> (k0, k)
  in
    if sgn < 0 then let
      val ans = bstree_insert_atroot<key,itm> (tl, k0, x0)
    in
      if ans = 0 then let
        val tl_ = tl
        val+ @BSTcons
          (nl, _, _, tll, tlr) = tl_
        // end of [val]
        val n_ = n; val nll = bstree_size (tll)
        val () = tl := tlr
        val () = n := n_ - nll
        prval () = fold@ (t)
        val () = tlr := t
        val () = nl := n_ + 1
        prval () = fold@ (tl_)
        val () = t := tl_
      in
        ans
      end else let
        prval () = fold@ (t) in ans // [x0] is alreay in the tree [t]
      end // end of [if]
    end else if sgn > 0 then let
      val ans = bstree_insert_atroot<key,itm> (tr, k0, x0)
    in
      if ans = 0 then let
        val tr_ = tr
        val+ @BSTcons
          (nr, _, _, trl, trr) = tr_
        // end of [val]
        val n_ = n
        val nrr = bstree_size (trr)
        val () = tr := trl
        val () = n := n_ - nrr
        prval () = fold@ (t)
        val () = trl := t
        val () = nr := n_ + 1
        prval () = fold@ (tr_)
        val () = t := tr_
      in
        ans
      end else let
        prval () = fold@ (t) in ans // [k0] alreay in [t]
      end // end of [if]
    end else let (* sgn = 0 *)
      val x_ = x
      val () = x := x0
      val () = x0 := x_
      prval () = fold@ (t)
      prval () = opt_some{itm}(x0)
    in
      1 // replaced
    end // end of [if]
  end (* end of [BSTcons] *)
| ~BSTnil () => let
    val x0_ = x0
    val () = t := BSTcons{key,itm}(1, k0, x0_, BSTnil (), BSTnil ())
    prval () = opt_none{itm}(x0)
  in
    0 // inserted
  end // end of [BSTnil]
//
end // end of [bstree_insert_atroot]

fun
{key:t0p
;itm:vt0p}
bstree_insert_random
  {n:nat} .<n>. (
  t: &bstree (key, INV(itm), n) >> bstree (key, itm, n+1-i), k0: key, x0: &itm >> opt(itm, i>0)
) : #[i:nat2] int (i) = let
in
//
case+ t of
| @BSTcons
  (
    n, k, x, tl, tr
  ) => let
    val randbit =
      linmap_randbst_random_m_n (1, n)
    // end of [val]
  in
    if randbit = 0 then let
      prval () = fold@ (t) in bstree_insert_atroot<key,itm> (t, k0, x0)
    end else let
      val sgn = compare_key_key<key> (k0, k)
    in
      if sgn < 0 then let
        val ans = bstree_insert_random<key,itm> (tl, k0, x0)
      in
        if ans = 0 then (n := n + 1; fold@ (t); ans) else (fold@ (t); ans)
      end else if sgn > 0 then let
        val ans = bstree_insert_random<key,itm> (tr, k0, x0)
      in
        if ans = 0 then (n := n + 1; fold@ (t); ans) else (fold@ (t); ans)
      end else let // sgn = 0
        val x_ = x
        val () = x := x0
        val () = x0 := x_
        prval () = opt_some {itm} (x0)
      in
        fold@ (t); 1 // [k0] is at the root of [t]
      end // end of [if]
    end // end of [if]
  end (* end of [BSTcons] *)
| ~BSTnil () => let
    val x0_ = x0
    val () = t := BSTcons{key,itm}(1, k0, x0_, BSTnil (), BSTnil ())
    prval () = opt_none {itm} (x0)
  in
    0 // inserted
  end (* end of [BSTnil] *)
//
end (* end of [bstree_insert_random] *)

(* ****** ****** *)

implement
{key,itm}
linmap_insert (
  map, k0, x0, res
) = let
  val () = res := x0
  val i = bstree_insert_random<key,itm> (map, k0, res)
in
  if i > 0 then true else false
end // end of [linmap_insert]

(* ****** ****** *)

fun
{key:t0p
;itm:vt0p}
bstree_join_random
  {nl,nr:nat} .<nl+nr>. (
  tl: bstree (key, INV(itm), nl), tr: bstree (key, itm, nr)
) : bstree (key, itm, nl+nr) = let
in
//
case+ tl of
//
| @BSTcons
  (
    nl, _, _, tll, tlr
  ) => (
  case+ tr of
  | @BSTcons
    (
      nr, _, _, trl, trr
    ) => let
      val n = nl + nr
      val randbit =
        linmap_randbst_random_m_n (nl, nr)
      // end of [val]
    in
      if randbit = 0 then let
        prval () = fold@ (tr)
        val () = tlr := bstree_join_random (tlr, tr)
        val () = nl := n
        prval () = fold@ (tl)
      in
        tl
      end else let
        prval () = fold@ tl
        val () = trl := bstree_join_random (tl, trl)
        val () = nr := n
        prval () = fold@ (tr)
      in
        tr
      end // end of [if]
    end (* end of [BSTcons] *)
  | ~BSTnil () => let
      val () = fold@ (tl) in tl
    end // end of [BSTnil]
  ) (* end of [BSTcons] *)
//
| ~BSTnil () => tr
//
end // end of [bstree_join_random]

(* ****** ****** *)

fun
{key:t0p
;itm:vt0p}
bstree_takeout_random
  {n:nat} .<n>. (
  t: &bstree (key, INV(itm), n) >> bstree (key, itm, n-i), k0: key, x0: &(itm?) >> opt (itm, i>0)
) : #[i:nat2 | i <= n] int (i) = let
in
//
case+ t of
| @BSTcons {..} {nl,nr}
    (n, k, x, tl, tr) => let
    val sgn = compare_key_key<key> (k0, k)
  in
    if sgn < 0 then let
      val ans = bstree_takeout_random<key,itm> (tl, k0, x0)
      val () = n := n - ans
      prval () = fold@ (t)
    in
      ans
    end else if sgn > 0 then let
      val ans = bstree_takeout_random<key,itm> (tr, k0, x0)
      val () = n := n - ans
      prval () = fold@ (t)
    in
      ans
    end else let
      val () = x0 := x
      prval () = opt_some (x0)
      val t_new = bstree_join_random<key,itm> (tl, tr)
      val () = free@ {key,itm} {0,0} (t)
      val () = t := t_new
    in
      1 (* removed *)
    end // end of [0]
  end (* end of [BSTcons] *)
| BSTnil () => let
    prval () = opt_none {itm} (x0) in 0 // not(removed)
  end // end of [BSTnil]
//
end // end of [bstree_takeout_random]

(* ****** ****** *)

implement
{key,itm}
linmap_takeout
  (map, k0, res) = let
  val i = bstree_takeout_random<key,itm> (map, k0, res)
in
  if i > 0 then true else false
end // end of [linmap_takeout]

(* ****** ****** *)

implement
{key,itm}{env}
linmap_foreach_env
  (map, env) = let
//
fun aux
  {n:nat} .<n>.
(
  t: !bstree (key, itm, n), env: &(env) >> _
) : void = let
in
//
case+ t of
| @BSTcons
  (
    n, k, x, tl, tr
  ) => let
    val () = aux (tl, env)
    val () = linmap_foreach$fwork<key,itm><env> (k, x, env)
    val () = aux (tr, env)
    prval () = fold@ (t)
  in
    // nothing
  end // end of [BSTcons]
| BSTnil ((*void*)) => ()
//
end // end of [aux]
//
fun aux2
(
  t: ptr, env: &(env) >> _
) : void = let
//
stadef
  bst = bstree0 (key, itm)
// end of [stadef]
val t = $UN.castvwtp0{bst}(t)
val () = aux (t, env)
val t = $UN.castvwtp0{ptr}(t)
//
in
  // nothing
end // end of [aux2]
//
val map = $UN.castvwtp1{ptr}(map)
//
in
  aux2 (map, env)
end // end of [linmap_foreach_env]

(* ****** ****** *)

implement
{key,itm}
linmap_freelin
  (map) = let
//
fun aux
  {n:nat} .<n>.
(
  t: bstree (key, itm, n)
) : void = let
in
//
case+ t of
| @BSTcons
  (
    _, k, x, tl, tr
  ) => let
    val () = linmap_freelin$clear<itm> (x)
    val tl = tl and tr = tr
    val () = free@ {..}{0,0} (t)
    val () = aux (tl) and () = aux (tr)
  in
    // nothing
  end // end of [BSTcons]
| ~BSTnil ((*void*)) => ()
//
end // end of [aux]
//
in
  $effmask_all (aux (map))
end // end of [linmap_freelin]

(* ****** ****** *)

implement
{key,itm}
linmap_free_ifnil
  (map) = let
//
vtypedef map = map (key, itm)
//
val map2 =
  __cast (map) where {
  extern castfn __cast : (!map >> map?) -<> map
} // end of [where] // end of [val]
//
in
//
case+ map2 of
| ~BSTnil () => let
    prval () = opt_none {map} (map) in false
  end // end of [BSTnil]
| @BSTcons _ => let
    prval () = fold@ (map2)
    prval () =
      __assert (map, map2) where {
      extern praxi __assert : (!map? >> map, map) -<prf> void
    } // end of [val]
    prval () = opt_some {map} (map) in true
  end // end of [BSTcons]
//
end // end of [linmap_free_ifnil]

(* ****** ****** *)

implement
{key,itm}{ki2}
linmap_flistize
  (map) = let
//
vtypedef ki = @(key, itm)
//
fun aux
  {m,n:nat} .<n>. (
  t: bstree (key, itm, n), res: list_vt (ki2, m)
) : list_vt (ki2, m+n) = let
in
//
case+ t of
| ~BSTcons
  (
    _, k, x, tl, tr
  ) => res where {
    val res = aux (tl, res)
    val kx2 = linmap_flistize$fopr<key,itm><ki2> (k, x)
    val res = list_vt_cons{ki2}(kx2, res)
    val res = aux (tr, res)
  } // end of [BSTcons]
| ~BSTnil ((*void*)) => res
//
end // end of [aux]
//
val res = aux (map, list_vt_nil ())
//
in
  list_vt_reverse (res)
end // end of [linmap_flistize]

(* ****** ****** *)

(*
implement
{key,itm}
linmap_listize1
  (map) = let
//
vtypedef ki = @(key, itm)
//
fun aux
  {m,n:nat} .<n>. (
  t0: !bstree (key, itm, n), res: list_vt (ki, m)
) :<!wrt> list_vt (ki, m+n) = let
in
//
case+ t0 of
| @BSTcons (
    _, k, x, tl, tr
  ) => res where {
    val res = aux (tl, res)
    val res = list_vt_cons{ki}((k, x), res)
    val res = aux (tr, res)
    prval ((*void*)) = fold@ (t0)
  } // end of [BSTcons]
| BSTnil () => (res)
//
end // end of [aux]
//
val res = aux (map, list_vt_nil ())
//
in
  list_vt_reverse (res)
end // end of [linmap_listize1]
*)

(* ****** ****** *)

implement{}
linmap_randbst_initize () =
(
  $STDLIB.srand48 ($UN.cast{lint}($TIME.time_get()))
) // end of [linmap_randbst_initize]

(* ****** ****** *)

implement{}
linmap_randbst_random_m_n
  (m, n) = let
  val r = $STDLIB.drand48 ()
in
  if g0i2f (m+n) * r <= g0i2f (m) then 0 else 1
end // end of [linmap_random_m_n]

(* ****** ****** *)

(* end of [linmap_randbst.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: Feburary, 2013 *)

(* ****** ****** *)
//
// HX-2013-02: this is a completely new effort
//
(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libats/SATS/gnode.sats"

(* ****** ****** *)

staload "libats/SATS/dllist.sats"

(* ****** ****** *)

#define nullp the_null_ptr

(* ****** ****** *)
//
extern
fun{a:vt0p}
g2node_make_elt (x: a):<!wrt> g2node1 (a)
//
extern
fun{a:t0p} // [a] is nonlinear
g2node_free (nx: g2node1 (INV(a))):<!wrt> void
extern
fun{a:vt0p}
g2node_free_elt
  (nx: g2node1 (INV(a)), res: &(a?) >> a):<!wrt> void
//
extern
fun{a:vt0p}
g2node_getfree_elt (nx: g2node1 (INV(a))):<!wrt> (a)
//
(* ****** ****** *)
//
extern
castfn
dllist_encode
  : {a:vt0p}{f,r:int} (g2node0 (INV(a))) -<> dllist (a, f, r)
extern
castfn
dllist_decode
  : {a:vt0p}{f,r:int} (dllist (INV(a), f, r)) -<> g2node0 (a)
//
extern
castfn
dllist1_encode
  : {a:vt0p}{f,r:int | r > 0} (g2node1 (INV(a))) -<> dllist (a, f, r)
extern
castfn
dllist1_decode
  : {a:vt0p}{f,r:int | r > 0} (dllist (INV(a), f, r)) -<> g2node1 (a)
//
(* ****** ****** *)

implement{}
dllist_nil () = dllist_encode (gnode_null ())

implement{a}
dllist_sing (x) = dllist_cons<a> (x, dllist_nil ())

(* ****** ****** *)

implement{a}
dllist_cons
  (x, xs) = let
//
val nx = g2node_make_elt<a> (x) in dllist_cons_ngc (nx, xs)
//
end // end of [dllist_cons]

implement{a}
dllist_uncons
  (xs) = let
//
val nx0 = dllist_uncons_ngc (xs) in g2node_getfree_elt<a> (nx0)
//
end // end of [dllist_uncons]

(* ****** ****** *)

implement{a}
dllist_snoc
  (xs, x) = let
//
val nx = g2node_make_elt<a> (x) in dllist_snoc_ngc (xs, nx)
//
end // end of [dllist_snoc]

implement{a}
dllist_unsnoc
  (xs) = let
//
val nx0 = dllist_unsnoc_ngc (xs) in g2node_getfree_elt<a> (nx0)
//
end // end of [dllist_unsnoc]

(* ****** ****** *)

implement{a}
dllist_make_list (xs) = let
//
fun loop (
  nx0: g2node1 (a), xs: List (a)
) : void = let
in
//
case+ xs of
| list_cons
    (x, xs) => let
    val nx1 =
      g2node_make_elt<a> (x)
    // end of [val]
    val () = gnode_link11 (nx0, nx1)
  in
    loop (nx1, xs)
  end // end of [loop]
| list_nil () => let
    val () = gnode_set_next_null (nx0)
  in
    // nothing
  end // end of [list_nil]
//
end // end of [loop]
//
in
//
case+ xs of
| list_cons
    (x, xs) => let
    val nx0 = g2node_make_elt<a> (x)
    val () = $effmask_all (loop (nx0, xs))
  in
    dllist_encode (nx0)
  end // end of [list_cons]
| list_nil () => dllist_nil ()
//
end // end of [dllist_make_list]

(* ****** ****** *)

implement{}
dllist_is_nil
  {a}{f,r} (xs) = let
  val nxs = $UN.castvwtp1{g2node0(a)}(xs)
in
  $UN.cast{bool(r==0)}(gnodelst_is_nil (nxs))
end // end of [dllist_is_nil]

implement{}
dllist_is_cons
  {a}{f,r} (xs) = let
  val nxs = $UN.castvwtp1{g2node0(a)}(xs)
in
  $UN.cast{bool(r > 0)}(gnodelst_is_cons (nxs))
end // end of [dllist_is_cons]

(* ****** ****** *)

(*
fun{a:vt0p}
dllist_is_atbeg
  {f,r:int}
  (xs: !dllist (INV(a), f, r)):<> bool (f==0)
// end of [dllist_is_atbeg]
*)
implement{a}
dllist_is_atbeg
  {f,r} (xs) = let
//
val nxs =
  $UN.castvwtp1{g2node0(a)}(xs)
val iscons = gnodelst_is_cons (nxs)
//
val ans = (
  if iscons
    then gnode_is_null (gnode_get_prev (nxs)) else true
  // end of [if]
) : bool // end of [val]
//
in
  $UN.cast{bool(f==0)}(ans)
end // end of [dllist_is_atbeg]

(* ****** ****** *)

(*
fun{a:vt0p}
dllist_is_atend
  {f,r:int | r > 0}
  (xs: !dllist (INV(a), f, r)):<> bool (r==1)
// end of [dllist_is_atend]
*)
implement{a}
dllist_is_atend
  {f,r} (xs) = let
//
val nxs = $UN.castvwtp1{g2node1(a)}(xs)
val ans = gnode_is_null (gnode_get_next (nxs))
//
in
  $UN.cast{bool(r==1)}(ans)
end // end of [dllist_is_atend]

(* ****** ****** *)

implement{a}
rdllist_is_atbeg {f,r} (xs) = dllist_is_atend {f,r} (xs)
implement{a}
rdllist_is_atend {f,r} (xs) = dllist_is_atbeg {f,r} (xs)

(* ****** ****** *)

implement{a}
dllist_getref_elt (xs) = let
  val nxs =
    $UN.castvwtp1{g2node1(a)}(xs) in gnode_getref_elt (nxs)
  // end of [val]
end // end of [dllist_getref_elt]

(* ****** ****** *)

implement{a}
dllist_getref_next (xs) = let
  val nxs =
    $UN.castvwtp1{g2node1(a)}(xs) in cptr2ptr (gnode_getref_next (nxs))
  // end of [val]  
end // end of [dllist_getref_next]

implement{a}
dllist_getref_prev (xs) = let
  val nxs =
    $UN.castvwtp1{g2node1(a)}(xs) in cptr2ptr (gnode_getref_prev (nxs))
  // end of [val]  
end // end of [dllist_getref_prev]

(* ****** ****** *)

implement{a}
dllist_get_elt (xs) = let
  val p_elt =
    dllist_getref_elt (xs) in $UN.cptr_get<a> (p_elt)
  // end of [val]
end // end of [dllist_get_elt]

implement{a}
dllist_set_elt (xs, x0) = let
  val p_elt = 
    dllist_getref_elt (xs) in $UN.cptr_set<a> (p_elt, x0)
  // end of [val]
end // end of [dllist_set_elt]

(* ****** ****** *)

(*
fun{a:vt0p}
dllist_length
  {f,r:int} (xs: !dllist (INV(a), f, r)):<> int (r)
*)
implement{a}
dllist_length
  {f,r} (xs) = let
//
val nxs = $UN.castvwtp1{g2node0(a)}(xs)
//
in
  $UN.cast{int(r)}(gnodelst_length (nxs))
end // end of [dllist_length]

(*
fun{a:vt0p}
rdllist_length
  {f,r:int} (xs: !dllist (INV(a), f, r)):<> int (f)
*)
implement{a}
rdllist_length
  {f,r} (xs) = let
//
val nxs = $UN.castvwtp1{g2node0(a)}(xs)
//
in
  $UN.cast{int(f)}(gnodelst_rlength (nxs))
end // end of [rdllist_length]

(* ****** ****** *)

(*
fun{a:vt0p}
dllist_move
  {f,r:int | r > 1}
  (xs: dllist (INV(a), f, r)):<> dllist (a, f+1, r-1)
*)
implement{a}
dllist_move (xs) = let
  val nxs = dllist1_decode (xs)
in
  dllist_encode (gnode_get_next (nxs))
end // end of [dllist_move]

(*
fun{a:vt0p}
dllist_move_all
  {f,r:int | r > 0}
  (xs: dllist (INV(a), f, r)):<> dllist (a, f+r-1, 1)
*)
implement{a}
dllist_move_all
  {f,r} (xs) = let
//
val nxs = dllist1_decode (xs)
val nxs_end = gnodelst_next_all (nxs)
//
in
  dllist_encode (nxs_end)
end // end of [dllist_move_all]

(* ****** ****** *)

(*
fun{a:vt0p}
rdllist_move
  {f,r:int | f > 0}
  (xs: dllist (INV(a), f, r)):<> dllist (a, f-1, r+1)
*)
implement{a}
rdllist_move (xs) = let
//
prval (
) = lemma2_dllist_param (xs)
//
val nxs = dllist1_decode (xs)
//
in
  dllist_encode (gnode_get_prev (nxs))
end // end of [rdllist_move]

(*
fun{a:vt0p}
rdllist_move_all
  {f,r:int | r >= 0}
  (xs: dllist (INV(a), f, r)):<> dllist (a, 0(*front*), f+r)
*)
implement{a}
rdllist_move_all
  {f,r} (xs) = let
//
val nxs = dllist_decode (xs)
val iscons = gnodelst_is_cons (nxs)
val nxs_beg = (
  if iscons then $effmask_all (gnodelst_prev_all (nxs)) else nxs
) : g2node0 (a) // end of [val]
//
in
  dllist_encode (nxs_beg)
end // end of [rdllist_move_all]

(* ****** ****** *)

(*
fun{a:vt0p}
dllist_insert_next
  {f,r:int | r > 0}
  (xs: dllist (INV(a), f, r), x0: a):<!wrt> dllist (a, f, r+1)
*)
implement{a}
dllist_insert_next
  (xs, x0) = let
  val nxs = dllist1_decode (xs)
  val nx0 = g2node_make_elt<a> (x0)
  val () = gnode_insert_next (nxs, nx0)
in
  dllist_encode (nxs)
end // end of [dllist_insert_next]

(*
fun{a:vt0p}
dllist_insert_prev
  {f,r:int | r > 0}
  (xs: dllist (INV(a), f, r), x0: a):<!wrt> dllist (a, f, r+1)
*)
implement{a}
dllist_insert_prev
  (xs, x0) = let
  val nxs = dllist1_decode (xs)
  val nx0 = g2node_make_elt<a> (x0)
  val () = gnode_insert_prev (nxs, nx0)
in
  dllist_encode (nx0)
end // end of [dllist_insert_prev]

(* ****** ****** *)

(*
fun{a:vt0p}
dllist_takeout
  {f,r:int | r > 1}
  (xs: &dllist (INV(a), f, r) >> dllist (a, f, r-1)):<!wrt> (a)
*)
implement{a}
dllist_takeout
  (xs) = let
  val nxs = dllist1_decode (xs)
  val nxs_prev = gnode_get_prev (nxs)
  val nxs_next = gnode_get_next (nxs)
  val nxs_next = $UN.cast{g2node1(a)}(nxs_next)
  val () = gnode_link01 (nxs_prev, nxs_next)
  val () = (xs := dllist_encode (nxs_next))
in
  g2node_getfree_elt (nxs)
end // end of [dllist_takeout]

(* ****** ****** *)

(*
fun{a:vt0p}
dllist_append
  {f1,r1:int}{f2,r2:int} (
  xs1: dllist (INV(a), f1, r1), xs2: dllist (a, f2, r2)
) :<!wrt> dllist (a, f1, r1+f2+r2) // end of [dllist_append]
*)
implement{a}
dllist_append
  {f1,r1}{f2,r2} (xs1, xs2) = let
//
prval () = lemma1_dllist_param (xs1)
prval () = lemma1_dllist_param (xs2)
//
val xs2_beg = rdllist_move_all (xs2)
//
val iscons1 = dllist_is_cons (xs1)
//
in
//
if iscons1 then let
  val iscons2 = dllist_is_cons (xs2_beg)
in
  if iscons2 then let
    val nxs1 =
      $UN.castvwtp1{g2node0(a)}(xs1)
    val xs1_end = dllist_move_all (xs1)
    val nxs1_end = dllist1_decode (xs1_end)
    val nxs2_beg = dllist_decode (xs2_beg)
    val () = gnode_link10 (nxs1_end, nxs2_beg)
  in
    dllist_encode (nxs1)
  end else let
    prval () = dllist_free_nil (xs2_beg)
  in
    xs1
  end // end of [if]
end else let
  prval () = lemma3_dllist_param (xs1)
  prval () = dllist_free_nil (xs1)
in
  xs2_beg
end // end of [if]
//
end // end of [dllist_append]

(* ****** ****** *)

(*
fun{a:vt0p}
rdllist_append
  {f1,r1:int}{f2,r2:int | r2 > 0} (
  xs1: dllist (INV(a), f1, r1), xs2: dllist (a, f2, r2)
) :<!wrt> dllist (a, f1+r1+f2, r2) // end of [rdllist_append]
*)
implement{a}
rdllist_append
  (xs1, xs2) = let
//
prval () = lemma1_dllist_param (xs1)
prval () = lemma1_dllist_param (xs2)
//
val iscons1 = dllist_is_cons (xs1)
//
in
//
if iscons1 then let
  val nxs2 =
    $UN.castvwtp1{g2node1(a)}(xs2)
  val xs1_end = dllist_move_all (xs1)
  val xs2_beg = rdllist_move_all (xs2)
  val nxs1_end = dllist_decode (xs1_end)
  val nxs2_beg = dllist1_decode (xs2_beg)
  val () = gnode_link01 (nxs1_end, nxs2_beg)
in
  dllist_encode (nxs2)
end else let
  prval () = lemma3_dllist_param (xs1)
  prval () = dllist_free_nil (xs1)
in
  xs2
end // end of [if]
//
end // end of [rdllist_append]

(* ****** ****** *)

implement{a}
dllist_reverse (xs) = let
//
fun loop (
  nxs: g2node0 (a), res: g2node1 (a)
) : g2node1 (a) = let
  val iscons = gnodelst_is_cons (nxs)
in
//
if iscons then let
  val nx0 = nxs
  val nxs = gnode_get_next (nx0)
  val () = gnode_link11 (nx0, res)
in
  loop (nxs, nx0)
end else res // end of [if]
//
end // end of [loop]
//
val iscons = dllist_is_cons (xs)
//
in
//
if iscons then let
  val nxs = dllist1_decode (xs)
  val nx0 = nxs
  val nxs = gnode_get_next (nx0)
  val nxp = gnode_get_prev (nx0)
  val () = gnode_set_next_null (nx0)
  val res = $effmask_all (loop (nxs, nx0))
  val () = gnode_link01 (nxp, res)
in
  dllist_encode (res)
end else (xs) // end of [if]
//
end // end of [dllist_reverse]

(* ****** ****** *)

implement{a}
dllist_free (xs) = let
//
fun loop (
  nxs: g2node0 (a)
) : void = let
//
val iscons = gnodelst_is_cons (nxs)
//
in
//
if iscons then let
  val nxs2 = gnode_get_next (nxs)
  val () = g2node_free (nxs)
in
  loop (nxs2)
end else () // end of [if]
//
end // end of [loop]
//
val nxs = dllist_decode (xs)
//
in
  $effmask_all (loop (nxs))
end // end of [dllist_free]

(* ****** ****** *)

(*
fun{
a:vt0p}{env:vt0p
} dllist_foreach_env
  {f,r:int} (xs: !dllist (INV(a), f, r), env: &env >> _): void
*)
implement
{a}{env}
dllist_foreach_env
  (xs, env) = let
//
fun loop (
  nxs: g2node0 (a), env: &env
) : void = let
  val iscons = gnodelst_is_cons (nxs)
in
//
if iscons then let
  val nx0 = nxs
  val nxs = gnode_get_next (nxs)
  val p_elt = gnode_getref_elt (nx0)
  val (pf, fpf | p_elt) = $UN.cptr_vtake {a} (p_elt)
  val test = dllist_foreach$cont (!p_elt, env)
in
  if test then let
    val () = dllist_foreach$fwork (!p_elt, env)
    prval () = fpf (pf)
  in
    loop (nxs, env)
  end else let
    prval () = fpf (pf)
  in
    // nothing
  end // end of [if]
end else () // end of [if]
//
end // end of [loop]
//
val nxs = $UN.castvwtp1{g2node0(a)}(xs)
//
in
  loop (nxs, env)
end // end of [dllist_foreach_env]

(* ****** ****** *)

(*
fun{
a:vt0p}{env:vt0p
} rdllist_foreach_env
  {f,r:int} (xs: !dllist (INV(a), f, r), env: &env >> _): void
*)
implement
{a}{env}
rdllist_foreach_env
  (xs, env) = let
//
fun loop (
  nxs: g2node1 (a), env: &env
) : void = let
  val nxs2 = gnode_get_prev (nxs)
  val iscons = gnodelst_is_cons (nxs2)
in
//
if iscons then let
  val nx0 = nxs2
  val p_elt = gnode_getref_elt (nx0)
  val (pf, fpf | p_elt) = $UN.cptr_vtake {a} (p_elt)
  val test = rdllist_foreach$cont (!p_elt, env)
in
  if test then let
    val () = rdllist_foreach$fwork (!p_elt, env)
    prval () = fpf (pf)
  in
    loop (nxs2, env)
  end else let
    prval () = fpf (pf)
  in
    // nothing
  end // end of [if]
end else () // end of [if]
//
end // end of [loop]
//
val nxs = $UN.castvwtp1{g2node0(a)}(xs)
//
in
  if gnodelst_is_cons (nxs) then loop (nxs, env) else ()
end // end of [rdllist_foreach_env]

(* ****** ****** *)

implement{}
fprint_dllist$sep
  (out) = fprint_string (out, "->")
implement{a}
fprint_dllist (out, xs) = let
//
fun loop (
  out: FILEref, nxs: g2node0 (a), i: int
) : void = let
  val iscons = gnodelst_is_cons (nxs)
in
//
if iscons then let
  val nx0 = nxs
  val nxs = gnode_get_next (nx0)
  val () =
    if i > 0 then fprint_dllist$sep (out)
  // end of [val]
  val p_elt = gnode_getref_elt (nx0)
  val (pf, fpf | p_elt) = $UN.cptr_vtake {a} (p_elt)
  val () = fprint_ref (out, !p_elt)
  prval () = fpf (pf)
in
  loop (out, nxs, i+1)
end // end of [if]
//
end // end of [loop]
//
val nxs = $UN.castvwtp1{g2node0(a)}(xs)
//
in
  loop (out, nxs, 0)
end // end of [fprint_dllist]

(* ****** ****** *)

implement{}
fprint_rdllist$sep
  (out) = fprint_string (out, "<-")
implement{a}
fprint_rdllist (out, xs) = let
//
fun loop (
  out: FILEref, nxs: g2node0 (a), i: int
) : void = let
  val iscons = gnodelst_is_cons (nxs)
in
//
if iscons then let
  val nx0 = nxs
  val nxs = gnode_get_prev (nx0)
  val () =
    if i > 0 then fprint_rdllist$sep (out)
  // end of [val]
  val p_elt = gnode_getref_elt (nx0)
  val (pf, fpf | p_elt) = $UN.cptr_vtake {a} (p_elt)
  val () = fprint_ref (out, !p_elt)
  prval () = fpf (pf)
in
  loop (out, nxs, i+1)
end // end of [if]
//
end // end of [loop]
//
val nxs = $UN.castvwtp1{g2node0(a)}(xs)
//
val iscons = gnodelst_is_cons (nxs)
//
in
  if iscons then loop (out, gnode_get_prev (nxs), 0) else ()
end // end of [fprint_rdllist]

(* ****** ****** *)

datavtype
dlnode_vtype (a:vt@ype+) =
  | DLNODE of (a, ptr(*next*), ptr(*prev*))
// end of [dlnode_vtype]

(* ****** ****** *)

vtypedef dlnode (a:vt0p) = dlnode_vtype (a)

(* ****** ****** *)

extern
praxi dlnode_vfree {a:vt0p} (nx: dlnode (a)): void
extern
castfn
g2node_decode {a:vt0p} (nx: g2node1 (INV(a))):<> dlnode (a)
extern
castfn
g2node_encode {a:vt0p} (nx: dlnode (INV(a))):<> g2node1 (a)

(* ****** ****** *)

implement{a}
g2node_make_elt
  (x) = let
in
  $UN.castvwtp0{g2node1(a)}(DLNODE{a}(x, _, _))
end // end of [g2node_make_elt]

(* ****** ****** *)

implement{a}
g2node_free (nx) = let
  val nx = g2node_decode (nx)
  val~DLNODE (_, _, _) = (nx) in (*nothing*)
end // end of [g2node_free]

implement{a}
g2node_free_elt
  (nx, res) = let
  val nx = g2node_decode (nx)
  val~DLNODE (x, _, _) = (nx); val () = res := x in (*nothing*)
end // end of [g2node_free_elt]

implement{a}
g2node_getfree_elt
  (nx) = let
  val nx = g2node_decode (nx)
  val~DLNODE (x, _, _) = (nx) in x
end // end of [g2node_getfree_elt]

(* ****** ****** *)

implement(a)
gnode_getref_elt<mytkind><a>
  (nx) = let
//
val nx = g2node_decode (nx)
//
val+@DLNODE (elt, _, _) = nx
val p_elt = addr@ (elt)
prval ((*void*)) = fold@ (nx)
prval ((*void*)) = dlnode_vfree (nx)
//
in
  $UN.cast{cPtr1(a)}(p_elt)
end // end of [gnode_getref_elt]

(* ****** ****** *)

implement(a)
gnode_getref_next<mytkind><a>
  (nx) = let
//
val nx = g2node_decode (nx)
//
val+@DLNODE (_, next, _) = nx
val p_next = addr@ (next)
prval ((*void*)) = fold@ (nx)
prval ((*void*)) = dlnode_vfree (nx)
//
in
  $UN.cast{cPtr1(g2node0(a))}(p_next)
end // end of [gnode_getref_next]

(* ****** ****** *)

implement(a)
gnode_getref_prev<mytkind><a>
  (nx) = let
//
val nx = g2node_decode (nx)
//
val+@DLNODE (_, _, prev) = nx
val p_prev = addr@ (prev)
prval ((*void*)) = fold@ (nx)
prval ((*void*)) = dlnode_vfree (nx)
//
in
  $UN.cast{cPtr1(g2node0(a))}(p_prev)
end // end of [gnode_getref_prev]

(* ****** ****** *)

implement{a}
dllist_cons_ngc
  (nx0, xs) = let
//
val () =
  gnode_set_prev_null (nx0)
val nxs = dllist_decode (xs)
val () = gnode_link10 (nx0, nxs)
//
in
  dllist_encode (nx0)
end // end of [dllist_cons_ngc]

implement{a}
dllist_uncons_ngc
  (xs) = let
//
val nxs = dllist1_decode (xs)
val nxs2 = gnode_get_next (nxs)
val () = gnode0_set_prev_null (nxs2)
val () = xs := dllist_encode (nxs2)
//
in
  nxs
end // end of [dllist_uncons_ngc]

(* ****** ****** *)

implement{a}
dllist_snoc_ngc
  (xs, nx0) = let
//
val () = gnode_set_next_null (nx0)
val nxs = dllist_decode (xs)
val () = gnode_link01 (nxs, nx0)
//
in
  dllist_encode (nx0)
end // end of [dllist_snoc_ngc]

implement{a}
dllist_unsnoc_ngc
  (xs) = let
//
val nxs = dllist1_decode (xs)
val nxs2 = gnode_get_prev (nxs)
val () = gnode0_set_next_null (nxs2)
val () = xs := dllist_encode (nxs2)
//
in
  nxs
end // end of [dllist_unsnoc_ngc]

(* ****** ****** *)

(* end of [dllist.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: September, 2013 *)

(* ****** ****** *)
  
#define ATS_PACKNAME "ATSLIB.libats.stkarray"
#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names
  
(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libats/SATS/stkarray.sats"

(* ****** ****** *)

implement
{a}(*tmp*)
stkarray_make_cap
  (cap) = stk where
{
//
val A = arrayptr_make_uninitized<a> (cap)
//
val (pfat, pfgc | p) = ptr_alloc<stkarray_tsize> ()
//
val (pfngc | stk) = stkarray_make_ngc__tsz (pfat | p, A, cap, sizeof<a>)
//
prval ((*void*)) = mfree_gcngc_v_nullify (pfgc, pfngc)
//
} // end of [stkarray_make_cap]

(* ****** ****** *)

local

extern
fun stkarray_get_size__tsz{a:vt0p}
  {m,n:int} (stk: !stkarray (a, m, n), sizeof_t(a)):<> size_t(n) = "mac#%"
extern
fun stkarray_get_capacity__tsz{a:vt0p}
  {m,n:int} (stk: !stkarray (a, m, n), sizeof_t(a)):<> size_t(m) = "mac#%"

in (* in of [local] *)

implement{a}
stkarray_get_size (stk) = stkarray_get_size__tsz (stk, sizeof<a>)
implement{a}
stkarray_get_capacity (stk) = stkarray_get_capacity__tsz (stk, sizeof<a>)

end // end of [local]

(* ****** ****** *)

implement{}
fprint_stkarray$sep (out) = fprint (out, "<-")

implement{a}
fprint_stkarray
  (out, stk) = let
//
val n = stkarray_get_size (stk)
prval [n:int] EQINT () = eqint_make_guint (n)
//
implement
fprint_array$sep<> (out) = fprint_stkarray$sep (out)
//
val p_beg = stkarray_get_ptrbeg (stk)
val (pf, fpf | p_beg) = $UN.ptr_vtake{array(a,n)}(p_beg)
val () = fprint_array (out, !p_beg, n)
prval () = fpf (pf) // end of [prval]
//
in
  // nothing
end // end of [fprint_stkarray]

(* ****** ****** *)

implement{a}
fprint_stkarray_sep
  (out, stk, sep) = let
//
implement{}
fprint_stkarray$sep (out) = fprint_string (out, sep)
//
in
  fprint_stkarray<a> (out, stk)
end // end of [fprint_stkarray_sep]

(* ****** ****** *)

extern fun
stkarray_get_ptrcur{a:vt0p}
  {m,n:int} (stk: !stkarray (INV(a), m, n)):<> ptr = "mac#%"
// end of [stkarray_get_ptrcur]
extern fun
stkarray_set_ptrcur{a:vt0p}
  {m,n:int} (stk: !stkarray (INV(a), m, n), ptr):<!wrt> void = "mac#%"
// end of [stkarray_set_ptrcur]

(* ****** ****** *)

implement{a}
stkarray_insert
  {m,n} (stk, x0) = let
//
val p_cur = stkarray_get_ptrcur (stk)
val ((*void*)) = $UN.ptr0_set<a> (p_cur, x0)
val ((*void*)) = stkarray_set_ptrcur (stk, ptr_succ<a> (p_cur))
//
prval () = __assert (stk) where
{
extern praxi __assert (!stkarray (a, m, n) >> stkarray (a, m, n+1)): void
} (* end of [prval] *)
//
in
  // nothing
end // end of [stkarray_insert]

(* ****** ****** *)

implement{a}
stkarray_insert_opt
  (stk, x0) = let
//
val isnot = stkarray_isnot_full (stk)
//
in
//
if isnot then let
  val () = stkarray_insert (stk, x0) in None_vt()
end else Some_vt{a}(x0)
//
end // end of [stkarray_insert_opt]

(* ****** ****** *)

implement{a}
stkarray_takeout
  {m,n} (stk) = x0 where
{
//
val p_cur = stkarray_get_ptrcur (stk)
val p1_cur = ptr_pred<a> (p_cur)
val x0 = $UN.ptr0_get<a> (p1_cur)
val () = stkarray_set_ptrcur (stk, p1_cur)
//
prval () = __assert (stk) where
{
extern praxi __assert (!stkarray (a, m, n) >> stkarray (a, m, n-1)): void
} (* end of [prval] *)
//
} // end of [stkarray_takeout]

(* ****** ****** *)

implement{a}
stkarray_takeout_opt
  (stk) = let
//
val isnot = stkarray_isnot_nil (stk)
//
in
//
if isnot then let
  val x0 = stkarray_takeout (stk) in Some_vt{a}(x0)
end else None_vt((*void*))
//
end // end of [stkarray_takeout_opt]

(* ****** ****** *)

implement
{a}{env}
stkarray_foreach$cont (x, env) = true

implement{a}
stkarray_foreach (stk) = let
  var env: void = () in stkarray_foreach_env<a><void> (stk, env)
end // end of [stkarray_foreach]

(* ****** ****** *)

implement
{a}{env}
stkarray_foreach_env
  (stk, env) = let
//
implement
array_rforeach$cont<a><env>
  (x, env) = stkarray_foreach$cont<a><env> (x, env)
implement
array_rforeach$fwork<a><env>
  (x, env) = stkarray_foreach$fwork<a><env> (x, env)
//
val n = stkarray_get_size (stk)
prval [n:int] EQINT () = eqint_make_guint (n)
val p0 = stkarray_get_ptrbeg (stk)
val (pf, fpf | p0) = $UN.ptr0_vtake{array(a,n)}(p0)
val res = array_rforeach_env<a><env> (!p0, n, env)
prval ((*void*)) = fpf (pf)
//
in
  res
end // end of [stkarray_foreach_env]

(* ****** ****** *)

(* end of [stkarray.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: December, 2012 *)

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.linmap_skiplist"
#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libats/SATS/linmap_skiplist.sats"

(* ****** ****** *)

#include "./SHARE/linmap.hats" // code reuse

(* ****** ****** *)

stadef mytkind = $extkind"atslib_linmap_skiplist"

(* ****** ****** *)
//
%{^
//
#include <time.h>
//
// HX: it is in stdlib.h
//
extern void srand48 (time_t);
//
%}
typedef time_t = $extype"time_t"
//
(* ****** ****** *)

implement
linmap_skiplist_initize
  ((*void*)) = let
//
val seed = $extfcall (time_t, "time", 0)
//
in
  $extfcall (void, "srand48", seed)
end // end of [linmap_skiplist_initize]

(* ****** ****** *)

#define lgMAX 40 // HX: 2^40 >= 10^12

(* ****** ****** *)

extern
fun
linmap_random_lgN
  {n:int | n >= 1} (lgMAX: int(n)): intBtwe(1, n)
// end of [linmap_random_lgN]

(* ****** ****** *)

abstype
sknode_type
(
  key:t@ype, itm:vt@ype+, l:addr, n:int
) = ptr (l) // end of [sknode_type]

(* ****** ****** *)

stadef sknode = sknode_type // HX: a shorthand

(* ****** ****** *)

typedef
sknode0
(
  key:t0p
, itm:vt0p
, n:int
) = [l:addr] sknode (key, itm, l, n)
typedef
sknode0
(
  key:t0p
, itm:vt0p
) = [l:addr;n:nat] sknode (key, itm, l, n)

(* ****** ****** *)

typedef
sknode1
(
  key:t0p
, itm:vt0p
, n:int
) = [l:agz] sknode (key, itm, l, n)
typedef
sknode1
(
  key:t0p
, itm:vt0p
) = [l:agz;n:nat] sknode (key, itm, l, n)

(* ****** ****** *)

typedef
sknodeGt0
(
  key:t0p, itm:vt0p, ni:int
) = [n:int | n > ni] sknode0 (key, itm, n)

(* ****** ****** *)

extern
castfn
sknode2ptr
  {key:t0p;itm:vt0p}{l:addr}{n:int}
  (nx: sknode (key, INV(itm), l, n)):<> ptr (l)
// end of [sknode2ptr]

(* ****** ****** *)

#define nullp the_null_ptr

(* ****** ****** *)

extern
fun{
} sknode_null
  {key:t0p;itm:vt0p}
  {n:nat} (n: int n):<> sknode (key, itm, null, n)
implement{} sknode_null (n) = $UN.castvwtp0 (nullp)

(* ****** ****** *)

extern
fun
{key:t0p
;itm:vt0p}
sknode_make
  {lgN:int | lgN > 0}
  (k0: key, x0: itm, lgN: int lgN): sknode1 (key, itm, lgN)
// end of [sknode_make]
extern
fun
{key:t0p
;itm:vt0p}
sknode_free
  {lgN:int | lgN > 0}
  (nx: sknode1 (key, INV(itm), lgN), res: &itm? >> itm): void
// end of [sknode_free]

(* ****** ****** *)

extern
fun{
key:t0p;itm:vt0p
} sknode_get_key (nx: sknode1 (key, INV(itm))):<> key
extern
fun{
key:t0p;itm:vt0p
} sknode_getref_item (nx: sknode1 (key, INV(itm))):<> cPtr1 (itm)

(* ****** ****** *)
//
abstype
sknodelst_type
  (key:t@ype, itm:vt@ype+, int(*size*)) = ptr
//
(* ****** ****** *)

stadef sknodelst = sknodelst_type // HX: a shorthand

(* ****** ****** *)
//
// HX: initized with nulls
//
extern
fun{}
sknodelst_make
  {key:t0p;itm:vt0p}{n:nat} (n: int n):<!wrt> sknodelst (key, itm, n)
// end of [sknodelst_make]

(* ****** ****** *)
//
extern
fun{}
sknodelst_get_at
  {key:t0p;itm:vt0p}
  {n:int}{i:nat | i < n}
  (nxa: sknodelst (key, INV(itm), n), i: int i):<> sknodeGt0 (key, itm, i)
// end of [sknodelst_get_at]
extern
fun{}
sknodelst_set_at
  {key:t0p;itm:vt0p}
  {n:int}{i:nat | i < n}
(
  nxa: sknodelst (key, INV(itm), n), i: int i, nx0: sknodeGt0 (key, itm, i)
) :<!wrt> void // end of [sknodelst_set_at]
//
overload [] with sknodelst_get_at
overload [] with sknodelst_set_at
//
(* ****** ****** *)

extern
fun{
key:t0p;itm:vt0p
} sknode_get_sknodelst{n:nat}
  (nx: sknode1 (key, INV(itm), n)) :<> sknodelst (key, itm, n)
// end of [sknode_get_sknodelst]

extern
fun{
key:t0p;itm:vt0p
} sknode_get_sknodelen{n:nat} (nx: sknode1 (key, INV(itm), n)):<> int (n)

(* ****** ****** *)
//
// HX: internal representation of a sknode
//
vtypedef
sknode_struct
(
  key: t0p, itm: vt0p
) = // sknode_struct
@{
  key= key, item=itm, sknodelst=ptr, sknodelen= int
} (* end of [sknode_struct] *)

(* ****** ****** *)

implement
{key,itm}
sknode_make
  {lgN} (
  k0, x0, lgN
) = let
  vtypedef VT = sknode_struct (key, itm)
  val (pfat, pfgc | p) = ptr_alloc<VT> ()
  val () = p->key := k0
  val () = p->item := $UN.castvwtp0{itm?}{itm}(x0)
  val () = p->sknodelst := $UN.cast{ptr}(sknodelst_make(lgN))
  val () = p->sknodelen := lgN
in
  $UN.castvwtp0 {sknode1(key,itm,lgN)}((pfat, pfgc | p))
end // end of [sknode_make]

(* ****** ****** *)

implement
{key,itm}
sknode_free
  (nx, res) = let
//
vtypedef VT = sknode_struct (key, itm)
//
val (
  pfat, pfgc | p
) = __cast (nx) where
{
  extern
  castfn __cast
  (
    nx: sknode1 (key, itm)
  ) :<> [l:addr] (VT @ l, mfree_gc_v l | ptr l)
} // end of [prval]
//
val () = res := p->item
val (
) = $extfcall (void, "ATS_MFREE", p->sknodelst)
val () = ptr_free {VT?} (pfgc, pfat | p)
//
in
  // nothing
end // end of [sknode_free]

(* ****** ****** *)

extern
castfn
__cast_sknode
  {key:t0p;itm:vt0p}
(
  nx: sknode1 (key, INV(itm))
) :<> [l:addr]
(
  sknode_struct (key, itm) @ l
, sknode_struct (key, itm) @ l -<lin,prf> void
| ptr l
) // end of [__cast_sknode]

(* ****** ****** *)

implement
{key,itm}
sknode_get_key
  (nx) = let
//
val (pf, fpf | p) = __cast_sknode (nx)
val key = p->key
prval () = fpf (pf)
//
in
  key
end // end of [sknode_get_key]

implement
{key,itm}
sknode_getref_item
  (nx) = let
//
val (pf, fpf | p) = __cast_sknode (nx)
val p2 = addr@(p->item)
prval () = fpf (pf)
//
in
  $UN.cast{cPtr1(itm)}(p2)
end // end of [sknode_getref_item]

implement
{key,itm}
sknode_get_sknodelst
  {n} (nx) = let
//
val (pf, fpf | p) = __cast_sknode (nx)
val nxa = p->sknodelst
prval () = fpf (pf)
//
in
  $UN.cast{sknodelst(key,itm,n)}(nxa)
end // end of [sknode_get_sknodelst]

implement
{key,itm}
sknode_get_sknodelen
  {n} (nx) = let
//
val (pf, fpf | p) = __cast_sknode (nx)
val len = p->sknodelen
prval () = fpf (pf)
//
in
  $UN.cast{int(n)}(len)
end // end of [sknode_get_sknodelen]

(* ****** ****** *)

local

assume
sknodelst_type
  (key:t0p, itm:vt0p, n:int) = arrayref (ptr, n)
// end of [sknodelst_type]

in (* in of [local] *)

implement{}
sknodelst_make (n) = let
  val asz = i2sz(n) in arrayref_make_elt<ptr> (asz, nullp)
end // end of [sknodelst]

implement{}
sknodelst_get_at
  {key,itm}{i}
  (nxa, i) = let
  typedef T = sknodeGt0 (key, itm, i)
  val nx0 = $effmask_ref (arrayref_get_at (nxa, i)) in $UN.cast{T}(nx0)
end // end of [sknodelst_get_at]

implement{}
sknodelst_set_at
  {key,itm}{i}
  (nxa, i, nx0) = let
  val nx0 = $UN.cast{ptr} (nx0) in $effmask_ref (arrayref_set_at (nxa, i, nx0))
end // end of [sknodelst_set_at]

end // end of [local]

(* ****** ****** *)

extern
fun{
key:t0p;itm:vt0p
} sknode_get_next
  {n:int}{ni:nat | ni < n}
  (nx: sknode1 (key, INV(itm), n), ni: int ni):<> sknodeGt0 (key, itm, ni)
// end of [sknode_get_next]

extern
fun{
key:t0p;itm:vt0p
} sknode_set_next
  {n,n1:int}{ni:nat | ni < n} (
  nx: sknode1 (key, INV(itm), n), ni: int ni, nx0: sknodeGt0 (key, itm, ni)
) :<!wrt> void // end of [sknode_set_next]

(* ****** ****** *)

implement
{key,itm}
sknode_get_next (nx, ni) = let
  val nxa = sknode_get_sknodelst (nx) in nxa[ni]
end // end of [sknode_get_next]

implement
{key,itm}
sknode_set_next (nx, ni, nx0) = let
  val nxa = sknode_get_sknodelst (nx) in nxa[ni] := nx0
end // end of [sknode_set_next]

(* ****** ****** *)

datavtype
skiplist (
  key:t@ype, itm:vt@ype+
) = // HX: [lgN] is the *current* highest level
  | {N:nat}{lgN:nat | lgN <= lgMAX}
    SKIPLIST (key, itm) of (size_t(N), int(lgN), sknodelst(key, itm, lgMAX))
// end of [skiplist]

(* ****** ****** *)

assume
map_vtype
  (key:t0p, itm:vt0p) = skiplist (key, itm)
// end of [map_vtype]

(* ****** ****** *)

implement{}
linmap_make_nil () =
  SKIPLIST (i2sz(0), 0, sknodelst_make (lgMAX))
// end of [linmap_make_nil]

(* ****** ****** *)

implement{}
linmap_is_nil (map) = let
//
val+SKIPLIST (N, _, _) = map
//
in
  if N = i2sz(0) then true else false
end // end of [linmap_is_nil]

implement{}
linmap_isnot_nil (map) = let
//
val+SKIPLIST (N, _, _) = map
//
in
  if N > i2sz(0) then true else false
end // end of [linmap_isnot_nil]

(* ****** ****** *)

implement
{key,itm}
linmap_size (map) =
  let val+SKIPLIST (N, _, _) = map in N end
// end of [linmap_size]

(* ****** ****** *)
//
// HX:
// for [sknode_search] to be called, k0 > the key contained in it
//
extern
fun{
key:t0p;itm:vt0p
} sknode_search {n:int}
  (nx: sknode1 (key, INV(itm), n), k0: key, ni: natLte n):<> sknode0 (key, itm)
// end of [sknode_search]
extern
fun{
key:t0p;itm:vt0p
} sknodelst_search {n:int}
  (nxa: sknodelst (key, INV(itm), n), k0: key, ni: natLte n):<> sknode0 (key, itm)
// end of [sknodelst_search]
//
(* ****** ****** *)

implement
{key,itm}
sknode_search
  (nx, k0, ni) = let
in
//
if ni > 0 then let
  val ni1 = pred(ni)
  val nx1 = sknode_get_next (nx, ni1)
  val p_nx1 = sknode2ptr (nx1)
in
//
if p_nx1 > 0 then let
  val k1 = sknode_get_key (nx1)
  val sgn = compare_key_key<key> (k0, k1)
in
  if sgn < 0 then
    sknode_search (nx, k0, ni1)
  else if sgn > 0 then
    sknode_search (nx1, k0, ni)
  else nx1 // end of [if]
end else
  sknode_search (nx, k0, ni1)
// end of [if]
//
end else sknode_null (0)
//
end // end of [sknode_search]

(* ****** ****** *)

implement
{key,itm}
sknodelst_search
  (nxa, k0, ni) = let
in
//
if ni > 0 then let
  val ni1 = pred(ni)
  val nx = nxa[ni1]
  val p_nx = sknode2ptr (nx)
in
  if p_nx > 0 then let
    val k = sknode_get_key (nx)
    val sgn = compare_key_key<key> (k0, k)
  in
    if sgn < 0 then
      sknodelst_search (nxa, k0, ni1)
    else if sgn > 0 then
      sknode_search (nx, k0, ni)
    else nx // end of [if]
  end else
    sknodelst_search (nxa, k0, ni1)  
  // end of [if]
end else
  sknode_null (0)
// end of [if]
//
end // end of [sknodelst_search]

(* ****** ****** *)

implement
{key,itm}
linmap_search_ref
  (map, k0) = let
in
//
case+ map of
| SKIPLIST
    (N, lgN, nxa) => let
    val nx =
      sknodelst_search (nxa, k0, lgN)
    val p_nx = sknode2ptr (nx)
  in
    if p_nx > 0
      then sknode_getref_item (nx) else cptr_null ()
    // end of [if]
  end // end of [SKIPLIST]
//
end // end of [linmap_search_ref]

(* ****** ****** *)
//
// HX:
// for [sknode_insert] to be called, k0 > the key contained in it
//
extern
fun{
key:t0p;itm:vt0p
} sknode_insert {n:int}{ni:nat | ni <= n} (
  nx: sknode1 (key, INV(itm), n), k0: key, ni: int ni, nx0: sknode1 (key, itm)
) : void // end of [sknode_insert]
extern
fun{
key:t0p;itm:vt0p
} sknodelst_insert {n:int}{ni:nat | ni <= n} (
  nxa: sknodelst (key, INV(itm), n), k0: key, ni: int ni, nx0: sknode1 (key, itm)
) : void // end of [sknodelst_insert]
//
(* ****** ****** *)

implement
{key,itm}
sknode_insert
  (nx, k0, ni, nx0) = let
in
//
if ni > 0 then let
  val ni1 = pred(ni)
  val nx1 = sknode_get_next (nx, ni1)
  val p_nx1 = sknode2ptr (nx1)
in
  if p_nx1 > 0 then let
    val k1 = sknode_get_key (nx1)
    val sgn = compare_key_key<key> (k0, k1)
  in
    if sgn <= 0 then let
      val n0 = sknode_get_sknodelen (nx0)
      val () =
      if (n0 >= ni) then
      {
        val () = sknode_set_next (nx, ni1, nx0)
        val () = sknode_set_next (nx0, ni1, nx1)
      } // end of [if] // end of [val]
    in
      sknode_insert (nx, k0, ni1, nx0)
    end else
      sknode_insert (nx1, k0, ni, nx0)
    // end of [if]
  end else let
    val n0 = sknode_get_sknodelen (nx0)
    val () =
      if (n0 >= ni) then sknode_set_next (nx, ni1, nx0)
    // end of [val]
  in
    sknode_insert (nx, k0, ni1, nx0)
  end // end of [if]
end else (
  // nothing
) // end of [if]
//
end // end of [sknode_insert]

(* ****** ****** *)

implement
{key,itm}
sknodelst_insert
  (nxa, k0, ni, nx0) = let
in
//
if ni > 0 then let
  val ni1 = pred(ni)
  val nx = nxa[ni1]
  val p_nx = sknode2ptr (nx)
in
  if p_nx > 0 then let
    val k = sknode_get_key (nx)
    val sgn = compare_key_key<key> (k0, k)
  in
    if sgn <= 0 then let
      val n0 = sknode_get_sknodelen (nx0)
      val () =
      if (n0 >= ni) then {
        val () = nxa[ni1] := nx0
        val () = sknode_set_next (nx0, ni1, nx)
      } // end of [if] // end of [val]
    in
      sknodelst_insert (nxa, k0, ni1, nx0)
    end else
      sknode_insert (nx, k0, ni, nx0)
    // end of [if]
  end else let
    val n0 = sknode_get_sknodelen (nx0)
    val () = if (n0 >= ni) then nxa[ni1] := nx0
  in
    sknodelst_insert (nxa, k0, ni1, nx0)
  end // end of [if]
end else (
  // nothing
) // end of [if]
//
end // end of [sknodelst_insert]

(* ****** ****** *)

implement
{key,itm}
linmap_insert
  (map, k0, x0, res) = let
//
val p_itm =
  linmap_search_ref (map, k0)
val isnot = cptr2ptr(p_itm) > 0
//
in
//
if isnot then let
  val (pf, fpf | p_itm) = $UN.cptr_vtake (p_itm)
  val () = res := !p_itm
  prval () = opt_some{itm}(res)
  val () = (!p_itm := x0)
  prval () = fpf (pf)
in
  true
end else let
  val () = linmap_insert_any (map, k0, x0)
  prval () = opt_none{itm}(res)
in
  false
end // end of [if]
//
end // end of [linmap_insert]

(* ****** ****** *)

implement
{key,itm}
linmap_insert_any
  (map, k0, x0) = let
//
val lgN0 = linmap_random_lgN (lgMAX)
val nx_new = sknode_make<key,itm> (k0, x0, lgN0)
//
in
//
case+ map of
| @SKIPLIST
    (N, lgN, nxa) => let
    val () = N := succ (N)
    val () =
    (
      if :(
        lgN: natLte (lgMAX)
      ) =>
        (lgN < lgN0) then lgN := lgN0
      // end of [if]
    ) : void // end of [val]
    val () = sknodelst_insert (nxa, k0, lgN0, nx_new)
    prval () =
      pridentity_vt (lgN) // for opening the type of [lgN]
    prval () = fold@ (map)
  in
    // nothing
  end // end of [SKIPLIST]
//
end // end of [linmap_insert_any]

(* ****** ****** *)
//
// HX:
// for [sknode_takeout] to be called, k0 > the key contained in it
//
extern
fun{
key:t0p;itm:vt0p
} sknode_takeout
  {n:int}{ni:nat | ni <= n}
  (nx: sknode1 (key, INV(itm), n), k0: key, ni: int ni): sknodeGt0 (key, itm, 0)
// end of [sknode_takeout]
extern
fun{
key:t0p;itm:vt0p
} sknodelst_takeout
  {n:int}{ni:nat | ni <= n}
  (nxa: sknodelst (key, INV(itm), n), k0: key, ni: int ni): sknodeGt0 (key, itm, 0)
// end of [sknodelst_takeout]
//
(* ****** ****** *)

implement
{key,itm}
sknode_takeout
  (nx, k0, ni) = let
in
//
if ni > 0 then let
  val ni1 = pred(ni)
  val nx1 = sknode_get_next (nx, ni1)
  val p_nx1 = sknode2ptr (nx1)
in
  if p_nx1 > 0 then let
    val k1 = sknode_get_key (nx1)
    val sgn = compare_key_key<key> (k0, k1)
  in
    if sgn < 0 then
      sknode_takeout (nx, k0, ni1)
    else if sgn > 0 then
      sknode_takeout (nx1, k1, ni)
    else let // sgn = 0
      val () =
        sknode_set_next (nx, ni1, sknode_get_next (nx1, ni1))
      // end of [val]
    in
      if ni1 > 0 then sknode_takeout (nx, k0, ni1) else nx1
    end // end of [if]
  end else
    sknode_takeout (nx, k0, ni1)
  // end of [if]
end else
  sknode_null (1)
// end of [of]
//
end // end of [sknode_takeout]

(* ****** ****** *)

implement
{key,itm}
sknodelst_takeout
  (nxa, k0, ni) = let
in
//
if ni > 0 then let
  val ni1 = pred(ni)
  val nx = nxa[ni1]
  val p_nx = sknode2ptr (nx)
in
  if p_nx > 0 then let
    val k = sknode_get_key (nx)
    val sgn = compare_key_key<key> (k0, k)
  in
    if sgn < 0 then
      sknodelst_takeout (nxa, k0, ni1)
    else if sgn > 0 then
      sknode_takeout (nx, k0, ni)
    else let // sgn = 0
      val () = nxa[ni1] := sknode_get_next (nx, ni1)
    in
      if ni1 > 0 then sknodelst_takeout (nxa, k0, ni1) else nx
    end
  end else
    sknodelst_takeout (nxa, k0, ni1)
  // end of [if]
end else
  sknode_null (1)
// end of [if]
//
end // end of [sknodelst_takeout]

(* ****** ****** *)

implement
{key,itm}
linmap_takeout
  (map, k0, res) = let
in
//
case+ map of
| @SKIPLIST
    (N, lgN, nxa) => let
    val nx = sknodelst_takeout (nxa, k0, lgN)
    val p_nx = sknode2ptr (nx)
  in
    if p_nx > 0 then let
      prval (
      ) = __assert (N) where
      {
        extern praxi __assert {N:int} (N: size_t N): [N>0] void
      } // end of [where] // end of [prval]
      val () = N := pred (N)
      prval () = fold@ (map)
      val () = sknode_free (nx, res)
      prval () = opt_some{itm}(res)
    in
      true
    end else let
      prval () = fold@ (map)
      prval () = opt_none{itm}(res)
    in
      false
    end // end of [if]
  end // end of [SKIPLIST]
//
end // end of [linmap_takeout]

(* ****** ****** *)

implement
{key,itm}{env}
linmap_foreach_env
  (map, env) = let
//
fun
sknode_foreach_env
(
  nx: sknodeGt0 (key, itm, 0), env: &env
) : void = let
//
val p_nx = sknode2ptr (nx)
//
in
//
if p_nx > 0 then let
  val k = sknode_get_key (nx)
  val p_i = sknode_getref_item (nx)
  val nx1 = sknode_get_next<key,itm> (nx, 0)
//
  val (pf, fpf | p_i) = $UN.cptr_vtake{itm}(p_i)
  val () =
    linmap_foreach$fwork<key,itm><env> (k, !p_i, env)
  prval () = fpf (pf)
//
in
  sknode_foreach_env (nx1, env)
end else () // end of [if]
//
end // end of [sknode_foreach_env]
//
in
//
case+ map of
| SKIPLIST
    (N, lgN, nxa) => let
    val nx = nxa[0]
    val () = sknode_foreach_env (nx, env)
  in
    // nothing
  end // end of [SKIPLIST]
//
end // end of [linmap_foreach_env]

(* ****** ****** *)

implement
{key,itm}
linmap_freelin
  (map) = let
//
fun
sknode_freelin
(
  nx: sknodeGt0 (key, itm, 0)
) : void = let
//
val p_nx = sknode2ptr (nx)
//
in
//
if p_nx > 0 then let
//
val cp = sknode_getref_item (nx)
val nx1 = sknode_get_next<key,itm> (nx, 0)
//
prval (pf, fpf) =
__assert (cp) where
{
  extern praxi
  __assert{l:addr}
    (cp: cptr (itm, l)): (itm @ l, itm? @ l -<lin,prf> void)
} // end of [prval]
val p_i = cptr2ptr (cp)
val () = linmap_freelin$clear<itm> (!p_i)
prval () = fpf (pf)
//
val () = $extfcall (void, "ATS_MFREE", nx)
//
in
  sknode_freelin (nx1)
end else () // end of [if]
//
end // end of [sknode_freelin]
//
in
//
case+ map of
| ~SKIPLIST
    (N, lgN, nxa) => let
    val nx0 = nxa[0]
    val () =
    $extfcall (void, "ATS_MFREE", nxa)
  in
    $effmask_all (sknode_freelin (nx0))
  end // end of [SKIPLIST]
//
end // end of [linmap_freelin]

(* ****** ****** *)

implement
{key,itm}
linmap_free_ifnil
  (map) = let
//
vtypedef map = map (key, itm)
val map2 =
  __cast (map) where
{
  extern castfn __cast : (!map >> map?) -<> map
} // end of [where] // end of [val]
//
in
//
case+ map2 of
| @SKIPLIST
    (N, lgN, nxa) => let
  in
    if N = i2sz(0) then let
      val nxa_ = nxa
      val () = free@{..}{0}{0}(map2)
      val () = $extfcall (void, "ATS_MFREE", nxa_)
      prval () = opt_none{map}(map)
    in
      false
    end else let
      prval () = fold@ (map2)
      prval (
      ) = __assert (map, map2) where
      {
        extern praxi __assert : (!map? >> map, map) -<prf> void
      } // end of [prval]
      prval () = opt_some{map}(map)
    in
      true
    end // end of [if]
  end // end of [SKIPLIST]
//
end // end of [linmap_free_ifnil]

(* ****** ****** *)

local
//
staload "libc/SATS/stdlib.sats"
//
staload INT = "prelude/DATS/integer.dats"
staload FLOAT = "prelude/DATS/float.dats"
//
in (* in of [local] *)

implement
linmap_random_lgN
  (n) = let
//
fun loop
  {n:int}
  {i:int | 1 <= i; i <= n}
  .<n-i>. (
  n: int n, i: int i, r: double
) :<> intBtwe (1, n) = let
in
//
if i < n then
  if (r <= 0.5) then loop (n, i+1, r+r) else i
else n // end of [if]
//
end // end of [loop]
//
val r = drand48 () // HX: containing ref-effect!
//
in
  loop (n, 1, r)
end // end of [linmap_random_lgN]

end // end of [local]

(* ****** ****** *)

(* end of [linmap_skiplist.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: hwxiATcsDOTbuDOTedu
// Time: October, 2010
//
(* ****** ****** *)
//
// HX: generic functional lists (fully indexed)
//
(* ****** ****** *)
//
// HX-2012-11-28: ported to ATS/Postiats from ATS/Anairiats
//
(* ****** ****** *)

staload "libats/SATS/ilist_prf.sats"

(* ****** ****** *)

staload "libats/SATS/gflist.sats"
staload "libats/SATS/gflist_vt.sats"

(* ****** ****** *)

implement
{a}(*tmp*)
gflist_length (xs) = let
//
val (pf | xs) = gflist2list (xs)
//
in
  (pf | list_length<a> (xs))
end // end of [gflist_length]

(* ****** ****** *)
//
implement
{a}(*tmp*)
gflist_snoc
  {xs}{x0}(xs, x0) = let
//
fun
loop
{xs:ilist}
(
  xs: gflist (a, xs)
, x0: stamped_t (a, x0)
, res: &ptr? >> gflist_vt(a, xsx)
) : #[xsx:ilist] (SNOC(xs, x0, xsx) | void) =
(
//
case+ xs of
| gflist_nil() => let
    val x0 = stamped_t2vt(x0)
    val () =
      res := gflist_vt_sing(x0)
    // end of [val]
  in
    (SNOCnil() | ())
  end // end of [gflist_nil]
| gflist_cons(x, xs) => let
    val x = stamped_t2vt(x)
    val () =
      res := gflist_vt_cons(x, _)
    // end of [val]
    val+gflist_vt_cons(_, res1) = res
    val (pf1 | ()) = loop (xs, x0, res1)
    prval () = fold@(res)
  in
    (SNOCcons(pf1) | ())
  end // end of [gflist_cons]
//
) (* end of [loop] *)
//
var res: ptr? // uninitialized
val (pfsnoc | ()) = loop (xs, x0, res)
//
in
  (pfsnoc | res)
end (* end of [gflist_snoc] *)

(* ****** ****** *)

implement
{a}(*tmp*)
gflist_copy (xs) = let
//
fun loop
  {xs:ilist} .<xs>.
(
  xs: gflist (a, xs), res: &ptr? >> gflist_vt (a, xs)
) :<!wrt> void = let
in
//
case+ xs of
| gflist_nil() =>
    (res := gflist_vt_nil())
  // end of [gflist_nil]
| gflist_cons(x, xs1) => let
    val x = stamped_t2vt (x)
    val () =
    res := gflist_vt_cons(x, _)
    val+
    gflist_vt_cons (_, res1) = res
    val ((*void*)) = loop (xs1, res1)
    prval ((*void*)) = fold@ (res)
  in
    // nothing
  end // end of [gflist_vt_cons]
end // end of [loop]
//
var res: ptr // uninitialized
//
val () = $effmask_wrt (loop (xs, res))
//
in
  res
end // end of [gflist_copy]

(* ****** ****** *)

implement
{a}(*tmp*)
gflist_append
  (xs1, xs2) = let
//
fun loop
  {xs1:ilist}
  {xs2:ilist} .<xs1>.
(
  xs1: gflist (a, xs1)
, xs2: gflist (a, xs2)
, res: &ptr? >> gflist (a, ys)
) :<!wrt> #[ys:ilist] (APPEND(xs1, xs2, ys) | void) = let
in
//
case+ xs1 of
| gflist_nil() => let
    val () = res := xs2
  in
    (APPENDnil() | ())
  end // end of [gflist_nil]
| gflist_cons(x1, xs1) => let
    val () =
    res := gflist_cons(x1, _)
    val+gflist_cons(_, res1) = res
    val (pf | ()) = loop (xs1, xs2, res1)
    prval () = fold@ (res)
  in
    (APPENDcons(pf) | ())
  end // end of [gflist_cons]
//
end // end of [loop]
//
var res: ptr // uninitialized
//
val (pf | ()) = $effmask_wrt(loop (xs1, xs2, res))
//
in
  (pf | res)
end // end of [gflist_append]

(* ****** ****** *)

implement
{a}(*tmp*)
gflist_revapp
  (xs1, xs2) = let
//
fun loop
  {xs1,xs2:ilist} .<xs1>.
(
  xs1: gflist (a, xs1), xs2: gflist (a, xs2)
) :<> [res:ilist]
  (REVAPP (xs1, xs2, res) | gflist (a, res)) = let
in
//
case+ xs1 of
//
| gflist_nil() =>
    (REVAPPnil () | xs2)
  // end of [gflist_nil]
//
| gflist_cons(x1, xs1) => let
    val (pf | res) = loop (xs1, gflist_cons(x1, xs2))
  in
    (REVAPPcons (pf) | res)
  end // end of [gflist_cons]
//
end // end of [loop]
//
in
  loop (xs1, xs2)
end // end of [gflist_revapp]

(* ****** ****** *)

implement
{a}(*tmp*)
gflist_revapp1_vt
  (xs1, xs2) = let
//
val xs2 =
  __cast (xs2) where {
  extern
  castfn
  __cast{xs2:ilist}
    (gflist (a, xs2)):<> gflist_vt (a, xs2)
  // end of [castfn]
} (* end of [val] *)
val (pf | ys) = gflist_vt_revapp<a> (xs1, xs2)
//
in
  (pf | gflist_vt2t{a}(ys))
end // end of [gflist_revapp1_vt]

(* ****** ****** *)

implement
{a}(*tmp*)
gflist_revapp2_vt
  (xs1, xs2) = let
//
fun loop
  {xs1,xs2:ilist} .<xs1>.
(
  xs1: gflist (a, xs1), xs2: gflist_vt (a, xs2)
) :<> [res:ilist]
  (REVAPP (xs1, xs2, res) | gflist_vt (a, res)) = let
in
//
case+ xs1 of
| gflist_nil() =>
    (REVAPPnil () | xs2)
  // end of [gflist_nil]
| gflist_cons(x1, xs1) => let
    val x1 = stamped_t2vt (x1)
    val (pf | res) = loop (xs1, gflist_vt_cons(x1, xs2))
  in
    (REVAPPcons (pf) | res)
  end // end of [gflist_cons]
//
end // end of [loop]
//
in
  loop (xs1, xs2)
end // end of [gflist_revapp2_vt]

(* ****** ****** *)

implement
{a}(*tmp*)
gflist_reverse (xs) =
  $effmask_wrt (gflist_revapp2_vt<a> (xs, gflist_vt_nil))
// end of [gflist_reverse]

(* ****** ****** *)

implement
{a}(*tmp*)
gflist_get_at
  {xs}{x0}{i}
  (pf | xs, i) = let
//
fun
loop
{xs:ilist}{i:int}
(
  pf: NTH(x0, xs, i)
| xs: gflist(a, xs), i: int(i)
) : stamped_t(a, x0) = let
//
prval
ILISTEQ() =
lemma_nth_param(pf)
//
val+gflist_cons(x, xs) = xs
//
in
//
if
i = 0
then let
  prval NTHbas() = pf in x
end // end of [then]
else let
  prval NTHind(pf) = pf in loop(pf | xs, i-1)
end // end of [else]
//
end // end of [loop]
//
in
  loop (pf | xs, i)
end (* end of [gflist_get_at] *)

(* ****** ****** *)

implement
{a}(*tmp*)
gflist_mergesort
  (xs) = let
//
val xs = gflist_copy<a>(xs)
//
implement(a:t0p)
gflist_vt_mergesort$cmp<a>
  (x1, x2) =
  gflist_mergesort$cmp<a>(stamped_vt2t_ref(x1), stamped_vt2t_ref(x2))
//
in
  gflist_vt_mergesort<a>(xs)
end // end of [gflist_mergesort]

(* ****** ****** *)

(* end of [gflist.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (hwxi AT cs DOT bu DOT edu)
// Time: December, 2012
//
(* ****** ****** *)
//
// HX: generic nodes: singly-linked, doubly-linked, ...
//
(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libats/SATS/gnode.sats"

(* ****** ****** *)

#define nullp the_null_ptr

(* ****** ****** *)

implement{
} gnode_null
  {tk}{a}() = $UN.cast{gnode(tk,a,null)}(nullp)
// end of [gnode_null]

(* ****** ****** *)

implement{
} gnode_is_null
  {tk}{a}{l}(nx) = let
  val p = $UN.cast{ptr}(nx) in $UN.cast{bool(l==null)}(p = nullp)
end // end of [gnode_is_null]

implement{}
gnode_isnot_null
  {tk}{a}{l}(nx) = let
  val p = $UN.cast{ptr}(nx) in $UN.cast{bool(l > null)}(p > nullp)
end // end of [gnode_isnot_null]

(* ****** ****** *)

implement
{tk}{elt}
gnode_get_elt
  (nx) = let
  val p = gnode_getref_elt (nx) in $UN.cptr_get<elt> (p)
end // end of [gnode_get_elt]

implement
{tk}{elt}
gnode_set_elt
  (nx, x0) = let
  val p = gnode_getref_elt (nx) in $UN.cptr_set<elt> (p, x0)
end // end of [gnode_set_elt]

(* ****** ****** *)

implement
{tk}{elt}
gnode_get_next
  (nx) = nx2 where {
  val p = gnode_getref_next (nx)
  val nx2 = $UN.cptr_get<gnode0(tk,elt)> (p)
} // end of [gnode_get_next]

implement
{tk}{elt}
gnode_set_next
  (nx, nx2) = () where {
  val p = gnode_getref_next (nx)
  val () = $UN.cptr_set<gnode(tk,elt)> (p, nx2)
} // end of [gnode_set_next]

implement
{tk}{elt}
gnode0_set_next
  (nx, nx2) = let
in
  if gnode_isnot_null (nx) then gnode_set_next (nx, nx2)
end // end of [gnode0_set_next]

(* ****** ****** *)

implement
{tk}{elt}
gnode_set_next_null
  (nx) = gnode_set_next (nx, gnode_null ())
// end of [gnode_set_next_null]

implement
{tk}{elt}
gnode0_set_next_null (nx) = let
in
  if gnode_isnot_null (nx) then gnode_set_next_null (nx)
end // end of [gnode0_set_next_null]

(* ****** ****** *)

implement
{tk}{elt}
gnode_get_prev
  (nx) = nx2 where {
  val p = gnode_getref_prev (nx)
  val nx2 = $UN.cptr_get<gnode0(tk,elt)> (p)
} // end of [gnode_get_prev]

implement
{tk}{elt}
gnode_set_prev
  (nx, nx2) = () where {
  val p = gnode_getref_prev (nx)
  val () = $UN.cptr_set<gnode(tk,elt)> (p, nx2)
} // end of [gnode_set_prev]

implement
{tk}{elt}
gnode0_set_prev
  (nx, nx2) = let
in
  if gnode_isnot_null (nx) then gnode_set_prev (nx, nx2)
end // end of [gnode0_set_prev]

(* ****** ****** *)

implement
{tk}{elt}
gnode_set_prev_null
  (nx) = gnode_set_prev (nx, gnode_null ())
// end of [gnode_set_prev_null]

implement
{tk}{elt}
gnode0_set_prev_null (nx) = let
in
  if gnode_isnot_null (nx) then gnode_set_prev_null (nx)
end // end of [gnode0_set_prev_null]

(* ****** ****** *)

(*
implement
{tk}{elt}
gnode_link = gnode_link11
*)

implement
{tk}{elt}
gnode_link00
  (nx1, nx2) = let
  val () = gnode0_set_next (nx1, nx2)
  val () = gnode0_set_prev (nx2, nx1)
in
  // nothing
end // end of [gnode_link00]

implement
{tk}{elt}
gnode_link01
  (nx1, nx2) = let
  val () = gnode0_set_next (nx1, nx2)
  val () = gnode_set_prev (nx2, nx1)
in
  // nothing
end // end of [gnode_link01]

implement
{tk}{elt}
gnode_link10
  (nx1, nx2) = let
  val () = gnode_set_next (nx1, nx2)
  val () = gnode0_set_prev (nx2, nx1)
  // end of [val]
in
  // nothing
end // end of [gnode_link10]

implement
{tk}{elt}
gnode_link11
  (nx1, nx2) = let
  val () = gnode_set_next (nx1, nx2)
  val () = gnode_set_prev (nx2, nx1)
in
  // nothing
end // end of [gnode_link11]

(* ****** ****** *)

implement
{tk}{elt}
gnode_insert_next
  (nx1, nx2) = let
  val nx1_next = gnode_get_next (nx1)
  val () = gnode_link11 (nx1, nx2)
  val () = gnode_link10 (nx2, nx1_next)
in
  // nothing
end // end of [gnode_insert_next]

implement
{tk}{elt}
gnode_insert_prev
  (nx1, nx2) = let
  val nx1_prev = gnode_get_prev (nx1)
  val () = gnode_link11 (nx2, nx1)
  val () = gnode_link01 (nx1_prev, nx2)
in
  // nothing
end // end of [gnode_insert_prev]

(* ****** ****** *)

implement
{tk}{elt}
gnode_remove
  (nx) = nx where {
//
val nx_prev = gnode_get_prev (nx)
val nx_next = gnode_get_next (nx)
//
val () = gnode_link00 (nx_prev, nx_next)
//
} // end of [gnode_remove]

implement
{tk}{elt}
gnode_remove_next (nx) = let
//
val nx_next = gnode_get_next (nx)
val isnot = gnode_isnot_null (nx_next)
val () =
  if isnot then let
  val nx_next2 = gnode_get_next (nx_next) in gnode_link10 (nx, nx_next2)
end // end of [of] // end of [val]
//
in
  nx_next
end // end of [gnode_remove_next]

implement
{tk}{elt}
gnode_remove_prev (nx) = let
//
val nx_prev = gnode_get_prev (nx)
val isnot = gnode_isnot_null (nx_prev)
val () =
  if isnot then let
  val nx_prev2 = gnode_get_prev (nx_prev) in gnode_link01 (nx_prev2, nx)
end // end of [of] // end of [val]
//
in
  nx_prev
end // end of [gnode_remove_prev]

(* ****** ****** *)

implement
{tk}{elt}
gnodelst_length (nxs) = let
//
typedef gnode0 = gnode0 (tk, elt)
//
fun loop (
  nxs: gnode0, len: intGte(0)
) : intGte(0) = let
  val iscons = gnodelst_is_cons (nxs)
in
//
if iscons then let
  val nxs = gnode_get_next (nxs)
in
  loop (nxs, succ (len))
end else (len) // end of [if]
//
end // end of [loop]
//
in
  $effmask_all (loop (nxs, 0))
end // end of [gnodelst_length]

(* ****** ****** *)

implement
{tk}{elt}
gnodelst_rlength (nxs) = let
//
typedef gnode1 = gnode1 (tk, elt)
//
fun loop (
  nxs: gnode1, len: intGte(0)
) : intGte(0) = let
  val nxs2 = gnode_get_prev (nxs)
  val iscons = gnodelst_is_cons (nxs2)
in
  if iscons then loop (nxs2, succ (len)) else len
end // end of [loop]
//
val iscons = gnodelst_is_cons (nxs)
//
in
  if iscons then $effmask_all (loop (nxs, 0)) else 0
end // end of [gnodelst_rlength]

(* ****** ****** *)

implement
{tk}{elt}
gnodelst_next_all (nxs) = let
//
fun loop (
  nxs: gnode1 (tk, elt)
) : gnode1 (tk, elt) = let
  val nxs_next = gnode_get_next (nxs)
in
  if gnodelst_is_cons (nxs_next) then loop (nxs_next) else nxs
end // end of [loop]
//
in
  $effmask_all (loop (nxs))  
end // end of [gnodelst_next_all]

implement
{tk}{elt}
gnodelst_prev_all (nxs) = let
//
fun loop (
  nxs: gnode1 (tk, elt)
) : gnode1 (tk, elt) = let
  val nxs_prev = gnode_get_prev (nxs)
in
  if gnodelst_is_cons (nxs_prev) then loop (nxs_prev) else nxs
end // end of [loop]
//
in
  $effmask_all (loop (nxs))
end // end of [gnodelst_prev_all]

(* ****** ****** *)

(* end of [gnode.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: July, 2013 *)

(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libats/SATS/gvector.sats"
staload "libats/SATS/gmatrix.sats"
staload "libats/SATS/gmatrix_col.sats"

(* ****** ****** *)

implement{a}
gmatcol_get_at
  (M, ld, i, j) = let
//
val pij =
  gmatcol_getref_at<a> (M, ld, i, j) in $UN.cptr_get<a> (pij)
//
end // end of [gmatcol_get_at]

implement{a}
gmatcol_set_at
  (M, ld, i, j, x) = let
//
val pij =
  gmatcol_getref_at<a> (M, ld, i, j) in $UN.cptr_set<a> (pij, x)
//
end // end of [gmatcol_set_at]

(* ****** ****** *)

implement{a}
gmatcol_getref_at
  (M, ld, i, j) = let
//
val p = $UN.cast2Ptr1(ptr_add<a> (addr@M, i+j*ld))
//
in
  $UN.ptr2cptr{a}(p)
end // end of [gmatcol_getref_at]

(* ****** ****** *)

implement{a}
gmatcol_getref_row_at
  {m,n}{ld}(M, ld, i) = let
//
val prow = $UN.cast2Ptr1(ptr_add<a> (addr@M, i))
//
in
  $UN.ptr2cptr{GVT(a,n,ld)}(prow)
end // end of [gmatcol_getref_row_at]

implement{a}
gmatcol_getref_col_at
  {m,n}{ld}(M, ld, j) = let
//
val pcol = $UN.cast2Ptr1(ptr_add<a> (addr@M, j*ld))
//
in
  $UN.ptr2cptr{GVT(a,m,1(*d*))}(pcol)
end // end of [gmatcol_getref_col_at]

(* ****** ****** *)

implement{a}
gmatcol_interchange_row
  {m,n}{ld}
(
  M, n, ld, i1, i2
) = let
in
//
if i1 != i2 then let
//
val cp1 =
  gmatcol_getref_row_at (M, ld, i1)
val cp2 =
  gmatcol_getref_row_at (M, ld, i2)
//
val
(pf1, fpf1 | p1) = $UN.cptr_vtake (cp1)
val
(pf2, fpf2 | p2) = $UN.cptr_vtake (cp2)
//
val () = gvector_exchange (!p1, !p2, n, ld, ld)
//
prval () = fpf1 (pf1) and () = fpf2 (pf2)
//
in
  // nothing
end else () // end of [if]
//
end (* end of [gmatcol_interchange_row] *)

(* ****** ****** *)

implement{a}
gmatcol_interchange_col
  {m,n}{ld}
(
  M, m, ld, j1, j2
) = let
in
//
if j1 != j2 then let
//
val cp1 =
  gmatcol_getref_col_at (M, ld, j1)
val cp2 =
  gmatcol_getref_col_at (M, ld, j2)
//
val
(pf1, fpf1 | p1) = $UN.cptr_vtake (cp1)
val
(pf2, fpf2 | p2) = $UN.cptr_vtake (cp2)
//
val () = gvector_exchange (!p1, !p2, m, 1, 1)
//
prval () = fpf1 (pf1) and () = fpf2 (pf2)
//
in
  // nothing
end else () // end of [if]
//
end (* end of [gmatcol_interchange_col] *)

(* ****** ****** *)

implement
{a}(*tmp*)
gmatcol_copyto
  {m,n}{ldx,ldy}
(
  X2, Y2, m, n, ldx, ldy
) = let
//
prval (
) = __initize (Y2) where
{
extern praxi
__initize (&GMC(a?, m, n, ldy) >> GMC(a, m, n, ldy)): void
} (* end of [where] *) // end of [prval]
//
implement(env)
gmatcol_foreachcol2$fwork<a,a><env>
  (X, Y, m, env) = let
  prval () = gvector_uninitize (Y) in gvector_copyto (X, Y, m, 1, 1)
end // end of [gmatcol_foreachcol2$fwork]
//
val () = gmatcol_foreachcol2<a,a> (X2, Y2, m, n, ldx, ldy)
//
in
  // nothing
end // end of [gmatcol_copyto]

(* ****** ****** *)

implement
{a}(*tmp*)
gmatcol_transpto
  {m,n}{ldx,ldy}
(
  X2, Y2, m, n, ldx, ldy
) = let
typedef tenv = ptr
implement
gmatcol_foreachcol$fwork<a><tenv>
  {m} (X, m, env) = () where
{
//
typedef tYcol = gvector(a,m,ldy)
//
val pY = env
val () = env := ptr_succ<a> (env)
//
val (pf, fpf | pY) = $UN.ptr_vtake{tYcol}(pY)
//
prval (
) = gvector_uninitize{a}(!pY)
val () = gvector_copyto<a> (X, !pY, m, 1, ldy)
//
prval ((*void*)) = fpf (pf)
//
} // end of [gmatcol_foreachcol$fwork]
//
var env: ptr = addr@Y2
val () = gmatcol_foreachcol_env<a><tenv> (X2, m, n, ldx, env)
//
prval () = gmatrix_initize{a}(Y2)
//
in
  // nothing
end // end of [gmatcol_transpto]

(* ****** ****** *)

implement{a}
gmatcol_ptr_split_2x2
  (pf | p, ld, i, j) = let
//
val j_ld = j * ld
val p01 = ptr_add<a> (p, j_ld  )
val p10 = ptr_add<a> (p, i     )
val p11 = ptr_add<a> (p, i+j_ld)
prval (pf00, pf01, pf10, pf11) = gmatcol_v_split_2x2 (pf, i, j)
//
in
  (pf00, pf01, pf10, pf11, gmatcol_v_unsplit_2x2 | p01, p10, p11)
end // end of [gmatcol_ptr_split_2x2]

(* ****** ****** *)

implement{a}
gmatcol_foreachcol
  (M, m, n, ld) = let
  var env: void = () in
  gmatcol_foreachcol_env<a><void> (M, m, n, ld, env)
end // end of [gmatcol_foreachcol]

(* ****** ****** *)

implement
{a}{env}
gmatcol_foreachcol_env
  {m,n}{ld}
  (M, m, n, ld, env) = let
fun loop
  {l:addr}{n:nat} .<n>.
(
  pfM: !GMC(a, l, m, n, ld) | p: ptr l, n: int n, env: &env
) : void = let
in
//
if n > 0
then let
//
prval (pfM1, pfM2) = gmatcol_v_uncons1 (pfM)
val () = gmatcol_foreachcol$fwork<a><env> (!p, m, env)
val () = loop (pfM2 | ptr_add<a> (p, ld), pred(n), env)
prval ((*void*)) = pfM := gmatcol_v_cons1 (pfM1, pfM2)
//
in
  // nothing
end else let
//
(*
prval () = (pfM := gmatcol_v_renil0 {a,a} (pfM))
*)
//
in
  // nothing
end // end of [if]
//
end // end of [loop]
//
prval () = lemma_gmatcol_param (M)
//
in
  loop (view@M | addr@M, n, env)
end // end of [gmatcol_foreachcol_env]

(* ****** ****** *)

implement{a1,a2}
gmatcol_foreachcol2
  (A, B, m, n, ld1, ld2) = let
  var env: void = () in
  gmatcol_foreachcol2_env<a1,a2><void> (A, B, m, n, ld1, ld2, env)
end // end of [gmatrix_foreachcol2]

implement
{a1,a2}{env}
gmatcol_foreachcol2_env
  {m,n}{lda,ldb}
(
  A, B, m, n, lda, ldb, env
) = let
//
fun loop
  {l1,l2:addr}{n:nat} .<n>.
(
  pfA: !GMC(a1, l1, m, n, lda)
, pfB: !GMC(a2, l2, m, n, ldb)
| p1: ptr l1, p2: ptr l2, n: int n, env: &env
) : void = let
in
//
if n > 0
then let
//
prval
  (pfA1, pfA2) = gmatcol_v_uncons1 (pfA)
prval
  (pfB1, pfB2) = gmatcol_v_uncons1 (pfB)
//
val () = gmatcol_foreachcol2$fwork<a1,a2><env> (!p1, !p2, m, env)
//
val () = loop
(
  pfA2, pfB2
| ptr_add<a1> (p1, lda), ptr_add<a2> (p2, ldb), pred(n), env
) (* end of [val] *)
//
prval () = pfA := gmatcol_v_cons1 (pfA1, pfA2)
prval () = pfB := gmatcol_v_cons1 (pfB1, pfB2)
//
in
  // nothing
end else let
//
(*
prval () = (pfA := gmatrow_v_renil0 {a,a} (pfA))
prval () = (pfB := gmatrow_v_renil0 {a,a} (pfB))
*)
//
in
  // nothing
end // end of [if]
//
end // end of [loop]
//
prval () = lemma_gmatcol_param (A)
prval () = lemma_gmatcol_param (B)
//
in
  loop (view@A, view@B | addr@A, addr@B, n, env)
end // end of [gmatcol_foreachcol2]

(* ****** ****** *)

(* end of [gmatrix_col.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: October, 2013 *)

(* ****** ****** *)
  
#define ATS_PACKNAME "ATSLIB.libats.deqarray"
#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names
  
(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libats/SATS/deqarray.sats"

(* ****** ****** *)

implement
{a}(*tmp*)
deqarray_make_cap
  (cap) = deq where
{
//
val cap1 = succ (cap)
//
val A = arrayptr_make_uninitized<a> (cap1)
//
val (pfat, pfgc | p) = ptr_alloc<deqarray_tsize> ()
//
val (pfngc | deq) = deqarray_make_ngc__tsz (pfat | p, A, cap, sizeof<a>)
//
prval ((*void*)) = mfree_gcngc_v_nullify (pfgc, pfngc)
//
} // end of [deqarray_make_cap]

(* ****** ****** *)

local
//
extern
fun deqarray_get_size__tsz{a:vt0p}
  {m,n:int} (deq: !deqarray (a, m, n), sizeof_t(a)):<> size_t(n) = "mac#%"
extern
fun deqarray_get_capacity__tsz{a:vt0p}
  {m,n:int} (deq: !deqarray (a, m, n), sizeof_t(a)):<> size_t(m) = "mac#%"
//
in (* in of [local] *)

implement
{a}(*tmp*)
deqarray_get_size (deq) = deqarray_get_size__tsz (deq, sizeof<a>)
implement
{a}(*tmp*)
deqarray_get_capacity (deq) = deqarray_get_capacity__tsz (deq, sizeof<a>)

end // end of [local]

(* ****** ****** *)
//
extern
fun
deqarray_get_ptrbeg{a:vt0p}
  {m,n:int} (deq: !deqarray (a, m, n)):<> Ptr1 = "mac#%"
extern
fun
deqarray_get_ptrend{a:vt0p}
  {m,n:int} (deq: !deqarray (a, m, n)):<> Ptr1 = "mac#%"
//
(* ****** ****** *)
//
extern
fun
deqarray_get_ptrfrnt{a:vt0p}
  {m,n:int} (deq: !deqarray (a, m, n)):<> Ptr1 = "mac#%"
extern
fun
deqarray_set_ptrfrnt{a:vt0p}
  {m,n:int} (deq: !deqarray (a, m, n), p: ptr):<!wrt> void = "mac#%"
//
extern
fun
deqarray_get_ptrrear{a:vt0p}
  {m,n:int} (deq: !deqarray (a, m, n)):<> Ptr1 = "mac#%"
extern
fun
deqarray_set_ptrrear{a:vt0p}
  {m,n:int} (deq: !deqarray (a, m, n), p: ptr):<!wrt> void = "mac#%"
//
(* ****** ****** *)
//
extern
fun{a:vt0p}
deqarray_ptr_succ{m,n:int} (deq: !deqarray (INV(a), m, n), p: ptr):<> ptr
extern
fun{a:vt0p}
deqarray_ptr_pred{m,n:int} (deq: !deqarray (INV(a), m, n), p: ptr):<> ptr
//
(* ****** ****** *)

local
//
extern
fun
deqarray_ptr_succ__tsz
  {a:vt0p}{m,n:int}
  (deq: !deqarray (INV(a), m, n), p: ptr, sizeof_t(a)):<> ptr = "mac#%"
extern
fun
deqarray_ptr_pred__tsz
  {a:vt0p}{m,n:int}
  (deq: !deqarray (INV(a), m, n), p: ptr, sizeof_t(a)):<> ptr = "mac#%"
//
in (* in of [local] *)

implement
{a}(*tmp*)
deqarray_ptr_succ (deq, p) = deqarray_ptr_succ__tsz (deq, p, sizeof<a>)
implement
{a}(*tmp*)
deqarray_ptr_pred (deq, p) = deqarray_ptr_pred__tsz (deq, p, sizeof<a>)

end // end of [local]

(* ****** ****** *)

local
//
extern
fun
deqarray_is_full__tsz
  {a:vt0p}{m,n:int}
(
  !deqarray (INV(a), m, n), sizeof_t(a)
) :<> bool (m==n) = "mac#%" // endfun
//
in (* in of [local] *)

implement
{a}(*tmp*)
deqarray_is_full (deq) =
  deqarray_is_full__tsz (deq, sizeof<a>)
implement
{a}(*tmp*)
deqarray_isnot_full (deq) = let
//
prval () = lemma_deqarray_param (deq)
//
in
  not(deqarray_is_full__tsz (deq, sizeof<a>))
end // end of [deqarray_isnot_full]

end // end of [local]

(* ****** ****** *)

implement
{a}(*tmp*)
deqarray_insert_atbeg
  {m,n} (deq, x0) = let
//
val p_rear = deqarray_get_ptrrear{a}(deq)
val p1_rear = deqarray_ptr_pred<a> (deq, p_rear)
val ((*void*)) = $UN.ptr0_set<a> (p1_rear, x0)
val ((*void*)) = deqarray_set_ptrrear{a}(deq, p1_rear)
//
prval () = __assert (deq) where
{
extern praxi __assert (!deqarray (a, m, n) >> deqarray (a, m, n+1)): void
} (* end of [prval] *)
//
in
  // nothing
end // end of [deqarray_insert_atbeg]

implement
{a}(*tmp*)
deqarray_insert_atbeg_opt
  (deq, x0) = let
//
val isnot = deqarray_isnot_full<a> (deq)
//
in
//
if isnot then let
  val () = deqarray_insert_atbeg (deq, x0) in None_vt()
end else Some_vt{a}(x0)
//
end // end of [deqarray_insert_atbeg_opt]

(* ****** ****** *)

implement
{a}(*tmp*)
deqarray_insert_atend
  {m,n} (deq, x0) = let
//
val p_frnt = deqarray_get_ptrfrnt{a}(deq)
val ((*void*)) = $UN.ptr0_set<a> (p_frnt, x0)
val ((*void*)) =
  deqarray_set_ptrfrnt{a}(deq, deqarray_ptr_succ<a> (deq, p_frnt))
//
prval () = __assert (deq) where
{
extern praxi __assert (!deqarray (a, m, n) >> deqarray (a, m, n+1)): void
} (* end of [prval] *)
//
in
  // nothing
end // end of [deqarray_insert_atend]

implement
{a}(*tmp*)
deqarray_insert_atend_opt
  (deq, x0) = let
//
val isnot = deqarray_isnot_full<a> (deq)
//
in
//
if isnot then let
  val () = deqarray_insert_atend (deq, x0) in None_vt()
end else Some_vt{a}(x0)
//
end // end of [deqarray_insert_atend_opt]

(* ****** ****** *)

implement
{a}(*tmp*)
deqarray_takeout_atbeg
  {m,n} (deq) = (x0) where
{
//
val p_rear = deqarray_get_ptrrear{a}(deq)
//
val (
  pf, fpf | p
) = $UN.ptr0_vtake{a}(p_rear)
val x0 = !p
prval () = $UN.castview0((fpf, pf))
//
val ((*void*)) =
  deqarray_set_ptrrear{a}(deq, deqarray_ptr_succ<a> (deq, p_rear))
//
prval () = __assert (deq) where
{
extern
praxi __assert (!deqarray (a, m, n) >> deqarray (a, m, n-1)): void
} (* end of [where] *) // end of [prval]
//
} (* end of [deqarray_takeout_atbeg] *)

(* ****** ****** *)

implement
{a}(*tmp*)
deqarray_takeout_atbeg_opt
  (deq) = let
//
val isnot = deqarray_isnot_nil (deq)
//
in
//
if isnot then let
  val x0 = deqarray_takeout_atbeg (deq) in Some_vt{a}(x0)
end else None_vt((*void*))
//
end // end of [deqarray_takeout_atbeg_opt]

(* ****** ****** *)

implement
{a}(*tmp*)
deqarray_takeout_atend
  {m,n} (deq) = (x0) where
{
//
val p_frnt = deqarray_get_ptrfrnt{a}(deq)
val p1_frnt = deqarray_ptr_pred<a> (deq, p_frnt)
//
val (
  pf, fpf | p
) = $UN.ptr0_vtake{a}(p1_frnt)
val x0 = !p
prval () = $UN.castview0((fpf, pf))
//
val () =
deqarray_set_ptrfrnt{a}(deq, p1_frnt)
//
prval () = __assert (deq) where
{
extern
praxi __assert (!deqarray (a, m, n) >> deqarray (a, m, n-1)): void
} (* end of [where] *) // end of [prval]
//
} (* end of [deqarray_takeout_atend] *)

(* ****** ****** *)

implement
{a}(*tmp*)
deqarray_takeout_atend_opt
  (deq) = let
//
val isnot = deqarray_isnot_nil (deq)
//
in
//
if isnot then let
  val x0 = deqarray_takeout_atend (deq) in Some_vt{a}(x0)
end else None_vt((*void*))
//
end // end of [deqarray_takeout_atend_opt]

(* ****** ****** *)

implement
{a}(*tmp*)
deqarray_get_at
  (deq, i) =
(
  $UN.cptr_get (deqarray_getref_at<a> (deq, i))
) (* end of [deqarray_get_at] *)

implement
{a}(*tmp*)
deqarray_set_at
  (deq, i, x) =
(
  $UN.cptr_set (deqarray_getref_at<a> (deq, i), x)
) (* end of [deqarray_set_at] *)

(* ****** ****** *)

local
//
extern
fun
deqarray_getref_at__tsz
  {a:vt0p}{m,n:int}
(
  deq: !deqarray (a, m, n), i: sizeLt(n), tsz: sizeof_t(a)
) :<> cPtr1(a) = "mac#%" // end-of-fun
//
in (* in of [local] *)
//
implement
{a}(*tmp*)
deqarray_getref_at
  (deq, i) = deqarray_getref_at__tsz{a}(deq, i, sizeof<a>)
//
end // end of [local]

(* ****** ****** *)

implement
{a}(*tmp*)
fprint_deqarray
  (out, deq) = let
//
typedef tenv = int
implement
deqarray_foreach$fwork<a><tenv>
  (x, env) = let
  val n = env
  val () = if n > 0 then fprint_deqarray$sep<> (out)
  val () = env := n + 1
in
  fprint_ref<a> (out, x)
end // end of [deqarray_foreach$fwork]
//
var env: tenv = 0
val ((*void*)) = deqarray_foreach_env<a><tenv> (deq, env)
//
in
  // nothing
end // end of [fprint_deqarray]

(* ****** ****** *)
//
implement
{}(*tmp*)
fprint_deqarray$sep
  (out) = fprint_string (out, ", ")
//
(* ****** ****** *)

implement
{a}(*tmp*)
fprint_deqarray_sep
  (out, deq, sep) = let
//
implement{}
fprint_deqarray$sep (out) = fprint_string (out, sep)
//
in
  fprint_deqarray<a> (out, deq)
end // end of [fprint_deqarray_sep]

(* ****** ****** *)

implement
{a}{env}
deqarray_foreach$cont (x, env) = true

(* ****** ****** *)

implement
{a}(*tmp*)
deqarray_foreach (deq) = let
  var env: void = () in deqarray_foreach_env<a><void> (deq, env)
end // end of [deqarray_foreach]

(* ****** ****** *)

implement
{a}{env}
deqarray_foreach_env
  (deq, env) = let
//
fun
foreach
(
  p0: ptr, p1: ptr, env: &env
) : void = let
in
//
if
p0 < p1
then let
  val (
    pf, fpf | p0
  ) = $UN.ptr_vtake{a}(p0)
  val cont =
    deqarray_foreach$cont (!p0, env)
  prval () = fpf (pf)
in
  if cont
    then let
      val (
        pf, fpf | p0
      ) = $UN.ptr_vtake{a}(p0)
      val () =
        deqarray_foreach$fwork (!p0, env)
      prval () = fpf (pf)
    in
      foreach (ptr_succ<a> (p0), p1, env)
    end // end of [then]
    else () // end of [else]
  // end of [if]
end // end of [then]
else () // end of [else]
//
end // end of [foreach]
//
val p_frnt = deqarray_get_ptrfrnt{a}(deq)
val p_rear = deqarray_get_ptrrear{a}(deq)
//
in
//
if
p_frnt > p_rear
then foreach (p_rear, p_frnt, env)
else let
  val p_beg = deqarray_get_ptrbeg{a}(deq)
  val p_end = deqarray_get_ptrend{a}(deq)
in
  foreach (p_rear, p_end, env); foreach (p_beg, p_frnt, env)
end // end of [else]
//
end // end of [deqarray_foreach_env]

(* ****** ****** *)

(* end of [deqarray.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: December, 2012 *)

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libats/SATS/funmap_list.sats"

(* ****** ****** *)
//
#include "./SHARE/funmap.hats" // code reuse
//
(* ****** ****** *)

assume
map_type
  (key:t0p, itm: vt0p) = List0 @(key, itm)
// end of [map_type]

(* ****** ****** *)

implement{} funmap_nil () = list_nil ()
implement{} funmap_make_nil () = list_nil ()

(* ****** ****** *)

implement{}
funmap_is_nil (map) =
  case+ map of list_nil _ => true | list_cons _ => false
// end of [funmap_is_nil]

implement{}
funmap_isnot_nil (map) =
  case+ map of list_nil _ => false | list_cons _ => true
// end of [funmap_isnot_nil]

(* ****** ****** *)

implement
{key,itm}
funmap_size
  (map) = g1int2uint (list_length (map))
// end of [funmap_size]

(* ****** ****** *)

implement
{key,itm}
funmap_search
  (map, k0, res) = let
//
fun search (
  kxs: List @(key, itm)
, k0: key, res: &itm? >> opt (itm, b)
) : #[b:bool] bool (b) = let
in
//
case+ kxs of
| list_cons
    (kx, kxs) => let
    val iseq =
      equal_key_key<key> (k0, kx.0)
    // end of [val]
  in
    if iseq then let
      val () = res := kx.1
      prval () = opt_some {itm} (res) in true
    end else
      search (kxs, k0, res)
    // end of [if]
  end // end of [list_cons]
| list_nil () => let
    prval () = opt_none {itm} (res) in false
  end // end of [list_nil]
//
end // end of [search]
//
in
//
  $effmask_all (search (map, k0, res))
//
end // end of [funmap_search]

(* ****** ****** *)

implement
{key,itm}
funmap_insert
(
  map, k0, x0, res
) = let
//
typedef ki = @(key, itm)
//
val ans =
  funmap_takeout<key,itm>(map, k0, res)
val () =
  (map := list_cons{ki}( @(k0, x0), map ))
// end of [val]
//
in
  ans
end // end of [funmap_insert]

(* ****** ****** *)

implement
{key,itm}
funmap_insert_any
  (map, k0, x0) = let
//
typedef ki = @(key, itm)
//
in
  map := list_cons{ki}( @(k0, x0), map )
end // end of [funmap_insert_any]

(* ****** ****** *)

implement
{key,itm}
funmap_takeout
  (map, k0, res) = let
//
typedef map = map (key, itm)
//
fun loop
(
  map: &map >> _
, kxs1: List0 @(key, itm)
, kxs2: List0_vt @(key, itm)
, k0: key, res: &itm? >> opt (itm, b)
) : #[b:bool] bool (b) = let
//
typedef ki = @(key, itm)
//
in
//
case+ kxs1 of
| list_cons
    (kx, kxs1) => let
    val iseq = equal_key_key<key> (k0, kx.0)
  in
    if iseq then let
      val () = res := kx.1
      prval () = opt_some {itm} (res)
      val () = map := list_reverse_append1_vt (kxs2, kxs1)
    in
      true
    end else
      loop (map, kxs1, list_vt_cons{ki}(kx, kxs2), k0, res)
    // end of [if]
  end // end of [list_cons]
| list_nil () => let
    val () = list_vt_free<ki> (kxs2)
    prval () = opt_none {itm} (res) in false
  end // end of [list_nil]
//
end // end of [loop]
//
in
  loop (map, map, list_vt_nil (), k0, res)
end // end of [funmap_takeout]

(* ****** ****** *)

implement
{key,itm}{env}
funmap_foreach_env
  (map, env) = let
//
vtypedef ki = @(key, itm)
//
implement{ki}{env}
list_foreach$cont (kx, env) = true
implement
list_foreach$fwork<ki><env> (kx, env) =
  funmap_foreach$fwork<key,itm><env> (kx.0, kx.1, env)
//
in
  list_foreach_env<ki><env> (map, env)
end // end of [funmap_foreach_env]

(* ****** ****** *)

(* end of [funmap_list.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: July, 2013 *)

(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libats/SATS/gvector.sats"
staload "libats/SATS/gmatrix.sats"
staload "libats/SATS/gmatrix_row.sats"

(* ****** ****** *)

implement{a}
gmatrow_get_at
  (M, ld, i, j) = let
//
val pij =
  gmatrow_getref_at<a> (M, ld, i, j) in $UN.cptr_get<a> (pij)
//
end // end of [gmatrow_get_at]

implement{a}
gmatrow_set_at
  (M, ld, i, j, x) = let
//
val pij =
  gmatrow_getref_at<a> (M, ld, i, j) in $UN.cptr_set<a> (pij, x)
//
end // end of [gmatrow_set_at]

(* ****** ****** *)

implement{a}
gmatrow_getref_at
  (M, ld, i, j) = let
//
val p = $UN.cast2Ptr1(ptr_add<a> (addr@M, i*ld+j))
//
in
  $UN.ptr2cptr{a}(p)
end // end of [gmatrow_getref_at]

(* ****** ****** *)

implement{a}
gmatrow_getref_col_at
  {m,n}{ld}(M, ld, j) = let
//
val pcol = $UN.cast2Ptr1(ptr_add<a> (addr@M, j))
//
in
  $UN.ptr2cptr{GVT(a,m,ld)}(pcol)
end // end of [gmatrow_getref_col_at]

implement{a}
gmatrow_getref_row_at
  {m,n}{ld}(M, ld, i) = let
//
val prow = $UN.cast2Ptr1(ptr_add<a> (addr@M, i*ld))
//
in
  $UN.ptr2cptr{GVT(a,n,1(*d*))}(prow)
end // end of [gmatrow_getref_row_at]

(* ****** ****** *)

implement{a}
gmatrow_interchange_row
  {m,n}{ld}
(
  M, n, ld, i1, i2
) = let
in
//
if i1 != i2 then let
//
val cp1 =
  gmatrow_getref_row_at (M, ld, i1)
val cp2 =
  gmatrow_getref_row_at (M, ld, i2)
//
val
(pf1, fpf1 | p1) = $UN.cptr_vtake (cp1)
val
(pf2, fpf2 | p2) = $UN.cptr_vtake (cp2)
//
val () = gvector_exchange (!p1, !p2, n, 1, 1)
//
prval () = fpf1 (pf1) and () = fpf2 (pf2)
//
in
  // nothing
end else () // end of [if]
//
end (* end of [gmatrow_interchange_row] *)

(* ****** ****** *)

implement{a}
gmatrow_interchange_col
  {m,n}{ld}
(
  M, m, ld, j1, j2
) = let
in
//
if j1 != j2 then let
//
val cp1 =
  gmatrow_getref_col_at (M, ld, j1)
val cp2 =
  gmatrow_getref_col_at (M, ld, j2)
//
val
(pf1, fpf1 | p1) = $UN.cptr_vtake (cp1)
val
(pf2, fpf2 | p2) = $UN.cptr_vtake (cp2)
//
val () = gvector_exchange (!p1, !p2, m, ld, ld)
//
prval () = fpf1 (pf1) and () = fpf2 (pf2)
//
in
  // nothing
end else () // end of [if]
//
end (* end of [gmatrow_interchange_col] *)

(* ****** ****** *)

implement
{a}(*tmp*)
gmatrow_copyto
  {m,n}{ldx,ldy}
(
  X2, Y2, m, n, ldx, ldy
) = let
//
prval (
) = __initize (Y2) where
{
extern praxi
__initize (&GMR(a?, m, n, ldy) >> GMR(a, m, n, ldy)): void
} (* end of [where] *) // end of [prval]
//
implement(env)
gmatrow_foreachrow2$fwork<a,a><env>
  (X, Y, n, env) = let
  prval () = gvector_uninitize (Y) in gvector_copyto<a> (X, Y, n, 1, 1)
end // end of [gmatrow_foreachrow2$fwork]
//
val () = gmatrow_foreachrow2<a,a> (X2, Y2, m, n, ldx, ldy)
//
in
  // nothing
end // end of [gmatrow_copyto]

(* ****** ****** *)

implement
{a}(*tmp*)
gmatrow_transpto
  {m,n}{ldx,ldy}
(
  X2, Y2, m, n, ldx, ldy
) = let
typedef tenv = ptr
implement
gmatrow_foreachrow$fwork<a><tenv>
  {n} (X, n, env) = () where
{
//
typedef tYcol = gvector(a,n,ldy)
//
val pY = env
val () = env := ptr_succ<a> (env)
//
val (pf, fpf | pY) = $UN.ptr_vtake{tYcol}(pY)
//
prval (
) = gvector_uninitize{a}(!pY)
val () = gvector_copyto<a> (X, !pY, n, 1, ldy)
//
prval ((*void*)) = fpf (pf)
//
} // end of [gmatrow_foreachrow$fwork]
//
var env: ptr = addr@Y2
val () = gmatrow_foreachrow_env<a><tenv> (X2, m, n, ldx, env)
//
prval () = gmatrix_initize{a}(Y2)
//
in
  // nothing
end // end of [gmatrow_transpto]

(* ****** ****** *)

implement{a}
gmatrow_ptr_split_2x2
  (pf | p, ld, i, j) = let
//
val i_ld = i * ld
val p01 = ptr_add<a> (p, j     )
val p10 = ptr_add<a> (p, i_ld  )
val p11 = ptr_add<a> (p, i_ld+j)
prval (pf00, pf01, pf10, pf11) = gmatrow_v_split_2x2 (pf, i, j)
//
in
  (pf00, pf01, pf10, pf11, gmatrow_v_unsplit_2x2 | p01, p10, p11)
end // end of [gmatrow_ptr_split_2x2]

(* ****** ****** *)

implement
{a}(*tmp*)
gmatrow_foreachrow
  (M, m, n, ld) = let
  var env: void = () in
  gmatrow_foreachrow_env<a><void> (M, m, n, ld, env)
end // end of [gmatrix_foreachrow]

(* ****** ****** *)

implement
{a}{env}
gmatrow_foreachrow_env
  {m,n}{ld}
  (M, m, n, ld, env) = let
fun loop
  {l:addr}{m:nat} .<m>.
(
  pfM: !GMR(a, l, m, n, ld) | p: ptr l, m: int m, env: &env
) : void = let
in
//
if m > 0
then let
//
prval (pfM1, pfM2) = gmatrow_v_uncons0 (pfM)
val () = gmatrow_foreachrow$fwork<a><env> (!p, n, env)
val () = loop (pfM2 | ptr_add<a> (p, ld), pred(m), env)
prval ((*void*)) = pfM := gmatrow_v_cons0 (pfM1, pfM2)
//
in
  // nothing
end else let
//
(*
prval () = (pfM := gmatrow_v_renil0 {a,a} (pfM))
*)
//
in
  // nothing
end // end of [if]
//
end // end of [loop]
//
prval () = lemma_gmatrow_param (M)
//
in
  loop (view@M | addr@M, m, env)
end // end of [gmatrow_foreachrow_env]

(* ****** ****** *)

implement
{a1,a2}
gmatrow_foreachrow2
  (A, B, m, n, ld1, ld2) = let
  var env: void = () in
  gmatrow_foreachrow2_env<a1,a2><void> (A, B, m, n, ld1, ld2, env)
end // end of [gmatrix_foreachrow2]

implement
{a1,a2}{env}
gmatrow_foreachrow2_env
  {m,n}{lda,ldb}
(
  A, B, m, n, lda, ldb, env
) = let
//
fun loop
  {l1,l2:addr}{m:nat} .<m>.
(
  pfA: !GMR(a1, l1, m, n, lda)
, pfB: !GMR(a2, l2, m, n, ldb)
| p1: ptr l1, p2: ptr l2, m: int m, env: &env
) : void = let
in
//
if m > 0
then let
//
prval
  (pfA1, pfA2) = gmatrow_v_uncons0 (pfA)
prval
  (pfB1, pfB2) = gmatrow_v_uncons0 (pfB)
//
val () = gmatrow_foreachrow2$fwork<a1,a2><env> (!p1, !p2, n, env)
//
val () = loop
(
  pfA2, pfB2
| ptr_add<a1> (p1, lda), ptr_add<a2> (p2, ldb), pred(m), env
) (* end of [val] *)
//
prval () = pfA := gmatrow_v_cons0 (pfA1, pfA2)
prval () = pfB := gmatrow_v_cons0 (pfB1, pfB2)
//
in
  // nothing
end else let
//
(*
prval () = (pfA := gmatrow_v_renil0 {a,a} (pfA))
prval () = (pfB := gmatrow_v_renil0 {a,a} (pfB))
*)
//
in
  // nothing
end // end of [if]
//
end // end of [loop]
//
prval () = lemma_gmatrow_param (A)
prval () = lemma_gmatrow_param (B)
//
in
  loop (view@A, view@B | addr@A, addr@B, m, env)
end // end of [gmatrow_foreachrow2]

(* ****** ****** *)

(* end of [gmatrix_row.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: August, 2013 *)

(* ****** ****** *)

#define
ATS_PACKNAME "ATSLIB.libats.funmap_avltree"
#define
ATS_DYNLOADFLAG 0 // no need for dynloading at run-time

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libats/SATS/funmap_avltree.sats"

(* ****** ****** *)

implement
{key}
compare_key_key
  (k1, k2) = gcompare_val_val<key> (k1, k2)
// end of [compare_key_key]

(* ****** ****** *)
//
// HX-2012-12-26:
// the file should be included here
// before [map_type] is assumed
//
#include "./SHARE/funmap.hats" // code reuse
//
(* ****** ****** *)
//
// HX: maximal height difference of two siblings
//
#define HTDF 1
#define HTDF1 (HTDF+1)
#define HTDF_1 (HTDF-1)
//
(* ****** ****** *)

datatype avltree
(
  key:t@ype, itm:t@ype+, int(*height*)
) =
  | {hl,hr:nat |
     hl <= hr+HTDF;
     hr <= hl+HTDF}
    B (key, itm, 1+max(hl,hr)) of
    (
      int(1+max(hl,hr)), key, itm, avltree(key, itm, hl), avltree(key, itm, hr)
    )
  | E (key, itm, 0) of ((*void*))
// end of [datatype avltree]

(* ****** ****** *)

typedef
avltree
  (key:t0p, itm:t0p) = [h:nat] avltree (key, itm, h)
// end of [avltree]

typedef
avltree_inc
  (key:t0p, itm:t0p, h:int) =
  [h1:nat | h <= h1; h1 <= h+1] avltree (key, itm, h1)
// end of [avltree_inc]

typedef
avltree_dec
  (key:t0p, itm:t0p, h:int) =
  [h1:nat | h1 <= h; h <= h1+1] avltree (key, itm, h1)
// end of [avltree_dec]

(* ****** ****** *)

assume
map_type (key:t0p, itm:t0p) = avltree (key, itm)
// end of [map_type]

(* ****** ****** *)

implement{} funmap_nil () = E ()
implement{} funmap_make_nil () = E ()

(* ****** ****** *)

implement{}
funmap_is_nil (map) =
  case+ map of E _ => true | B _ => false
// end of [funmap_is_nil]

implement{}
funmap_isnot_nil (map) =
  case+ map of B _ => true | E _ => false
// end of [funmap_isnot_nil]

(* ****** ****** *)

implement
{key,itm}
funmap_size
  (map) = let
//
fun aux
(
  t0: avltree (key, itm), res: size_t
) : size_t = let
in
//
case+ t0 of
| B (
    _, _, _, tl, tr
  ) => let
    val res = succ(res)
    val res = aux (tl, res)
    val res = aux (tr, res)
  in
    res
  end // end of [B]
| E ((*void*)) => res
//
end // end of [aux]
//
in
  $effmask_all (aux (map, i2sz(0)))
end // end of [funmap_size]

(* ****** ****** *)

implement
{key,itm}
funmap_search
  (map, k0, res) = let
//
fun search{h:nat} .<h>.
(
  t0: avltree (key, itm, h)
, res: &itm? >> opt (itm, b)
) :<!wrt> #[b:bool] bool(b) = let
in
//
case+ t0 of
| B (
    _(*h*), k, x, tl, tr
  ) => let
    val sgn =
      compare_key_key<key> (k0, k)
    // end of [val]
  in
    case+ 0 of
    | _ when sgn < 0 => search (tl, res)
    | _ when sgn > 0 => search (tr, res)
    | _ => let
        val () = res := x
        prval () = opt_some{itm}(res) in true
      end // end of [_]
  end // end of [B]
| E () => 
    let prval () = opt_none{itm}(res) in false end
  // end of [E]
//
end // end of [search]
//
in
  search (map, res)
end // end of [funmap_search]

(* ****** ****** *)

macdef
avlht (t) =
(
case+ ,(t) of B (h, _, _, _, _) => h | E ((*void*)) => 0
) // end of [avlht]

(* ****** ****** *)

(*
** left rotation for restoring height invariant
*)
fn{
key,itm:t0p
} avltree_lrotate
  {hl,hr:nat | hl+HTDF1 == hr}
(
  k: key, x: itm
, hl : int hl
, tl: avltree (key, itm, hl)
, hr : int hr
, tr: avltree (key, itm, hr)
) :<> avltree_inc (key, itm, hr) = let
  val+B{..}{hrl,hrr}(_, kr, xr, trl, trr) = tr
  val hrl = avlht(trl) : int hrl
  and hrr = avlht(trr) : int hrr
in
//
if hrl <= hrr+HTDF_1 then let
  val hrl1 = hrl + 1
in
  B{key,itm}
  (
    1+max(hrl1,hrr), kr, xr
  , B{key,itm}(hrl1, k, x, tl, trl), trr
  )
end else let // [hrl=hrr+2]: deep rotation
  val+B{..}{hrll,hrlr}(_(*hrl*), krl, xrl, trll, trlr) = trl
  val hrll = avlht(trll) : int hrll
  and hrlr = avlht(trlr) : int hrlr
in
  B{key,itm}
  (
    hr, krl, xrl
  , B{key,itm}(1+max(hl,hrll), k, x, tl, trll)
  , B{key,itm}(1+max(hrlr,hrr), kr, xr, trlr, trr)
  )
end // end of [if]
//
end // end of [avltree_lrotate]

(* ****** ****** *)

(*
** right rotation for restoring height invariant
*)
fn{key,itm:t0p}
avltree_rrotate
  {hl,hr:nat | hl == hr+HTDF1}
(
  k: key, x: itm
, hl: int hl
, tl: avltree (key, itm, hl)
, hr: int hr
, tr: avltree (key, itm, hr)
) :<> avltree_inc (key, itm, hl) = let
  val+B{..}{hll,hlr}(_(*hl*), kl, xl, tll, tlr) = tl
  val hll = avlht(tll) : int hll
  and hlr = avlht(tlr) : int hlr
in
//
if hll+HTDF_1 >= hlr then let
  val hlr1 = hlr + 1
in
  B{key,itm}
  (
    1+max(hll,hlr1), kl, xl
  , tll, B{key,itm}(hlr1, k, x, tlr, tr)
  )
end else let
  val+B{..}{hlrl,hlrr}(_(*hlr*), klr, xlr, tlrl, tlrr) = tlr
  val hlrl = avlht(tlrl) : int hlrl
  and hlrr = avlht(tlrr) : int hlrr
in
  B{key,itm}
  (
    hl, klr, xlr
  , B{key,itm}(1+max(hll,hlrl), kl, xl, tll, tlrl)
  , B{key,itm}(1+max(hlrr,hr), k, x, tlrr, tr)
  )
end // end of [if]
//
end // end of [avltree_rrotate]

(* ****** ****** *)

implement
{key,itm}
funmap_insert
(
  map, k0, x0, res2
) = res where {
//
fun insert
  {h:nat} .<h>. (
  t0: avltree (key, itm, h)
, res: &bool? >> bool (b)
, res2: &itm? >> opt (itm, b)
) :<!wrt> #[b:bool]
  avltree_inc (key, itm, h) = let
in
//
case+ t0 of
| B{..}{hl,hr}
    (h, k, x, tl, tr) => let
    val sgn = compare_key_key<key> (k0, k)
  in
    case+ 0 of
    | _ when sgn < 0 => let
        val [hl:int]
          tl = insert (tl, res, res2)
        val hl = avlht(tl) : int (hl)
        and hr = avlht(tr) : int (hr)
      in
        if hl - hr <= HTDF then
          B{key,itm}(1+max(hl,hr), k, x, tl, tr)
        else // hl = hr+HTDF1
          avltree_rrotate<key,itm> (k, x, hl, tl, hr, tr)
        // end of [if]
      end // end of [sgn < 0]
    | _ when sgn > 0 => let
        val [hr:int]
          tr = insert (tr, res, res2)
        val hl = avlht(tl) : int (hl)
        and hr = avlht(tr) : int (hr)
      in
        if hr - hl <= HTDF then
          B{key,itm}(1+max(hl, hr), k, x, tl, tr)
        else // hl+HTDF1 = hr
          avltree_lrotate<key,itm> (k, x, hl, tl, hr, tr)
        // end of [if]
      end // end of [sgn > 0]
    | _ (* sgn=0 *) => let
        val () = res := true
        val () = res2 := x
        prval () = opt_some{itm}(res2)
      in
        B{key,itm}(h, k, x0, tl, tr)
      end // end of [sgn = 0]
  end (* end of [B] *)
| E ((*void*)) => let
    val () = res := false
    prval () = opt_none{itm}(res2)
  in
    B{key,itm}(1, k0, x0, E (), E ())
  end (* end of [E] *)
//
end // end of [insert]
//
var res: bool // uninitialized
val ((*void*)) = map := insert (map, res, res2)
//
} // end of [funmap_insert]

(* ****** ****** *)

fun{
key,itm:t0p
} avlmaxout{h:pos} .<h>.
(
  t: avltree (key, itm, h)
, k0: &key? >> key, x0: &itm? >> itm
) :<!wrt> avltree_dec (key, itm, h) = let
//
val+B{..}{hl,hr}(h, k, x, tl, tr) = t
//
in
//
case+ tr of
| B _ => let
    val [hr:int]
      tr = avlmaxout<key,itm> (tr, k0, x0)
    val hl = avlht(tl) : int(hl)
    and hr = avlht(tr) : int(hr)
  in
    if hl - hr <= HTDF
      then B{key,itm}(1+max(hl,hr), k, x, tl, tr)
      else avltree_rrotate<key,itm> (k, x, hl, tl, hr, tr)
    // end of [if]
  end // end of [B]
| E () => (k0 := k; x0 := x; tl)
//
end // end of [avlmaxout]

(* ****** ****** *)

fun{
key,itm:t0p
} avlminout{h:pos} .<h>.
(
  t: avltree (key, itm, h)
, k0: &key? >> key, x0: &itm? >> itm
) :<!wrt> avltree_dec (key, itm, h) = let
//
val+B{..}{hl,hr}(h, k, x, tl, tr) = t
//
in
//
case+ tl of
| B _ => let
    val [hl:int]
      tl = avlminout<key,itm> (tl, k0, x0)
    val hl = avlht(tl) : int(hl)
    and hr = avlht(tr) : int(hr)
  in
    if hr - hl <= HTDF
      then B{key,itm}(1+max(hl,hr), k, x, tl, tr)
      else avltree_lrotate<key,itm> (k, x, hl, tl, hr, tr)
    // end of [if]
  end // end of [B]
| E () => (k0 := k; x0 := x; tr)
//
end // end of [avlminout]

(* ****** ****** *)

(*
** left join: height(tl) >= height(tr)
*)
fun{
key,itm:t0p
} avltree_ljoin
  {hl,hr:nat | hl >= hr} .<hl>.
(
  k: key, x: itm
, tl: avltree (key, itm, hl)
, tr: avltree (key, itm, hr)
) :<> avltree_inc (key, itm, hl) = let
  val hl = avlht(tl) : int hl
  and hr = avlht(tr) : int hr
in
//
if hl >= hr + HTDF1 then let
  val+B{..}{hll, hlr}(_, kl, xl, tll, tlr) = tl
  val [hlr:int] tlr = avltree_ljoin<key,itm> (k, x, tlr, tr)
  val hll = avlht(tll) : int hll
  and hlr = avlht(tlr) : int hlr
in
  if hlr <= hll + HTDF
    then B{key,itm}(1+max(hll,hlr), kl, xl, tll, tlr)
    else avltree_lrotate<key,itm> (kl, xl, hll, tll, hlr, tlr)
  // end of [if]
end else B{key,itm}(hl+1, k, x, tl, tr) // end of [if]
//
end // end of [avltree_ljoin]

(* ****** ****** *)

(*
** right join: height(tl) <= height(tr)
*)
fun{
key,itm:t0p
} avltree_rjoin
  {hl,hr:nat | hl <= hr} .<hr>.
(
  k: key, x: itm
, tl: avltree (key, itm, hl)
, tr: avltree (key, itm, hr)
) :<> avltree_inc (key, itm, hr) = let
  val hl = avlht(tl) : int hl
  and hr = avlht(tr) : int hr
in
//
if hr >= hl + HTDF1 then let
  val+B{..}{hrl,hrr}(_, kr, xr, trl, trr) = tr
  val [hrl:int] trl = avltree_rjoin<key,itm> (k, x, tl, trl)
  val hrl = avlht(trl) : int hrl
  and hrr = avlht(trr) : int hrr
in
  if hrl <= hrr + HTDF
    then B{key,itm}(1+max(hrl,hrr), kr, xr, trl, trr)
    else avltree_rrotate<key,itm> (kr, xr, hrl, trl, hrr, trr)
  // end of [if]
end else B{key,itm}(hr+1, k, x, tl, tr) // end of [if]
//
end // end of [avltree_rjoin]

(* ****** ****** *)

fn{
key,itm:t0p
} avltree_join3
  {hl,hr:nat}
(
  k: key, x: itm
, tl: avltree (key, itm, hl)
, tr: avltree (key, itm, hr)
) :<> [
  h:int
| hl <= h
; hr <= h
; h <= 1+max(hl,hr)
] avltree (key, itm, h) = let
  val hl = avlht(tl) : int hl
  and hr = avlht(tr) : int hr
in
  if hl >= hr then
    avltree_ljoin<key,itm> (k, x, tl, tr) else avltree_rjoin<key,itm> (k, x, tl, tr)
  // end of [if]
end // end of [avltree_join3]

(* ****** ****** *)

fn{
key,itm:t0p
} avltree_join2
  {hl,hr:nat}
(
  tl: avltree (key, itm, hl)
, tr: avltree (key, itm, hr)
) :<> [
  h:nat
| h <= 1+max(hl,hr)
] avltree (key, itm, h) =
(
case+
  (tl, tr) of
| (E (), _) => tr
| (_, E ()) => tl
| (_, _) =>> let
    var kmin: key // uninitialized
    var xmin: itm // uninitialized
    val tr = $effmask_wrt
      (avlminout<key,itm> (tr, kmin, xmin))
    // end of [val]
  in
    avltree_join3<key,itm> (kmin, xmin, tl, tr)
  end // end of [_, _]
) // end of [avltree_join2]

(* ****** ****** *)

implement
{key,itm}
funmap_takeout
(
  map, k0, res2
) = res where {
//
fun takeout
  {h:nat} .<h>. (
  t0: avltree (key, itm, h)
, res: &bool? >> bool(b)
, res2: &itm? >> opt(itm, b)
) :<!wrt> #[b:bool]
  avltree_dec (key, itm, h) = let
in
//
case+ t0 of
| B {..}{hl,hr}
    (h, k, x, tl, tr) => let
    val sgn = compare_key_key<key> (k0, k)
  in
    case+ 0 of
    | _ when sgn < 0 => let
        val [hl:int] tl = takeout (tl, res, res2)
        val hl = avlht(tl) : int hl
        and hr = avlht(tr) : int hr
      in
        if hr - hl <= HTDF
          then B{key,itm}(1+max(hl,hr), k, x, tl, tr)
          else avltree_lrotate<key,itm> (k, x, hl, tl, hr, tr)
        // end of [if]
      end // end of [sgn < 0]
    | _ when sgn > 0 => let
        val [hr:int] tr = takeout (tr, res, res2)
        val hl = avlht(tl) : int hl
        and hr = avlht(tr) : int hr
      in
        if hl - hr <= HTDF
          then B{key,itm}(1+max(hl,hr), k, x, tl, tr)
          else avltree_rrotate<key,itm> (k, x, hl, tl, hr, tr)
        // end of [if]
      end // end of [sgn > 0]
    | _ (* sgn = 0 *) => let
        val () = res := true // found
        val () = res2 := x
        prval () = opt_some{itm}(res2)
      in
        case+ tr of
        | B _ => let
            var kmin: key?
            var xmin: itm?
            val [hr:int] tr = avlminout<key,itm> (tr, kmin, xmin)
            val hl = avlht(tl) : int (hl)
            and hr = avlht(tr) : int (hr)
          in
            if hl - hr <= HTDF
              then B{key,itm}(1+max(hl,hr), kmin, xmin, tl, tr)
              else avltree_rrotate<key,itm> (kmin, xmin, hl, tl, hr, tr)
            // end of [if]
          end // end of [B]
        | E _ => tl
      end // end of [sgn = 0]
  end // end of [B]
| E ((*void*)) => let
    val () = res := false
    prval () = opt_none{itm}(res2) in t0 
  end // end of [E]
//
end // end of [takeout]
//
var res: bool
val ((*void*)) = map := takeout (map, res, res2)
//
} // end of [funmap_takeout]

(* ****** ****** *)

implement
{key,itm}{env}
funmap_foreach_env
  (xs, env) = let
//
val p_env = addr@ (env)
//
fun foreach
  {h:nat} .<h>.
(
  t: avltree (key, itm, h), p_env: ptr
) : void = let
in
//
case+ t of
| B (_, k, x, tl, tr) => let
//
    val () = foreach (tl, p_env)
//
    val (
      pf, fpf | p_env
    ) = $UN.ptr_vtake (p_env)
    val ((*void*)) =
      funmap_foreach$fwork<key,itm><env> (k, x, !p_env)
    prval ((*void*)) = fpf (pf)
//
    val () = foreach (tr, p_env)
//
  in
    // nothing
  end // end of [B]
| E ((*void*)) => ()
//
end // end of [foreach]
//
in
  foreach (xs, p_env)
end // end of [funmap_foreach_env]

(* ****** ****** *)

implement
{key,itm}
funmap_avltree_height (map) = avlht (map)

(* ****** ****** *)

(* end of [funmap_avltree.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: hwxiATcsDOTbuDOTedu
// Time: October, 2010
//
(* ****** ****** *)
//
// HX: generic functional lists (fully indexed)
//
(* ****** ****** *)
//
// HX-2012-11-28: ported to ATS/Postiats from ATS/Anairiats
//
(* ****** ****** *)

staload "libats/SATS/ilist_prf.sats"

(* ****** ****** *)

staload "libats/SATS/gflist.sats"
staload "libats/SATS/gflist_vt.sats"

(* ****** ****** *)

implement
{a}(*tmp*)
gflist_vt_length (xs) = let
//
fun loop
  {xs:ilist}{j:int} .<xs>. (
  xs: !gflist_vt (a, xs), j: int j
) :<> [i:nat]
  (LENGTH (xs, i) | int (i+j)) = let
in
//
case+ xs of
| gflist_vt_cons
    (_, xs) => let
    val (pf | res) = loop (xs, j+1)
  in
    (LENGTHcons (pf) | res)
  end // end of [gflist_vt_cons]
| gflist_vt_nil () => (LENGTHnil () | j)
//
end // end of [loop]
//
in
  loop (xs, 0)
end // end of [gflist_vt_length]

(* ****** ****** *)
//
implement
{a}(*tmp*)
gflist_vt_snoc
  {xs}{x0}(xs, x0) = let
//
val (pfapp | res) =
  gflist_vt_append<a> (xs, gflist_vt_sing(x0))
//
extern
praxi
lemma :
{xsx:ilist}
APPEND(xs, ilist_sing(x0), xsx) -> SNOC(xs, x0, xsx)
//
in
  (lemma(pfapp) | res)
end // end of [gflist_vt_snoc]

(* ****** ****** *)

implement
{a}(*tmp*)
gflist_vt_append
  (xs, ys) = let
//
fun loop
  {xs:ilist}
  {ys:ilist} .<xs>. (
  xs: gflist_vt (a, xs), ys: gflist_vt (a, ys), res: &ptr? >> gflist_vt (a, zs)
) :<!wrt> #[zs:ilist] (APPEND (xs, ys, zs) | void) = let
in
//
case+ xs of
| @gflist_vt_cons
    (x, xs1) => let
    val () = res := xs
    val xs = xs1
    val (pf | ()) = loop (xs, ys, xs1)
    prval () = fold@ (res)
  in
    (APPENDcons (pf) | ())
  end // end of [gflist_vt_cons]
| ~gflist_vt_nil () => let
    val () = res := ys in (APPENDnil () | ())
  end // end of [gflist_vt_nil]
//
end // end of [loop]
//
var res: ptr // uninitialized
//
val (pf | ()) = loop (xs, ys, res)
//
in
  (pf | res)
end // end of [gflist_vt_append]

(* ****** ****** *)

implement
{a}(*tmp*)
gflist_vt_revapp
  (xs, ys) = let
in
//
case+ xs of
| @gflist_vt_cons
    (x, xs1) => let
    val xs1_ = xs1
    val () = xs1 := ys
    prval () = fold@ (xs)
    val (pf | res) = gflist_vt_revapp (xs1_, xs)
  in
    (REVAPPcons (pf) | res)
  end // end of [gflist_vt_cons]
| ~gflist_vt_nil () => (REVAPPnil () | ys)
//
end // end of [gflist_vt_append]

implement
{a}(*tmp*)
gflist_vt_reverse (xs) = gflist_vt_revapp (xs, gflist_vt_nil)

(* ****** ****** *)

local

(*
//
// HX-2012-11-28: mergesort on gflist_vt // ported from ATS/Anairiats
//
*)

fun{
a:vt0p
} split
  {xs:ilist}
  {n,i:nat | i <= n} .<i>. (
  pflen: LENGTH (xs, n)
| xs: &gflist_vt (a, xs) >> gflist_vt (a, xs1), i: int i
) : #[xs1,xs2:ilist] (
  APPEND (xs1, xs2, xs), LENGTH (xs1, i) | gflist_vt (a, xs2)
) =
  if i > 0 then let
    prval LENGTHcons (pflen) = pflen
    val @gflist_vt_cons (_, xs1) = xs
    val (pfapp, pf1len | xs2) = split (pflen | xs1, i-1)
    prval () = fold@ (xs)
  in
    (APPENDcons (pfapp), LENGTHcons (pf1len) | xs2)
  end else let
    val xs2 = xs
    val () = xs := gflist_vt_nil ()
    prval pfapp = append_unit_left ()
  in
    (pfapp, LENGTHnil () | xs2)
  end // end of [if]
// end of [split]

(* ****** ****** *)

absprop
UNION (
  ys1: ilist, ys2: ilist, res: ilist
) (* end of [absprop] *)

(* ****** ****** *)

extern
prfun
union_commute
  {ys1,ys2:ilist} {ys:ilist}
  (pf: UNION (ys1, ys2, ys)): UNION (ys2, ys1, ys)
// end of [union_commute]

extern
prfun
union_nil1 {ys:ilist} (): UNION (ilist_nil, ys, ys)
extern
prfun
union_nil2 {ys:ilist} (): UNION (ys, ilist_nil, ys)

extern
prfun
union_cons1
  {y:int}
  {ys1,ys2:ilist}
  {ys:ilist} (
  pf: UNION (ys1, ys2, ys)
) : UNION (ilist_cons (y, ys1), ys2, ilist_cons (y, ys))
// end of [union_cons1]

extern
prfun
union_cons2
  {y:int}
  {ys1,ys2:ilist}
  {ys:ilist} (
  pf: UNION (ys1, ys2, ys)
) : UNION (ys1, ilist_cons (y, ys2), ilist_cons (y, ys))
// end of [union_cons2]

extern
prfun
isord_union_cons
  {y1,y2:int | y1 <= y2}
  {ys1,ys2:ilist} {ys:ilist} (
  pf1: ISORD (ilist_cons (y1, ys1))
, pf2: ISORD (ilist_cons (y2, ys2))
, pf3: UNION (ys1, ilist_cons (y2, ys2), ys)
, pf4: ISORD (ys)
) : ISORD (ilist_cons (y1, ys))

(* ****** ****** *)

fun{
a:vt0p
} merge
  {ys1,ys2:ilist}
(
  pf1ord: ISORD (ys1)
, pf2ord: ISORD (ys2)
| ys1: gflist_vt (a, ys1), ys2: gflist_vt (a, ys2)
, ys: &ptr? >> gflist_vt (a, ys)
) : #[ys:ilist] (UNION (ys1, ys2, ys), ISORD (ys) | void) =
  case+ ys1 of
  | @gflist_vt_cons
      (y1, ys1_tl) =>
    (
    case+ ys2 of
    | @gflist_vt_cons
        (y2, ys2_tl) => let
        val sgn = gflist_vt_mergesort$cmp (y1, y2)
      in
        if sgn <= 0 then let
          val () = ys := ys1; val ys1 = ys1_tl
          prval () = fold@ (ys2)
          prval ISORDcons (pf1ord1, _) = pf1ord
          val (pfuni, pford | ()) = merge (pf1ord1, pf2ord | ys1, ys2, ys1_tl)
          prval pford = isord_union_cons (pf1ord, pf2ord, pfuni, pford)
          prval () = fold@ (ys)
          prval pfuni = union_cons1 (pfuni)
        in
          (pfuni, pford | ())
        end else let
          prval () = fold@ (ys1)
          val () = ys := ys2; val ys2 = ys2_tl
          prval ISORDcons (pf2ord1, _) = pf2ord
          val (pfuni, pford | ()) = merge (pf1ord, pf2ord1 | ys1, ys2, ys2_tl)
          prval pfuni = union_commute (pfuni)
          prval pford = isord_union_cons (pf2ord, pf1ord, pfuni, pford)
          prval () = fold@ (ys)
          prval pfuni = union_cons1 (pfuni)
          prval pfuni = union_commute (pfuni)
        in
          (pfuni, pford | ())
        end // end of [if]
      end // end of [gflist_vt_cons]
    | ~gflist_vt_nil () => let
        val () = fold@ (ys1); val () = ys := ys1 in (union_nil2 (), pf1ord | ())
      end // end of [gflist_vt_nil]
    ) (* end of [gflist_vt_cons] *)
  | ~gflist_vt_nil () => let
      val () = ys := ys2 in (union_nil1 (), pf2ord | ())
    end // end of [gflist_vt_nil]
// end of [merge]

(* ****** ****** *)

extern
prfun sort_nilsing
  {xs:ilist} {n:nat | n <= 1} (pf: LENGTH (xs, n)): SORT (xs, xs)
// end of [sort_nilsing]

(* ****** ****** *)

fun{
a:vt0p
} msort
  {xs:ilist}{n:nat} .<n>.
(
  pflen: LENGTH (xs, n)
| xs: gflist_vt (a, xs), n: int n
) : [ys:ilist] (
  SORT (xs, ys) | gflist_vt (a, ys)
) = let
in
//
if n >= 2 then let
  var xs = xs
  val n2 = half(n)
  val (pfapp, pf1len | xs2) = split (pflen | xs, n2)
  val xs1 = xs
  prval pf2len = length_istot ()
  prval pflen_alt = lemma_append_length (pfapp, pf1len, pf2len)
  prval () = length_isfun (pflen, pflen_alt)
  val (pf1srt | ys1) = msort (pf1len | xs1, n2)
  prval (pf1ord, pf1perm) = sort_elim (pf1srt)
  val (pf2srt | ys2) = msort (pf2len | xs2, n-n2)
  prval (pf2ord, pf2perm) = sort_elim (pf2srt)
  val (pfuni, pford | ()) = merge (pf1ord, pf2ord | ys1, ys2, xs)
//
  prval
  pfperm =
  lemma
  (
    pfapp, pf1perm, pf2perm, pfuni
  ) where
  {
    extern
    prfun
    lemma
    {xs1,xs2:ilist}{xs:ilist}
    {ys1,ys2:ilist}{ys:ilist}
    (
      APPEND (xs1, xs2, xs)
    , PERMUTE (xs1, ys1), PERMUTE (xs2, ys2), UNION (ys1, ys2, ys)
    ) : PERMUTE (xs, ys) // end of [lemma]
  } (* end of [where] *) // end of [prval]
//
  prval pfsrt = sort_make (pford, pfperm)
//
in
  (pfsrt | xs)
end else
  (sort_nilsing (pflen) | xs)
// end of [if]
//
end // end of [msort]

in (* in of [local] *)

implement
{a}(*tmp*)
gflist_vt_mergesort (xs) = let
  val (pflen | n) = gflist_vt_length<a> (xs) in msort<a> (pflen | xs, n)
end // end of [mergesort]

end // end of [local]

(* ****** ****** *)

(* end of [gflist_vt.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

#define
ATS_PACKNAME "ATSLIB.libats.funset_avltree"
#define
ATS_DYNLOADFLAG 0 // no need for dynloading at run-time

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libats/SATS/funset_avltree.sats"

(* ****** ****** *)
//
#include "./SHARE/funset.hats" // code reuse
//
(* ****** ****** *)
//
// HX: maximal height difference of two siblings
//
#define HTDF 1
#define HTDF1 (HTDF+1)
#define HTDF_1 (HTDF-1)
//
(* ****** ****** *)

datatype avltree
(
  a:t@ype+, int(*height*)
) =
  | {hl,hr:nat |
     hl <= hr+HTDF;
     hr <= hl+HTDF}
    B (a, 1+max(hl,hr)) of
      (int (1+max(hl,hr)), a, avltree (a, hl), avltree (a, hr))
  | E (a, 0) of ((*void*))
// end of [avltree]

typedef
avltree_inc (a:t0p, h:int) =
  [h1:nat | h <= h1; h1 <= h+1] avltree (a, h1)
// end of [avltree_inc] // end of [typedef]

typedef
avltree_dec (a:t0p, h:int) =
  [h1:nat | h1 <= h; h <= h1+1] avltree (a, h1)
// end of [avltree_dec] // end of [typedef]

(* ****** ****** *)

assume
set_type (a:t@ype) = [h:nat] avltree (a, h)

(* ****** ****** *)

implement{} funset_nil () = E ()
implement{} funset_make_nil () = E ()

(* ****** ****** *)

implement{a}
funset_sing (x) = B{a}(1, x, E, E)
implement{a}
funset_make_sing (x) = B{a}(1, x, E, E)

(* ****** ****** *)

implement
{a}(*tmp*)
funset_size
  (xs) = aux (xs) where
{
//
fun aux
  {h:nat} .<h>.
  (t: avltree (a, h)):<> size_t =
(
  case+ t of
  | B (_, _, tl, tr) => succ(aux (tl) + aux (tr))
  | E ((*void*)) => i2sz(0)
) (* end of [aux] *)
//
} // end of [funset_size]

(* ****** ****** *)

implement{}
funset_is_nil (xs) =
(
  case+ xs of B _ => false | E () => true
)
implement{}
funset_isnot_nil (xs) =
(
  case+ xs of B _ => true | E () => false
)

(* ****** ****** *)

implement{a}
funset_is_member
  (xs, x0) = aux (xs) where
{
//
fun aux {h:nat} .<h>.
  (t: avltree (a, h)):<> bool = let
in
//
case+ t of
| B (_, x, tl, tr) => let
    val sgn = compare_elt_elt<a> (x0, x)
  in
    if sgn < 0
      then aux (tl)
      else (if sgn > 0 then aux (tr) else true)
    // end of [if]
  end // end of [B]
| E ((*void*)) => false
//
end // end of [aux]
//
} // end of [funset_is_member]

(* ****** ****** *)

macdef
avlht (t) =
(
case+ ,(t) of B (h, _, _, _) => h | E ((*void*)) => 0
) // end of [avlht]

(* ****** ****** *)

fun{a:t0p}
avlmax{h:pos} .<h>.
  (t: avltree (a, h)):<> a = let
//
val+B{..}{hl,hr}(h, x, tl, tr) = t
//
in
//
case+ tr of B _ => avlmax<a> (tr) | E () => x
//
end // end of [avlmax]

(* ****** ****** *)

fun{a:t0p}
avlmin{h:pos} .<h>.
  (t: avltree (a, h)):<> a = let
//
val+B{..}{hl,hr}(h, x, tl, tr) = t
//
in
//
case+ tl of B _ => avlmin<a> (tl) | E () => x
//
end // end of [avlmin]

(* ****** ****** *)

(*
** left rotation for restoring height invariant
*)
fn{a:t0p}
avltree_lrotate
  {hl,hr:nat | hl+HTDF1 == hr}
(
  x: a
, hl : int hl
, tl: avltree (a, hl)
, hr : int hr
, tr: avltree (a, hr)
) :<> avltree_inc (a, hr) = let
  val+B{..}{hrl,hrr}(_, xr, trl, trr) = tr
  val hrl = avlht(trl) : int hrl
  and hrr = avlht(trr) : int hrr
in
//
if hrl <= hrr+HTDF_1 then let
  val hrl1 = hrl + 1
in
  B{a}(1+max(hrl1,hrr), xr, B{a}(hrl1, x, tl, trl), trr)
end else let // [hrl=hrr+2]: deep rotation
  val+B{..}{hrll,hrlr}(_(*hrl*), xrl, trll, trlr) = trl
  val hrll = avlht(trll) : int hrll
  and hrlr = avlht(trlr) : int hrlr
in
  B{a}(hr, xrl, B{a}(1+max(hl,hrll), x, tl, trll), B{a}(1+max(hrlr,hrr), xr, trlr, trr))
end // end of [if]
//
end // end of [avltree_lrotate]

(* ****** ****** *)

(*
** right rotation for restoring height invariant
*)
fn{a:t0p}
avltree_rrotate
  {hl,hr:nat | hl == hr+HTDF1}
(
  x: a
, hl: int hl
, tl: avltree (a, hl)
, hr: int hr
, tr: avltree (a, hr)
) :<> avltree_inc (a, hl) = let
  val+B{..}{hll,hlr}(_(*hl*), xl, tll, tlr) = tl
  val hll = avlht(tll) : int hll
  and hlr = avlht(tlr) : int hlr
in
//
if hll+HTDF_1 >= hlr then let
  val hlr1 = hlr + 1
in
  B{a}(1+max(hll,hlr1), xl, tll, B{a}(hlr1, x, tlr, tr))
end else let
  val+B{..}{hlrl,hlrr}(_(*hlr*), xlr, tlrl, tlrr) = tlr
  val hlrl = avlht(tlrl) : int hlrl
  and hlrr = avlht(tlrr) : int hlrr
in
  B{a}(hl, xlr, B{a}(1+max(hll,hlrl), xl, tll, tlrl), B{a}(1+max(hlrr,hr), x, tlrr, tr))
end // end of [if]
//
end // end of [avltree_rrotate]

(* ****** ****** *)

implement{a}
funset_insert
  (xs, x0) = found where
{
//
fun insert
  {h:nat} .<h>.
(
  t: avltree (a, h), found: &bool? >> bool
) :<!wrt> avltree_inc (a, h) = let
in
//
case+ t of
| B {..}{hl,hr}
    (h, x, tl, tr) => let
    val sgn = compare_elt_elt<a> (x0, x)
  in
    if sgn < 0 then let
      val [hl:int] tl = insert (tl, found)
      val hl = avlht(tl) : int hl
      and hr = avlht(tr) : int hr
    in
      if hl-hr <= HTDF
        then B{a}(1+max(hl,hr), x, tl, tr)
        else avltree_rrotate<a> (x, hl, tl, hr, tr)
      // end of [if]
    end else if sgn > 0 then let
      val [hr:int] tr = insert (tr, found)
      val hl = avlht(tl) : int hl
      and hr = avlht(tr) : int hr
    in
      if hr-hl <= HTDF
        then B{a}(1+max(hl, hr), x, tl, tr)
        else avltree_lrotate<a> (x, hl, tl, hr, tr)
      // end of [if]
    end else let (* [k0] already exists *)
      val () = found := true in B{a}(h, x0, tl, tr)
    end // end of [if]
  end // end of [B]
| E ((*void*)) => let // [x0] is not in [xs]
    val () = found := false in B{a}(1, x0, E(), E())
  end // end of [E]
end // end of [insert]
//
var found: bool // uninitialized
val () = (xs := insert (xs, found))
//
} // end of [funset_insert]

(* ****** ****** *)

fun{a:t0p}
avlmaxout{h:pos} .<h>.
(
  t: avltree (a, h), x0: &a? >> a
) :<!wrt> avltree_dec (a, h) = let
//
val+B{..}{hl,hr}(h, x, tl, tr) = t
//
in
//
case+ tr of
| B _ => let
    val [hr:int]
      tr = avlmaxout<a> (tr, x0)
    val hl = avlht(tl) : int(hl)
    and hr = avlht(tr) : int(hr)
  in
    if hl-hr <= HTDF
      then B{a}(1+max(hl,hr), x, tl, tr)
      else avltree_rrotate<a> (x, hl, tl, hr, tr)
    // end of [if]
  end // end of [B]
| E () => (x0 := x; tl)
//
end // end of [avlmaxout]

(* ****** ****** *)

fun{a:t0p}
avlminout{h:pos} .<h>.
(
  t: avltree (a, h), x0: &a? >> a
) :<!wrt> avltree_dec (a, h) = let
//
val+B{..}{hl,hr}(h, x, tl, tr) = t
//
in
//
case+ tl of
| B _ => let
    val [hl:int]
      tl = avlminout<a> (tl, x0)
    val hl = avlht(tl) : int(hl)
    and hr = avlht(tr) : int(hr)
  in
    if hr-hl <= HTDF
      then B{a}(1+max(hl,hr), x, tl, tr)
      else avltree_lrotate<a> (x, hl, tl, hr, tr)
    // end of [if]
  end // end of [B]
| E () => (x0 := x; tr)
//
end // end of [avlminout]

(* ****** ****** *)

(*
** left join: height(tl) >= height(tr)
*)
fun{a:t0p}
avltree_ljoin
  {hl,hr:nat | hl >= hr} .<hl>.
(
  x: a, tl: avltree (a, hl), tr: avltree (a, hr)
) :<> avltree_inc (a, hl) = let
  val hl = avlht(tl) : int hl
  and hr = avlht(tr) : int hr
in
//
if hl >= hr + HTDF1 then let
  val+B{..}{hll, hlr}(_, xl, tll, tlr) = tl
  val [hlr:int] tlr = avltree_ljoin<a> (x, tlr, tr)
  val hll = avlht(tll) : int hll
  and hlr = avlht(tlr) : int hlr
in
  if hlr <= hll + HTDF
    then B{a}(max(hll,hlr)+1, xl, tll, tlr)
    else avltree_lrotate<a> (xl, hll, tll, hlr, tlr)
  // end of [if]
end else B{a}(hl+1, x, tl, tr) // end of [if]
//
end // end of [avltree_ljoin]

(* ****** ****** *)

(*
** right join: height(tl) <= height(tr)
*)
fun{a:t0p}
avltree_rjoin
  {hl,hr:nat | hl <= hr} .<hr>.
(
  x: a, tl: avltree (a, hl), tr: avltree (a, hr)
) :<> avltree_inc (a, hr) = let
  val hl = avlht(tl) : int hl
  and hr = avlht(tr) : int hr
in
//
if hr >= hl + HTDF1 then let
  val+B{..}{hrl,hrr}(_, xr, trl, trr) = tr
  val [hrl:int] trl = avltree_rjoin<a> (x, tl, trl)
  val hrl = avlht(trl) : int hrl
  and hrr = avlht(trr) : int hrr
in
  if hrl <= hrr + HTDF
    then B{a}(max(hrl,hrr)+1, xr, trl, trr)
    else avltree_rrotate<a> (xr, hrl, trl, hrr, trr)
  // end of [if]
end else B{a}(hr+1, x, tl, tr) // end of [if]
//
end // end of [avltree_rjoin]

(* ****** ****** *)

fn{a:t0p}
avltree_join3
  {hl,hr:nat}
(
  x: a, tl: avltree (a, hl), tr: avltree (a, hr)
) :<> [
  h:int | hl <= h; hr <= h; h <= max(hl,hr)+1
] avltree (a, h) = let
  val hl = avlht(tl) : int hl
  and hr = avlht(tr) : int hr
in
  if hl >= hr then
    avltree_ljoin<a> (x, tl, tr) else avltree_rjoin<a> (x, tl, tr)
  // end of [if]
end // end of [avltree_join3]

(* ****** ****** *)

fn{a:t0p}
avltree_join2
  {hl,hr:nat}
(
  tl: avltree (a, hl), tr: avltree (a, hr)
) :<> [h:nat | h <= max(hl,hr)+1] avltree (a, h) =
(
case+
  (tl, tr) of
| (E (), _) => tr
| (_, E ()) => tl
| (_, _) =>> let
    var xmin: a // uninitialized
    val tr = $effmask_wrt (avlminout<a> (tr, xmin))
  in
    avltree_join3<a> (xmin, tl, tr)
  end // end of [_, _]
) // end of [avltree_join2]

(* ****** ****** *)

fun{a:t@ype}
avltree_split_at
  {h:nat} .<h>.
(
  t: avltree (a, h), x0: a
, tl0: &ptr? >> avltree (a, hl)
, tr0: &ptr? >> avltree (a, hr)
) :<!wrt>
  #[i,hl,hr:nat | i <= 1; hl <= h; hr <= h] int (i) =
(
case+ t of
| B (_, x, tl, tr) => let
    val sgn = compare_elt_elt<a> (x0, x)
  in
    if sgn < 0 then let
      val i = avltree_split_at<a> (tl, x0, tl0, tr0)
    in
      tr0 := avltree_join3<a> (x, tr0, tr); i
    end else if sgn > 0 then let
      val i = avltree_split_at<a> (tr, x0, tl0, tr0)
    in
      tl0 := avltree_join3<a> (x, tl, tl0); i
    end else (
      tl0 := tl; tr0 := tr; 1 // [x] is found in [t]
    ) // end of [if]
  end // end of [B]
| E ((*void*)) => (tl0 := E (); tr0 := E (); 0)
) // end of [avltree_split_at]

(* ****** ****** *)

implement{a}
funset_remove
  (xs, x0) = let
//
fun remove{h:nat} .<h>.
(
  t: avltree (a, h), found: &bool? >> bool
) :<!wrt> avltree_dec (a, h) = let
in
//
case+ t of
| B {..}{hl,hr}
    (h, x, tl, tr) => let
    val sgn = compare_elt_elt<a> (x0, x)
  in
    case+ 0 of
    | _ when sgn < 0 => let
        val [hl:int] tl = remove (tl, found)
        val hl = avlht(tl) : int hl
        and hr = avlht(tr) : int hr
      in
        if hr-hl <= HTDF
          then B{a}(1+max(hl,hr), x, tl, tr)
          else avltree_lrotate<a> (x, hl, tl, hr, tr)
        // end of [if]
      end // end of [sgn < 0]
    | _ when sgn > 0 => let
        val [hr:int] tr = remove (tr, found)
        val hl = avlht(tl) : int hl
        and hr = avlht(tr) : int hr
      in
        if hl-hr <= HTDF
          then B{a}(1+max(hl,hr), x, tl, tr)
          else avltree_rrotate<a> (x, hl, tl, hr, tr)
        // end of [if]
      end // end of [sgn > 0]
    | _ (*sgn = 0*) => let
        val () = found := true
      in
        case+ tr of
        | B _ => let
            var xmin: a? // uninitialized
            val [hr:int] tr = avlminout<a> (tr, xmin)
            val hl = avlht(tl) : int (hl)
            and hr = avlht(tr) : int (hr)
          in
            if hl-hr <= HTDF
              then B{a}(1+max(hl,hr), xmin, tl, tr)
              else avltree_rrotate<a> (xmin, hl, tl, hr, tr)
            // end of [if]
          end // end of [B]
        | E _ => tl
      end // end of [sgn = 0]
    end // end of [B]
| E ((*void*)) =>
    let val () = found := false in E () end
  (* end of [E] *)
//
end // end of [remove]
//
var found: bool
val () = (xs := remove (xs, found))
//
in
  found
end // end of [funset_remove]

(* ****** ****** *)

implement{a}
funset_getmax
  (xs, x0) = let
in
//
case+ xs of
| B _ => let
    val () = x0 := avlmax<a> (xs)
    prval () = opt_some{a}(x0) in true
  end // end of [B]
| E _ => let
    prval () = opt_none{a}(x0) in false
  end // end of [E]
//
end // end of [funset_getmax]

(* ****** ****** *)

implement{a}
funset_getmin
  (xs, x0) = let
in
//
case+ xs of
| B _ => let
    val () = x0 := avlmin<a> (xs)
    prval () = opt_some{a}(x0) in true
  end // end of [B]
| E _ => let
    prval () = opt_none{a}(x0) in false
  end // end of [E]
//
end // end of [funset_getmin]

(* ****** ****** *)

implement{a}
funset_takeoutmax
  (xs, x0) = let
in
//
case+ xs of
| B _ => let
    val (
    ) = xs := avlmaxout<a> (xs, x0)
    prval ((*void*)) = opt_some{a}(x0)
  in
    true
  end // end of [B]
| E _ => let
    prval () = opt_none{a}(x0)
  in
    false
  end // end of [E]
//
end // end of [funset_takeoutmax]

(* ****** ****** *)

implement{a}
funset_takeoutmin
  (xs, x0) = let
in
//
case+ xs of
| B _ => let
    val (
    ) = xs := avlminout<a> (xs, x0)
    prval ((*void*)) = opt_some{a}(x0)
  in
    true
  end // end of [B]
| E _ => let
    prval () = opt_none{a}(x0)
  in
    false
  end // end of [E]
//
end // end of [funset_takeoutmin]

(* ****** ****** *)

implement
{a}(*tmp*)
funset_union
  (t1, t2) = let
//
fun aux
  {h1,h2:nat} .<h1>.
(
  t1: avltree (a, h1)
, t2: avltree (a, h2)
) :<!wrt> [h:nat] avltree (a, h) =
(
  case+ (t1, t2) of
  | (E (), _) => t2
  | (_, E ()) => t1
  | (_, _) =>> let
      val+B (_, x1, t1l, t1r) = t1
      var t2l0: ptr and t2r0: ptr
      val i = avltree_split_at<a> (t2, x1, t2l0, t2r0)
      val t12l = aux (t1l, t2l0) and t12r = aux (t1r, t2r0)
    in
      avltree_join3<a> (x1, t12l, t12r)
    end // end of [_, _]
) // end of [aux] // [aux] is a keyword
//
in
//
$effmask_wrt (aux (t1, t2))
//
end // end of [funset_union]

(* ****** ****** *)

implement
{a}(*tmp*)
funset_intersect
  (t1, t2) = let
//
fun aux
  {h1,h2:nat} .<h1>.
(
  t1: avltree (a, h1), t2: avltree (a, h2)
) :<!wrt> [h:nat] avltree (a, h) = let
in
//
case+
  (t1, t2) of
| (E (), _) => E ()
| (_, E ()) => E ()
| (_, _) =>> let
    val+B (_, x1, t1l, t1r) = t1
    var t2l0: ptr and t2r0: ptr
    val i = avltree_split_at<a> (t2, x1, t2l0, t2r0)
    val t12l = aux (t1l, t2l0) and t12r = aux (t1r, t2r0)
  in
    if i = 0 then
      avltree_join2<a> (t12l, t12r) else avltree_join3<a> (x1, t12l, t12r)
    // end of [if]
  end // end of [_, _]
end // end // end of [aux]
//
in
//
$effmask_wrt (aux (t1, t2))
//
end // end of [funset_intersect]

(* ****** ****** *)

implement
{a}(*tmp*)
funset_differ
  (t1, t2) = let
//
fun aux
  {h1,h2:nat} .<h1>.
(
  t1: avltree (a, h1), t2: avltree (a, h2)
) :<!wrt> [h:nat] avltree (a, h) = let
in
//
case+
  (t1, t2) of
| (E (), _) => E ()
| (_, E ()) => t1
| (_, _) =>> let
    val+B (_, x1, t1l, t1r) = t1
    var t2l0: ptr and t2r0: ptr
    val i = avltree_split_at<a> (t2, x1, t2l0, t2r0)
    val t12l = aux (t1l, t2l0) and t12r = aux (t1r, t2r0)
  in
    if i > 0 then
      avltree_join2<a> (t12l, t12r) else avltree_join3<a> (x1, t12l, t12r)
    // end of [if]
  end // end of [_, _]
//
end // end of [aux]
//
in
//
$effmask_wrt (aux (t1, t2))
//
end // end of [funset_differ]

(* ****** ****** *)

implement
{a}(*tmp*)
funset_symdiff
  (t1, t2) = let
//
fun aux {h1,h2:nat} .<h1>.
(
  t1: avltree (a, h1), t2: avltree (a, h2)
) :<!wrt> [h:nat] avltree (a, h) = let
in
//
case+
  (t1, t2) of
| (E (), _) => t2
| (_, E ()) => t1
| (_, _) =>> let
    val+B (_, x1, t1l, t1r) = t1
    var t2l0: ptr and t2r0: ptr
    val i = avltree_split_at<a> (t2, x1, t2l0, t2r0)
    val t12l = aux (t1l, t2l0) and t12r = aux (t1r, t2r0)
  in
    if i > 0 then
      avltree_join2<a> (t12l, t12r) else avltree_join3<a> (x1, t12l, t12r)
    // end of [if]
  end // end of [_, _]
//
end // end of [aux]
//
in
//
$effmask_wrt (aux (t1, t2))
//
end // end of [funset_symdiff]

(* ****** ****** *)

implement{a}
funset_equal
  (t1, t2) = let
//
fun aux
  {h1,h2:nat} .<h1>.
(
  t1: avltree (a, h1), t2: avltree (a, h2)
) :<!wrt> bool = let
in
//
case+
  (t1, t2) of
| (E _, E _) => true
| (E _, B _) => false
| (B _, E _) => false
| (_, _) =>> let
    val+B(_, x1, t1l, t1r) = t1
    var t2l0: ptr and t2r0: ptr
    val i = avltree_split_at<a> (t2, x1, t2l0, t2r0)
  in
    if i > 0 then
      (if aux (t1l, t2l0) then aux (t1r, t2r0) else false)
    else false // end of [if]
  end // end of [_, _]
//
end // end of [aux]    
//
in
//
$effmask_wrt (aux (t1, t2))
//
end // end of [funset_equal]

(* ****** ****** *)

implement{a}
funset_compare
  (t1, t2) = let
//
fun aux
  {h1,h2:nat} .<h1>.
(
  t1: avltree (a, h1), t2: avltree (a, h2)
) :<!wrt> Sgn = let
in
//
case+
  (t1, t2) of
| (E _, E _) => 0
| (E _, B _) => ~1
| (B _, E _) => 1
| (_, _) =>> let
    val+B(_, x1, t1l, t1r) = t1
    var t2l0: ptr and t2r0: ptr
    val i = avltree_split_at<a> (t2, x1, t2l0, t2r0)
  in
    if i = 0 then let
      val sgn_r = aux (t1r, t2r0)
    in
      if sgn_r >= 0 then 1 else ~1
    end else let
      val sgn_r = aux (t1r, t2r0)
    in
      if sgn_r = 0 then aux (t1l, t2l0) else sgn_r
    end (* end of [if] *)
  end // end of [_, _]
//
end // end of [aux]    
//
in
//
$effmask_wrt (aux (t1, t2))
//
end // end of [funset_compare]

(* ****** ****** *)

implement{a}
funset_is_subset
  (t1, t2) = let
//
fun aux
  {h1,h2:nat} .<h1>.
(
  t1: avltree (a, h1), t2: avltree (a, h2)
) :<!wrt> bool = let
in
//
case+
  (t1, t2) of
| (E (), _) => true
| (_, E ()) => false
| (_, _) =>> let
    val+B(_, x1, t1l, t1r) = t1
    var t2l0: ptr and t2r0: ptr
    val i = avltree_split_at<a> (t2, x1, t2l0, t2r0)
  in
    if i > 0 then
      (if aux (t1l, t2l0) then aux (t1r, t2r0) else false)
    else false // end of [if]
  end // end of [_, _]
//
end // end of [test]    
//
in
//
$effmask_wrt (aux (t1, t2))
//
end // end of [funset_is_subset]

(* ****** ****** *)

implement
{a}{env}
funset_foreach_env
  (xs, env) = let
//
val p_env = addr@ (env)
//
fun foreach
  {h:nat} .<h>.
(
  t: avltree (a, h), p_env: ptr
) : void = let
in
//
case+ t of
| B (_, x, tl, tr) => let
//
    val () = foreach (tl, p_env)
//
    val (
      pf, fpf | p_env
    ) = $UN.ptr_vtake (p_env)
    val () = funset_foreach$fwork<a><env> (x, !p_env)
    prval () = fpf (pf)
//
    val () = foreach (tr, p_env)
//
  in
    // nothing
  end // end of [B]
| E ((*void*)) => ()
//
end // end of [foreach]
//
in
  foreach (xs, p_env)
end // end of [funset_foreach_env]

(* ****** ****** *)

implement
{a}(*tmp*)
funset_listize
  (xs) = let
//
fun aux
  {h:nat} .<h>.
(
  t: avltree (a, h), res: List0_vt(a)
) :<> List0_vt(a) = let
in
//
case+ t of
| B (_, x, tl, tr) => let
    val res = aux (tr, res)
    val res = list_vt_cons{a}(x, res)
    val res = aux (tl, res)
  in
    res
  end // end of [B]
| E ((*void*)) => res
//
end // end of [aux]
//
in
  aux (xs, list_vt_nil)
end // end of [funset_listize]

(* ****** ****** *)

implement{a}
funset_avltree_height (xs) = avlht (xs)

(* ****** ****** *)

(* end of [funset_avltree.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2015 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
**
** Functional mset based on ordered lists
**
** Contributed by Hongwei Xi (hwxi AT cs DOT bu DOT edu)
** Time: May 18, 2011
**
*)

(* ****** ****** *)
//
// HX-2015-09: ported to ATS/Postitats from ATS/Anairiats
//
(* ****** ****** *)

#define
ATS_PACKNAME "ATSLIB.libats.funmset_listord"
#define
ATS_DYNLOADFLAG 0 // no need for dynloading at run-time
#define
ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libats/SATS/funmset_listord.sats"

(* ****** ****** *)
//
#include "./SHARE/funmset.hats" // code reuse
//
(* ****** ****** *)

assume
mset_type (a: t0p) = List0 @(intGt(0), a)

(* ****** ****** *)
//
// HX:
// A mset is represented as a sorted list in descending order;
// note that descending order is chosen to faciliate set comparison
//
(* ****** ****** *)

implement
{}(*tmp*)
funmset_nil () = list_nil()
implement
{}(*tmp*)
funmset_make_nil () = list_nil()

(* ****** ****** *)
//
implement
{a}(*tmp*)
funmset_sing
  (x) = list_cons((1, x), list_nil)
implement
{a}(*tmp*)
funmset_make_sing
  (x) = list_cons((1, x), list_nil)
//
(* ****** ****** *)

implement
{a}(*tmp*)
funmset_make_list
  (xs) = let
//
fun
loop1
(
  xs: List_vt(a)
) : mset(a) =
(
case+ xs of
| ~nil_vt() => list_nil()
| ~cons_vt(x, xs) => loop2(xs, x, 1, list_nil)
) (* end of [loop1] *)
//
and
loop2
(
  xs: List_vt(a), x0: a, n: intGt(0), res: mset(a)
) : mset(a) =
(
case+ xs of
| ~nil_vt() =>
    list_cons ((n, x0), res)
  // end of [list_nil]
| ~cons_vt(x1, xs) => let
    val sgn = compare_elt_elt<a> (x0, x1)
  in
    if sgn = 0
      then loop2(xs, x0, n+1, res)
      else loop2(xs, x1, 1, list_cons ((n, x0), res))
    // end of [if]
  end // end of [list_cons]
)
//
implement
list_mergesort$cmp<a>
  (x1, x2) = compare_elt_elt<a> (x1, x2)
//
in
  $effmask_all(loop1(list_mergesort(xs)))
end // end of [funmset_make_list]

(* ****** ****** *)
//
implement
{}(*tmp*)
funmset_is_nil(nxs) = list_is_nil(nxs)
implement
{}(*tmp*)
funmset_isnot_nil(nxs) = list_is_cons(nxs)
//
(* ****** ****** *)

implement
{a}(*tmp*)
funmset_size(nxs) = let
//
fun
loop
(
  nxs: List0 @(intGt(0), a), res: size_t
) : size_t =
(
case+ nxs of
| list_nil
    ((*void*)) => res
| list_cons
    ((n, x), nxs) => loop (nxs, res+i2sz(n))
  // end of [list_cons]
)
//
in
  $effmask_all(loop(nxs, i2sz(0)))
end // end of [funmset_size]

(* ****** ****** *)
//
implement
{a}(*tmp*)
funmset_is_member
  (nxs, x0) = funmset_get_ntime(nxs, x0) > 0
implement
{a}(*tmp*)
funmset_isnot_member
  (nxs, x0) = funmset_get_ntime(nxs, x0) = 0
//
(* ****** ****** *)

implement
{a}(*tmp*)
funmset_get_ntime
  (nxs, x0) = let
//
fun
loop
(
  nxs: List0 @(intGt(0), a), x0: a
) : intGte(0) =
(
case+ nxs of
| list_nil
    ((*void*)) => 0
| list_cons
    ((n, x), nxs) => let
    val sgn = compare_elt_elt<a> (x0, x)
  in
    if sgn < 0
      then loop(nxs, x0) else (if sgn > 0 then 0 else n)
    // end of [if]
  end // end of [list_cons]
) (* end of [loop] *)
//
in
  loop(nxs, x0)
end // end of [funmset_get_ntime]

(* ****** ****** *)

implement
{a}(*tmp*)
funmset_insert2
  (nxs, n0, x0) = let
//
typedef nx = @(intGt(0), a)
//
fun
loop
(
  nxs: List(nx)
, nbef: &int? >> intGte(0)
) : List0 nx =
(
//
case+ nxs of
| list_nil() => let
    val () = nbef := 0
  in
    list_cons((n0, x0), list_nil)
  end // end of [list_nil]
| list_cons
    (nx, nxs2) => let
    val x1 = nx.1
    val sgn =
      compare_elt_elt<a> (x0, nx.1)
    // end of [val]
  in
    if sgn < 0
      then list_cons(nx, loop(nxs2, nbef))
      else (
        if sgn > 0
          then (nbef := 0; list_cons((n0, x0), nxs))
          else (nbef := nx.0; list_cons((nbef+n0, x1), nxs2))
        // end of [if]
      ) (* end of [else] *)
    // end of [if]
  end // end of [list_cons]
) (* end of [loop] *)
//
var nbef: int // uninitized
//
in
  nxs := loop(nxs, nbef); nbef
end // end of [funmset_insert2]

(* ****** ****** *)

implement
{a}(*tmp*)
funmset_remove2
  (nxs, n0, x0) = let
//
typedef nx = @(intGt(0), a)
//
fun
loop
(
  nxs: List(nx), nbef: &int? >> intGte(0)
) : List0 nx =
(
//
case+ nxs of
| list_nil() =>
  (
    nbef := 0; list_nil()
  ) // end of [list_nil]
| list_cons
    (nx, nxs2) => let
    val x1 = nx.1
    val sgn =
      compare_elt_elt<a> (x0, nx.1)
    // end of [val]
  in
    if sgn < 0
      then list_cons(nx, loop(nxs2, nbef))
      else (
        if sgn > 0
          then (nbef := 0; nxs)
          else let
            val () = nbef := nx.0
          in
            if n0 <= nbef
              then nxs2 else list_cons((n0-nbef, nx.1), nxs2)
            // end of [if]
          end // end of [else]
        // end of [if]
      ) (* end of [else] *)
    // end of [if]
  end // end of [list_cons]
) (* end of [loop] *)
//
var nbef: int // uninitized
//
in
  nxs := loop(nxs, nbef); nbef
end // end of [funmset_remove2]

(* ****** ****** *)

implement
{a}(*tmp*)
funmset_union
  (nxs, nys) = let
//
typedef nx = (intGt(0), a)
//
prval () = lemma_list_param(nxs)
prval () = lemma_list_param(nys)
//
fun
union
(
  nxs: List0(nx)
, nys: List0(nx)
) : List0(nx) = (
//
case+
(nxs, nys) of
// case+
| (list_nil(), _) => nys
| (_, list_nil()) => nxs
| (list_cons(nx, nxs2),
   list_cons(ny, nys2)) => let
   val x = nx.1
   and y = ny.1
   val sgn = compare_elt_elt<a> (x, y)
 in
   if sgn < 0
     then list_cons(ny, union(nxs, nys2))
     else (
       if sgn > 0
         then list_cons(nx, union(nxs2, nys))
         else list_cons((nx.0+ny.0, x), union(nxs2, nys2))
       // end of [if]
     ) (* end of [if] *)
   // end of [if]
 end // end of [cons, cons]
//
) (* end of [union] *)
//
in
  union(nxs, nys)
end // end of [funmset_union]

(* ****** ****** *)

implement
{a}(*tmp*)
funmset_intersect
  (nxs, nys) = let
//
typedef nx = (intGt(0), a)
//
prval () = lemma_list_param(nxs)
prval () = lemma_list_param(nys)
//
fun
intersect
(
  nxs: List0(nx)
, nys: List0(nx)
) : List0(nx) = (
//
case+
(nxs, nys) of
// case+
| (list_nil(), _) => list_nil()
| (_, list_nil()) => list_nil()
| (list_cons(nx, nxs2),
   list_cons(ny, nys2)) => let
   val x = nx.1
   and y = ny.1
   val sgn = compare_elt_elt<a> (x, y)
 in
   if sgn < 0
     then intersect(nxs, nys2)
     else (
       if sgn > 0
         then intersect(nxs2, nys)
         else list_cons((min(nx.0,ny.0), x), intersect(nxs2, nys2))
       // end of [if]
     ) (* end of [if] *)
   // end of [if]
 end // end of [cons, cons]
//
) (* end of [intersect] *)
//
in
  intersect(nxs, nys)
end // end of [funmset_intersect]

(* ****** ****** *)

implement
{a}{env}
funmset_foreach_env
  (nxs, env) = let
//
fun
loop:
$d2ctype
(
  funmset_foreach_env<a><env>
) =
lam(nxs, env) =>
(
case+ nxs of
| list_nil
    ((*void*)) => ()
| list_cons
    ((n, x), nxs) => let
    val () = funmset_foreach$fwork(n, x, env)
  in
    loop(nxs, env)
  end // end of [list_cons]
)
//
in
  loop(nxs, env)
end // end of [funmset_foreach_env]

(* ****** ****** *)

(* end of [funmset_listord.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (hwxi AT cs DOT bu DOT edu)
// Time: October, 2010
//
(* ****** ****** *)
//
// HX: reasoning about integer sequences
//
(* ****** ****** *)
//
// HX-2012-12: starting to implement proofs
//
(* ****** ****** *)

staload "libats/SATS/ilist_prf.sats"

(* ****** ****** *)

(*
prfun
ILISTEQ2_elim
  {xs1,xs2:ilist}
  (pf: ILISTEQ2(xs1, xs2)): ILISTEQ(xs1, xs2)
// end of [ILISTEQ2_elim]
*)
primplmnt
ILISTEQ2_elim (pf) = let
//
prfun lemma
  {xs1,xs2:ilist} .<xs1>.
(
  pf: ILISTEQ2(xs1, xs2)
) : ILISTEQ(xs1, xs2) = let
in
//
case+ pf of
| ILISTEQ2nil() => ILISTEQ()
| ILISTEQ2cons(pf) => let
    prval ILISTEQ () = lemma (pf) in ILISTEQ ()
  end // end of [ILISTEQ_cons]
//
end // end of [lemma]
//
in
  lemma (pf)
end // end of [ILISTEQ2_elim]

(* ****** ****** *)

(*
prfun length_istot {xs:ilist} (): [n:nat] LENGTH (xs, n)
*)
primplmnt
length_istot {xs} () = let
//
prfun lemma
  {xs:ilist} .<xs>. (): [n:nat] LENGTH (xs, n) = (
  scase xs of
  | ilist_cons (x, xs) => LENGTHcons (lemma {xs} ()) | ilist_nil () => LENGTHnil ()
) // end of [lemma]
//
in
  lemma {xs} ()
end // end of [length_istot]

(* ****** ****** *)

(*
prfun length_isfun {xs:ilist} {n1,n2:int}
  (pf1: LENGTH (xs, n1), pf2: LENGTH (xs, n2)): [n1==n2] void
// end of [length_isfun]
*)
primplmnt
length_isfun {xs} (pf1, pf2) = let
//
prfun lemma
  {xs:ilist} {n1,n2:int} .<xs>. (
  pf1: LENGTH (xs, n1), pf2: LENGTH (xs, n2)
) : [n1==n2] void = let
in
//
case+ (pf1, pf2) of
| (LENGTHcons (pf1),
   LENGTHcons (pf2)) => lemma (pf1, pf2)
| (LENGTHnil (), LENGTHnil ()) => ()
//
end // end of [length_isfun]
//
in
  lemma (pf1, pf2)
end // end of [length_isfun]

(* ****** ****** *)

(*
prfun length_isnat
  {xs:ilist} {n:int} (pf: LENGTH (xs, n)): [n>=0] void
// end of [length_isnat]
*)
primplmnt
length_isnat (pf) = (
  case+ pf of LENGTHcons _ => () | LENGTHnil () => ()
) // end of [length_isnat]

(* ****** ****** *)

(*
prfun
lemma_snoc_length
  {xs:ilist}{x:int}{xsx:ilist}{n:int}
  (pf1: SNOC (xs, x, xsx), pf2: LENGTH (xs, n)): LENGTH (xsx, n+1)
// end of [lemma_snoc_length]
*)
primplmnt
lemma_snoc_length
  (pf1, pf2) = let
//
prfun
lemma
  {xs:ilist}
  {x:int}
  {xsx:ilist}
  {n:int} .<xs>. (
  pf1: SNOC (xs, x, xsx), pf2: LENGTH (xs, n)
) : LENGTH (xsx, n+1) = let
in
//
case+ pf1 of
//
| SNOCnil () => let
    prval LENGTHnil () = pf2 in LENGTHcons (LENGTHnil ())
  end // end of [SNOCnil]
//
| SNOCcons (pf1) => let
    prval LENGTHcons (pf2) = pf2 in LENGTHcons (lemma (pf1, pf2))
  end // end of [SNOCcons]
//
end // end of [lemma]
//
in
  lemma (pf1, pf2)
end // end of [lemma_snoc_length]

(* ****** ****** *)

primplmnt
append_istot
  {xs,ys} () = let
//
prfun
istot {xs,ys:ilist} .<xs>.
  () : [zs:ilist] APPEND (xs, ys, zs) =
  scase xs of
  | ilist_nil () => APPENDnil ()
  | ilist_cons (x, xs) => APPENDcons (istot {xs,ys} ())
// end of [istot]
in
  istot {xs,ys} ()
end // end of [append_istot]

primplmnt
append_isfun
  (pf1, pf2) = let
//
prfun isfun
  {xs,ys:ilist}
  {zs1,zs2:ilist} .<xs>. (
  pf1: APPEND (xs, ys, zs1), pf2: APPEND (xs, ys, zs2)
) : ILISTEQ (zs1, zs2) = (
  case+ (pf1, pf2) of
  | (APPENDnil (), APPENDnil ()) => ILISTEQ ()
  | (APPENDcons (pf1), APPENDcons (pf2)) => let
      prval ILISTEQ () = isfun (pf1, pf2) in ILISTEQ ()
    end // end of [...]
) // end of [isfun]
in
  isfun (pf1, pf2)
end // end of [append_isfun]

(* ****** ****** *)

primplmnt
append_unit_left () = APPENDnil ()

primplmnt
append_unit_right {xs} () = let
//
prfun lemma
  {xs:ilist} .<xs>. (
) : APPEND (xs, ilist_nil, xs) =
  scase xs of
  | ilist_cons (x, xs) => APPENDcons (lemma {xs} ())
  | ilist_nil () => APPENDnil ()
//
in
  lemma {xs} ()
end // end of [append_unit_right]

(* ****** ****** *)

primplmnt
append_sing () = APPENDcons (APPENDnil ())

(* ****** ****** *)

(*
prfun
lemma_append_length
  {xs1,xs2:ilist}
  {xs:ilist}
  {n1,n2:int} (
  pf: APPEND (xs1, xs2, xs), pf1len: LENGTH (xs1, n1), pf2len: LENGTH (xs2, n2)
) : LENGTH (xs, n1+n2) // end of [lemma_append_length]
*)
primplmnt
lemma_append_length
  (pf, pf1len, pf2len) = let
//
prfun lemma
  {xs1,xs2:ilist}
  {xs:ilist}
  {n1,n2:nat} .<xs1>. (
  pf: APPEND (xs1, xs2, xs), pf1len: LENGTH (xs1, n1), pf2len: LENGTH (xs2, n2)
) : LENGTH (xs, n1+n2) = let
in
//
case+ pf of
| APPENDnil () => let
    prval LENGTHnil () = pf1len in pf2len
  end // end of [APPENDnil]
| APPENDcons (pf) => let
    prval LENGTHcons (pf1len) = pf1len in LENGTHcons (lemma (pf, pf1len, pf2len))
  end // end of [APPENDcons]
//
end // end of [lemma]
//
prval () = length_isnat (pf1len)
prval () = length_isnat (pf2len)
//
in
  lemma (pf, pf1len, pf2len)
end // end of [lemma_append_length]

(* ****** ****** *)

(*
prfun
lemma_append_snoc
  {xs1:ilist}
  {x:int}
  {xs2:ilist}
  {xs1x:ilist}
  {xs:ilist} (
  pf1: APPEND (xs1, ilist_cons (x, xs2), xs)
, pf2: SNOC (xs1, x, xs1x)
) : APPEND (xs1x, xs2, xs) // end of [lemma_append_snoc]
*)
primplmnt
lemma_append_snoc
  (pf1, pf2) = let
//
prfun
lemma
  {xs1:ilist}
  {x:int}
  {xs2:ilist}
  {xs1x:ilist}
  {xs:ilist} .<xs1>. (
  pf1: APPEND (xs1, ilist_cons (x, xs2), xs)
, pf2: SNOC (xs1, x, xs1x)
) : APPEND (xs1x, xs2, xs) = let
in
//
case+ pf1 of
| APPENDnil () => let
    prval SNOCnil () = pf2 in APPENDcons (APPENDnil)
  end // end of [APPENDnil]
| APPENDcons (pf1) => let
    prval SNOCcons (pf2) = pf2 in APPENDcons (lemma (pf1, pf2))
  end // end of [APPENDcons]
//
end // end of [lemma]
//
in
  lemma (pf1, pf2)
end // end of [lemma_append_snoc]

(* ****** ****** *)

(*
prfun
lemma_append_assoc
  {xs1,xs2,xs3:ilist}
  {xs12,xs23:ilist}
  {xs12_3,xs1_23:ilist} (
  pf12: APPEND (xs1, xs2, xs12), pf23: APPEND (xs2, xs3, xs23)
, pf12_3: APPEND (xs12, xs3, xs12_3), pf1_23: APPEND (xs1, xs23, xs1_23)
) : ILISTEQ (xs12_3, xs1_23) // end of [lemma_append_assoc]
*)
primplmnt
lemma_append_assoc (
  pf12, pf23, pf12_3, pf1_23
) = let
//
prfun
lemma
  {xs1,xs2,xs3:ilist}
  {xs12,xs23:ilist}
  {xs12_3,xs1_23:ilist} .<xs1>. (
  pf12: APPEND (xs1, xs2, xs12), pf23: APPEND (xs2, xs3, xs23)
, pf12_3: APPEND (xs12, xs3, xs12_3), pf1_23: APPEND (xs1, xs23, xs1_23)
) : ILISTEQ (xs12_3, xs1_23) = let
in
//
case+ pf12 of
| APPENDnil () => let
    prval APPENDnil () = pf1_23
    prval ILISTEQ () = append_isfun (pf23, pf12_3)
  in
    ILISTEQ ()
  end // end of [APPENDnil]
| APPENDcons (pf12) => let
    prval APPENDcons (pf12_3) = pf12_3
    prval APPENDcons (pf1_23) = pf1_23
    prval ILISTEQ () = lemma (pf12, pf23, pf12_3, pf1_23)
  in
    ILISTEQ ()
  end // end of [APPENDcons]
//
end // end of [lemma]
//
in
  lemma (pf12, pf23, pf12_3, pf1_23)
end // end of [lemma_append_assoc]

(* ****** ****** *)

(*
prfun
lemma_nth_ilisteq
  {xs1,xs2:ilist}{n:int}
(
  pf1len: LENGTH (xs1, n), pf2len: LENGTH (xs2, n)
, fpf: {x:int}{i:int | i < n} NTH (x, xs1, i) -> NTH (x, xs2, i)
) : ILISTEQ (xs1, xs2) =
*)
primplmnt
lemma_nth_ilisteq
  (pf1len, pf2len, fpf) = let
//
prval () = length_isnat(pf1len)
//
prfun
lemma
  {xs1,xs2:ilist}
  {n:nat} .<n>. (
  pf1len: LENGTH (xs1, n)
, pf2len: LENGTH (xs2, n)
, fpf: {x:int}{i:int | i < n} NTH (x, xs1, i) -> NTH (x, xs2, i)
) : ILISTEQ (xs1, xs2) = let
in
//
sif n > 0 then let
  prval
  LENGTHcons{x1}{xs11} pf11len = pf1len
  prval
  LENGTHcons{x2}{xs21} pf21len = pf2len
  prval NTHbas () = fpf {x1}{0} (NTHbas ())
  prfn fpf1
    {x:int}{i:int | i < n-1}
    (pf: NTH (x, xs11, i)): NTH (x, xs21, i) = let
    prval _ = lemma_nth_param(pf)
    prval NTHind (pfres) = fpf(NTHind(pf))
  in
    pfres
  end // end of [fpf1]
  prval ILISTEQ () = lemma (pf11len, pf21len, fpf1)
in
  ILISTEQ ()
end else let
  prval LENGTHnil () = pf1len and LENGTHnil () = pf2len
in
  ILISTEQ ()
end // end of [sif]
//
end // end of [lemma]
//
in
  lemma (pf1len, pf2len, fpf)
end // end of [lemma_nth_ilisteq]

(* ****** ****** *)

primplmnt
lemma_length_nth
  (pflen) = let
//
prfun
lemma
{xs:ilist}
{n:int}{i:nat | i < n}
  .<xs>.
(
  pflen: LENGTH(xs, n)
) : [x:int] NTH(x, xs, i) = let
//
prval
LENGTHcons(pflen1) = pflen
//
in
//
sif
(i==0)
then NTHbas()
else NTHind(lemma{..}{..}{i-1}(pflen1))
//
end (* end of [lemma] *)
//
in
  lemma(pflen)
end // end of [lemma_length_nth]

(* ****** ****** *)

primplmnt
revapp_istot
  {xs,ys} () = let
//
prfun
istot
{xs,ys:ilist} .<xs>.
(
// argumentless
) : [zs:ilist] REVAPP (xs, ys, zs) =
  scase xs of
  | ilist_nil () => REVAPPnil ()
  | ilist_cons (x, xs) =>
      REVAPPcons (istot {xs,ilist_cons (x,ys)} ())
    // end of [ilist_cons]
// end of [istot]
in
  istot {xs,ys} ()
end // end of [revapp_istot]

primplmnt
revapp_isfun
  (pf1, pf2) = let
//
prfun isfun
  {xs,ys:ilist}
  {zs1,zs2:ilist} .<xs>. (
  pf1: REVAPP (xs, ys, zs1), pf2: REVAPP (xs, ys, zs2)
) : ILISTEQ (zs1, zs2) = (
  case+ (pf1, pf2) of
  | (REVAPPnil (), REVAPPnil ()) => ILISTEQ ()
  | (REVAPPcons (pf1), REVAPPcons (pf2)) => let
      prval ILISTEQ () = isfun (pf1, pf2) in ILISTEQ ()
    end // end of [...]
) // end of [isfun]
in
  isfun (pf1, pf2)
end // end of [revapp_isfun]

(* ****** ****** *)

(*
prfun
lemma_revapp_length
  {xs,ys,zs:ilist}{m,n:int} .<xs>. (
  pf1: REVAPP (xs, ys, zs), pf2: LENGTH (xs, m), pf3: LENGTH (ys, n)
) : LENGTH (zs, m+n) // end of [lemma_revapp_length]
*)
primplmnt
lemma_revapp_length
  (pf, pf1len, pf2len) = let
//
prfun
lemma
  {xs,ys,zs:ilist}
  {m,n:nat} .<xs>. (
  pf: REVAPP (xs, ys, zs)
, pf1len: LENGTH (xs, m), pf2len: LENGTH (ys, n)
) : LENGTH (zs, m+n) = let
in
//
case+ pf of
| REVAPPnil () => let
    prval
    LENGTHnil () = pf1len in pf2len
  end // end of[REVAPPnil]
| REVAPPcons (pf) => let
    prval
    LENGTHcons(pf1len) = pf1len
  in
    lemma (pf, pf1len, LENGTHcons(pf2len))
  end // end of [REVAPPcons]
//
end // end of [revapp_length_lemma]
//
prval () = length_isnat (pf1len)
prval () = length_isnat (pf2len)
//
in
  lemma (pf, pf1len, pf2len)
end // end of [lemma_revapp_length]

(* ****** ****** *)

primplmnt
reverse_istot() = revapp_istot()
primplmnt
reverse_isfun(pf1, pf2) = revapp_isfun(pf1, pf2)

(* ****** ****** *)
//
primplmnt
lemma_reverse_length
  (pfrev, pflen) = lemma_revapp_length(pfrev, pflen, LENGTHnil())
//
(* ****** ****** *)

(*
prfun
lemma1_revapp_nth
  {xs,ys,zs:ilist}{n:int}{x:int}{i:int} (
  pf: REVAPP (xs, ys, zs), pflen: LENGTH (xs, n), pfnth: NTH (x, ys, i)
) : NTH (x, zs, n+i) // end of [lemma1_revapp_nth]
*)
primplmnt
lemma1_revapp_nth
  (pf, pflen, pfnth) = let
//
prfun
lemma
  {xs,ys,zs:ilist}
  {n:int}{x:int}{i:int} .<xs>. (
  pf: REVAPP (xs, ys, zs), pflen: LENGTH (xs, n), pfnth: NTH (x, ys, i)
) : NTH (x, zs, n+i) = let
//
prval _ = lemma_nth_param(pfnth)
//
in
//
case+ pf of
| REVAPPnil () => let
    prval LENGTHnil () = pflen in pfnth
  end // end of [REVAPPnil]
| REVAPPcons (pf) => let
    prval LENGTHcons (pflen) = pflen in lemma (pf, pflen, NTHind (pfnth))
  end // end of[REVAPPcons]
//
end // end of [lemma1_revapp_nth]
//
in
  lemma (pf, pflen, pfnth)
end // end of [lemma1_revapp_nth]

(* ****** ****** *)

(*
prfun
lemma2_revapp_nth
  {xs,ys,zs:ilist}{n:int}{x:int}{i:int} (
  pf: REVAPP (xs, ys, zs), pflen: LENGTH (xs, n), pfnth: NTH (x, xs, i)
) : NTH (x, zs, n-1-i) // end of [lemma2_revapp_nth]
*)
primplmnt
lemma2_revapp_nth
  (pf, pflen, pfnth) = let
//
prval _ = lemma_nth_param(pfnth)
//
prfun lemma
  {xs,ys,zs:ilist}
  {n:int}{x:int}{i:nat} .<i>.
(
  pf: REVAPP (xs, ys, zs)
, pflen: LENGTH (xs, n), pfnth: NTH (x, xs, i)
) : NTH (x, zs, n-1-i) = let
in
//
case+ pfnth of
//
| NTHbas () => let
    prval REVAPPcons (pf) = pf
    prval LENGTHcons pflen = pflen
  in
    lemma1_revapp_nth (pf, pflen, NTHbas ())
  end // end of [NTHbas]
//
| NTHind (pfnth) => let
    prval REVAPPcons (pf) = pf
    prval LENGTHcons (pflen) = pflen in lemma (pf, pflen, pfnth)
  end // end of [NTHind]
//
end // end of [lemma]
//
in
  lemma (pf, pflen, pfnth)
end // end of [lemma2_revapp_nth]

(* ****** ****** *)

primplmnt
lemma_reverse_nth
  (pf, pflen, pfnth) = lemma2_revapp_nth (pf, pflen, pfnth)
// end of [lemma_reverse_nth]    

(* ****** ****** *)

primplmnt
lemma_reverse_symm{xs,ys}(pf) = let
//
prval
[n:int]
pflen_xs = length_istot {xs} ()
prval
pflen_ys = lemma_revapp_length (pf, pflen_xs, LENGTHnil ())
prval
[zs:ilist]
pfrev_zs = revapp_istot {ys,ilist_nil} ()
prval
pflen_zs = lemma_revapp_length (pfrev_zs, pflen_ys, LENGTHnil ())
//
prfun
fpf
{x:int}
{i:int | i < n} .<>.
  (pfnth: NTH (x, xs, i)): NTH (x, zs, i) = let
  prval pf2nth = lemma_reverse_nth (pf, pflen_xs, pfnth)
in
  lemma_reverse_nth (pfrev_zs, pflen_ys, pf2nth)
end // end of [fpf]
//
prval
ILISTEQ () = lemma_nth_ilisteq (pflen_xs, pflen_zs, fpf)
//
in
  pfrev_zs
end // end of [lemma_reverse_symm]

(* ****** ****** *)

(*
prfun
lemma_insert_length
  {x0:int}{xs:ilist}{i:int}{ys:ilist}{n:int}
  (pf1: INSERT (x0, xs, i, ys), pf2: LENGTH (xs, n)): LENGTH (ys, n+1)
// end of [lemma_insert_length]
*)
primplmnt
lemma_insert_length
  (pf1, pf2) = let
//
prfun
lemma
  {x0:int}{xs:ilist}{i:int}{ys:ilist}{n:int} .<xs>.
  (pf1: INSERT (x0, xs, i, ys), pf2: LENGTH (xs, n)): LENGTH (ys, n+1) = let
in
//
case+ pf1 of
| INSERTbas () => let
    prval () = length_isnat (pf2) in LENGTHcons (pf2)
  end // end of [INSERTbas]
| INSERTind (pf1) => let
    prval LENGTHcons (pf2) = pf2 in LENGTHcons (lemma (pf1, pf2))
  end // end of [INSERTind]
//
end // end of [lemma]  
//
in
  lemma (pf1, pf2)
end // end of [lemma_insert_length]

(* ****** ****** *)

(*
prfun lemma_insert_nth_at
  {x0:int}{xs:ilist}{i:int}{ys:ilist}
  (pf: INSERT (x0, xs, i, ys)): NTH (x0, ys, i)
// end of [lemma_insert_nth_eq]
*)
primplmnt
lemma_insert_nth_at (pf) = let
//
prfun
lemma
  {x0:int}{xs:ilist}{i:int}{ys:ilist} .<xs>.
  (pf: INSERT (x0, xs, i, ys)): NTH (x0, ys, i) = let
in
  case+ pf of
  | INSERTbas () => NTHbas () | INSERTind (pf) => NTHind (lemma (pf))
end // end of [lemma]  
//
in
  lemma (pf)
end // end of [lemma_insert_nth_at]

(* ****** ****** *)

(*
prfun lemma_insert_nth_lt
  {x0:int}{xs:ilist}{i:int}{ys:ilist}{x:int}{j:int | j < i}
  (pf1: INSERT (x0, xs, i, ys), pf2: NTH (x, xs, j)): NTH (x, ys, j)
// end of [lemma_insert_nth_lt]
*)
primplmnt
lemma_insert_nth_lt
  (pf1, pf2) = let
//
prfun lemma
  {x0:int}{xs:ilist}{i:int}{ys:ilist}{x:int}{j:int | j < i} .<xs>.
  (pf1: INSERT (x0, xs, i, ys), pf2: NTH (x, xs, j)): NTH (x, ys, j) = let
in
//
case+ pf2 of
| NTHbas () => let
    prval INSERTind (pf1) = pf1 in NTHbas ()
  end // end of [NTHbas]
| NTHind (pf2) => let
    prval INSERTind (pf1) = pf1 in NTHind (lemma (pf1, pf2))
  end // end of [NTHind]
//
end // end of [lemma]
//
in
  lemma (pf1, pf2)
end // end of [lemma_insert_nth_lt]

(* ****** ****** *)

(*
prfun lemma_insert_nth_gte
  {x0:int}{xs:ilist}{i:int}{ys:ilist}{x:int}{j:int | j >= i}
  (pf1: INSERT (x0, xs, i, ys), pf2: NTH (x, xs, j)): NTH (x, ys, j+1)
// end of [lemma_insert_nth_lt]
*)
primplmnt
lemma_insert_nth_gte
  (pf1, pf2) = let
//
prfun lemma
  {x0:int}{xs:ilist}{i:int}{ys:ilist}{x:int}{j:int | j >= i} .<xs>.
  (pf1: INSERT (x0, xs, i, ys), pf2: NTH (x, xs, j)): NTH (x, ys, j+1) = let
//
in
//
case+ pf1 of
| INSERTbas () => NTHind (pf2)
| INSERTind (pf1) => let
    prval NTHind (pf2) = pf2 in NTHind (lemma (pf1, pf2))
  end // end of [INSERTind]
//
end // end of [lemma]
//
in
  lemma (pf1, pf2)
end // end of [lemma_insert_nth_gte]

(* ****** ****** *)

(*
prfun lemma_nth_insert
  {x:int} {xs:ilist} {n:int}
  (pf: NTH (x, xs, n)): [ys:ilist] INSERT (x, ys, n, xs)
// end of [lemma_nth_insert]
*)
primplmnt
lemma_nth_insert (pf) = let
//
prfun lemma
  {x:int} {xs:ilist} {n:int} .<xs>.
  (pf: NTH (x, xs, n)): [ys:ilist] INSERT (x, ys, n, xs) = let
in
//
case+ pf of
| NTHbas () => INSERTbas () | NTHind (pf) => INSERTind (lemma (pf))
//
end
//
in
  lemma (pf)
end // end of [lemma_nth_insert]

(* ****** ****** *)

(* end of [ilist_prf.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// HX-2013-09:
// A collection of hash functions
//
(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libats/SATS/hashfun.sats"

(* ****** ****** *)

(*
fun{}
inthash_jenkins (uint32): uint32
*)
(*
** HX-2013-08:
** This one by Robert Jenkins
** is a full-avalanche hash function
*)
/*
uint32_t
atslib_inthash_jenkins
  (uint32_t a)
{
  a = (a+0x7ed55d16) + (a<<12);
  a = (a^0xc761c23c) ^ (a>>19);
  a = (a+0x165667b1) + (a<< 5);
  a = (a+0xd3a2646c) ^ (a<< 9);
  a = (a+0xfd7046c5) + (a<< 3);
  a = (a^0xb55a4f09) ^ (a>>16);
  return a;
}
*/
implement
{}(*tmp*)
inthash_jenkins (a) =
  $extfcall (uint32, "atslib_inthash_jenkins", a)
//
(* ****** ****** *)

(*
fun{}
string_hash_multiplier
(
  K: ulint, H0: ulint, str: string
) :<> ulint // endfun
*)
implement
{}(*tmp*)
string_hash_multiplier
  (K, H0, str) = let
//
fun loop
(
  p: ptr, res: ulint
) : ulint = let
  val c = $UN.ptr0_get<char> (p)
in
//
if isneqz(c)
  then loop (ptr_succ<char> (p), K*res + $UN.cast{ulint}(c))
  else (res)
//
end // end of [loop]
//
in
  $effmask_all(loop (string2ptr(str), H0))
end // end of [string_hash_multiplier]

(* ****** ****** *)

(* end of [hashfun.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"
// end of [staload]

(* ****** ****** *)

#define nullp the_null_ptr

(* ****** ****** *)

staload "libats/SATS/gnode.sats"

(* ****** ****** *)

staload "libats/SATS/dllist.sats"
staload "libats/DATS/dllist.dats"

(* ****** ****** *)

staload "libats/SATS/lindeque_dllist.sats"

(* ****** ****** *)
//
extern
castfn
deque_encode
  : {a:vt0p}{n:int} (g2node0 (INV(a))) -<> deque (a, n)
extern
castfn
deque_decode
  : {a:vt0p}{n:int} (deque (INV(a), n)) -<> g2node0 (a)
//
extern
castfn
deque1_encode
  : {a:vt0p}{n:int | n > 0} (g2node1 (INV(a))) -<> deque (a, n)
extern
castfn
deque1_decode
  : {a:vt0p}{n:int | n > 0} (deque (INV(a), n)) -<> g2node1 (a)
//
(* ****** ****** *)

implement{}
lindeque_nil{a} () = $UN.castvwtp0{deque(a,0)}(nullp)

(* ****** ****** *)
//
implement{}
lindeque_is_nil{a}{n} (dq) =
  $UN.cast{bool(n==0)}($UN.castvwtp1{ptr}(dq) = nullp)
//
implement{}
lindeque_isnot_nil{a}{n} (dq) =
  $UN.cast{bool(n > 0)}($UN.castvwtp1{ptr}(dq) > nullp)
//
(* ****** ****** *)

implement{a}
lindeque_length {n} (dq) = let
//
fun loop
(
  nxs: g2node1 (a), p0: ptr, n: int
) : int = let
  val nxs2 = gnode_get_next (nxs)
  val nxs2 = $UN.cast{g2node1(a)}(nxs2)
in
//
if p0 != gnode2ptr (nxs2) then loop (nxs2, p0, n+1) else n
//
end // end of [loop]
//
prval () = lemma_deque_param (dq)
val isnot = lindeque_isnot_nil (dq)
//
in
//
if isnot then let
  val nxs = $UN.castvwtp1{g2node1(a)}(dq)
  val len = $effmask_all (loop (nxs, gnode2ptr (nxs), 1))
in
  $UN.cast{int(n)}(len)
end else (0) // end of [if]
//
end // end of [lindeque_length]

(* ****** ****** *)

implement{a}
lindeque_insert_at
  (dq, i, x) = let
//
val nx0 =
  g2node_make_elt<a> (x) in lindeque_insert_at_ngc (dq, i, nx0)
//
end // end of [lindeque_insert_at]

implement{a}
lindeque_insert_atbeg
  (dq, x) = let
//
val nx0 =
  g2node_make_elt<a> (x) in lindeque_insert_atbeg_ngc (dq, nx0)
//
end // end of [lindeque_insert_atbeg]

implement{a}
lindeque_insert_atend
  (dq, x) = let
//
val nx0 =
  g2node_make_elt<a> (x) in lindeque_insert_atend_ngc (dq, nx0)
//
end // end of [lindeque_insert_atend]

(* ****** ****** *)

implement{a}
lindeque_takeout_at
  (dq, i) = let
//
val nx = lindeque_takeout_at_ngc (dq, i) in g2node_getfree_elt (nx)
//
end // end of [lindeque_takeout_at]

implement{a}
lindeque_takeout_atbeg
  (dq) = let
//
val nx = lindeque_takeout_atbeg_ngc (dq) in g2node_getfree_elt (nx)
//
end // end of [lindeque_takeout_atbeg]

implement{a}
lindeque_takeout_atend
  (dq) = let
//
val nx = lindeque_takeout_atend_ngc (dq) in g2node_getfree_elt (nx)
//
end // end of [lindeque_takeout_atend]

(* ****** ****** *)

implement{a}
lindeque2dllist {n} (dq) = let
//
val nxs = deque_decode (dq)
val isnot = gnode_isnot_null (nxs)
//
val () =
if isnot then
{
  val nxs2 = gnode_get_prev (nxs)
  val nxs2 = $UN.cast{g2node1(a)}(nxs2)
  val () = gnode_set_prev_null (nxs)
  val () = gnode_set_next_null (nxs2)
} // end of [if]
in
  $UN.castvwtp0{dllist(a,0,n)}(nxs)
end // end of [lindeque2dllist]

(* ****** ****** *)
//
// HX: ngc-functions should not involve malloc/free!
//
(* ****** ****** *)

implement{a}
lindeque_insert_atbeg_ngc
  (dq, nx0) = let
//
val nxs = deque_decode (dq)
val isnul = gnode_is_null (nxs)
//
in
//
if isnul then let
  val () = gnode_link11 (nx0, nx0)
in
  dq := deque_encode (nx0)
end else let
  val () = gnode_insert_prev (nxs, nx0)
in
  dq := deque_encode (nx0)
end // end of [if]
//
end // end of [lindeque_insert_atbeg_ngc]

(* ****** ****** *)

implement{a}
lindeque_insert_atend_ngc
  (dq, nx0) = let
//
val nxs = deque_decode (dq)
val isnul = gnode_is_null (nxs)
//
in
//
if isnul then let
  val () = gnode_link11 (nx0, nx0)
in
  dq := deque_encode (nx0)
end else let
  val () = gnode_insert_prev (nxs, nx0)
in
  dq := deque_encode (nxs)
end // end of [if]
//
end // end of [lindeque_insert_atend_ngc]

(* ****** ****** *)

implement{a}
lindeque_takeout_atbeg_ngc
  (dq) = let
//
val nxs = deque1_decode (dq)
val nxs2 = gnode_get_next (nxs)
//
val p = gnode2ptr (nxs)
val p2 = gnode2ptr (nxs2)
//
val nxs = gnode_remove (nxs)
//
in
//
if (p != p2) then let
  val () = dq := deque_encode (nxs2) in nxs
end else let
  val () = dq := deque_encode (gnode_null ()) in nxs
end // end of [if]
//
end // end of [lindeque_takeout_atbeg_ngc]

(* ****** ****** *)

implement{a}
lindeque_takeout_atend_ngc
  (dq) = let
//
val nxs = deque1_decode (dq)
val nxs2 = gnode_remove_prev (nxs)
val nxs2 = $UN.cast{g2node1(a)}(nxs2)
//
val p = gnode2ptr (nxs)
val p2 = gnode2ptr (nxs2)
//
in
//
if (p != p2) then let
  val () = dq := deque_encode (nxs) in nxs2
end else let
  val () = dq := deque_encode (gnode_null ()) in nxs2
end // end of [if]
//
end // end of [lindeque_takeout_atend_ngc]

(* ****** ****** *)

(* end of [lindeque_dllist.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: May, 2012 *)

(* ****** ****** *)
//
// HX-2013-01:
//
// this data structure is essentially based on
// Chris Okasaki's random-access list (formulated
// as a nested datatype). However, unlike Okasaki's
// formulation, [ralist] is *not* a nested datatype.
//
(* ****** ****** *)

#define
ATS_PACKNAME "ATSLIB.libats.funralist_nested"
#define
ATS_DYNLOADFLAG 0 // no dynamic loading at run-time

(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload
_(*anon*) = "prelude/DATS/integer.dats"

(* ****** ****** *)
//
staload "libats/SATS/funralist_nested.sats"
//
(* ****** ****** *)
//
#include "./SHARE/funralist.hats" // code reuse
//
(* ****** ****** *)

datatype node
  (a:t@ype+, int(*d*)) =
  | N1 (a, 0) of (a) // singleton
  | {d:nat}
    N2 (a, d+1) of (node (a, d), node (a, d))
// end of [node]

datatype myralist
  (a:t@ype+, int(*d*), int(*n*)) =
  | {d:nat}
    RAnil (a, d, 0) of ()
  | {d:nat}{n:pos}
    RAevn (a, d, n+n) of myralist (a, d+1, n)
  | {d:nat}{n:nat}
    RAodd (a, d, n+n+1) of (node (a, d), myralist (a, d+1, n))
// end of [myralist]

(* ****** ****** *)

assume
ralist_type
  (a:t0p, n:int) = myralist (a, 0, n)
// end of [ralist_type]

(* ****** ****** *)

primplmnt
lemma_ralist_param (xs) = let
in
//
case+ xs of
| RAevn _ => () | RAodd _ => () | RAnil () => ()
//
end // end of [lemma_ralist_param]

(* ****** ****** *)

implement{}
funralist_nil{a} () = RAnil{a}{0}((*void*))
implement{}
funralist_make_nil{a} () = RAnil{a}{0}((*void*))

(* ****** ****** *)

local

extern
fun cons
  {a:t0p}{d:nat}{n:nat}
(
  x0: node (a, d), xs: myralist (a, d, n)
) :<> myralist (a, d, n+1)
implement
cons{a}{d}{n} (x0, xs) = let
in
//
case+ xs of
| RAevn (xxs) => RAodd (x0, xxs)
| RAodd (x1, xxs) => let
    val x0x1 = N2 (x0, x1) in RAevn (cons (x0x1, xxs))
  end // end of [RAodd]
| RAnil () => RAodd (x0, RAnil)
//
end // end of [cons]

in (* in of [local] *)

implement{a}
funralist_cons
  (x, xs) = let
//
prval () = lemma_ralist_param (xs)
//
in
  cons{a} (N1{a}(x), xs)
end // end of [funralist_cons]

end // end of [local]

(* ****** ****** *)

implement{}
funralist_is_nil (xs) =
  case+ xs of RAnil () => true | _ =>> false
// end of [funralist_is_nil]

implement{}
funralist_is_cons (xs) =
  case+ xs of RAnil () => false | _ =>> true
// end of [funralist_is_cons]

(* ****** ****** *)

local

extern
fun length
  {a:t0p}{d:nat}{n:nat}
  (xs: myralist (a, d, n)):<> int (n)
implement
length{a}{d}{n} (xs) = let
in
//
case+ xs of
| RAevn (xxs) => let
    val n2 = length (xxs) in 2 * n2
  end // end of [RAevn]
| RAodd (_, xxs) => let
    val n2 = length (xxs) in 2 * n2 + 1
  end // end of [RAodd]
| RAnil ((*void*)) => (0)
//
end // end of [length]

in (* in of [local] *)

implement{}
funralist_length{a} (xs) = let
//
prval () = lemma_ralist_param (xs)
//
in
  length{a} (xs)
end // end of [funralist_length]

end // end of [local]

(* ****** ****** *)

local

extern
fun head
  {a:t0p}{d:nat}{n:pos}
  (xs: myralist (a, d, n)):<> node (a, d)
implement
head{a}{d}{n} (xs) = let
in
//
case+ xs of
| RAevn (xxs) =>
    let val+N2 (x, _) = head (xxs) in x end
  // end of [RAevn]
| RAodd (x, _) => x
//
end // end of [head]

in (* in of [local] *)

implement{a}
funralist_head (xs) =
  let val+N1 (x) = head{a} (xs) in x end
// end of [funralist_head]

end // end of [local]

(* ****** ****** *)

implement{a}
funralist_tail
  (xs) = xs1 where {
  var xs1 = xs
  val _(*hd*) = $effmask_wrt (funralist_uncons<a> (xs1))
} // end of [funralist_tail]

(* ****** ****** *)

local

extern
fun uncons
  {a:t0p}{d:nat}{n:pos}
(
  xs: myralist (a, d, n), x: &ptr? >> node (a, d)
) :<!wrt> myralist (a, d, n-1)
implement
uncons{a}{d}{n} (xs, x) = let
in
//
case+ xs of
| RAevn
    (xxs) => let
    var nxx: ptr
    val xxs = uncons (xxs, nxx)
    val+N2 (x0, x1) = nxx
    prval () = topize (nxx) // HX: this is not necessary
    val () = x := x0
  in
    RAodd (x1, xxs)
  end // end of [RAevn]
| RAodd
    (x0, xxs) => let
    val () = x := x0
  in
    case+ xxs of
    | RAnil () => RAnil () | _ =>> RAevn (xxs)
  end // end of [RAodd]
//
end // end of [uncons]

in (* in of [local] *)

implement{a}
funralist_uncons
  (xs) = let
//
var nx: ptr // unintialized
val () = (xs := uncons{a} (xs, nx))
val+N1 (x0) = nx
prval () = topize (nx) // HX: this is not necessary
//
in
  x0
end // end of [funralist_uncons]

end // end of [local]

(* ****** ****** *)

local

extern
fun get_at
  {a:t0p}{d:nat}{n:nat}
(
  xs: myralist (a, d, n), i: natLt n
) :<> node (a, d) // endfun
implement
get_at{a}{d}{n} (xs, i) = let
in
//
case+ xs of
| RAevn (xxs) => let
    val x01 = get_at (xxs, half i)
  in
    if i mod 2 = 0 then
      let val+N2 (x0, _) = x01 in x0 end
    else
      let val+N2 (_, x1) = x01 in x1 end
    // end of [if]
  end // end of [RAevn]
| RAodd (x, xxs) => (
    if i = 0 then x else let
      val x01 = get_at (xxs, half (i-1))
    in
      if i mod 2 = 0 then
        let val+N2 (_, x1) = x01 in x1 end
      else
        let val+N2 (x0, _) = x01 in x0 end
      // end of [if]
    end // end of [if]
  ) // end of [RAodd]
//
end // end of [get_at]

in (* in of [local] *)

implement{a}
funralist_get_at
  (xs, i) = let
//
val+N1 (x) = get_at{a} (xs, i) in x (*return*)
//
end // end of [funralist_get_at]

implement{a} funralist_lookup = funralist_get_at

end // end of [local]

(* ****** ****** *)

local

extern
fun __free (p: ptr):<!wrt> void = "mac#ATS_MFREE"
extern
fun fset_at
  {a:t0p}{d:nat}{n:nat}
(
  xs: myralist (a, d, n)
, i: natLt (n), f: node (a, d) -<cloref0> node (a, d)
) :<> myralist (a, d, n)
extern
fun fset2_at
  {a:t0p}{d:nat}{n2:pos}
(
  xxs: myralist (a, d+1, n2)
, i: natLt (2*n2), f: node (a, d) -<cloref0> node (a, d)
) :<> myralist (a, d+1, n2)

implement
fset_at{a}{d}{n}
  (xs, i, f) = let
in
  case+ xs of
  | RAevn (xxs) => RAevn (fset2_at (xxs, i, f))
  | RAodd (x, xxs) =>
      if i = 0 then RAodd (f x, xxs) else RAodd (x, fset2_at (xxs, i-1, f))
    // end of [RAodd]
end // end of [fset_at]
implement
fset2_at{a}{d}{n}
  (xxs, i, f) = let
  typedef node = node (a, d+1)
in
//
if i mod 2 = 0 then let
  val f1 = lam
    (xx: node): node =<cloref0>
    let val+N2 (x0, x1) = xx in N2 (f x0, x1) end
  // end of [val]
  val xxs =
    fset_at (xxs, half(i), f1)
  val () = $effmask_wrt (__free ($UN.cast2ptr(f1)))
in
  xxs
end else let
  val f1 = lam
    (xx: node): node =<cloref0>
    let val+N2 (x0, x1) = xx in N2 (x0, f x1) end
  // end of [val]
  val xxs =
    fset_at (xxs, half(i), f1)
  val () = $effmask_wrt (__free ($UN.cast2ptr(f1)))
in
  xxs
end // end of [if]
//
end // end of [fset2_at]

in (* in of [local] *)

implement{a}
funralist_set_at
  (xs, i, x0) = let
//
typedef node = node (a, 0)
//
val f = lam (_: node): node =<cloref0> N1{a}(x0)
val xs = fset_at{a} (xs, i, f)
val () = $effmask_wrt (__free ($UN.cast2ptr(f)))
//
in
  xs
end // end of [funralist_set_at]

end // end of [local]

(* ****** ****** *)

local

extern
fun __free (p: ptr):<!wrt> void = "mac#ATS_MFREE"

extern fun
foreach{a:t0p}{d:nat}{n:nat}
(
  xs: myralist (a, d, n), f: node (a, d) -<cloref0> void
) :<> void // end of [foreach]
extern fun
foreach2{a:t0p}{d:nat}{n2:pos}
(
  xxs: myralist (a, d+1, n2), f: node (a, d) -<cloref0> void
) :<> void // end of [foreach2]

implement
foreach
  {a}{d}{n}(xs, f) = let
in
//
case+ xs of
| RAevn (xxs) =>
    foreach2 (xxs, f)
  // end of [RAevn]
| RAodd (x, xxs) => let
    val () = f (x) in case+ xxs of
    | RAnil () => () | _ =>> foreach2 (xxs, f)
  end // end of [RAodd]
| RAnil ((*void*)) => ()
//
end // end of [foreach]
implement
foreach2
  {a}{d}{n2}(xxs, f) = let
//
typedef node = node (a, d+1)
//
val f1 = lam
  (xx: node): void =<cloref0> let
  val+N2 (x0, x1) = xx in f (x0); f (x1)
end // end of [val]
//
val () = foreach (xxs, f1)
val () = $effmask_wrt (__free ($UN.cast2ptr(f1)))
//
in
  // nothing
end // end of [foreach2]

in (* in of [local] *)

implement{a}
funralist_foreach (xs) = let
  var env: void = () in funralist_foreach_env (xs, env)
end // end of [funralist_foreach]

implement{a}{env}
funralist_foreach_env
  (xs, env) = let
//
typedef node = node (a, 0)
//
prval () = lemma_ralist_param (xs)
//
val p_env = addr@ (env)
//
val f = lam
  (x0: node): void =<cloref0> let
  val+N1 (x) = x0
  val (
    pf, fpf | p_env
  ) = $UN.ptr_vtake{env}(p_env)
  val () =
    $effmask_all (funralist_foreach$fwork<a><env> (x, !p_env))
  prval ((*void*)) = fpf (pf)
in
  // nothing
end // end of [val]
//
val () = foreach (xs, f)
//
val () = $effmask_wrt (__free ($UN.cast2ptr(f)))
//
in
  // nothing
end // end of [funralist_foreach_env]

end // end of [local]

(* ****** ****** *)

(* end of [funralist_nested.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
(*
**
** A functional concatenable deque implementation based on finger-trees.
** Please see the JFP paper by Hinze and Paterson on finger-trees for more
** details on this interesting data structure.
**
** Contributed by Hongwei Xi (hwxi AT cs DOT bu DOT edu)
** Contributed by Robbie Harwood (rharwood AT cs DOT bu DOT edu)
**
** Time: November, 2010
**
*)
(* ****** ****** *)
(*
** Ported to ATS2 by Hongwei Xi (hwxi AT cs DOT bu DOT edu)
** Time: May, 2012
*)
(* ****** ****** *)

#define
ATS_PACKNAME "ATSLIB.libats.fundeque_fngtree"
#define
ATS_DYNLOADFLAG 0 // no dynamic loading at run-time

(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"
staload
_(*anon*) = "prelude/DATS/integer.dats"

(* ****** ****** *)
//
staload "libats/SATS/fundeque_fngtree.sats"
//
(* ****** ****** *)
//
#include "./SHARE/fundeque.hats" // code reuse
//
(* ****** ****** *)

datatype
ftnode
(
  a:t@ype+, int(*dpth*), int(*size*)
) = (* ftnode *)
  | FTN1 (a, 0, 1) of (a) // singleton
  | {d:nat} {n1,n2:nat}
    FTN2 (a, d+1, n1+n2) of
    (
      ftnode (a, d, n1), ftnode (a, d, n2)
    ) // end of [FTN2]
  | {d:nat} {n1,n2,n3:nat}
    FTN3 (a, d+1, n1+n2+n3) of
    (
      ftnode (a, d, n1), ftnode (a, d, n2), ftnode (a, d, n3)
    ) // end of [FTN3]
// end of [ftnode] // end of [datatype]

(* ****** ****** *)

datatype
ftdigit
(
  a:t@ype+, int(*dpth*), int(*size*)
) = (* ftdigit *)
  | {d:nat} {n:nat}
    FTD1 (a, d, n) of ftnode (a, d, n)
  | {d:nat} {n1,n2:nat}
    FTD2 (a, d, n1+n2) of (
      ftnode (a, d, n1), ftnode (a, d, n2)
    ) // end of [FTD2]
  | {d:nat} {n1,n2,n3:nat}
    FTD3 (a, d, n1+n2+n3) of (
      ftnode (a, d, n1), ftnode (a, d, n2), ftnode (a, d, n3)
    ) // end of [FTD3]
  | {d:nat} {n1,n2,n3,n4:nat}
    FTD4 (a, d, n1+n2+n3+n4) of (
      ftnode (a, d, n1), ftnode (a, d, n2), ftnode (a, d, n3), ftnode (a, d, n4)
    ) // end of [FTD4]
// end of [ftdigit]

(* ****** ****** *)

datatype
fngtree (
  a:t@ype, int(*d*), int(*n*)
) = (* fngtree *)
  | {d:nat}
    FTemp (a, d, 0) of ()
  | {d:nat}
    {n:int}
    FTsing (a, d, n) of ftnode (a, d, n)
  | {d:nat}
    {npr,nm,nsf:nat}
    FTdeep (a, d, npr+nm+nsf) of
    (
      ftdigit(a, d, npr), fngtree (a, d+1, nm), ftdigit (a, d, nsf)
    ) // end of [FTdeep]
// end of [fngtree]

(* ****** ****** *)
//
extern
fun{a:t0p}
fprint_fngtree
  {d:int}{n:int}
  (out: FILEref, xt: fngtree (INV(a), d, n)): void
//
(* ****** ****** *)

local

fun{a:t0p}
fprint_ftnode
  {d:int}{n:int}
(
  out: FILEref, xn: ftnode (INV(a), d, n)
) : void = let
//
macdef
prstr (str) = fprint_string (out, ,(str))
//
in
//
case+ xn of
| FTN1 (x) =>
  {
    val () = prstr "FTN1("
    val () = fprint_val<a> (out, x)
    val () = prstr ")"
  }
| FTN2 (xn1, xn2) =>
  {
    val () = prstr "FTN2("
    val () = fprint_ftnode (out, xn1)
    val () = prstr ", "
    val () = fprint_ftnode (out, xn2)
    val () = prstr ")"
  }
| FTN3 (xn1, xn2, xn3) =>
  {
    val () = prstr "FTN3("
    val () = fprint_ftnode (out, xn1)
    val () = prstr ", "
    val () = fprint_ftnode (out, xn2)
    val () = prstr ", "
    val () = fprint_ftnode (out, xn3)
    val () = prstr ")"
  }
//
end // end of [fprint_ftnode]

fun{a:t0p}
fprint_ftdigit
  {d:int}{n:int}
(
  out: FILEref, xn: ftdigit (INV(a), d, n)
) : void = let
//
macdef
prstr (str) = fprint_string (out, ,(str))
//
in
//
case+ xn of
| FTD1 (xn1) =>
  {
    val () = prstr "FTD1("
    val () = fprint_ftnode (out, xn1)
    val () = prstr ")"
  }
| FTD2 (xn1, xn2) =>
  {
    val () = prstr "FTD2("
    val () = fprint_ftnode (out, xn1)
    val () = prstr ", "
    val () = fprint_ftnode (out, xn2)
    val () = prstr ")"
  }
| FTD3 (xn1, xn2, xn3) =>
  {
    val () = prstr "FTD2("
    val () = fprint_ftnode (out, xn1)
    val () = prstr ", "
    val () = fprint_ftnode (out, xn2)
    val () = prstr ", "
    val () = fprint_ftnode (out, xn3)
    val () = prstr ")"
  }
| FTD4 (xn1, xn2, xn3, xn4) =>
  {
    val () = prstr "FTD2("
    val () = fprint_ftnode (out, xn1)
    val () = prstr ", "
    val () = fprint_ftnode (out, xn2)
    val () = prstr ", "
    val () = fprint_ftnode (out, xn3)
    val () = prstr ", "
    val () = fprint_ftnode (out, xn4)
    val () = prstr ")"
  }
//
end // end of [fprint_ftdigit]

in (* in of [local] *)

implement{a}
fprint_fngtree
  (out, xt) = let
//
macdef
prstr (str) = fprint_string (out, ,(str))
//
in
//
case+ xt of
| FTemp () => prstr "FTemp()"
| FTsing (xn) =>
  {
    val () = prstr "FTsing("
    val () = fprint_ftnode (out, xn)
    val () = prstr ")"
  }
| FTdeep (xn1, xt2, xn3) =>
  {
    val () = prstr "FTdeep("
    val () = fprint_ftdigit (out, xn1)
    val () = prstr ", "
    val () = fprint_fngtree (out, xt2)
    val () = prstr ", "
    val () = fprint_ftdigit (out, xn3)
    val () = prstr ")"
  }
//
end // end of [fprint_fngtree]

end // end of [local]

(* ****** ****** *)

prfun
ftnode_prop_szpos
  {a:t0p}
  {d:int}
  {n:int} .<d \nsub 0>.
  (xn: ftnode (a, d, n)): [n > 0] void =
  case+ xn of
  | FTN1 _ => ()
  | FTN2 (xn1, xn2) => {
      prval () = ftnode_prop_szpos (xn1)
      prval () = ftnode_prop_szpos (xn2)
    } // end of [FTN2]
  | FTN3 (xn1, xn2, xn3) => {
      prval () = ftnode_prop_szpos (xn1)
      prval () = ftnode_prop_szpos (xn2)
      prval () = ftnode_prop_szpos (xn3)
    } // end of [FTN3]
// end of [ftnode_prop_szpos]

(* ****** ****** *)

prfun
ftdigit_prop_szpos
  {a:t0p}
  {d:int}
  {n:int} .<>.
  (xd: ftdigit (a, d, n)): [n > 0] void =
  case+ xd of
  | FTD1 (xn1) => ftnode_prop_szpos (xn1)
  | FTD2 (xn1, _) => ftnode_prop_szpos (xn1)
  | FTD3 (xn1, _, _) => ftnode_prop_szpos (xn1)
  | FTD4 (xn1, _, _, _) => ftnode_prop_szpos (xn1)
// end of [ftdigit_prop_szpos]

(* ****** ****** *)

prfun
fngtree_prop1_sznat
  {a:t0p}
  {d:int}
  {n:int} .<>.
  (xt: fngtree (a, d, n)): [n >= 0] void =
  case+ xt of
  | FTemp () => ()
  | FTsing (xn) => ftnode_prop_szpos (xn)
  | FTdeep (pr, m, sf) => {
      val () = ftdigit_prop_szpos (pr) and () = ftdigit_prop_szpos (sf)
    } // end of [FTdeep]
// end of [fngtree_prop1_sznat]

(* ****** ****** *)

fun
ftnode_size
  {a:t0p}
  {d:int}
  {n:nat} .<n>.
(
  xn: ftnode (a, d, n)
) :<> size_t (n) = let
  #define nsz(x) ftnode_size(x)
in
  case+ xn of
  | FTN1 _ => g1i2u(1)
  | FTN2 (xn1, xn2) => let
      prval () = ftnode_prop_szpos (xn1)
      prval () = ftnode_prop_szpos (xn2)
    in
      nsz (xn1) + nsz (xn2)
    end // end of [FTN2]
  | FTN3 (xn1, xn2, xn3) => let
      prval () = ftnode_prop_szpos (xn1)
      prval () = ftnode_prop_szpos (xn2)
      prval () = ftnode_prop_szpos (xn3)
    in
      nsz (xn1) + nsz (xn2) + nsz (xn3)
    end // endof [FTN3]
end // end of [ftnode_size]

(* ****** ****** *)

fun
ftdigit_size
  {a:t0p}
  {d:int}
  {n:int} .<>.
(
  xd: ftdigit (a, d, n)
) :<> size_t (n) = let
  #define nsz(x) ftnode_size(x)
in
  case+ xd of
  | FTD1 (xn1) => nsz (xn1)
  | FTD2 (xn1, xn2) => nsz (xn1) + nsz (xn2)
  | FTD3 (xn1, xn2, xn3) => nsz (xn1) + nsz (xn2) + nsz (xn3)
  | FTD4 (xn1, xn2, xn3, xn4) => nsz (xn1) + nsz (xn2) + nsz (xn3) + nsz (xn4)
end // end of [ftdigit_size]

(* ****** ****** *)

fun ftnode2ftdigit
  {a:t0p} {d:pos} {n:int} .<>.
  (xn: ftnode (a, d, n)):<> ftdigit (a, d-1, n) =
  case+ xn of
  | FTN2 (xn1, xn2) => FTD2 (xn1, xn2)
  | FTN3 (xn1, xn2, xn3) => FTD3 (xn1, xn2, xn3)
// end of [ftnode2ftdigit]

(* ****** ****** *)

fun ftdigit2fngtree
  {a:t0p} {d:nat} {n:int} .<>.
  (xd: ftdigit (a, d, n)):<> fngtree (a, d, n) =
  case+ xd of
  | FTD1 (xn1) => FTsing (xn1)
  | FTD2 (xn1, xn2) => FTdeep (FTD1 (xn1), FTemp(), FTD1 (xn2))
  | FTD3 (xn1, xn2, xn3) => FTdeep (FTD2 (xn1, xn2), FTemp(), FTD1 (xn3))
  | FTD4 (xn1, xn2, xn3, xn4) => FTdeep (FTD2 (xn1, xn2), FTemp(), FTD2 (xn3, xn4))
// end of [ftdigit2fngtree]

(* ****** ****** *)

extern
fun fngtree_cons
  {a:t0p}{d:nat}{n1,n2:int} (
  xn: ftnode (a, d, n1), xt: fngtree (a, d, n2)
) :<> fngtree (a, d, n1+n2) // end of [fngtree_cons]

implement
fngtree_cons{a}
  (xn, xt) = cons (xn, xt) where
{
//
fun cons {d:nat}
  {n1,n2:int | n2 >= 0} .<n2>.
(
  xn: ftnode (a, d, n1), xt: fngtree (a, d, n2)
) :<> fngtree (a, d, n1+n2) = let
  prval () = ftnode_prop_szpos (xn) in
  case+ xt of
  | FTemp () => FTsing (xn)
  | FTsing (xn1) => let
      prval () = ftnode_prop_szpos (xn1)
    in
      FTdeep (FTD1(xn), FTemp(), FTD1(xn1))
    end // end [FTsing]
  | FTdeep (pr, m, sf) => (case+ pr of
    | FTD1 (xn1) => FTdeep (FTD2 (xn, xn1), m, sf) 
    | FTD2 (xn1, xn2) => FTdeep (FTD3 (xn, xn1, xn2), m, sf)
    | FTD3 (xn1, xn2, xn3) => FTdeep (FTD4 (xn, xn1, xn2, xn3), m, sf)
    | FTD4 (xn1, xn2, xn3, xn4) => let
        val pr = FTD2 (xn, xn1)
//
        prval () = ftdigit_prop_szpos (sf)
        prval () = fngtree_prop1_sznat (m)
//
        val m = cons (FTN3 (xn2, xn3, xn4), m)
      in
        FTdeep (pr, m, sf)
      end // end of [FTD4]
    ) // end of [FTdeep]
end // end of [cons]
//
prval () = fngtree_prop1_sznat (xt)
//
} // end of [fngtree_cons]

(* ****** ****** *)

extern
fun fngtree_uncons
  {a:t0p}{d:nat}{n:pos}
(
  xt: fngtree (a, d, n), r: &ptr? >> ftnode (a, d, n1)
) :<!wrt> #[n1:nat] fngtree (a, d, n-n1)
// end of [fngtree_uncons]

implement
fngtree_uncons{a}
  (xt, r) = uncons (xt, r) where
{
//
fun uncons
  {d:nat}{n:pos} .<n>.
(
  xt: fngtree (a, d, n)
, r: &ptr? >> ftnode (a, d, n1)
) :<!wrt> #[n1:nat | n1 <= n] fngtree (a, d, n-n1) =
  case+ xt of
  | FTsing (xn) => let
      val () = r := xn in FTemp ()
    end // end of [Single]
  | FTdeep (pr, m, sf) => (case+ pr of
    | FTD1 (xn) => let
        val () = r := xn
        prval () = ftdigit_prop_szpos (pr)
        prval () = ftdigit_prop_szpos (sf)
      in
        case+ m of
        | FTemp () => ftdigit2fngtree (sf)
        | FTsing (xn1) => FTdeep (ftnode2ftdigit (xn1), FTemp (), sf)
        | FTdeep (pr1, m1, sf1) => let
            var r1: ptr?
            prval () = ftdigit_prop_szpos (pr1)
            prval () = fngtree_prop1_sznat (m1)
            prval () = ftdigit_prop_szpos (sf1)
            val m = uncons (m, r1)
          in
            FTdeep (ftnode2ftdigit (r1), m, sf)
          end // end of [_]
      end // end of [FTD1]
    | FTD2 (xn, xn1) => let
        val () = r := xn in FTdeep (FTD1 (xn1), m, sf)
      end // end of [FTD2]
    | FTD3 (xn, xn1, xn2) => let
        val () = r := xn in FTdeep (FTD2 (xn1, xn2), m, sf)
      end // end of [FTD3]
    | FTD4 (xn, xn1, xn2, xn3) => let
        val () = r := xn in FTdeep (FTD3 (xn1, xn2, xn3), m, sf)
      end // end of [FTD4]
    ) // end of [FTdeep]
// end of [uncons]
} // end of [fngtree_uncons]

(* ****** ****** *)

extern
fun fngtree_get_atbeg
  {a:t0p}{d:nat}{n:pos}
  (xt: fngtree (a, d, n)) :<> [n1:nat] ftnode (a, d, n1)
// end of [fngtree_get_atbeg]

implement
fngtree_get_atbeg
  (xt) = (case+ xt of
  | FTsing (xn) => xn
  | FTdeep (pr, m, sf) => (
    case+ pr of
    | FTD1 (xn) => xn
    | FTD2 (xn, xn1) => xn
    | FTD3 (xn, xn1, xn2) => xn
    | FTD4 (xn, xn1, xn2, xn3) => xn
    ) // end of [FTdeep]
) // end of [fngtree_get_atbeg]

(* ****** ****** *)

extern
fun fngtree_snoc
  {a:t0p}{d:nat}{n1,n2:int}
(
  xt: fngtree (a, d, n2), xn: ftnode (a, d, n1)
) :<> fngtree (a, d, n1+n2) // end of [fngtree_snoc]

implement
fngtree_snoc{a}
  (xt, xn) = snoc (xt, xn) where
{
//
fun snoc {d:nat}
  {n1,n2:int | n2 >= 0} .<n2>.
(
  xt: fngtree (a, d, n2), xn: ftnode (a, d, n1)
) :<> fngtree (a, d, n1+n2) = let
  prval () = ftnode_prop_szpos (xn) in
  case+ xt of
  | FTemp () => FTsing (xn)
  | FTsing (xn1) => let
      prval () = ftnode_prop_szpos (xn1)
    in
      FTdeep (FTD1(xn1), FTemp(), FTD1(xn))
    end // end [FTsing]
  | FTdeep (pr, m, sf) => (case+ sf of
    | FTD1 (xn1) => FTdeep (pr, m, FTD2 (xn1, xn))
    | FTD2 (xn1, xn2) => FTdeep (pr, m, FTD3 (xn1, xn2, xn))
    | FTD3 (xn1, xn2, xn3) => FTdeep (pr, m, FTD4 (xn1, xn2, xn3, xn))
    | FTD4 (xn1, xn2, xn3, xn4) => let
        val sf = FTD2 (xn4, xn)
//
        prval () = ftdigit_prop_szpos (pr)
        prval () = fngtree_prop1_sznat (m)
//
        val m = snoc (m, FTN3 (xn1, xn2, xn3))
      in
        FTdeep (pr, m, sf)
      end // end of [FTD4]
    ) // end of [FTdeep]
end // end of [snoc]
//
prval () = fngtree_prop1_sznat (xt)
//
} // end of [fngtree_snoc]

(* ****** ****** *)

extern
fun fngtree_unsnoc
  {a:t0p}{d:nat}{n:pos}
(
  xt: fngtree (a, d, n), r: &ptr? >> ftnode (a, d, n1)
) :<!wrt> #[n1:nat] fngtree (a, d, n-n1)
// end of [fngtree_unsnoc]

implement
fngtree_unsnoc{a}
  (xt, r) = unsnoc (xt, r) where
{
//
fun unsnoc
  {d:nat}{n:pos} .<n>.
(
  xt: fngtree (a, d, n)
, r: &ptr? >> ftnode (a, d, n1)
) :<!wrt> #[n1:nat | n1 <= n] fngtree (a, d, n-n1) =
  case+ xt of
  | FTsing (xn) => let
      val () = r := xn in FTemp ()
    end // end of [Single]
  | FTdeep (pr, m, sf) => (case+ sf of
    | FTD1 (xn) => let
        val () = r := xn
        prval () = ftdigit_prop_szpos (pr)
        prval () = ftdigit_prop_szpos (sf)
      in
        case+ m of
        | FTemp () => ftdigit2fngtree (pr)
        | FTsing (xn1) => FTdeep (pr, FTemp (), ftnode2ftdigit (xn1))
        | FTdeep (pr1, m1, sf1) => let
            var r1: ptr?
            prval () = ftdigit_prop_szpos (pr1)
            prval () = fngtree_prop1_sznat (m1)
            prval () = ftdigit_prop_szpos (sf1)
            val m = unsnoc (m, r1)
          in
            FTdeep (pr, m, ftnode2ftdigit (r1))
          end // end of [_]
      end // end of [FTD1]
    | FTD2 (xn1, xn) => let
        val () = r := xn in FTdeep (pr, m, FTD1 (xn1))
      end // end of [FTD2]
    | FTD3 (xn1, xn2, xn) => let
        val () = r := xn in FTdeep (pr, m, FTD2 (xn1, xn2))
      end // end of [FTD3]
    | FTD4 (xn1, xn2, xn3, xn) => let
        val () = r := xn in FTdeep (pr, m, FTD3 (xn1, xn2, xn3))
      end // end of [FTD4]
    ) // end of [FTdeep]
// end of [unsnoc]
} // end of [fngtree_unsnoc]

(* ****** ****** *)

extern
fun fngtree_get_atend
  {a:t0p}{d:nat}{n:pos}
  (xt: fngtree (a, d, n)) :<> [n1:nat] ftnode (a, d, n1)
// end of [fngtree_get_atend]

implement
fngtree_get_atend
  (xt) = (case+ xt of
  | FTsing (xn) => xn
  | FTdeep (pr, m, sf) => (
    case+ sf of
    | FTD1 (xn) => xn
    | FTD2 (xn1, xn) => xn
    | FTD3 (xn1, xn2, xn) => xn
    | FTD4 (xn1, xn2, xn3, xn) => xn
    ) // end of [FTdeep]
) // end of [fngtree_get_atend]

(* ****** ****** *)

assume
deque_type
  (a:t0p, n:int) = fngtree (a, 0(*d*), n)
// end of [deque_type]

(* ****** ****** *)

primplmnt
lemma_deque_param
  (xs) = fngtree_prop1_sznat (xs)
// end of [lemma_deque_param]

(* ****** ****** *)

implement{}
fundeque_nil () = FTemp ((*void*))

(* ****** ****** *)

implement{a}
fundeque_cons (x0, xs) =
  fngtree_cons (FTN1{a}(x0), xs)
// end of [fundeque_cons]

implement{a}
fundeque_uncons
  (xs) = x0 where
{
  var xn: ptr?
  val () = xs := fngtree_uncons (xs, xn)
  val+FTN1 (x0) = xn
} // end of [fundeque_uncons]

(* ****** ****** *)

implement{a}
fundeque_snoc (xs, xn) =
  fngtree_snoc (xs, FTN1{a}(xn))
// end of [fundeque_snoc]

implement{a}
fundeque_unsnoc
  (xs) = x0 where
{
  var xn: ptr?
  val () = xs := fngtree_unsnoc (xs, xn)
  val+FTN1 (x0) = xn
} // end of [fundeque_unsnoc]

(* ****** ****** *)

implement{}
fundeque_is_nil (xs) = let
in
//
case+ xs of
| FTemp () => true
| FTsing (xn) => let
    prval () = ftnode_prop_szpos (xn) in false
  end // end of [FTsing]
| FTdeep (pr, _, _) => let
    prval () = ftdigit_prop_szpos (pr) in false
  end // end of [FTdeep]
//
end // end of [fundeque_is_nil]

implement{}
fundeque_is_cons (xs) = let
  prval () = lemma_deque_param (xs) in ~fundeque_is_nil<> (xs)
end // end of [fundeque_is_cons]

(* ****** ****** *)

implement
fundeque_size
  {a} (xs) = let
//
fun size
  {d:int}{n:nat} .<n>.
(
  xt: fngtree (a, d, n)
) :<> size_t (n) = let
in
//
case+ xt of
| FTemp () => g1i2u(0)
| FTsing (xn) => ftnode_size (xn)
| FTdeep (pr, m, sf) => let
    prval () = ftdigit_prop_szpos (pr)
  in
    ftdigit_size (pr) + size (m) + ftdigit_size (sf)
  end // end of [FTdeep]
//
end (* end of [size] *)
//
prval () = lemma_deque_param (xs)
//
in
  size (xs)
end // end of [fundeque_size]

(* ****** ****** *)

implement{a}
fundeque_get_atbeg (xs) = let
  val+FTN1 (x) = fngtree_get_atbeg{a}(xs) in (x)
end // end of [fundeque_get_atbeg]

implement{a}
fundeque_get_atend (xs) = let
  val+FTN1 (x) = fngtree_get_atend{a}(xs) in (x)
end // end of [fundeque_get_atend]

(* ****** ****** *)

local

symintr ++
infix (+) ++
overload ++ with fngtree_cons
overload ++ with fngtree_snoc

fun ftapp0
  {a:t0p}
  {d:int}
  {n1,n2:nat} (
  xt1: fngtree (a, d, n1)
, xt2: fngtree (a, d, n2)
) : fngtree (a, d, n1+n2) =
(
  case+ (xt1, xt2) of
  | (FTemp (), _) => xt2
  | (_, FTemp ()) => xt1
  | (FTsing xn1, _) => xn1 ++ xt2
  | (_, FTsing xn2) => xt1 ++ xn2
  | (FTdeep (pr1, m1, sf1),
     FTdeep (pr2, m2, sf2)) => FTdeep (pr1, ftadd0 (m1, sf1, pr2, m2), sf2)
) // end of [ftapp0]

and ftadd0
  {a:t0p}
  {d:int}
  {nm1,nm2:nat}
  {nsf1,npr2:nat} (
  m1: fngtree (a, d+1, nm1)
, sf1: ftdigit (a, d, nsf1)
, pr2: ftdigit (a, d, npr2)
, m2: fngtree (a, d+1, nm2)
) : fngtree (a, d+1, nm1+nsf1+npr2+nm2) = let
in
//
case+ sf1 of
| FTD1 (xn1) => (case+ pr2 of
  | FTD1 (xn_1) => ftapp1 (m1, FTN2 (xn1, xn_1), m2)
  | FTD2 (xn_1, xn_2) => ftapp1 (m1, FTN3 (xn1, xn_1, xn_2), m2)
  | FTD3 (xn_1, xn_2, xn_3) =>
      ftapp2 (m1, FTN2 (xn1, xn_1), FTN2 (xn_2, xn_3), m2)
  | FTD4 (xn_1, xn_2, xn_3, xn_4) =>
      ftapp2 (m1, FTN3 (xn1, xn_1, xn_2), FTN2 (xn_3, xn_4), m2)
  ) // end of [FTD1]
| FTD2 (xn1, xn2) => (case+ pr2 of
  | FTD1 (xn_1) => ftapp1 (m1, FTN3 (xn1, xn2, xn_1), m2)
  | FTD2 (xn_1, xn_2) => ftapp2 (m1, FTN2 (xn1, xn2), FTN2 (xn_1, xn_2), m2)
  | FTD3 (xn_1, xn_2, xn_3) =>
      ftapp2 (m1, FTN3 (xn1, xn2, xn_1), FTN2 (xn_2, xn_3), m2)
  | FTD4 (xn_1, xn_2, xn_3, xn_4) =>
      ftapp2 (m1, FTN3 (xn1, xn2, xn_1), FTN3 (xn_2, xn_3, xn_4), m2)
  ) // end of [FTD2]
| FTD3 (xn1, xn2, xn3) => (case+ pr2 of
  | FTD1 (xn_1) => ftapp2 (m1, FTN2 (xn1, xn2), FTN2 (xn3, xn_1), m2)
  | FTD2 (xn_1, xn_2) => ftapp2 (m1, FTN3 (xn1, xn2, xn3), FTN2 (xn_1, xn_2), m2)
  | FTD3 (xn_1, xn_2, xn_3) =>
      ftapp2 (m1, FTN3 (xn1, xn2, xn3), FTN3 (xn_1, xn_2, xn_3), m2)
  | FTD4 (xn_1, xn_2, xn_3, xn_4) =>
      ftapp3 (m1, FTN3 (xn1, xn2, xn3), FTN2 (xn_1, xn_2), FTN2 (xn_3, xn_4), m2)
  ) // end of [FTD3]
| FTD4 (xn1, xn2, xn3, xn4) => (case+ pr2 of
  | FTD1 (xn_1) => ftapp2 (m1, FTN3 (xn1, xn2, xn3), FTN2 (xn4, xn_1), m2)
  | FTD2 (xn_1, xn_2) => ftapp2 (m1, FTN3 (xn1, xn2, xn3), FTN3 (xn4, xn_1, xn_2), m2)
  | FTD3 (xn_1, xn_2, xn_3) =>
      ftapp3 (m1, FTN3 (xn1, xn2, xn3), FTN2 (xn4, xn_1), FTN2 (xn_2, xn_3), m2)
  | FTD4 (xn_1, xn_2, xn_3, xn_4) =>
      ftapp3 (m1, FTN3 (xn1, xn2, xn3), FTN3 (xn4, xn_1, xn_2), FTN2 (xn_3, xn_4), m2)
  ) // end of [FTD4]
//
end // end of [ftadd0]

and ftapp1
  {a:t0p}
  {d:int}
  {n1,n2:nat}
  {na:nat} (
  xt1: fngtree (a, d, n1)
, xna: ftnode (a, d, na)
, xt2: fngtree (a, d, n2)
) : fngtree (a, d, n1+na+n2) =
(
  case+ (xt1, xt2) of
  | (FTemp (), _) => xna ++ xt2
  | (_, FTemp ()) => xt1 ++ xna
  | (FTsing xn1, _) => xn1 ++ (xna ++ xt2)
  | (_, FTsing xn2) => (xt1 ++ xna) ++ xn2
  | (FTdeep (pr1, m1, sf1), FTdeep (pr2, m2, sf2)) =>
      FTdeep (pr1, ftadd1 (m1, sf1, xna, pr2, m2), sf2)
) // end of [ftapp1]

and ftadd1
  {a:t0p}
  {d:int}
  {nm1,nm2:nat}
  {nsf1,npr2:nat}
  {na:nat} (
  m1: fngtree (a, d+1, nm1)
, sf1: ftdigit (a, d, nsf1)
, xna: ftnode (a, d, na)
, pr2: ftdigit (a, d, npr2)
, m2: fngtree (a, d+1, nm2)
) : fngtree (a, d+1, nm1+nsf1+na+npr2+nm2) = let
in
//
case+ sf1 of
| FTD1 (xn1) => (case+ pr2 of
  | FTD1 (xn_1) => ftapp1 (m1, FTN3 (xn1, xna, xn_1), m2)
  | FTD2 (xn_1, xn_2) => ftapp2 (m1, FTN2 (xn1, xna), FTN2 (xn_1, xn_2), m2)
  | FTD3 (xn_1, xn_2, xn_3) =>
      ftapp2 (m1, FTN3 (xn1, xna, xn_1), FTN2 (xn_2, xn_3), m2)
  | FTD4 (xn_1, xn_2, xn_3, xn_4) =>
      ftapp2 (m1, FTN3 (xn1, xna, xn_1), FTN3 (xn_2, xn_3, xn_4), m2)
  ) // end of [FTD1]
| FTD2 (xn1, xn2) => (case+ pr2 of
  | FTD1 (xn_1) => ftapp2 (m1, FTN2 (xn1, xn2), FTN2 (xna, xn_1), m2)
  | FTD2 (xn_1, xn_2) => ftapp2 (m1, FTN3 (xn1, xn2, xna), FTN2 (xn_1, xn_2), m2)
  | FTD3 (xn_1, xn_2, xn_3) =>
      ftapp2 (m1, FTN3 (xn1, xn2, xna), FTN3 (xn_1, xn_2, xn_3), m2)
  | FTD4 (xn_1, xn_2, xn_3, xn_4) =>
      ftapp3 (m1, FTN3 (xn1, xn2, xna), FTN2 (xn_1, xn_2), FTN2 (xn_3, xn_4), m2)
  ) // end of [FTD2]
| FTD3 (xn1, xn2, xn3) => (case+ pr2 of
  | FTD1 (xn_1) => ftapp2 (m1, FTN3 (xn1, xn2, xn3), FTN2 (xna, xn_1), m2)
  | FTD2 (xn_1, xn_2) => ftapp2 (m1, FTN3 (xn1, xn2, xn3), FTN3 (xna, xn_1, xn_2), m2)
  | FTD3 (xn_1, xn_2, xn_3) =>
      ftapp3 (m1, FTN3 (xn1, xn2, xn3), FTN2 (xna, xn_1), FTN2 (xn_2, xn_3), m2)
  | FTD4 (xn_1, xn_2, xn_3, xn_4) =>
      ftapp3 (m1, FTN3 (xn1, xn2, xn3), FTN3 (xna, xn_1, xn_2), FTN2 (xn_3, xn_4), m2)
  ) // end of [FTD3]
| FTD4 (xn1, xn2, xn3, xn4) => (case+ pr2 of
  | FTD1 (xn_1) => ftapp2 (m1, FTN3 (xn1, xn2, xn3), FTN3 (xn4, xna, xn_1), m2)
  | FTD2 (xn_1, xn_2) =>
      ftapp3 (m1, FTN3 (xn1, xn2, xn3), FTN2 (xn4, xna), FTN2 (xn_1, xn_2), m2)
  | FTD3 (xn_1, xn_2, xn_3) =>
      ftapp3 (m1, FTN3 (xn1, xn2, xn3), FTN3 (xn4, xna, xn_1), FTN2 (xn_2, xn_3), m2)
  | FTD4 (xn_1, xn_2, xn_3, xn_4) =>
      ftapp3 (m1, FTN3 (xn1, xn2, xn3), FTN3 (xn4, xna, xn_1), FTN3 (xn_2, xn_3, xn_4), m2)
  ) // end of [FTD4]
//
end // end of [ftadd1]

and ftapp2
  {a:t0p}
  {d:int}
  {n1,n2:nat}
  {na,nb:nat} (
  xt1: fngtree (a, d, n1)
, xna: ftnode (a, d, na)
, xnb: ftnode (a, d, nb)
, xt2: fngtree (a, d, n2)
) : fngtree (a, d, n1+na+nb+n2) =
(
  case+ (xt1, xt2) of
  | (FTemp (), _) => xna ++ (xnb ++ xt2)
  | (_, FTemp ()) => (xt1 ++ xna) ++ xnb
  | (FTsing xn1, _) => xn1 ++ (xna ++ (xnb ++ xt2))
  | (_, FTsing xn2) => ((xt1 ++ xna) ++ xnb) ++ xn2
  | (FTdeep (pr1, m1, sf1), FTdeep (pr2, m2, sf2)) =>
      FTdeep (pr1, ftadd2 (m1, sf1, xna, xnb, pr2, m2), sf2)
) // end of [ftapp2]

and ftadd2
  {a:t0p}
  {d:int}
  {nm1,nm2:nat}
  {nsf1,npr2:nat}
  {na,nb:nat} (
  m1: fngtree (a, d+1, nm1)
, sf1: ftdigit (a, d, nsf1)
, xna: ftnode (a, d, na)
, xnb: ftnode (a, d, nb)
, pr2: ftdigit (a, d, npr2)
, m2: fngtree (a, d+1, nm2)
) : fngtree (a, d+1, nm1+nsf1+na+nb+npr2+nm2) = let
in
//
case+ sf1 of
| FTD1 (xn1) => (case+ pr2 of
  | FTD1 (xn_1) => ftapp2 (m1, FTN2 (xn1, xna), FTN2 (xnb, xn_1), m2)
  | FTD2 (xn_1, xn_2) => ftapp2 (m1, FTN3 (xn1, xna, xnb), FTN2 (xn_1, xn_2), m2)
  | FTD3 (xn_1, xn_2, xn_3) =>
      ftapp2 (m1, FTN3 (xn1, xna, xnb), FTN3 (xn_1, xn_2, xn_3), m2)
  | FTD4 (xn_1, xn_2, xn_3, xn_4) =>
      ftapp3 (m1, FTN3 (xn1, xna, xnb), FTN2 (xn_1, xn_2), FTN2 (xn_3, xn_4), m2)
  ) // end of [FTD1]
| FTD2 (xn1, xn2) => (case+ pr2 of
  | FTD1 (xn_1) => ftapp2 (m1, FTN3 (xn1, xn2, xna), FTN2 (xnb, xn_1), m2)
  | FTD2 (xn_1, xn_2) => ftapp2 (m1, FTN3 (xn1, xn2, xna), FTN3 (xnb, xn_1, xn_2), m2)
  | FTD3 (xn_1, xn_2, xn_3) =>
      ftapp3 (m1, FTN3 (xn1, xn2, xna), FTN2 (xnb, xn_1), FTN2 (xn_2, xn_3), m2)
  | FTD4 (xn_1, xn_2, xn_3, xn_4) =>
      ftapp3 (m1, FTN3 (xn1, xn2, xna), FTN3 (xnb, xn_1, xn_2), FTN2 (xn_3, xn_4), m2)
  ) // end of [FTD2]
| FTD3 (xn1, xn2, xn3) => (case+ pr2 of
  | FTD1 (xn_1) => ftapp2 (m1, FTN3 (xn1, xn2, xn3), FTN3 (xna, xnb, xn_1), m2)
  | FTD2 (xn_1, xn_2) =>
      ftapp3 (m1, FTN3 (xn1, xn2, xn3), FTN2 (xna, xnb), FTN2 (xn_1, xn_2), m2)
  | FTD3 (xn_1, xn_2, xn_3) =>
      ftapp3 (m1, FTN3 (xn1, xn2, xn3), FTN3 (xna, xnb, xn_1), FTN2 (xn_2, xn_3), m2)
  | FTD4 (xn_1, xn_2, xn_3, xn_4) =>
      ftapp3 (m1, FTN3 (xn1, xn2, xn3), FTN3 (xna, xnb, xn_1), FTN3 (xn_2, xn_3, xn_4), m2)
  ) // end of [FTD3]
| FTD4 (xn1, xn2, xn3, xn4) => (case+ pr2 of
  | FTD1 (xn_1) => ftapp3 (m1, FTN3 (xn1, xn2, xn3), FTN2 (xn4, xna), FTN2 (xnb, xn_1), m2)
  | FTD2 (xn_1, xn_2) =>
      ftapp3 (m1, FTN3 (xn1, xn2, xn3), FTN3 (xn4, xna, xnb), FTN2 (xn_1, xn_2), m2)
  | FTD3 (xn_1, xn_2, xn_3) =>
      ftapp3 (m1, FTN3 (xn1, xn2, xn3), FTN3 (xn4, xna, xnb), FTN3 (xn_1, xn_2, xn_3), m2)
  | FTD4 (xn_1, xn_2, xn_3, xn_4) =>
      ftapp4 (m1, FTN3 (xn1, xn2, xn3), FTN3 (xn4, xna, xnb), FTN2 (xn_1, xn_2), FTN2 (xn_3, xn_4), m2)
  ) // end of [FTD4]
//
end // end of [ftadd2]

and ftapp3
  {a:t0p}
  {d:int}
  {n1,n2:nat}
  {na,nb,nc:nat} (
  xt1: fngtree (a, d, n1)
, xna: ftnode (a, d, na)
, xnb: ftnode (a, d, nb)
, xnc: ftnode (a, d, nc)
, xt2: fngtree (a, d, n2)
) : fngtree (a, d, n1+na+nb+nc+n2) =
(
  case+ (xt1, xt2) of
  | (FTemp (), _) => xna ++ (xnb ++ (xnc ++ xt2))
  | (_, FTemp ()) => ((xt1 ++ xna) ++ xnb) ++ xnc
  | (FTsing xn1, _) => xn1 ++ (xna ++ (xnb ++ (xnc ++ xt2)))
  | (_, FTsing xn2) => (((xt1 ++ xna) ++ xnb) ++ xnc) ++ xn2
  | (FTdeep (pr1, m1, sf1), FTdeep (pr2, m2, sf2)) =>
      FTdeep (pr1, ftadd3 (m1, sf1, xna, xnb, xnc, pr2, m2), sf2)
) // end of [ftapp3]

and ftadd3
  {a:t0p}
  {d:int}
  {nm1,nm2:nat}
  {nsf1,npr2:nat}
  {na,nb,nc:nat} (
  m1: fngtree (a, d+1, nm1)
, sf1: ftdigit (a, d, nsf1)
, xna: ftnode (a, d, na)
, xnb: ftnode (a, d, nb)
, xnc: ftnode (a, d, nc)
, pr2: ftdigit (a, d, npr2)
, m2: fngtree (a, d+1, nm2)
) : fngtree (a, d+1, nm1+nsf1+na+nb+nc+npr2+nm2) = let
in
//
case+ sf1 of
| FTD1 (xn1) => (case+ pr2 of
  | FTD1 (xn_1) => ftapp2 (m1, FTN3 (xn1, xna, xnb), FTN2 (xnc, xn_1), m2)
  | FTD2 (xn_1, xn_2) => ftapp2 (m1, FTN3 (xn1, xna, xnb), FTN3 (xnc, xn_1, xn_2), m2)
  | FTD3 (xn_1, xn_2, xn_3) =>
      ftapp3 (m1, FTN3 (xn1, xna, xnb), FTN2 (xnc, xn_1), FTN2 (xn_2, xn_3), m2)
  | FTD4 (xn_1, xn_2, xn_3, xn_4) =>
      ftapp3 (m1, FTN3 (xn1, xna, xnb), FTN3 (xnc, xn_1, xn_2), FTN2 (xn_3, xn_4), m2)
  ) // end of [FTD1]
| FTD2 (xn1, xn2) => (case+ pr2 of
  | FTD1 (xn_1) => ftapp2 (m1, FTN3 (xn1, xn2, xna), FTN3 (xnb, xnc, xn_1), m2)
  | FTD2 (xn_1, xn_2) =>
      ftapp3 (m1, FTN3 (xn1, xn2, xna), FTN2 (xnb, xnc), FTN2 (xn_1, xn_2), m2)
  | FTD3 (xn_1, xn_2, xn_3) =>
      ftapp3 (m1, FTN3 (xn1, xn2, xna), FTN3 (xnb, xnc, xn_1), FTN2 (xn_2, xn_3), m2)
  | FTD4 (xn_1, xn_2, xn_3, xn_4) =>
      ftapp3 (m1, FTN3 (xn1, xn2, xna), FTN3 (xnb, xnc, xn_1), FTN3 (xn_2, xn_3, xn_4), m2)
  ) // end of [FTD2]
| FTD3 (xn1, xn2, xn3) => (case+ pr2 of
  | FTD1 (xn_1) => ftapp3 (m1, FTN3 (xn1, xn2, xn3), FTN2 (xna, xnb), FTN2 (xnc, xn_1), m2)
  | FTD2 (xn_1, xn_2) =>
      ftapp3 (m1, FTN3 (xn1, xn2, xn3), FTN3 (xna, xnb, xnc), FTN2 (xn_1, xn_2), m2)
  | FTD3 (xn_1, xn_2, xn_3) =>
      ftapp3 (m1, FTN3 (xn1, xn2, xn3), FTN3 (xna, xnb, xnc), FTN3 (xn_1, xn_2, xn_3), m2)
  | FTD4 (xn_1, xn_2, xn_3, xn_4) =>
      ftapp4 (m1, FTN3 (xn1, xn2, xn3), FTN3 (xna, xnb, xnc), FTN2 (xn_1, xn_2), FTN2 (xn_3, xn_4), m2)
  ) // end of [FTD3]
| FTD4 (xn1, xn2, xn3, xn4) => (case+ pr2 of
  | FTD1 (xn_1) => ftapp3 (m1, FTN3 (xn1, xn2, xn3), FTN3 (xn4, xna, xnb), FTN2 (xnc, xn_1), m2)
  | FTD2 (xn_1, xn_2) =>
      ftapp3 (m1, FTN3 (xn1, xn2, xn3), FTN3 (xn4, xna, xnb), FTN3 (xnc, xn_1, xn_2), m2)
  | FTD3 (xn_1, xn_2, xn_3) =>
      ftapp4 (m1, FTN3 (xn1, xn2, xn3), FTN3 (xn4, xna, xnb), FTN2 (xnc, xn_1), FTN2 (xn_2, xn_3), m2)
  | FTD4 (xn_1, xn_2, xn_3, xn_4) =>
      ftapp4 (m1, FTN3 (xn1, xn2, xn3), FTN3 (xn4, xna, xnb), FTN3 (xnc, xn_1, xn_2), FTN2 (xn_3, xn_4), m2)
  ) // end of [FTD4]
//
end // end of [ftadd3]

and ftapp4
  {a:t0p}
  {d:int}
  {n1,n2:nat}
  {na,nb,nc,nd:nat} (
  xt1: fngtree (a, d, n1)
, xna: ftnode (a, d, na)
, xnb: ftnode (a, d, nb)
, xnc: ftnode (a, d, nc)
, xnd: ftnode (a, d, nd)
, xt2: fngtree (a, d, n2)
) : fngtree (a, d, n1+na+nb+nc+nd+n2) =
(
  case+ (xt1, xt2) of
  | (FTemp (), _) => xna ++ (xnb ++ (xnc ++ (xnd ++ xt2)))
  | (_, FTemp ()) => (((xt1 ++ xna) ++ xnb) ++ xnc) ++ xnd
  | (FTsing xn1, _) => xn1 ++ (xna ++ (xnb ++ (xnc ++ (xnd ++ xt2))))
  | (_, FTsing xn2) => ((((xt1 ++ xna) ++ xnb) ++ xnc) ++ xnd) ++ xn2
  | (FTdeep (pr1, m1, sf1), FTdeep (pr2, m2, sf2)) =>
      FTdeep (pr1, ftadd4 (m1, sf1, xna, xnb, xnc, xnd, pr2, m2), sf2)
) // end of [ftapp4]

and ftadd4
  {a:t0p}
  {d:int}
  {nm1,nm2:nat}
  {nsf1,npr2:nat}
  {na,nb,nc,nd:nat} (
  m1: fngtree (a, d+1, nm1)
, sf1: ftdigit (a, d, nsf1)
, xna: ftnode (a, d, na)
, xnb: ftnode (a, d, nb)
, xnc: ftnode (a, d, nc)
, xnd: ftnode (a, d, nd)
, pr2: ftdigit (a, d, npr2)
, m2: fngtree (a, d+1, nm2)
) : fngtree (a, d+1, nm1+nsf1+na+nb+nc+nd+npr2+nm2) = let
in
//
case+ sf1 of
| FTD1 (xn1) => (case+ pr2 of
  | FTD1 (xn_1) => ftapp2 (m1, FTN3 (xn1, xna, xnb), FTN3 (xnc, xnd, xn_1), m2)
  | FTD2 (xn_1, xn_2) =>
      ftapp3 (m1, FTN3 (xn1, xna, xnb), FTN2 (xnc, xnd), FTN2 (xn_1, xn_2), m2)
  | FTD3 (xn_1, xn_2, xn_3) =>
      ftapp3 (m1, FTN3 (xn1, xna, xnb), FTN3 (xnc, xnd, xn_1), FTN2 (xn_2, xn_3), m2)
  | FTD4 (xn_1, xn_2, xn_3, xn_4) =>
      ftapp3 (m1, FTN3 (xn1, xna, xnb), FTN3 (xnc, xnd, xn_1), FTN3 (xn_2, xn_3, xn_4), m2)
  ) // end of [FTD1]
| FTD2 (xn1, xn2) => (case+ pr2 of
  | FTD1 (xn_1) =>
      ftapp3 (m1, FTN3 (xn1, xn2, xna), FTN2 (xnb, xnc), FTN2 (xnd, xn_1), m2)
  | FTD2 (xn_1, xn_2) =>
      ftapp3 (m1, FTN3 (xn1, xn2, xna), FTN3 (xnb, xnc, xnd), FTN2 (xn_1, xn_2), m2)
  | FTD3 (xn_1, xn_2, xn_3) =>
      ftapp3 (m1, FTN3 (xn1, xn2, xna), FTN3 (xnb, xnc, xnd), FTN3 (xn_1, xn_2, xn_3), m2)
  | FTD4 (xn_1, xn_2, xn_3, xn_4) =>
      ftapp4 (m1, FTN3 (xn1, xn2, xna), FTN3 (xnb, xnc, xnd), FTN2 (xn_1, xn_2), FTN2 (xn_3, xn_4), m2)
  ) // end of [FTD2]
| FTD3 (xn1, xn2, xn3) => (case+ pr2 of
  | FTD1 (xn_1) =>
      ftapp3 (m1, FTN3 (xn1, xn2, xn3), FTN3 (xna, xnb, xnc), FTN2 (xnd, xn_1), m2)
  | FTD2 (xn_1, xn_2) =>
      ftapp3 (m1, FTN3 (xn1, xn2, xn3), FTN3 (xna, xnb, xnc), FTN3 (xnd, xn_1, xn_2), m2)
  | FTD3 (xn_1, xn_2, xn_3) =>
      ftapp4 (m1, FTN3 (xn1, xn2, xn3), FTN3 (xna, xnb, xnc), FTN2 (xnd, xn_1), FTN2 (xn_2, xn_3), m2)
  | FTD4 (xn_1, xn_2, xn_3, xn_4) =>
      ftapp4 (m1, FTN3 (xn1, xn2, xn3), FTN3 (xna, xnb, xnc), FTN3 (xnd, xn_1, xn_2), FTN2 (xn_3, xn_4), m2)
  ) // end of [FTD3]
| FTD4 (xn1, xn2, xn3, xn4) => (case+ pr2 of
  | FTD1 (xn_1) =>
      ftapp3 (m1, FTN3 (xn1, xn2, xn3), FTN3 (xn4, xna, xnb), FTN3 (xnc, xnd, xn_1), m2)
  | FTD2 (xn_1, xn_2) =>
      ftapp4 (m1, FTN3 (xn1, xn2, xn3), FTN3 (xn4, xna, xnb), FTN2 (xnc, xnd), FTN2 (xn_1, xn_2), m2)
  | FTD3 (xn_1, xn_2, xn_3) =>
      ftapp4 (m1, FTN3 (xn1, xn2, xn3), FTN3 (xn4, xna, xnb), FTN3 (xnc, xnd, xn_1), FTN2 (xn_2, xn_3), m2)
  | FTD4 (xn_1, xn_2, xn_3, xn_4) =>
      ftapp4 (m1, FTN3 (xn1, xn2, xn3), FTN3 (xn4, xna, xnb), FTN3 (xnc, xnd, xn_1), FTN3 (xn_2, xn_3, xn_4), m2)
  ) // end of [FTD4]
//
end // end of [ftadd4]

in (* in of [local] *)

implement
fundeque_append
  (xs1, xs2) = let
//
prval () = lemma_deque_param (xs1)
prval () = lemma_deque_param (xs2)
//
in
  $effmask_all (ftapp0 (xs1, xs2))
end // end of [fundeque_append]

end // end of [local]

(* ****** ****** *)

typedef ftnode
  (a:t0p, d:int) = [n:int] ftnode (a, d, n)
// end of [ftnode]

(* ****** ****** *)

local

extern
fun __free (p: ptr):<!wrt> void = "mac#ATS_MFREE"

extern fun
foreach{a:t0p}{d:nat}{n:nat}
(
  xt: fngtree (a, d, n), f: ftnode (a, d) -<cloref> void
) :<> void // end of [foreach]

implement
foreach{a}{d}{n} (xt, f) = let
in
//
case+ xt of
| FTemp () => ()
| FTsing (xn) => f (xn)
| FTdeep (pr, m, sf) => let
//
    prval () = ftdigit_prop_szpos (pr)
    prval () = ftdigit_prop_szpos (sf)
//
    val (
    ) = (case+ pr of
      | FTD1 (xn1) => f (xn1)
      | FTD2 (xn1, xn2) => (f (xn1); f (xn2))
      | FTD3 (xn1, xn2, xn3) => (f (xn1); f (xn2); f (xn3))
      | FTD4 (xn1, xn2, xn3, xn4) =>
          (f (xn1); f (xn2); f (xn3); f (xn4))
    ) : void // end of [val]
    val () = (
      case+ m of
      | FTemp () => ()
      | _ => let
          val f1 = lam
            (xn_1: ftnode (a, d+1)): void =<cloref> let
          in
            case+ xn_1 of
            | FTN2 (xn1, xn2) => (f (xn1); f (xn2))
            | FTN3 (xn1, xn2, xn3) => (f (xn1); f (xn2); f (xn3))
          end // end of [lam] // end of [val]
          val () = foreach (m, f1)
          val () = $effmask_wrt (__free ($UN.cast2ptr(f1)))
        in
          // nothing          
        end // end of [_]
    ) : void // end of [val]
    val () = (case+ sf of
      | FTD1 (xn1) => f (xn1)
      | FTD2 (xn1, xn2) => (f (xn1); f (xn2))
      | FTD3 (xn1, xn2, xn3) => (f (xn1); f (xn2); f (xn3))
      | FTD4 (xn1, xn2, xn3, xn4) =>
          (f (xn1); f (xn2); f (xn3); f (xn4))
    ) : void // end of [val]
  in
    // nothing
  end // end of [FTdeep]
end // end of [foreach]

in (* in of [local] *)

implement{a}
fundeque_foreach (xs) = let
  var env: void = () in fundeque_foreach_env<a><void> (xs, env)
end // end of [fundeque_foreach]

implement
{a}{env}
fundeque_foreach_env
  (xs, env) = let
//
typedef ftnode = ftnode (a, 0)
//
prval () = fngtree_prop1_sznat (xs)
//
val p_env = addr@ (env)
//
val f = lam
  (xn: ftnode): void =<cloref> let
  val+FTN1 (x) = xn
  val
  (
    pf, fpf | p_env
  ) = $UN.ptr_vtake{env}(p_env)
  val () = $effmask_all (fundeque_foreach$fwork<a><env> (x, !p_env))
  prval () = fpf (pf)
in
  // nothing
end // end of [val]
//
val () = foreach (xs, f)
val () = $effmask_wrt (__free ($UN.cast2ptr(f)))
//
in
  // nothing
end // end of [fundeque_foreach_env]

end // end of [local]

(* ****** ****** *)

local

extern
fun __free (p: ptr):<!wrt> void = "mac#ATS_MFREE"

extern fun
rforeach{a:t0p}{d:nat}{n:nat}
(
  xt: fngtree (a, d, n), f: (ftnode (a, d)) -<cloref> void
) :<> void // end of [rforeach]

implement
rforeach{a}{d}{n} (xt, f) = let
in
//
case+ xt of
| FTemp () => ()
| FTsing (xn) => f (xn)
| FTdeep (pr, m, sf) => let
//
    prval () = ftdigit_prop_szpos (pr)
    prval () = ftdigit_prop_szpos (sf)
//
    val (
    ) = (case+ sf of
      | FTD1 (xn1) => f (xn1)
      | FTD2 (xn1, xn2) => (f (xn2); f (xn1))
      | FTD3 (xn1, xn2, xn3) => (f (xn3); f (xn2); f (xn1))
      | FTD4 (xn1, xn2, xn3, xn4) =>
          (f (xn4); f (xn3); f (xn2); f (xn1))
    ) : void // end of [val]
    val () = (case+ m of
      | FTemp () => ()
      | _ => let
          val f1 = lam
            (xn_1: ftnode (a, d+1)): void =<cloref> let
          in
            case+ xn_1 of
            | FTN2 (xn1, xn2) => (f (xn2); f (xn1))
            | FTN3 (xn1, xn2, xn3) => (f (xn3); f (xn2); f (xn1))
          end // end of [val]
          val () = rforeach (m, f1)
          val () = $effmask_wrt (__free ($UN.cast2ptr(f1)))
        in
          // nothing          
        end // end of [_]
    ) : void // end of [val]
    val () = (case+ pr of
      | FTD1 (xn1) => f (xn1)
      | FTD2 (xn1, xn2) => (f (xn2); f (xn1))
      | FTD3 (xn1, xn2, xn3) => (f (xn3); f (xn2); f (xn1))
      | FTD4 (xn1, xn2, xn3, xn4) =>
          (f (xn4); f (xn3); f (xn2); f (xn1))
    ) : void // end of [val]
  in
    // nothing
  end // end of [FTdeep]
//
end // end of [rforeach]

in (* in of [local] *)

implement{a}
fundeque_rforeach (xs) = let
  var env: void = () in fundeque_rforeach_env<a><void> (xs, env)
end // end of [fundeque_rforeach]

implement
{a}{env}
fundeque_rforeach_env
  (xs, env) = let
//
typedef ftnode = ftnode (a, 0)
//
prval () = fngtree_prop1_sznat (xs)
//
val p_env = addr@ (env)
//
val f = lam
  (xn: ftnode): void =<cloref> let
  val+FTN1 (x) = xn
  val (
    pf, fpf | p_env
  ) = $UN.ptr_vtake{env}(p_env)
  val () = $effmask_all (fundeque_rforeach$fwork<a><env> (x, !p_env))
  prval () = fpf (pf)
in
  // nothing
end // end of [val]
//
val () = rforeach (xs, f)
val () = $effmask_wrt (__free ($UN.cast2ptr(f)))
//
in
  // nothing
end // end of [fundeque_rforeach_env]

end // end of [local]

(* ****** ****** *)

(* end of [fundeque_fngtree.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: July, 2013 *)

(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libats/SATS/gvector.sats"
staload "libats/SATS/gmatrix.sats"
staload "libats/SATS/gmatrix_col.sats"
staload "libats/SATS/gmatrix_row.sats"

(* ****** ****** *)

//
implement{}
fprint_gmatrix$sep1 (out) = fprint (out, ", ")
implement{}
fprint_gmatrix$sep2 (out) = fprint (out, "; ")
//
implement{a}
fprint_gmatrix
  {mo}{m,n}{ld}
  (out, M, mo, m0, n0, ld) = let
//
implement
fprint_gvector$sep<> (out) = fprint_gmatrix$sep1 (out)
//
fun loop_row
  {l:addr}{m:nat}.<m>.
(
  pf: !GMR(a, l, m, n, ld) | p: ptr l, m: int m
) : void =
(
if m > 0
then let
//
val (
) = (
  if m < m0 then fprint_gmatrix$sep2 (out)
) (* end of [val] *)
//
prval
(pf1, pf2) = gmatrow_v_uncons0 (pf)
val () = fprint_gvector (out, !p, n0, 1)
val (
) = loop_row (pf2 | ptr_add<a> (p, ld), pred(m))
prval () = pf := gmatrow_v_cons0 (pf1, pf2)
//
in
  // nothing
end else () // end of [if]
)
//
fun loop_col
  {l:addr}{m:nat}.<m>.
(
  pf: !GMC(a, l, m, n, ld) | p: ptr l, m: int m
) : void =
(
if m > 0
then let
//
val (
) = (
  if m < m0 then fprint_gmatrix$sep2 (out)
) (* end of [val] *)
//
prval
(pf1, pf2) = gmatcol_v_uncons0 (pf)
val () = fprint_gvector (out, !p, n0, ld)
val () = loop_col (pf2 | ptr_succ<a> (p), pred(m))
prval () = pf := gmatcol_v_cons0 (pf1, pf2)
//
in
  // nothing
end else () // end of [if]
)
//
prval () = lemma_gmatrix_param (M)
//
in
//
case+ mo of
| MORDrow () => loop_row (view@M | addr@M, m0)
| MORDcol () => loop_col (view@M | addr@M, m0)
//
end // end of [fprint_gmatrix]

(* ****** ****** *)

implement{a}
fprint_gmatrix_sep
  (out, M, mo, m, n, ld, sep1, sep2) = let
//
implement
fprint_gmatrix$sep1<> (out) = fprint (out, sep1)
implement
fprint_gmatrix$sep2<> (out) = fprint (out, sep2)
//
in
  fprint_gmatrix (out, M, mo, m, n, ld)
end // end of [fprint_gmatrix_sep]

(* ****** ****** *)

implement
{a}(*tmp*)
gmatrix_iforeach
  (M, mo, m, n, ld) = let
  var env: void = () in
  gmatrix_iforeach_env<a><void> (M, mo, m, n, ld, env)
end // end of [gmatrix_iforeach]

(* ****** ****** *)

implement
{a}{env}
gmatrix_iforeach_env
  (M, mo, m, n, ld, env) = let
//
in
//
case mo of
| MORDrow () => let
    var i: int = 0
    and j: int = 0
    var p_i: ptr = addr@(M)
    var p_ij: ptr = the_null_ptr
  in
    for (i := 0; i < m; i := i+1)
    {
      val () = p_ij := p_i
      val (
      ) = for (j := 0; j < n; j := j+1)
      {
        val (pf, fpf | p) = $UN.ptr0_vtake (p_ij)
        val () = gmatrix_iforeach$fwork<a><env> (i, j, !p, env)
        prval () = fpf (pf)
        val () = p_ij := ptr_succ<a> (p)
      }
      val () = p_i := ptr_add<a> (p_i, ld)
    } 
  end // end of [MORDrow]
| MORDcol () => let
    var i: int = 0
    and j: int = 0
    var p_j: ptr = addr@(M)
    var p_ij: ptr = the_null_ptr
  in
    for (j := 0; j < n; j := j+1)
    {
      val () = p_ij := p_j
      val (
      ) = for (i := 0; i < m; i := i+1)
      {
        val (pf, fpf | p) = $UN.ptr0_vtake (p_ij)
        val () = gmatrix_iforeach$fwork<a><env> (i, j, !p, env)
        prval () = fpf (pf)
        val () = p_ij := ptr_succ<a> (p)
      }
      val () = p_j := ptr_add<a> (p_j, ld)
    } 
  end // end of [MORDcol]
//
end // end of [gmatrix_iforeach_env]

(* ****** ****** *)

implement{a}
gmatrix_imake$fopr (i, j, x) = x

implement{a}
gmatrix_imake_arrayptr
  {mo}{m,n}{ld}
  (M, mo, m, n, ld) = let
//
prval (
) = lemma_gmatrix_param (M)
prval () = mul_gte_gte_gte{m,n}()
val (pf, pfgc | p) = array_ptr_alloc<a> (i2sz(m*n))
//
typedef tenv = ptr
//
implement
gmatrix_iforeach$fwork<a><tenv>
  (i, j, x, env) = let
  val x2 = gmatrix_imake$fopr<a> (i, j, x)
  val p_ij = env
  val () = env := ptr_succ<a> (p_ij)
  val () = $UN.ptr0_set<a> (p_ij, x2)
in
  // nothing
end // end of [gmatrix_iforeach$fwork]
//
var env: tenv = p
val () = gmatrix_iforeach_env<a><tenv> (M, mo, m, n, ld, env)
//
in
  $UN.castvwtp0{arrayptr(a,m*n)}((pf, pfgc | p))
end // end of [gmatrix_imake_arrayptr]

implement{a}
gmatrix_imake_matrixptr
  {mo}{m,n}{ld}
  (M, mo, m, n, ld) = let
//
prval (
) = lemma_gmatrix_param (M)
val (pf, pfgc | p) = matrix_ptr_alloc<a> (i2sz(m), i2sz(n))
prval () = matrix2gmatrow (!p)
//
implement(env)
gmatrix_iforeach$fwork<a><env>
  (i, j, x, env) = let
  val x2 = gmatrix_imake$fopr<a> (i, j, x)
  val p_ij = ptr_add<a> (p, i*n+j)
  val () = $UN.ptr0_set<a> (p_ij, x2)
in
  // nothing
end // end of [gmatrix_iforeach$fwork]
//
val () = gmatrix_iforeach<a> (M, mo, m, n, ld)
//
prval () = gmatrow2matrix (!p)
//
in
  $UN.castvwtp0{matrixptr(a,m,n)}((pf, pfgc | p))
end // end of [gmatrix_imake_matrixptr]

(* ****** ****** *)

(* end of [gmatrix.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: August, 2013 *)

(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libats/SATS/linset_avltree.sats"

(* ****** ****** *)
//
#include "./SHARE/linset.hats" // code reuse
#include "./SHARE/linset_node.hats" // code reuse
//
(* ****** ****** *)

stadef mytkind = $extkind"atslib_linset_avltree"

(* ****** ****** *)
//
// HX: maximal height difference of two siblings
//
#define HTDF 1
#define HTDF1 (HTDF+1)
#define HTDF_1 (HTDF-1)
//
(* ****** ****** *)

datavtype avltree
(
  a:t@ype+, int(*height*)
) =
  | {hl,hr:nat |
     hl <= hr+HTDF;
     hr <= hl+HTDF}
    B (a, 1+max(hl,hr)) of
      (int (1+max(hl,hr)), a, avltree (a, hl), avltree (a, hr))
  | E (a, 0) of ((*void*))
// end of [avltree]

vtypedef
avltree_inc (a:t0p, h:int) =
  [h1:nat | h <= h1; h1 <= h+1] avltree (a, h1)
// end of [avltree_inc]

vtypedef
avltree_dec (a:t0p, h:int) =
  [h1:nat | h1 <= h; h <= h1+1] avltree (a, h1)
// end of [avltree_dec]

(* ****** ****** *)

assume
set_vtype (a:t@ype) = [h:nat] avltree (a, h)

(* ****** ****** *)

implement{} linset_nil () = E ()
implement{} linset_make_nil () = E ()

(* ****** ****** *)

implement{a}
linset_sing (x) = B{a}(1, x, E, E)
implement{a}
linset_make_sing (x) = B{a}(1, x, E, E)

(* ****** ****** *)

implement
{a}(*tmp*)
linset_size
  (xs) = aux (xs) where
{
//
fun aux
  {h:nat} .<h>.
  (t: !avltree (a, h)):<> size_t =
(
  case+ t of
  | B (h, x, tl, tr) => succ(aux (tl) + aux (tr))
  | E ((*void*)) => i2sz(0)
) (* end of [aux] *)
//
} // end of [linset_size]

(* ****** ****** *)

implement{}
linset_is_nil (xs) =
(
  case+ xs of B _ => false | E () => true
)
implement{}
linset_isnot_nil (xs) =
(
  case+ xs of B _ => true | E () => false
)

(* ****** ****** *)

implement{a}
linset_is_member
  (xs, x0) = aux (xs) where
{
//
fun aux {h:nat} .<h>.
  (t: !avltree (a, h)):<> bool = let
in
//
case+ t of
| B (h, x, tl, tr) => let
    val sgn = compare_elt_elt<a> (x0, x)
  in
    if sgn < 0
      then aux (tl)
      else (if sgn > 0 then aux (tr) else true)
    // end of [if]
  end // end of [B]
| E ((*void*)) => false
//
end // end of [aux]
//
} // end of [linset_is_member]

(* ****** ****** *)

implement{a}
linset_copy (xs) = let
//
fun copy
  {h:nat} .<h>.
  (t: !avltree (a, h)):<!wrt> avltree (a, h) =
(
case+ t of
| B (h, x, tl, tr) => B{a}(h, x, copy (tl), copy (tr)) | E () => E ()
) // end of [copy]
in
  copy (xs)
end // end of [linset_copy]

(* ****** ****** *)

implement{a}
linset_free (xs) = let
//
fun free
  {h:nat} .<h>.
  (t: avltree (a, h)):<!wrt> void =
(
case+ t of
| ~B (h, x, tl, tr) => (free (tl); free (tr)) | ~E () => ()
) // end of [free]
in
  free (xs)
end // end of [linset_free]

(* ****** ****** *)

macdef
avlht (t) =
(
case+ ,(t) of B (h, _, _, _) => h | E ((*void*)) => 0
) // end of [avlht]

(* ****** ****** *)

fn{a:t0p}
avltree_height{h:int}(t: !avltree (a, h)):<> int (h) = avlht(t)

(* ****** ****** *)

(*
** left rotation for restoring height invariant
*)
fn{a:t0p}
avltree_lrotate
  {hl,hr:nat | hl+HTDF1 == hr}
  {l,l_h,l_x,l_tl,l_tr:addr}
(
  pf_h: (int?)@l_h, pf_x: a@l_x
, pf_tl: avltree (a, hl) @ l_tl
, pf_tr: avltree (a, hr) @ l_tr
| p_h: ptr l_h
, hl: int hl, p_tl: ptr l_tl
, hr: int hr, p_tr: ptr l_tr
, t0: B_unfold (l, l_h, l_x, l_tl, l_tr)
) :<!wrt> avltree_inc (a, hr) = let
  val tr = !p_tr
  val+@B{..}{hrl,hrr}
    (hr2, _, trl, trr) = tr
  val hrl = avlht(trl): int(hrl)
  and hrr = avlht(trr): int(hrr)
in
  if hrl <= hrr+HTDF_1 then let
    val hrl1 = hrl + 1
    val () = !p_h := hrl1
    val () = !p_tr := trl
    prval () = fold@ (t0)
    val () = hr2 := 1+max(hrl1, hrr)
    val () = trl := t0
    prval () = fold@ (tr)
  in
    tr // B (1+max(hrl1,hrr), xr, B (hrl1, x, tl, trl), trr)
  end else let // [hrl==hrr+HTDF1]: deep rotation
    val trl_ = trl
    val+@B{..}{hrll,hrlr}
      (hrl, _, trll, trlr) = trl_
    val hrll = avlht (trll) : int(hrll)
    and hrlr = avlht (trlr) : int(hrlr)
    val () = !p_h := 1+max(hl,hrll)
    val () = !p_tr := trll
    prval () = fold@ (t0)
    val () = hr2 := 1+max(hrlr, hrr)
    val () = trl := trlr
    prval () = fold@ (tr)
    val () = hrl := hr
    val () = trll := t0
    val () = trlr := tr
    prval () = fold@ (trl_)
  in
    trl_ // B (hr, xrl, B (1+max(hl,hrll) x, tl, trll), B (1+max(hrlr,hrr), xr, trlr, trr))
  end // end of [if]
end // end of [avltree_lrotate]

(* ****** ****** *)

(*
** right rotation for restoring height invariant
*)
fn{a:t0p}
avltree_rrotate
  {hl,hr:nat | hl == hr+HTDF1}
  {l,l_h,l_x,l_tl,l_tr:addr}
(
  pf_h: (int?)@l_h, pf_x: a@l_x
, pf_tl: avltree (a, hl) @ l_tl
, pf_tr: avltree (a, hr) @ l_tr
| p_h: ptr l_h
, hl : int hl, p_tl: ptr l_tl
, hr : int hr, p_tr: ptr l_tr
, t0: B_unfold (l, l_h, l_x, l_tl, l_tr)
) :<!wrt> avltree_inc (a, hl) = let
  val tl = !p_tl
  val+@B{..}{hll,hlr}
    (hl2, _, tll, tlr) = tl
  val hll = avlht(tll): int(hll)
  and hlr = avlht(tlr): int(hlr)
in
  if hll+HTDF_1 >= hlr then let
    val hlr1 = hlr + 1
    val () = !p_h := hlr1
    val () = !p_tl := tlr
    prval () = fold@ (t0)
    val () = hl2 := 1+max(hll,hlr1)
    val () = tlr := t0
    prval () = fold@ (tl)
  in
    tl // B (1+max(hll,hlr1), xl, tll, B (hlr1, x, tlr, tr))
  end else let
    val tlr_ = tlr
    val+@B{..}{hlrl,hlrr}
      (hlr, _, tlrl, tlrr) = tlr_
    val hlrl = avlht (tlrl): int(hlrl)
    val hlrr = avlht (tlrr): int(hlrr)
    val () = !p_h := 1+max(hlrr,hr)
    val () = !p_tl := tlrr
    prval () = fold@ (t0)
    val () = hl2 := 1+max(hll,hlrl)
    val () = tlr := tlrl
    prval () = fold@ (tl)
    val () = hlr := hl
    val () = tlrl := tl
    val () = tlrr := t0
    prval () = fold@ (tlr_)
  in
    tlr_ // B (hl, xlr, B (1+max(hll,hlrl), xl, tll, tlrl), B (1+max(hlrr,hr), x, tlrr, tr))
  end // end of [if]
end // end of [avltree_rrotate]

(* ****** ****** *)

implement{a}
linset_insert
  (xs, x0) = insert (xs) where
{
//
fun insert
  {h:nat} .<h>.
(
  t0: &avltree (a, h) >> avltree_inc (a, h)
) :<!wrt> bool = let
in
//
case+ t0 of
//
| @B{..}{hl,hr}
    (h, x, tl, tr) => let
    prval pf_h = view@h
    prval pf_x = view@x
    prval pf_tl = view@tl
    prval pf_tr = view@tr
    val sgn = compare_elt_elt<a> (x0, x)
  in
    case+ 0 of
    | _ when sgn < 0 => let
        val ans = insert (tl)
        val hl = avltree_height<a> (tl)
        and hr = avltree_height<a> (tr)
      in
        if hl-hr <= HTDF then let
          val () = h := 1+max(hl,hr)
          prval () = fold@ (t0)
        in
          ans // B (1+max(hl,hr), x, tl, tr)
        end else let // hl==hr+HTDF1
          val p_h = addr@(h)
          val p_tl = addr@(tl)
          val p_tr = addr@(tr)
          val () = t0 := avltree_rrotate<a> (pf_h, pf_x, pf_tl, pf_tr | p_h, hl, p_tl, hr, p_tr, t0)
        in
          ans
        end // end of [if]
      end // end of [sgn < 0]
    | _ when sgn > 0 => let
        val ans = insert (tr)
        val hl = avltree_height<a> (tl)
        and hr = avltree_height<a> (tr)
      in
        if hr-hl <= HTDF then let
          val () = h := 1+max(hl,hr)
          prval () = fold@ (t0)
        in
          ans // B (1+max(hl, hr), x, tl, tr)
        end else let // hl+HTDF1==hr
          val p_h = addr@(h)
          val p_tl = addr@(tl)
          val p_tr = addr@(tr)
          val () = t0 := avltree_lrotate<a> (pf_h, pf_x, pf_tl, pf_tr | p_h, hl, p_tl, hr, p_tr, t0)
        in
          ans
        end // end of [if]
      end // end of [sgn > 0]
    | _ (*[x0] is found*) => let
        prval () = fold@ (t0)
      in
        true // B (h, x0, tl, tr)
      end // end of [sgn = 0]
  end // end of [B]
//
| ~E () => let
    val () = t0 := B{a}(1, x0, E (), E ())
  in
    false
  end // end of [E]
//
end // end of [insert]
//
} // end of [linset_insert]

(* ****** ****** *)

fun{a:t0p}
avltree_maxout
  {h:pos} .<h>.
(
  t0: &avltree (a, h) >> avltree_dec (a, h)
) :<!wrt> mynode1 (a) = let
  val+@B{..}{hl,hr}(h, x, tl, tr) = t0
  prval pf_h = view@h
  prval pf_x = view@x
  prval pf_tl = view@tl
  prval pf_tr = view@tr
in
  case+ tr of
  | B _ => let
      val nx = avltree_maxout<a> (tr)
      val hl = avltree_height<a> (tl)
      and hr = avltree_height<a> (tr)
    in
      if hl-hr <= HTDF then let
        val () = h := 1+max(hl,hr)
        prval () = fold@ (t0) // B (1+max(hl,hr), x, tl, tr)
      in
        nx
      end else let
        val p_h = addr@h
        val p_tl = addr@tl
        val p_tr = addr@tr
        val () = t0 := avltree_rrotate<a> (pf_h, pf_x, pf_tl, pf_tr | p_h, hl, p_tl, hr, p_tr, t0)
      in
        nx
      end // end of [if]
    end // end of [B]
  | ~E () => let
      val t0_ = t0
      val () = t0 := tl
    in
      $UN.castvwtp0{mynode1(a)}((pf_h, pf_x, pf_tl, pf_tr | t0_))
    end // end of [E]
end // end of [avltree_maxout]

(* ****** ****** *)

fun{a:t0p}
avltree_minout
  {h:pos} .<h>.
(
  t0: &avltree (a, h) >> avltree_dec (a, h)
) :<!wrt> mynode1 (a) = let
  val+@B{..}{hl,hr}(h, x, tl, tr) = t0
  prval pf_h = view@h
  prval pf_x = view@x
  prval pf_tl = view@tl
  prval pf_tr = view@tr
in
  case+ tl of
  | B _ => let
      val nx = avltree_minout<a> (tl)
      val hl = avltree_height<a> (tl)
      and hr = avltree_height<a> (tr)
    in
      if hr-hl <= HTDF then let
        val () = h := 1+max(hl,hr)
        prval () = fold@ (t0) // B (1+max(hl,hr), x, tl, tr)
      in
        nx
      end else let
        val p_h = addr@h
        val p_tl = addr@tl
        val p_tr = addr@tr
        val () = t0 := avltree_lrotate<a> (pf_h, pf_x, pf_tl, pf_tr | p_h, hl, p_tl, hr, p_tr, t0)
      in
        nx
      end // end of [if]
    end // end of [B]
  | ~E () => let
      val t0_ = t0
      val () = t0 := tr
    in
      $UN.castvwtp0{mynode1(a)}((pf_h, pf_x, pf_tl, pf_tr | t0_))
    end // end of [E]
end // end of [avltree_minout]

(* ****** ****** *)

extern
castfn
mynode_decode
  {a:t0p}{l:agz}
  (nx: mynode(INV(a), l)):<> B_pstruct (int?, a, ptr?, ptr?)
// end of [mynode_decode]

(* ****** ****** *)

fn{a:t0p}
avltree_lrcon
  {hl,hr:nat |
   hl <= hr+HTDF;
   hr <= hl+HTDF}
(
  tl: avltree (a, hl)
, tr: avltree (a, hr)
) :<!wrt> avltree_dec (a, 1+max(hl,hr)) =
(
case+ tr of
| B _ => let
    var tr = tr
    val nx =
      avltree_minout<a> (tr)
    // end of [val]
    val t1 = mynode_decode (nx)
    val+B(h1, x1, tl1, tr1) = t1
    prval pf_h1 = view@h1
    prval pf_x1 = view@x1
    prval pf_tl1 = view@tl1
    prval pf_tr1 = view@tr1
    val hl = avltree_height<a> (tl)
    and hr = avltree_height<a> (tr)
    val () = tl1 := tl and () = tr1 := tr 
  in
    if hl-hr <= HTDF then let
      val () = h1 := 1+max(hl,hr)
      prval () = fold@ (t1)
    in
      t1
    end else let
      val p_h1 = addr@h1
      val p_tl1 = addr@tl1
      val p_tr1 = addr@tr1
    in
      avltree_rrotate<a> (pf_h1, pf_x1, pf_tl1, pf_tr1 | p_h1, hl, p_tl1, hr, p_tr1, t1)
    end // end of [if]
  end // end of [B]
| ~E ((*void*)) => tl
) (* end of [avltree_lrcon] *)

(* ****** ****** *)

implement
{a}(*tmp*)
linset_takeout_ngc
  (xs, x0) = let
//
fun takeout{h:nat} .<h>.
(
  t0: &avltree (a, h) >> avltree_dec (a, h)
) :<!wrt> mynode0(a) = let
//
in
//
case+ t0 of
| @B{..}{hl,hr}
    (h, x, tl, tr) => let
    prval pf_h = view@h
    prval pf_x = view@x
    prval pf_tl = view@tl
    prval pf_tr = view@tr
    val sgn = compare_elt_elt<a> (x0, x)
  in
    case+ 0 of
    | _ when sgn < 0 => let
        val nx = takeout (tl)
        val hl = avltree_height<a> (tl)
        and hr = avltree_height<a> (tr)
      in
        if hr-hl <= HTDF then let
          val () = h := 1+max(hl,hr)
          prval () = fold@ (t0)
        in
          nx
        end else let
          val p_h = addr@(h)
          val p_tl = addr@(tl)
          val p_tr = addr@(tr)
          val () = t0 := avltree_lrotate<a> (pf_h, pf_x, pf_tl, pf_tr | p_h, hl, p_tl, hr, p_tr, t0)
        in
          nx
        end // end of [if]
      end // end of [sgn < 0]
    | _ when sgn > 0 => let
        val nx = takeout (tr)
        val hl = avltree_height<a> (tl)
        and hr = avltree_height<a> (tr)
      in
        if hl-hr <= HTDF then let
          val () = h := 1+max(hl,hr)
          prval () = fold@ (t0)
        in
          nx
        end else let
          val p_h = addr@(h)
          val p_tl = addr@(tl)
          val p_tr = addr@(tr)
          val () = t0 := avltree_rrotate<a> (pf_h, pf_x, pf_tl, pf_tr | p_h, hl, p_tl, hr, p_tr, t0)
        in
          nx
        end // end of [if]
      end // end of [sgn > 0]
    | _ (*[x0] is found*) => let
        val t0_ = t0
        val () = t0 := avltree_lrcon<a> (tl, tr)
      in
        $UN.castvwtp0{mynode1(a)}((pf_h, pf_x, pf_tl, pf_tr | t0_))
      end // end of [sgn = 0]
    // end of [case]
  end // end of [B]
| E ((*void*)) => mynode_null ()
//
end // end of [takeout]
//
in
  takeout (xs)
end // end of [linset_takeout_ngc]

(* ****** ****** *)

implement
{a}{env}
linset_foreach_env
  (xs, env) = let
//
val p_env = addr@env
//
fun foreach
  {h:nat} .<h>.
(
  t0: !avltree (a, h), p_env: ptr
) : void = let
in
//
case+ t0 of
| B (h, x, tl, tr) => let
//
    val () = foreach (tl, p_env)
//
    val (
      pf, fpf | p_env
    ) = $UN.ptr_vtake{env}(p_env)
    val () = linset_foreach$fwork<a><env> (x, !p_env)
    prval () = fpf (pf)
//
    val () = foreach (tr, p_env)
//
  in
    // nothing
  end // end of [B]
| E ((*void*)) => ()
//
end // end of [foreach]
//
in
  foreach (xs, p_env)
end // end of [linset_foreach_env]

(* ****** ****** *)

implement
{a}(*tmp*)
linset_listize
  (xs) = let
//
fun aux
  {h:nat} .<h>.
(
  t: avltree (a, h), res: List0_vt(a)
) :<> List0_vt(a) = let
in
//
case+ t of
| ~B (_, x, tl, tr) => let
    val res = aux (tr, res)
    val res = list_vt_cons{a}(x, res)
    val res = aux (tl, res)
  in
    res
  end // end of [B]
| ~E ((*void*)) => res
//
end // end of [aux]
//
in
  aux (xs, list_vt_nil)
end // end of [linset_listize]

(* ****** ****** *)

implement{a}
linset_avltree_height (xs) = avlht (xs)

(* ****** ****** *)
//
// HX: functions for handling mynodes
//
(* ****** ****** *)

implement{
} mynode_null{a} () =
  $UN.castvwtp0{mynode(a,null)}(the_null_ptr)
// end of [mynode_null]

(* ****** ****** *)

implement{
} mynode_free{a} (nx) =
{
//
val+~B(_, _, tl, tr) = $UN.castvwtp0{avltree(a,1)}(nx)
//
prval ((*void*)) = $UN.cast2void (tl)
prval ((*void*)) = $UN.cast2void (tr)
//
} (* end of [mynode_free] *)

(* ****** ****** *)

implement
{a}(*tmp*)
mynode_getfree_elt (nx) = x where
{
//
val+~B(_, x, tl, tr) = $UN.castvwtp0{avltree(a,1)}(nx)
//
prval ((*void*)) = $UN.cast2void (tl)
prval ((*void*)) = $UN.cast2void (tr)
//
} (* end of [mynode_getfree_elt] *)

(* ****** ****** *)

implement
{a}(*tmp*)
linset_takeoutmax_ngc
  (xs) = let
in
//
case+ xs of
| B _ => avltree_maxout<a> (xs)
| E _ => mynode_null{a}((*void*))
//
end // end of [linset_takeoutmax]

(* ****** ****** *)

implement
{a}(*tmp*)
linset_takeoutmin_ngc
  (xs) = let
in
//
case+ xs of
| B _ => avltree_minout<a> (xs)
| E _ => mynode_null{a}((*void*))
//
end // end of [linset_takeoutmin]

(* ****** ****** *)

(* end of [linset_avltree.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2013 *)

(* ****** ****** *)
//
// HX-2013-08:
// a set is represented as a sorted list in descending order;
// note that descending order is chosen to faciliate set comparison
//
(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libats/SATS/linset_listord.sats"

(* ****** ****** *)

#include "./SHARE/linset.hats" // code reuse
#include "./SHARE/linset_node.hats" // code reuse

(* ****** ****** *)

assume
set_vtype (elt:t@ype) = List0_vt (elt)

(* ****** ****** *)

implement{}
linset_nil () = list_vt_nil ()
implement{}
linset_make_nil () = list_vt_nil ()

(* ****** ****** *)

implement
{a}(*tmp*)
linset_sing
  (x) = list_vt_cons{a}(x, list_vt_nil)
// end of [linset_sing]
implement{a}
linset_make_sing
  (x) = list_vt_cons{a}(x, list_vt_nil)
// end of [linset_make_sing]

(* ****** ****** *)

implement{}
linset_is_nil (xs) = list_vt_is_nil (xs)
implement{}
linset_isnot_nil (xs) = list_vt_is_cons (xs)

(* ****** ****** *)

implement{a}
linset_size (xs) =
  let val n = list_vt_length(xs) in i2sz(n) end
// end of [linset_size]

(* ****** ****** *)

implement{a}
linset_is_member
  (xs, x0) = let
//
fun aux
  {n:nat} .<n>.
(
  xs: !list_vt (a, n)
) :<> bool = let
in
//
case+ xs of
| list_vt_cons (x, xs) => let
    val sgn = compare_elt_elt<a> (x0, x) in
    if sgn > 0 then false else (if sgn < 0 then aux (xs) else true)
  end // end of [list_vt_cons]
| list_vt_nil ((*void*)) => false
//
end // end of [aux]
//
in
  aux (xs)
end // end of [linset_is_member]

(* ****** ****** *)

implement{a}
linset_copy (xs) = list_vt_copy<a> (xs)
implement{a}
linset_free (xs) = list_vt_free<a> (xs)

(* ****** ****** *)

implement{a}
linset_insert
  (xs, x0) = let
//
fun
mynode_cons
  {n:nat} .<>.
(
  nx: mynode1 (a), xs: list_vt (a, n)
) : list_vt (a, n+1) = let
//
val xs1 =
$UN.castvwtp0{List1_vt(a)}(nx)
val+@list_vt_cons (_, xs2) = xs1
prval () = $UN.cast2void (xs2); val () = (xs2 := xs)
//
in
  fold@ (xs1); xs1
end // end of [mynode_cons]
//
fun ins
  {n:nat} .<n>. // tail-recursive
(
  xs: &list_vt (a, n) >> list_vt (a, n1)
) : #[n1:nat | n <= n1; n1 <= n+1] bool =
(
case+ xs of
| @list_vt_cons
    (x, xs1) => let
    val sgn =
      compare_elt_elt<a> (x0, x)
    // end of [val]
  in
    if sgn > 0 then let
      prval () = fold@ (xs)
      val nx = mynode_make_elt<a> (x0)
      val ((*void*)) = xs := mynode_cons (nx, xs)
    in
      false
    end else if sgn < 0 then let
      val ans = ins (xs1)
      prval () = fold@ (xs)
    in
      ans
    end else let // [x0] is found
      prval () = fold@ (xs)
    in
      true (* [x0] in [xs] *)
    end (* end of [if] *)
  end // end of [list_vt_cons]
| list_vt_nil () => let
    val nx = mynode_make_elt<a> (x0)
    val ((*void*)) = xs := mynode_cons (nx, xs)
  in
    false
  end // end of [list_vt_nil]
) (* end of [ins] *)
//
in
  $effmask_all (ins (xs))
end // end of [linset_insert]

(* ****** ****** *)

(*
//
HX-2013-08:
[linset_remove] moved up
//
implement{a}
linset_remove
  (xs, x0) = let
//
fun rem
  {n:nat} .<n>. // tail-recursive
(
  xs: &list_vt (a, n) >> list_vt (a, n1)
) : #[n1:nat | n1 <= n; n <= n1+1] bool =
(
case+ xs of
| @list_vt_cons
    (x, xs1) => let
    val sgn =
      compare_elt_elt<a> (x0, x)
    // end of [val]
  in
    if sgn > 0 then let
      prval () = fold@ (xs)
    in
      false
    end else if sgn < 0 then let
      val ans = rem (xs1)
      prval () = fold@ (xs)
    in
      ans
    end else let // x0 = x
      val xs1_ = xs1
      val ((*void*)) = free@{a}{0}(xs)
      val () = xs := xs1_
    in
      true // [x0] in [xs]
    end (* end of [if] *)
  end // end of [list_vt_cons]
| list_vt_nil () => false
) (* end of [rem] *)
//
in
  $effmask_all (rem (xs))
end // end of [linset_remove]
*)

(* ****** ****** *)
(*
** By Brandon Barker
*)
implement
{a}(*tmp*)
linset_choose
  (xs, x0) = let
in
//
case+ xs of
| list_vt_cons
    (x, xs1) => let
    val () = x0 := x
    prval () = opt_some{a}(x0)
  in
    true
  end // end of [list_vt_cons]
| list_vt_nil () => let
    prval () = opt_none{a}(x0)
  in
    false
  end // end of [list_vt_nil]
//
end // end of [linset_choose]

(* ****** ****** *)

implement
{a}{env}
linset_foreach_env (xs, env) = let
//
implement
list_vt_foreach$fwork<a><env>
  (x, env) = linset_foreach$fwork<a><env> (x, env)
//
in
  list_vt_foreach_env<a><env> (xs, env)
end // end of [linset_foreach_env]

(* ****** ****** *)

implement{a}
linset_listize (xs) = xs

(* ****** ****** *)

implement{a}
linset_listize1 (xs) = list_vt_copy (xs)

(* ****** ****** *)
//
// HX: functions for processing mynodes
//
(* ****** ****** *)

implement{
} mynode_null{a} () =
  $UN.castvwtp0{mynode(a,null)}(the_null_ptr)
// end of [mynode_null]

(* ****** ****** *)

implement
{a}(*tmp*)
mynode_make_elt
  (x) = let
//
val nx = list_vt_cons{a}{0}(x, _ )
//
in
  $UN.castvwtp0{mynode1(a)}(nx)
end // end of [mynode_make_elt]

(* ****** ****** *)

implement{
} mynode_free
  {a}(nx) = () where {
val nx =
  $UN.castvwtp0{List1_vt(a)}(nx)
//
val+~list_vt_cons (_, nx2) = nx
//
prval ((*void*)) = $UN.cast2void (nx2)
//
} (* end of [mynode_free] *)

(* ****** ****** *)

implement
{a}(*tmp*)
mynode_get_elt
  (nx) = (x) where {
//
val nx1 =
  $UN.castvwtp1{List1_vt(a)}(nx)
//
val+list_vt_cons (x, _) = nx1
//
prval ((*void*)) = $UN.cast2void (nx1)
//
} (* end of [mynode_get_elt] *)

(* ****** ****** *)

implement
{a}(*tmp*)
mynode_set_elt
  {l} (nx, x0) =
{
//
val nx1 =
  $UN.castvwtp1{List1_vt(a)}(nx)
//
val+@list_vt_cons (x, _) = nx1
//
val () = x := x0
//
prval () = fold@ (nx1)
prval () = $UN.cast2void (nx1)
//
prval () = __assert (nx) where
{
  extern praxi __assert (nx: !mynode(a?, l) >> mynode (a, l)): void
} (* end of [prval] *)
//
} (* end of [mynode_set_elt] *)

(* ****** ****** *)

implement
{a}(*tmp*)
mynode_getfree_elt
  (nx) = (x) where {
//
val nx =
  $UN.castvwtp0{List1_vt(a)}(nx)
//
val+~list_vt_cons (x, nx2) = nx
//
prval ((*void*)) = $UN.cast2void (nx2)
//
} (* end of [mynode_getfree_elt] *)

(* ****** ****** *)

(*
fun{a:t0p}
linset_takeout_ngc
  (set: &set(INV(a)) >> _, x0: a):<!wrt> mynode0 (a)
// end of [linset_takeout_ngc]
*)
implement
{a}(*tmp*)
linset_takeout_ngc
  (set, x0) = let
//
fun takeout
(
  xs: &List0_vt (a) >> _
) : mynode0(a) = let
in
//
case+ xs of
| @list_vt_cons
    (x, xs1) => let
    prval pf_x = view@x
    prval pf_xs1 = view@xs1
    val sgn =
      compare_elt_elt<a> (x0, x)
    // end of [val]
  in
    if sgn > 0 then let
      prval () = fold@ (xs)
    in
      mynode_null{a}((*void*))
    end else if sgn < 0 then let
      val res = takeout (xs1)
      prval ((*void*)) = fold@ (xs)
    in
      res
    end else let // x0 = x
      val xs1_ = xs1
      val res = $UN.castvwtp0{mynode1(a)}((pf_x, pf_xs1 | xs))
      val () = xs := xs1_
    in
      res // [x0] in [xs]
    end (* end of [if] *)
  end // end of [list_vt_cons]
| list_vt_nil () => mynode_null{a}((*void*))
//
end (* end of [takeout] *)
//
in
  $effmask_all (takeout (set))
end // end of [linset_takeout_ngc]

(* ****** ****** *)

implement
{a}(*tmp*)
linset_takeoutmax_ngc
  (xs) = let
in
//
case+ xs of
| @list_vt_cons
    (x, xs1) => let
    prval pf_x = view@x
    prval pf_xs1 = view@xs1
    val xs_ = xs
    val () = xs := xs1
  in
    $UN.castvwtp0{mynode1(a)}((pf_x, pf_xs1 | xs_))
  end // end of [list_vt_cons]
| @list_vt_nil () => let
    prval () = fold@ (xs)
  in
    mynode_null{a}((*void*))
  end // end of [list_vt_nil]
//
end // end of [linset_takeoutmax_ngc]

(* ****** ****** *)

implement
{a}(*tmp*)
linset_takeoutmin_ngc
  (xs) = let
//
fun unsnoc
  {n:pos} .<n>.
(
  xs: &list_vt (a, n) >> list_vt (a, n-1)
) :<!wrt> mynode1 (a) = let
//
val+@list_vt_cons (x, xs1) = xs
//
prval pf_x = view@x and pf_xs1 = view@xs1
//
in
//
case+ xs1 of
| list_vt_cons _ =>
    let val res = unsnoc(xs1) in fold@xs; res end
  // end of [list_vt_cons]
| list_vt_nil () => let
    val xs_ = xs
    val () = xs := list_vt_nil{a}()
  in
    $UN.castvwtp0{mynode1(a)}((pf_x, pf_xs1 | xs_))
  end // end of [list_vt_nil]
//
end // end of [unsnoc]
//
in
//
case+ xs of
| list_vt_cons _ => unsnoc (xs)
| list_vt_nil () => mynode_null{a}((*void*))
//
end // end of [linset_takeoutmin_ngc]

(* ****** ****** *)

(* end of [linset_listord.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: December, 2012 *)

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.linmap_list"
#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time

(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libats/SATS/linmap_list.sats"

(* ****** ****** *)

#include "./SHARE/linmap.hats" // code reuse
#include "./SHARE/linmap_node.hats" // code reuse

(* ****** ****** *)

stadef
mytkind = $extkind"atslib_linmap_list"

(* ****** ****** *)

assume
map_vtype (k:t0p, i:vt0p) = List0_vt @(k, i)

(* ****** ****** *)

implement{}
linmap_nil () = list_vt_nil ()
implement{}
linmap_make_nil () = list_vt_nil ()

(* ****** ****** *)

implement{}
linmap_is_nil
  (map) = ans where {
  val ans = (
    case+ map of list_vt_nil _ => true | list_vt_cons _ => false
  ) : bool // end of [val]
} // end of [linmap_is_nil]

implement{}
linmap_isnot_nil
  (map) = ans where {
  val ans = (
    case+ map of list_vt_nil _ => false | list_vt_cons _ => true
  ) : bool // end of [val]
} // end of [linmap_isnot_nil]

(* ****** ****** *)

implement
{key,itm}
linmap_size (map) = g1int2uint (list_vt_length (map))

(* ****** ****** *)

implement
{key,itm}
linmap_free (map) = list_vt_free<(key,itm)> (map)

implement
{key,itm}
linmap_freelin (map) = let
//
vtypedef ki = @(key, itm)
fun aux (kxs: List_vt(ki)): void =
(
case+ kxs of
| @list_vt_cons
    (kx, kxs1) => let
    val kxs1 = kxs1
    val () = linmap_freelin$clear<itm> (kx.1)
    val () = free@{ki}{0}(kxs)
  in
    aux (kxs1)
  end // end of [list_vt_cons]
| ~list_vt_nil ((*void*)) => ()
)
//
in
  $effmask_all (aux (map))
end // end of [linmap_freelin]

(* ****** ****** *)

implement
{key,itm}
linmap_insert
  (map, k0, x0, res) = let
//
val nx0 =
  mynode_make_keyitm<key,itm> (k0, x0)
//
val nx1 =
  linmap_insert_ngc<key,itm> (map, nx0)
//
val p1 = mynode2ptr (nx1)
//
in
//
if p1 > 0 then let
  val () =
  res := mynode_getfree_itm (nx1)
  prval () = opt_some{itm}(res)
in
  true
end else let
  prval () = mynode_free_null (nx1)
  prval () = opt_none{itm}(res)
in
  false
end (* end of [if] *)
//
end // end of [linmap_insert]

(* ****** ****** *)

implement
{key,itm}
linmap_insert_any
  (map, k0, x0) = let
//
vtypedef ki = @(key, itm)
val () = map := list_vt_cons{ki}( @(k0, x0), map )
//
in
  // nothing
end // end of [linmap_insert_any]

(* ****** ****** *)

implement
{key,itm}{env}
linmap_foreach_env
  (map, env) = let
//
vtypedef ki = @(key, itm)
//
implement{ki}{env}
list_vt_foreach$cont (kx, env) = true
implement
list_vt_foreach$fwork<ki><env>
  (kx, env) = linmap_foreach$fwork<key,itm><env> (kx.0, kx.1, env)
//
in
  list_vt_foreach_env<ki><env> (map, env)
end // end of [linmap_foreach_env]

(* ****** ****** *)
//
// HX: [map] is just a list
//
implement
{key,itm}
linmap_listize (map) = map

implement
{key,itm}{ki2}
linmap_flistize (map) = let
//
vtypedef ki = @(key, itm) 
implement
list_vt_mapfree$fopr<ki><ki2>
  (kx) = linmap_flistize$fopr<key,itm><ki2> (kx.0, kx.1)
//
in
  list_vt_mapfree<ki><ki2> (map)
end // end of [linmap_flistize]

(* ****** ****** *)

implement
{key,itm}
linmap_listize1 (map) = list_vt_copy<(key,itm)> (map)

(* ****** ****** *)
//
// HX: functions for processing mynodes
//
(* ****** ****** *)

implement{
} mynode_null
  {key,itm} () = let
//
vtypedef
mynode = mynode(key,itm,null)
//
in
  $UN.castvwtp0{mynode}(the_null_ptr)
end // end of [mynode_null]

(* ****** ****** *)

implement
{key,itm}
mynode_make_keyitm
  (k, x) = let
//
vtypedef ki = @(key, itm)
val nx = list_vt_cons{ki}{0}( @(k, x), _ )
//
in
  $UN.castvwtp0{mynode1(key,itm)}(nx)
end // end of [mynode_make_keyitm]

(* ****** ****** *)

implement
{key,itm}
mynode_get_key
  (nx) = k where {
//
vtypedef ki = @(key, itm)
//
val nx2 = $UN.castvwtp1{List1_vt(ki)}(nx)
//
val+@list_vt_cons (kx, _) = nx2
//
val k = kx.0
//
prval () = fold@ (nx2)
prval () = __assert (nx2) where {
  extern praxi __assert : List1_vt(ki) -<prf> void
} // end of [where] // end of [prval]
//
} // end of [mynode_get_key]

implement
{key,itm}
mynode_getref_itm
  (nx) = p_x where {
//
vtypedef ki = @(key, itm)
//
val nx2 = $UN.castvwtp1{List1_vt(ki)}(nx)
//
val+@list_vt_cons (kx, _) = nx2
//
val p_x = addr@ (kx.1)
val p_x = $UN.cast{cPtr1(itm)}(p_x)
//
prval () = fold@ (nx2)
prval () = __assert (nx2) where {
  extern praxi __assert : List1_vt(ki) -<prf> void
} // end of [where] // end of [prval]
//
} // end of [mynode_getref_itm]

(* ****** ****** *)

implement
{key,itm}
mynode_free_keyitm
  (nx, k0, x0) = () where {
//
vtypedef ki = @(key, itm)
//
val nx = $UN.castvwtp0{List1_vt(ki)}(nx)
//
val+~list_vt_cons (kx, nx2) = nx
val () = k0 := kx.0 and () = x0 := kx.1
prval () = __assert (nx2) where {
  extern praxi __assert : List0_vt(ki) -<prf> void
} // end of [where] // end of [prval]
//
} // end of [mynode_free_keyitm]

(* ****** ****** *)

implement
{key,itm}
mynode_getfree_itm
  (nx) = kx.1 where {
//
vtypedef ki = @(key, itm)
//
val nx = $UN.castvwtp0{List1_vt(ki)}(nx)
//
val+~list_vt_cons (kx, nx2) = nx
//
prval ((*void*)) = $UN.cast2void (nx2)
//
} // end of [mynode_getfree_itm]

(* ****** ****** *)

implement
{key,itm}
linmap_search_ngc
  (map, k0) = let
//
vtypedef ki = @(key, itm)
//
fun loop
  {n:nat} .<n>. (
  kxs: !list_vt (ki, n), k0: key
) :<> Ptr0 = let
in
//
case+ kxs of
| @list_vt_cons
    (kx, kxs1) => let
    val iseq = equal_key_key<key> (kx.0, k0)
  in
    if iseq then let
      prval () = fold@ (kxs)
    in
      $UN.castvwtp1{Ptr1} (kxs)
    end else let
      val res = loop (kxs1, k0)
      prval () = fold@ (kxs) in res
    end // end of [if]
  end // end of [list_vt_cons]
| @list_vt_nil () => let
    prval () = fold@ (kxs) in the_null_ptr
  end // end of [list_vt_cons]
//
end // end of [loop]
//
in
  loop (map, k0) // HX: Ptr1
end // end of [linmap_search_ngc]

(* ****** ****** *)

implement
{key,itm}
linmap_insert_ngc
  (map, nx0) = let
//
val k0 = mynode_get_key (nx0)
val nx1 =
  linmap_takeout_ngc<key,itm> (map, k0)
val () =
  linmap_insert_any_ngc<key,itm> (map, nx0)
//
in
  nx1
end // end of [linmap_insert_ngc]

(* ****** ****** *)

implement
{key,itm}
linmap_insert_any_ngc
  (map, nx0) = let
//
vtypedef ki = @(key, itm)
//
val nx0 = $UN.castvwtp0{List1_vt(ki)}(nx0)
//
val+@list_vt_cons (_, kxs) = nx0
prval () = __assert (kxs) where {
  extern praxi __assert : List0_vt(ki) -<prf> void
} // end of [where] // end of [prval]
//
in
  kxs := map; fold@ (nx0); map := nx0
end // end of [linmap_insert_any_ngc]

(* ****** ****** *)

implement
{key,itm}
linmap_takeout_ngc
  (map, k0) = let
//
vtypedef ki = @(key, itm)
vtypedef mynode0 = mynode0 (key, itm)
vtypedef mynode1 = mynode1 (key, itm)
//
fun loop (
  kxs: &List0_vt (ki) >> _, k0: key
) : mynode0 = let
//
vtypedef kis = List0_vt (ki)
//
in
//
case+ kxs of
| @list_vt_cons
    (kx, kxs1) => let
    val iseq =
      equal_key_key<key> (kx.0, k0)
    // end of [val]
  in
    if iseq then let
      val p1 = $UN.castvwtp1{ptr}(kxs1)
      prval () = fold@ (kxs)
      val res = $UN.castvwtp0{mynode1}(kxs)
      val () = kxs := $UN.castvwtp0{kis}(p1)
    in
      res
    end else let
      val res = loop (kxs1, k0)
      prval () = fold@ (kxs) in res
    end // end of [if]
  end // end of [list_vt_cons]
| @list_vt_nil () => let
    prval () = fold@ (kxs) in mynode_null ()
  end // end of [list_vt_cons]
//
end // end of [loop]
//
in
  loop (map, k0) // HX: mynode0
end // end of [linmap_takeout_ngc]

(* ****** ****** *)

(* end of [linmap_list.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (hwxi AT cs DOT bu DOT edu)
// Time: December, 2012
//
(* ****** ****** *)
//
// HX: generic arrays (fully indexed)
//
(* ****** ****** *)
//
// HX-2012-11-30: ported to ATS/Postiats from ATS/Anairiats
//
(* ****** ****** *)
//
// HX:
// for integer sequences
//
staload
"libats/SATS/ilist_prf.sats"
//
(* ****** ****** *)

staload "libats/SATS/gfarray.sats"

(* ****** ****** *)

primplmnt
gfarray_v_sing (pfat) = gfarray_v_cons (pfat, gfarray_v_nil ())

primplmnt
gfarray_v_unsing (pfarr) = let
  prval gfarray_v_cons (pfat, gfarray_v_nil ()) = pfarr in pfat
end // end of [gfarray_v_unsing]

(* ****** ****** *)

(*
prfun
gfarray_v_split
  {a:vt0p}
  {l:addr}
  {xs:ilist}
  {n:int}
  {i:nat | i <= n} (
  pflen: LENGTH (xs, n)
, pfarr: gfarray_v (a, l, xs)
) : [
  xs1,xs2:ilist
] (
  LENGTH (xs1, i)
, APPEND (xs1, xs2, xs)
, gfarray_v (a, l, xs1)
, gfarray_v (a, l+i*sizeof(a), xs2)
) // end of [gfarray_v_split]
*)
primplmnt
gfarray_v_split
  {a}{l}{xs}{n}{i} (pflen, pfarr) = let
//
prfun
split
  {l:addr}
  {xs:ilist}
  {n:int}
  {i:nat | i <= n} .<i>. (
  pflen: LENGTH (xs, n), pfarr: gfarray_v (a, l, xs)
) : [xs1,xs2:ilist] (
  LENGTH (xs1, i)
, APPEND (xs1, xs2, xs)
, gfarray_v (a, l, xs1)
, gfarray_v (a, l+i*sizeof(a), xs2)
) = let
in
//
sif i > 0 then let
  prval LENGTHcons (pflen) = pflen
  prval gfarray_v_cons (pf1at, pf2arr) = pfarr
  prval (pfres_len, pfres_app, pfres1, pfres2) = split {..}{..}{n-1}{i-1} (pflen, pf2arr)
in
  (LENGTHcons (pfres_len), APPENDcons (pfres_app), gfarray_v_cons (pf1at, pfres1), pfres2)
end else let
  prval EQINT () = eqint_make {i,0} ()
in
  (LENGTHnil (), APPENDnil (), gfarray_v_nil (), pfarr)
end // end of [sif]
//
end // end of [split]
//
val [
  xs1:ilist,xs2:ilist
] (
  pf1len, pfapp, pf1arr, pf2arr
) = split {l}{xs}{n}{i} (pflen, pfarr)
prval pf2len = length_istot {xs2} ()
prval pflen2 = lemma_append_length (pfapp, pf1len, pf2len)
prval () = length_isfun (pflen, pflen2)
//
in
  (pf1len, pf2len, pfapp, pf1arr, pf2arr)
end // end of [gfarray_v_split]

(* ****** ****** *)

(*
prfun
gfarray_v_unsplit
  {a:vt0p}
  {l:addr}
  {xs1,xs2:ilist}
  {n1:int} (
  pflen: LENGTH (xs1, n1)
, pfarr1: gfarray_v (a, l, xs1)
, pfarr2: gfarray_v (a, l+n1*sizeof(a), xs2)
) : [xs:ilist] (
  APPEND (xs1, xs2, xs), gfarray_v (a, l, xs)
) // end of [gfarray_v_unsplit]
*)
primplmnt
gfarray_v_unsplit
  {a}{l}{xs1,xs2}{n1}
  (pflen, pfarr1, pfarr2) = let
//
prfun
unsplit
  {l:addr}
  {xs1,xs2:ilist}
  {n1:int} .<xs1>. (
  pflen: LENGTH (xs1, n1)
, pfarr1: gfarray_v (a, l, xs1)
, pfarr2: gfarray_v (a, l+n1*sizeof(a), xs2)
) : [xs:ilist] (
  APPEND (xs1, xs2, xs), gfarray_v (a, l, xs)
) = let
in
//
case+ pflen of
| LENGTHcons
    (pflen) => let
    prval gfarray_v_cons (pf1at, pf2arr1) = pfarr1
    prval (pfres_app, pfres_arr) = unsplit (pflen, pf2arr1, pfarr2)
  in
    (APPENDcons (pfres_app), gfarray_v_cons (pf1at, pfres_arr))
  end // end of [LENGTHcons]
| LENGTHnil () => let
    prval gfarray_v_nil () = pfarr1
  in
    (APPENDnil (), pfarr2)
  end // end of [LENGTHnil]
//
end // end of [unsplit]
//
in
  unsplit (pflen, pfarr1, pfarr2)
end // end of [gfarray_v_unsplit]

(* ****** ****** *)

(*
prfun
gfarray_v_extend
  {a:vt0p}
  {l:addr}
  {xs:ilist}{x:int}{xsx:ilist}
  {n:nat} (
  pflen: LENGTH (xs, n)
, pfsnoc: SNOC (xs, x, xsx)
, pfat: stamped_vt (a, x) @ l+n*sizeof(a)
, pfarr: gfarray_v (a, l, xs)
) : gfarray_v (a, l, xsx)
// end of [gfarray_v_extend]
*)
primplmnt
gfarray_v_extend
  {a}{l}{xs}{x}{xsx}{n} (
  pflen, pfsnoc, pfat, pfarr
) = let
//
stadef xs1 = xs
stadef xs2 = ilist_sing (x)
//
prval pfapp =
  lemma (pfsnoc) where {
  extern praxi lemma : SNOC (xs, x, xsx) -<prf> APPEND (xs1, xs2, xsx)
} // end of [prval]
//
prval pf1arr = pfarr
prval pf2arr = gfarray_v_sing (pfat)
//
prval (pfapp2, pfarr) =
  gfarray_v_unsplit {a}{l}{xs1,xs2}{n} (pflen, pf1arr, pf2arr)
// end of [prval]
//
prval ILISTEQ () = append_isfun (pfapp, pfapp2)
//
in
  pfarr
end // end of [gfarray_v_extend]

(* ****** ****** *)

(*
prfun
gfarray_v_unextend
  {a:vt0p}
  {l:addr}
  {xs:ilist}
  {n:int | n > 0} (
  pflen: LENGTH (xs, n)
, pfarr: gfarray_v (a, l, xs)
) : [xsf:ilist;x:int] ( // xsf: the front
  SNOC (xsf, x, xs), stamped_vt (a, x) @ l+(n-1)*sizeof(a), gfarray_v (a, l, xsf)
) // end of [gfarray_v_unextend]
*)
primplmnt
gfarray_v_unextend
  {a}{l}{xs}{n} (pflen, pfarr) = let
//
prval [
  xs1:ilist,xs2:ilist
] (
  pf1len, pf2len, pfapp, pf1arr, pf2arr
) = gfarray_v_split {a}{l}{xs}{n}{n-1} (pflen, pfarr)
//
prval LENGTHcons (LENGTHnil()) = pf2len
prval pf2at = gfarray_v_unsing (pf2arr)
//
prval pfsnoc =
  lemma (pfapp) where { extern praxi lemma :
    {xs:ilist}{x:int}{xsx:ilist} APPEND (xs, ilist_sing(x), xsx) -<prf> SNOC (xs, x, xsx)
  // end of [extern]
} // end of [prval]
//
in
  (pfsnoc, pf2at, pf1arr)
end // end of [gfarray_v_unextend]

(* ****** ****** *)

local

staload UN = "prelude/SATS/unsafe.sats"

in (* in-of-local *)
//
implement
{a}(*tmp*)
gfarray_get_at
  {l}{x0}{xs}{i0}
  (pf1, pf2 | gp0, i0) =
  $UN.ptr0_get_at<stamped_t(a, x0)>(gp0, i0)
//
implement
{a}(*tmp*)
gfarray_set_at
  {l}{x0}{xs1}{xs2}{i0}
  (pf1, pf2 | gp0, i0, x0) = let
//
prval () =
  pf2 := $UN.castview0(pf2)
//
in
  $UN.ptr0_set_at<stamped_t(a, x0)>(gp0, i0, x0)
end // end of [gfarray_set_at]
//
end // end of [local]

(* ****** ****** *)

(* end of [gfarray.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: May, 2013 *)

(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libats/SATS/dynarray.sats"

(* ****** ****** *)
//
extern
fun memcpy
  : (ptr, ptr, size_t) -<0,!wrt> ptr = "mac#atslib_dynarray_memcpy"
extern
fun memmove
  : (ptr, ptr, size_t) -<0,!wrt> ptr = "mac#atslib_dynarray_memmove"
//
(* ****** ****** *)
//
// HX:
// recapacitizing policy
// 0: manual
// 1: automatic doubling
//
implement
{}(*tmp*)
dynarray$recapacitize () = 1 // default policy
//
(* ****** ****** *)

local

datavtype
dynarray (a:vt@ype+) =
  {m,n:int | m > 0; m >= n}
  DYNARRAY of (arrayptr (a, m), size_t m, size_t n)
// end of [dynarray]

assume
dynarray_vtype (a) = dynarray (a)

in (* in of [local] *)

implement
{a}(*tmp*)
dynarray_make_nil
  (cap) = let
//
val A = arrayptr_make_uninitized<a> (cap)
val A = __cast (A) where
{
  extern castfn __cast {n:int} (arrayptr (a?, n)):<> arrayptr (a, n)
} (* end of [val] *)
//
in
  DYNARRAY (A, cap, g1i2u(0))
end (* end of [dynarray_make_nil] *)

(* ****** ****** *)

implement
{}(*tmp*)
dynarray_getfree_arrayptr
  (DA, n) = let
//
val+
~DYNARRAY{a}{m,n}(A, _, n0) = DA
//
val () = n := n0
prval () = lemma_g1uint_param (n0)
//
in
  $UN.castvwtp0{arrayptr(a,n)}(A)
end (* end of [dynarray_getfree_arrayptr] *)

(* ****** ****** *)

implement
{}(*tmp*)
dynarray_get_array
  (DA, n) = let
//
val+DYNARRAY{a}{m,n}(A, _, n0) = DA
//
val () = n := n0
val p0 = arrayptr2ptr (A)
//
val (pf, fpf | p0) = $UN.ptr_vtake{array(a,n)}(p0)
//
in
  (pf, fpf | p0)
end (* end of [dynarray_get_array] *)

(* ****** ****** *)

implement
{}(*tmp*)
dynarray_get_size (DA) = let
  val+DYNARRAY (_, _, n) = DA in (n)
end // end of [dynarray_get_size]
implement
{}(*tmp*)
dynarray_get_capacity (DA) = let
  val+DYNARRAY (_, m, _) = DA in (m)
end // end of [dynarray_get_capacity]

(* ****** ****** *)

implement
{a}(*tmp*)
dynarray_getref_at
  (DA, i) = let
//
val i = g1ofg0_uint (i)
val+DYNARRAY (A, m, n) = DA
val pi =
(
  if i < n then ptr_add<a> (arrayptr2ptr(A), i) else the_null_ptr
) : ptr // end of [val]
//
in
  $UN.cast{cPtr0(a)}(pi)
end // end of [dynarray_getref_at]

(* ****** ****** *)

implement
{a}(*tmp*)
dynarray_insert_at
  (DA, i, x, res) = let
//
val i = g1ofg0_uint (i)
//
val+@DYNARRAY (A, m, n) = DA
//
in
//
if i <= n then let
//
// HX: [i] is a valid position
//
in
//
if m > n then let
  val p1 =
    ptr_add<a> (arrayptr2ptr(A), i)
  val p2 = ptr_succ<a> (p1)
  val ptr =
    memmove (p2, p1, (n-i)*sizeof<a>)
  val () = $UN.ptr0_set<a> (p1, x)
  val () = n := succ(n)
  prval () = fold@ (DA)
  prval () = opt_none{a}(res)
in
  false
end else let
  val m = m
  prval () = fold@ (DA)
  val recap = dynarray$recapacitize ()
in
  if recap > 0 then let
    val _(*true*) = dynarray_reset_capacity<a> (DA, m+m)
  in
    dynarray_insert_at (DA, i, x, res)
  end else let
    val () = res := x
    prval () = opt_some{a}(res)
  in
    true
  end // end of [if]
end // end of [if]
//
end else let
  prval () = fold@ (DA)
  val () = res := x
  prval () = opt_some{a}(res)
in
  true
end // end of [if]
//
end // end of [dynarray_insert_at]

(* ****** ****** *)

implement
{a}(*tmp*)
dynarray_insert_atbeg_exn
  (DA, x) = let
in
  dynarray_insert_at_exn (DA, i2sz(0), x)
end // end of [dynarray_insert_atbeg_exn]
implement
{a}(*tmp*)
dynarray_insert_atbeg_opt
  (DA, x) = let
in
  dynarray_insert_at_opt (DA, i2sz(0), x)
end // end of [dynarray_insert_atbeg_opt]

(* ****** ****** *)
//
implement
{a}(*tmp*)
dynarray_insert_atend_exn
  (DA, x) = let
//
val+DYNARRAY (_, _, n) = DA
//
in
  dynarray_insert_at_exn (DA, n, x)
end // end of [dynarray_insert_atend_exn]
//
implement
{a}(*tmp*)
dynarray_insert_atend_opt
  (DA, x) = let
//
val+DYNARRAY (_, _, n) = DA
//
in
  dynarray_insert_at_opt (DA, n, x)
end // end of [dynarray_insert_atend_opt]
//
(* ****** ****** *)

implement
{a}(*tmp*)
dynarray_insertseq_at
  (DA, i, xs, n2) = let
//
fun pow2min
(
  s1: sizeGte(1), s2: size_t
) : sizeGte(1) =
(
  if s1 >= s2 then s1 else pow2min (s1+s1, s2)
) (* end of [pow2min] *)
//
val i = g1ofg0_uint (i)
val+@DYNARRAY (A, m, n) = DA
//
in
//
if i <= n then let
//
// HX: [i] is a valid position
//
in
//
if n + n2 <= m then let
  val p1 =
    ptr_add<a> (arrayptr2ptr(A), i)
  val p2 = ptr_add<a> (p1, n2)
  val ptr =
    memmove (p2, p1, (n-i)*sizeof<a>)
  val ptr =
    memcpy (p1, addr@(xs), n2*sizeof<a>)
  val () = n := n+n2
  prval () = fold@ (DA)
  prval () =
  __assert (xs) where {
    extern praxi __assert {n:int} (xs: &array(a, n) >> arrayopt (a, n, false)): void
  } (* end of [prval] *)
in
  false
end else let
  val m = m and n = n
  prval () = fold@ (DA)
  val recap = dynarray$recapacitize ()
in
//
if recap > 0 then let
  val m2 = pow2min (m+m, n+n2)
  val _(*true*) = dynarray_reset_capacity (DA, m2)
in
  dynarray_insertseq_at (DA, i, xs, n2)
end else let
  prval () = arrayopt_some (xs) in true
end (* end of [if] *)
//
end // end of [if]
//
end else let
  prval () = fold@ (DA)
  prval () = arrayopt_some (xs) in true
end // end of [if]
//
end // end of [dynarray_insertseq_at]

(* ****** ****** *)

implement
{a}(*tmp*)
dynarray_takeout_at
  (DA, i, res) = let
//
val i = g1ofg0_uint (i)
val+@DYNARRAY (A, m, n) = DA
//
in
//
if i < n then let
  val p1 = ptr_add<a> (arrayptr2ptr(A), i)
  val p2 = ptr_succ<a> (p1)
  val n1 = pred (n)
  val x = $UN.ptr0_get<a> (p1)
  val ptr = memmove (p1, p2, (n1-i)*sizeof<a>)
  val () = n := n1
  prval () = fold@ (DA)
  val () = res := x
  prval () = opt_some{a}(res)
in
  true
end else let
  prval () = fold@ (DA)
  prval () = opt_none{a}(res)
in
  false
end // end of [if]
//
end // end of [dynarray_takeout_at]

(* ****** ****** *)

implement
{a}(*tmp*)
dynarray_takeout_atbeg_exn
  (DA) = let
in
  dynarray_takeout_at_exn (DA, i2sz(0))
end // end of [dynarray_takeout_atbeg_exn]
//
implement
{a}(*tmp*)
dynarray_takeout_atbeg_opt
  (DA) = let
in
  dynarray_takeout_at_opt (DA, i2sz(0))
end // end of [dynarray_takeout_atbeg_opt]

(* ****** ****** *)

implement
{a}(*tmp*)
dynarray_takeout_atend_exn
  (DA) = let
  val+DYNARRAY (_, _, n) = DA
in
//
if n > 0 then
  dynarray_takeout_at_exn (DA, pred(n))
else let
  var res: a?
  val () = prerr "exit(ATSLIB): [dynarray_takeout_atend_exn] failed."
  val () = exit_void (1)
in
  $UN.castvwtp0{a}(res)
end (* end of [if] *)
//
end // end of [dynarray_takeout_atend_exn]
//
implement
{a}(*tmp*)
dynarray_takeout_atend_opt
  (DA) = let
  val+DYNARRAY (_, _, n) = DA
in
  if n > 0 then dynarray_takeout_at_opt (DA, pred(n)) else None_vt{a}()
end // end of [dynarray_takeout_atend_opt]

(* ****** ****** *)

implement
{a}(*tmp*)
dynarray_removeseq_at
  (DA, st, ln) = let
//
val+DYNARRAY (A, m, n) = DA
//
in
//
if
st < n
then let
//
val ln1 = n - st
val ln2 = min (ln, ln1)
val p0 = ptrcast(A)
val p1 = ptr_add<a> (p0, st)
val p2 = ptr_add<a> (p1, ln2)
//
val p1 =
memmove (p1, p2, (ln1-ln2)*sizeof<a>)
//
val+@DYNARRAY (A, m, n) = DA
val ((*void*)) = n := n - ln2
//
prval () = $UN.castview0{void}(view@A)
prval () = $UN.castview0{void}(view@m)
prval () = $UN.castview0{void}(view@n)
prval () = $UN.castview2void{dynarray(a)}(DA) in ln2
//
end // end of [then]
else i2sz(0) // end of [else]
//
end // end of [dynarray_removeseq_at]

(* ****** ****** *)

implement
{a}(*tmp*)
dynarray_reset_capacity
  (DA, m2) = let
//
val+@DYNARRAY (A, m, n) = DA
//
in
//
if m2 >= n then let
//
val A2 = arrayptr_make_uninitized<a> (m2)
//
val ptr = memcpy
(
  arrayptr2ptr(A2), arrayptr2ptr(A), n*sizeof<a>
) (* end of [val] *)
//
extern castfn __cast {n:int} (arrayptr (a, n)):<> arrayptr (a?, n)
extern castfn __cast2 {n:int} (arrayptr (a?, n)):<> arrayptr (a, n)
//
val A1 = __cast(A)
val A2 = __cast2(A2)
//
val () = arrayptr_free (A1)
//
val () = A := A2
val () = m := m2
prval () = fold@ (DA)
//
in
  true
end else let
//
prval () = fold@ (DA)
//
in
  false
end // end of [if]
//
end // end of [dynarray_reset_capacity]

(* ****** ****** *)
//
implement
{a}(*tmp*)
dynarray_quicksort$cmp
  (x, y) = gcompare_ref_ref<a> (x, y)
//
(* ****** ****** *)

implement
{a}(*tmp*)
dynarray_quicksort(DA) = let
//
val+
DYNARRAY{_a_}{m,n}(A, m, n) = DA
//
val p0 = arrayptr2ptr (A)
//
prval
(
pf, fpf
) = __assert (p0) where
{
extern
praxi __assert
  {l:addr} (p: ptr l): vtakeout0 (array_v (a, l, n))
} (* end of [prval] *)
//
implement
{a}(*tmp*)
array_quicksort$cmp
  (x, y) = dynarray_quicksort$cmp<a> (x, y)
//
val () =
  array_quicksort<a> (!p0, n)
//
prval ((*returned*)) = fpf (pf)
//
in
  // nothing
end // end of [dynarray_quicksort]

(* ****** ****** *)

end // end of [local]

(* ****** ****** *)

implement
{}(*tmp*)
dynarray_free (DA) = let
  var n: size_t
  val A = dynarray_getfree_arrayptr (DA, n)
in
  arrayptr_free (A)
end (* end of [dynarray_free] *)

(* ****** ****** *)

implement
{a}(*tmp*)
fprint_dynarray (out, DA) = let
//
var n: size_t
val
(pf, fpf | p) = dynarray_get_array (DA, n)
//
val ((*void*)) = fprint_array (out, !p, n)
//
prval ((*void*)) = fpf (pf)
//
in
  // nothing
end (* end of [fprint_dynarray] *)

(* ****** ****** *)

implement
{a}(*tmp*)
dynarray_get_at_exn
  (DA, i) = let
//
val pi = dynarray_getref_at (DA, i)
//
in
//
if cptr2ptr(pi) > 0 then $UN.cptr_get (pi) else $raise ArraySubscriptExn()
//
end // end of [dynarray_get_at_exn]

implement
{a}(*tmp*)
dynarray_set_at_exn
  (DA, i, x) = let
//
val pi = dynarray_getref_at (DA, i)
//
in
//
if cptr2ptr(pi) > 0 then $UN.cptr_set (pi, x) else $raise ArraySubscriptExn()
//
end // end of [dynarray_set_at_exn]

(* ****** ****** *)

implement
{a}(*tmp*)
dynarray_insert_at_exn
  (DA, i, x) = let
//
var res: a?
val ans = dynarray_insert_at (DA, i, x, res)
//
in
//
if ans then let
//
prval () = opt_unsome{a}(res)
prval () = $UN.cast2void (res)
//
val () = prerr "exit(ATSLIB): [dynarray_insert_at_exn] failed."
//
in
  exit_void (1)
end else let
//
prval () = opt_unnone{a}(res)
//
in
  // nothing
end // end of [if]
//
end (* end of [dynarray_insert_at_exn] *)

(* ****** ****** *)

implement
{a}(*tmp*)
dynarray_insert_at_opt
  (DA, i, x) = let
//
var res: a?
val ans = dynarray_insert_at (DA, i, x, res)
//
in
//
option_vt_make_opt<a> (ans, res)
//
end (* end of [dynarray_insert_at_opt] *)

(* ****** ****** *)

implement
{a}(*tmp*)
dynarray_takeout_at_exn
  (DA, i) = let
//
var res: a?
val ans = dynarray_takeout_at (DA, i, res)
//
in
//
if ans then let
//
prval () = opt_unsome{a}(res)
//
in
  res
end else let
//
prval () = opt_unnone{a}(res)
//
val (
) = prerr "exit(ATSLIB): [dynarray_takeout_at_exn] failed."
//
val () = exit_void (1)
//
in
  $UN.castvwtp0{a}(res)
end // end of [if]
//
end // end of [dynarray_takeout_at_exn]

(* ****** ****** *)

implement
{a}(*tmp*)
dynarray_takeout_at_opt
  (DA, i) = let
//
var res: a?
val ans = dynarray_takeout_at (DA, i, res)
//
in
//
option_vt_make_opt<a> (ans, res)
//
end // end of [dynarray_takeout_at_opt]

(* ****** ****** *)
  
(* end of [dynarray.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: September, 2015 *)

(* ****** ****** *)

implement
{a}(*tmp*)
compare_elt_elt = gcompare_val_val<a>

(* ****** ****** *)
//
implement
{}(*tmp*)
funmset_isnot_nil
  (xs) = not(funmset_is_nil<> (xs))
//
(* ****** ****** *)

implement
{a}(*tmp*)
funmset_size(xs) = let
//
typedef tenv = size_t
//
implement(a)
funmset_foreach$fwork<a><tenv>
  (n, x, env) = (env := env + i2sz(n))
//
var env: tenv = i2sz(0)
//
in
//
  $effmask_all(funmset_foreach_env<a><tenv> (xs, env)); env
//
end // end of [funmset_size]
//
(* ****** ****** *)
//
implement
{a}(*tmp*)
funmset_isnot_member
  (xs, x0) = not(funmset_is_member<a> (xs, x0))
//
(* ****** ****** *)
//
implement
{a}(*tmp*)
funmset_insert
  (xs, x0) = funmset_insert2<a>(xs, 1, x0)
implement
{a}(*tmp*)
funmset_remove
  (xs, x0) = funmset_remove2<a>(xs, 1, x0)
//
(* ****** ****** *)

implement
{a}(*tmp*)
funmset_foreach
  (nxs) = let
//
var env: void = ()
//
in
  funmset_foreach_env<a><void> (nxs, env)
end // end of [funmset_foreach]

(* ****** ****** *)
//
implement
{}(*tmp*)
fprint_funmset$sep
  (out) = fprint_string (out, ", ")
//
implement
{a}(*tmp*)
fprint_funmset_sep
  (out, xs, sep) = let
//
implement{}
fprint_funmset$sep(out) = fprint_string(out, sep)
//
in
  fprint_funmset<a> (out, xs)
end // end of [fprint_funmset]
//
(* ****** ****** *)

implement
{a}(*tmp*)
fprint_funmset
  (out, xs) = let
//
typedef tenv = int
//
implement
funmset_foreach$fwork<a><tenv>
  (n, x, env) = () where
{
//
  val () =
  if env > 0
    then fprint_funmset$sep(out)
  // end of [if]
  val () = env := env + 1
  val () = fprint_val<a> (out, x)
  val () = fprint! (out, "(", n, ")")
} (* end of [fprint_funmset$fwork] *)
//
var env: tenv = 0
//
in
  funmset_foreach_env<a><tenv> (xs, env)
end // end of [fprint_funmset]

(* ****** ****** *)

(* end of [funmset.hats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: August, 2013 *)

(* ****** ****** *)
//
// HX: shared by hashtbl_chain
// HX: shared by hashtbl_linprb
//
(* ****** ****** *)

(*
implement
{key}(*tmp*)
hash_key = ghash_val_val<key>
*)

(* ****** ****** *)

implement
{key}(*tmp*)
equal_key_key = gequal_val_val<key>

(* ****** ****** *)
//
// HX: 31 and 37 are top choices
//
implement
hash_key<string> (str) =
  string_hash_multiplier (31UL, 61803398875UL, str)
//
(* ****** ****** *)

implement{}
hashtbl$recapacitize () = 1 // HX: default: resizable

(* ****** ****** *)

implement
{key,itm}
hashtbl_search
  (t, k0, res) = let
//
val p = hashtbl_search_ref (t, k0)
//
in
//
if cptr2ptr(p) > 0 then let
  val (pf, fpf | p) = $UN.cptr_vtake (p)
  val () = res := !p
  prval () = fpf (pf)
  prval () = opt_some {itm} (res)
in
  true
end else let
  prval () = opt_none {itm} (res)
in
  false
end // end of [if]
//
end // end of [hashtbl_search]

(* ****** ****** *)

implement
{key,itm}
hashtbl_search_opt
  (tbl, k0) = let
  var res: itm?
  val ans = hashtbl_search (tbl, k0, res)
in
//
if ans then let
  prval () = opt_unsome {itm} (res)
in
  Some_vt {itm} (res)
end else let
  prval () = opt_unnone {itm} (res)
in
  None_vt {itm} ((*void*))
end // end of [if]
//
end // end of [hashtbl_search_opt]

(* ****** ****** *)

implement
{key,itm}
hashtbl_insert_opt
  (tbl, k0, x0) = let
//
var res: itm?
val ans =
  hashtbl_insert (tbl, k0, x0, res)
//
in
//
if ans then let
  prval () = opt_unsome {itm} (res)
in
  Some_vt {itm} (res)
end else let
  prval () = opt_unnone {itm} (res)
in
  None_vt {itm} ((*void*))
end // end of [if]
//
end // end of [hashtbl_insert_opt]

(* ****** ****** *)

implement
{key,itm}
hashtbl_takeout_opt
  (tbl, k0) = let
//
var res: itm?
val ans = hashtbl_takeout (tbl, k0, res)
//
in
//
if ans then let
  prval () = opt_unsome {itm} (res)
in
  Some_vt{itm}(res)
end else let
  prval () = opt_unnone {itm} (res)
in
  None_vt{itm}((*void*))
end // end of [if]
//
end // end of [hashtbl_takeout_opt]

(* ****** ****** *)

implement
{key,itm}
hashtbl_remove
  (tbl, k0) = let
//
var res: itm
val takeout =
  hashtbl_takeout<key,itm> (tbl, k0, res)
prval () = opt_clear (res)
//
in
  takeout(*removed*)
end // end of [hashtbl_remove]

(* ****** ****** *)

implement
{key,itm}
fprint_hashtbl
  (out, tbl) = let
//
implement
hashtbl_foreach$fwork<key,itm><int>
  (k, x, env) = {
  val () = if env > 0 then fprint_hashtbl$sep (out)
  val () = env := env + 1
  val () = fprint_val<key> (out, k)
  val () = fprint_hashtbl$mapto (out)
  val () = fprint_val<itm> (out, x)
} (* end of [hashtbl_foreach$fwork] *)
//
var env: int = 0
//
in
  hashtbl_foreach_env<key,itm><int> (tbl, env)
end // end of [fprint_hashtbl]

(* ****** ****** *)

implement{}
fprint_hashtbl$sep (out) = fprint (out, "; ")
implement{}
fprint_hashtbl$mapto (out) = fprint (out, "->")

(* ****** ****** *)

implement
{key,itm}
hashtbl_foreach
  (tbl) = let
  var env: void = () in
  hashtbl_foreach_env<key,itm><void> (tbl, env)
end // end of [hashtbl_foreach]

(* ****** ****** *)

implement
{key,itm}
hashtbl_listize
  (tbl) = let
//
vtypedef ki2 = @(key, itm)
//
implement
hashtbl_flistize$fopr<key,itm><ki2> (k, x) = @(k, x)
//
in
  hashtbl_flistize<key,itm><ki2> (tbl)
end // end of [hashtbl_listize]

(* ****** ****** *)

local

staload Q = "libats/SATS/qlist.sats"

in (* in of [local] *)

implement
{key,itm}
hashtbl_listize1
  (tbl) = let
//
vtypedef ki = @(key, itm)
vtypedef tenv = $Q.qstruct (ki)
//
implement(env)
hashtbl_foreach$fwork<key,itm><env>
  (k, x, env) = let
//
val (
  pf, fpf | p
) = $UN.ptr_vtake{tenv}(addr@(env))
val () = $Q.qstruct_insert<ki> (env, @(k, x))
prval () = fpf (pf)
//
in
  // nothing
end // end of [hashtbl_foreach$fwork]
//
var env: $Q.qstruct
val () = $Q.qstruct_initize{ki}(env)
val () = $effmask_all (hashtbl_foreach_env<key,itm><tenv> (tbl, env))
val res = $Q.qstruct_takeout_list (env)
prval () = $Q.qstruct_uninitize{ki}(env)
//
prval () = lemma_list_vt_param (res)
//
in
  res
end // end of [hashtbl_listize1]

end // end of [local]

(* ****** ****** *)

(* end of [hashtbl.hats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: December, 2012 *)

(* ****** ****** *)

implement{a}
compare_elt_elt = gcompare_ref_ref<a>

(* ****** ****** *)

implement{a}
linheap_getmin
  (hp0, res) = let
//
val cp = linheap_getmin_ref (hp0)
//
in
//
if isneqz(cp) then let
  val
  (
    pf, fpf | p
  ) = $UN.cptr_vtake{a}(cp)
  val () = res := !p
  prval () = fpf (pf)
  prval () = opt_some{a}(res) in true
end else let
  prval () = opt_none{a}(res) in false
end // end of [if]
//
end // end of [linheap_getmin]

(* ****** ****** *)
  
implement{a}
linheap_getmin_opt
  (hp0) = let
//
var res: a? // unintialized
val ans = linheap_getmin (hp0, res)
(*
val () = println! ("linheap_getmin_opt: ans = ", ans)
*)
in
//
if ans then let
  prval () = opt_unsome{a}(res) in Some_vt{a}(res)
end else let
  prval () = opt_unnone{a}(res) in None_vt{a}((*void*))
end // end of [if]
//
end // end of [linheap_getmin_opt]

(* ****** ****** *)

implement{a}
linheap_delmin_opt
  (hp0) = let
//
var res: a? // unintialized
val ans = linheap_delmin (hp0, res)
//
in
//
if ans then let
  prval () = opt_unsome{a}(res) in Some_vt{a}(res)
end else let
  prval () = opt_unnone{a}(res) in None_vt{a}((*void*))
end // end of [if]
//
end // end of [linheap_delmin_opt]

(* ****** ****** *)

implement
{a}(*tmp*)
linheap_free (hp) = let
//
implement
linheap_freelin$clear<a> (x) = ()
//
in
  linheap_freelin<a> (hp)
end // end of [linheap_free]

(* ****** ****** *)

(* end of [linheap.hats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: December, 2012 *)

(* ****** ****** *)
//
// HX: shared by linmap_list
// HX: shared by linmap_avltree
//
(* ****** ****** *)

implement{key}
equal_key_key = gequal_val_val<key>
implement{key}
compare_key_key = gcompare_val_val<key>

(* ****** ****** *)

implement
{key,itm}
linmap_search_ref
  (map, k0) = let
//
val p0 = linmap_search_ngc (map, k0)
//
viewtypedef mynode1 = mynode1 (key,itm)
//
in
//
if p0 > 0 then let
//
val nx = $UN.castvwtp0{mynode1}{ptr}(p0)
val p_elt = mynode_getref_itm<key,itm> (nx)
val p0 = $UN.castvwtp0{ptr}{mynode1}(nx)
//
in
  p_elt
end else cptr_null () // end of [if]
//
end // end of [linmap_search_ref]

(* ****** ****** *)

implement
{key,itm}
linmap_takeout
  (map, k0, res) = let
//
val nx =
  linmap_takeout_ngc (map, k0)
val p_nx = mynode2ptr (nx)
//
in
//
if p_nx > 0 then let
  val () =
    res := mynode_getfree_itm (nx)
  // end of [val]
  prval () = opt_some{itm}(res) in true
end else let
  prval () = mynode_free_null (nx)
  prval () = opt_none{itm}(res) in false
end // end of [if]
//
end // end of [linmap_takeout]

(* ****** ****** *)

(* end of [linmap_node.hats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: August, 2013 *)

(* ****** ****** *)
//
// HX: shared by linset_listord (* ordered list *)
// HX: shared by linset_avltree (* AVL-tree-based *)
//
(* ****** ****** *)

implement{a}
linset_insert_ngc
  (set, nx0) = let
//
val p = mynode2ptr (nx0)
//
implement{a}
mynode_make_elt (x0) = $UN.castvwtp0{mynode1(a)}(p)
//
val x0 = mynode_get_elt (nx0)
val ans = linset_insert (set, x0)
//
in (* in of [let] *)
//
if ans
then nx0 else let
  prval () = $UN.cast2void(nx0) in mynode_null{a}((*void*))
end // end of [if]
//
end // end of [linset_insert_ngc]

(* ****** ****** *)

implement
{a}(*tmp*)
linset_remove
  (xs, x0) = let
//
val nx =
  linset_takeout_ngc (xs, x0)
val p_nx = mynode2ptr (nx)
//
in
//
if p_nx > 0
  then let
    val () = mynode_free (nx) in true
  end // end of [then]
  else let
    prval () = mynode_free_null (nx) in false
  end // end of [else]
// end of [if]
//
end // end of [linset_remove]

(* ****** ****** *)

implement
{a}(*tmp*)
linset_takeout
  (xs, x0, res) = let
//
val nx =
  linset_takeout_ngc (xs, x0)
val p_nx = mynode2ptr (nx)
//
in
//
if p_nx > 0 then let
  val () =
    res := mynode_getfree_elt (nx)
  // end of [val]
  prval () = opt_some{a}(res) in true
end else let
  prval () = mynode_free_null (nx)
  prval () = opt_none{a}(res) in false
end // end of [if]
//
end // end of [linset_takeout]

(* ****** ****** *)

implement
{a}(*tmp*)
linset_takeoutmax
  (xs, res) = let
//
val nx =
  linset_takeoutmax_ngc (xs)
val p_nx = mynode2ptr (nx)
//
in
//
if p_nx > 0 then let
  val () =
    res := mynode_getfree_elt (nx)
  // end of [val]
  prval () = opt_some{a}(res) in true
end else let
  prval () = mynode_free_null (nx)
  prval () = opt_none{a}(res) in false
end // end of [if]
//
end // end of [linset_takeoutmax]

(* ****** ****** *)

implement
{a}(*tmp*)
linset_takeoutmin
  (xs, res) = let
//
val nx =
  linset_takeoutmin_ngc (xs)
val p_nx = mynode2ptr (nx)
//
in
//
if p_nx > 0 then let
  val () =
    res := mynode_getfree_elt (nx)
  // end of [val]
  prval () = opt_some{a}(res) in true
end else let
  prval () = mynode_free_null (nx)
  prval () = opt_none{a}(res) in false
end // end of [if]
//
end // end of [linset_takeoutmin]

(* ****** ****** *)

(* end of [linset_node.hats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: December, 2012 *)

(* ****** ****** *)
//
// HX: shared by linmap_list
// HX: shared by linmap_avltree
// HX: shared by linmap_randbst
// HX: shared by linmap_skiplist
//
(* ****** ****** *)
//
implement
{key}(*tmp*)
equal_key_key = gequal_val_val<key>
//
implement
{key}(*tmp*)
compare_key_key = gcompare_val_val<key>
//
(* ****** ****** *)

implement
{key,itm}
linmap_search
  (t, k0, res) = let
//
val p = linmap_search_ref (t, k0)
//
in
//
if cptr2ptr(p) > 0 then let
  val (pf, fpf | p) = $UN.cptr_vtake (p)
  val () = res := !p
  prval () = fpf (pf)
  prval () = opt_some{itm}(res)
in
  true
end else let
  prval () = opt_none{itm}(res)
in
  false
end // end of [if]
//
end // end of [linmap_search]

(* ****** ****** *)

implement
{key,itm}
linmap_search_opt
  (map, k0) = let
//
var res: itm?
val ans = linmap_search (map, k0, res)
//
in
//
if ans then let
  prval () = opt_unsome {itm} (res)
in
  Some_vt {itm} (res)
end else let
  prval () = opt_unnone {itm} (res)
in
  None_vt {itm} ((*void*))
end // end of [if]
//
end // end of [linmap_search_opt]

(* ****** ****** *)

implement
{key,itm}
linmap_insert_opt
  (map, k0, x0) = let
//
var res: itm?
val ans = linmap_insert (map, k0, x0, res)
//
in
//
if ans then let
  prval () = opt_unsome {itm} (res)
in
  Some_vt {itm} (res)
end else let
  prval () = opt_unnone {itm} (res)
in
  None_vt {itm} ((*void*))
end // end of [if]
//
end // end of [linmap_insert_opt]

(* ****** ****** *)

implement
{key,itm}
linmap_takeout_opt
  (map, k0) = let
//
var res: itm?
val ans = linmap_takeout (map, k0, res)
//
in
//
if ans then let
  prval () = opt_unsome {itm} (res)
in
  Some_vt{itm}(res)
end else let
  prval () = opt_unnone {itm} (res)
in
  None_vt{itm}((*void*))
end // end of [if]
//
end // end of [linmap_takeout_opt]

(* ****** ****** *)

implement
{key,itm}
linmap_remove
  (map, k0) = let
//
var res: itm
val takeout =
  linmap_takeout<key,itm> (map, k0, res)
prval () = opt_clear (res)
//
in
  takeout(*removed*)
end // end of [linmap_remove]

(* ****** ****** *)

implement
{key,itm}
linmap_free (map) = let
//
implement
linmap_freelin$clear<itm> (x) = ()
//
in
  linmap_freelin<key,itm> (map)
end // end of [linmap_free]

(* ****** ****** *)

implement{}
fprint_linmap$sep (out) = fprint (out, "; ")
implement{}
fprint_linmap$mapto (out) = fprint (out, "->")

implement
{key,itm}
fprint_linmap
  (out, map) = let
//
implement
linmap_foreach$fwork<key,itm><int>
  (k, x, env) = {
  val () = if env > 0 then fprint_linmap$sep (out)
  val () = env := env + 1
  val () = fprint_val<key> (out, k)
  val () = fprint_linmap$mapto (out)
  val () = fprint_val<itm> (out, x)
} (* end of [linmap_foreach$fwork] *)
//
var env: int = 0
//
in
  linmap_foreach_env<key,itm><int> (map, env)
end // end of [fprint_linmap]

(* ****** ****** *)

implement
{key,itm}
linmap_foreach
  (map) = let
  var env: void = () in
  linmap_foreach_env<key,itm><void> (map, env)
end // end of [linmap_foreach]

(* ****** ****** *)

implement
{key,itm}
linmap_listize
  (map) = let
//
vtypedef ki2 = @(key, itm)
//
implement(k2,i2)
linmap_flistize$fopr<k2,i2><ki2> (k, x) =
  ($UN.castvwtp0{key}(k), $UN.castvwtp0{itm}(x))
//
in
  $effmask_all(linmap_flistize<key,itm><ki2> (map))
end // end of [linmap_listize]

(* ****** ****** *)

local
//
staload Q =
"libats/SATS/qlist.sats"
//
in (* in of [local] *)

implement
{key,itm}
linmap_listize1
  (map) = let
//
vtypedef ki = @(key, itm)
vtypedef tenv = $Q.qstruct (ki)
//
implement(env)
linmap_foreach$fwork<key,itm><env>
  (k, x, env) = let
//
val (
  pf, fpf | p
) = $UN.ptr_vtake{tenv}(addr@(env))
val () = $Q.qstruct_insert<ki> (env, @(k, x))
prval () = fpf (pf)
//
in
  // nothing
end // end of [linmap_foreach$fwork]
//
var env: $Q.qstruct
val () = $Q.qstruct_initize{ki}(env)
val () = $effmask_all (linmap_foreach_env<key,itm><tenv> (map, env))
val res = $Q.qstruct_takeout_list (env)
prval () = $Q.qstruct_uninitize{ki}(env)
//
in
  res
end // end of [linmap_listize1]

end // end of [local]

(* ****** ****** *)

(* end of [linmap.hats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: August, 2013 *)

(* ****** ****** *)
//
// HX: shared by linset_listord (* ordered list *)
// HX: shared by linset_avltree (* AVL-tree-based *)
//
(* ****** ****** *)

implement{a}
compare_elt_elt = gcompare_val_val<a>

(* ****** ****** *)

implement{a}
linset_make_list
  (xs) = res where
{
//
fun loop
(
  xs: List (a), res: &set(a) >> _
) : void = 
(
case+ xs of
| list_cons
    (x, xs) => let
    val _(*exi*) =
      linset_insert (res, x) in loop (xs, res)
    // end of [val]
  end // end of [list_cons]
| list_nil () => ()
)
//
var res: set(a) = linset_nil ()
val () = $effmask_all (loop (xs, res))
//
} // end of [linset_make_list]

(* ****** ****** *)

implement{a}
linset_isnot_member (xs, x0) = ~linset_is_member (xs, x0)

(* ****** ****** *)

implement{a}
linset_choose_opt
  (xs) = let
//
var x0: a?
val ans = linset_choose<a> (xs, x0)
//
in
//
if ans then let
  prval () = opt_unsome{a}(x0) in Some_vt{a}(x0)
end else let
  prval () = opt_unnone{a}(x0) in None_vt(*void*)
end (* end of [if] *)
//
end // end of [linset_choose_opt]

(* ****** ****** *)

implement{a}
linset_takeoutmax_opt
  (xs) = let
//
var x0: a?
val ans = linset_takeoutmax<a> (xs, x0)
//
in
//
if ans then let
  prval () = opt_unsome{a}(x0) in Some_vt{a}(x0)
end else let
  prval () = opt_unnone{a}(x0) in None_vt(*void*)
end (* end of [if] *)
//
end // end of [linset_takeoutmax_opt]

(* ****** ****** *)

implement{a}
linset_takeoutmin_opt
  (xs) = let
//
var x0: a?
val ans =
  $effmask_wrt (linset_takeoutmin<a> (xs, x0))
//
in
//
if ans then let
  prval () = opt_unsome{a}(x0) in Some_vt{a}(x0)
end else let
  prval () = opt_unnone{a}(x0) in None_vt(*void*)
end (* end of [if] *)
//
end // end of [linset_takeoutmin_opt]

(* ****** ****** *)

implement{}
fprint_linset$sep
  (out) = fprint_string (out, ", ")
implement
{a}(*tmp*)
fprint_linset
  (out, xs) = let
//
implement
linset_foreach$fwork<a><int>
  (x, env) = {
  val () = if env > 0 then fprint_linset$sep (out)
  val () = env := env + 1
  val () = fprint_val<a> (out, x)
} (* end of [linset_foreach$fwork] *)
//
var env: int = 0
//
in
  linset_foreach_env<a><int> (xs, env)
end // end of [fprint_linset]

(* ****** ****** *)

implement
{a}(*tmp*)
linset_foreach (xs) = let
//
var env: void = () in linset_foreach_env<a><void> (xs, env)
//
end // end of [linset_foreach]

(* ****** ****** *)

(* end of [linset.hats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: May, 2012 *)

(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

implement{a}
funralist_make_list
  (xs) = let
//
fun loop {m,n:nat} .<m>.
(
  xs: list_vt (a, m), res: ralist (a, n)
) : ralist (a, m+n) =
(
  case+ xs of
  | ~list_vt_cons
      (x, xs) => loop (xs, funralist_cons (x, res))
  | ~list_vt_nil ((*void*)) => res
) // end of [loop]
//
prval () = lemma_list_param (xs)
//
in
  loop (list_reverse (xs), funralist_nil ())
end // end of [funralist_make_list]

(* ****** ****** *)

implement{a}
fprint_funralist (out, xs) = let
//
typedef tenv = int
//
implement
funralist_foreach$fwork<a><tenv>
  (x, env) = let
//
val () =
if env > 0 then
  fprint_funralist$sep (out)
// end of [val]
val () = fprint_val<a> (out, x)
val () = env := env + 1
//
in
  // nothing
end // end of [funralist_foreach$fwork]
//
var env: tenv = 0
val () = funralist_foreach_env<a><tenv> (xs, env)
//
in
  // nothing
end // end of [fprint_funralist]

implement{}
fprint_funralist$sep (out) = fprint (out, ", ")

(* ****** ****** *)

local

staload Q = "libats/SATS/qlist.sats"

in (* in of [local] *)

implement{a}
funralist_listize
  {n} (xs) = let
//
viewtypedef tenv = $Q.qstruct (a)
//
implement
funralist_foreach$fwork<a><tenv> (x, env) = $Q.qstruct_insert<a> (env, x)
//
var env: $Q.qstruct
val () = $Q.qstruct_initize {a} (env)
val () = $effmask_all (funralist_foreach_env (xs, env))
val res = $Q.qstruct_takeout_list (env)
val () = $Q.qstruct_uninitize {a} (env)
//
in
  $UN.castvwtp0{list_vt(a,n)}(res)
end // end of [funralist_listize]

end // end of [local]

(* ****** ****** *)

(* end of [funralist.hats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: December, 2012 *)

(* ****** ****** *)

implement
{a}(*tmp*)
compare_elt_elt = gcompare_val_val<a>

(* ****** ****** *)

implement
{}(*tmp*)
funset_isnot_nil (xs) = not(funset_is_nil (xs))

(* ****** ****** *)

implement
{a}(*tmp*)
funset_make_list
  (xs) = set where {
//
typedef set = set (a)
//
fun loop (
  set: &set >> _, xs: List (a)
) : void = let
in
  case+ xs of
  | list_cons (x, xs) => let
      val _(*exi*) = funset_insert<a> (set, x) in loop (set, xs)
    end // end of [list_cons]
  | list_nil () => ()
end // end of [loop]
//
var set: set = funset_make_nil ()
//
val ((*void*)) = $effmask_all (loop (set, xs))
//
} // end of [funset_make_list]

(* ****** ****** *)

implement
{a}(*tmp*)
funset_isnot_member
  (xs, x0) = not (funset_is_member<a> (xs, x0))
// end of [funset_isnot_member]

(* ****** ****** *)

implement
{a}(*tmp*)
funset_getmax_opt
  (xs) = let
//
var x0: a?
val ans =
  $effmask_wrt (funset_getmax<a> (xs, x0))
//
in
//
if ans then let
  prval () = opt_unsome{a}(x0) in Some_vt{a}(x0)
end else let
  prval () = opt_unnone{a}(x0) in None_vt(*void*)
end (* end of [if] *)
//
end // end of [funset_getmax_opt]

(* ****** ****** *)

implement
{a}(*tmp*)
funset_getmin_opt
  (xs) = let
//
var x0: a?
val ans =
  $effmask_wrt (funset_getmin<a> (xs, x0))
//
in
//
if ans then let
  prval () = opt_unsome{a}(x0) in Some_vt{a}(x0)
end else let
  prval () = opt_unnone{a}(x0) in None_vt(*void*)
end (* end of [if] *)
//
end // end of [funset_getmin_opt]

(* ****** ****** *)

implement
{a}(*tmp*)
funset_takeoutmax_opt
  (xs) = let
//
var x0: a?
val ans =
  $effmask_wrt (funset_takeoutmax<a> (xs, x0))
//
in
//
if ans then let
  prval () = opt_unsome{a}(x0) in Some_vt{a}(x0)
end else let
  prval () = opt_unnone{a}(x0) in None_vt(*void*)
end (* end of [if] *)
//
end // end of [funset_takeoutmax_opt]

(* ****** ****** *)

implement
{a}(*tmp*)
funset_takeoutmin_opt
  (xs) = let
//
var x0: a?
val ans =
  $effmask_wrt (funset_takeoutmin<a> (xs, x0))
//
in
//
if ans then let
  prval () = opt_unsome{a}(x0) in Some_vt{a}(x0)
end else let
  prval () = opt_unnone{a}(x0) in None_vt(*void*)
end (* end of [if] *)
//
end // end of [funset_takeoutmin_opt]

(* ****** ****** *)

implement
{a}(*tmp*)
funset_equal
  (xs1, xs2) = let
  val sgn = funset_compare<a> (xs1, xs2) in sgn = 0
end // end of [funset_equal]

(* ****** ****** *)
//
implement
{a}(*tmp*)
funset_is_supset
  (xs1, xs2) = funset_is_subset<a> (xs2, xs1)
//
(* ****** ****** *)

implement
{a}(*tmp*)
funset_foreach (xs) = let
//
var env: void = () in funset_foreach_env<a><void> (xs, env)
//
end // end of [funset_foreach]

(* ****** ****** *)
//
implement
{}(*tmp*)
fprint_funset$sep
  (out) = fprint_string (out, ", ")
//
implement
{a}(*tmp*)
fprint_funset
  (out, xs) = let
//
implement
funset_foreach$fwork<a><int>
  (x, env) = {
  val () =
  if env > 0
    then fprint_funset$sep (out)
  // end of [val]
  val () = env := env + 1
  val () = fprint_val<a> (out, x)
} (* end of [funset_foreach$fwork] *)
//
var env: int = 0
//
in
  funset_foreach_env<a><int> (xs, env)
end // end of [fprint_funset]
//
implement
{a}(*tmp*)
fprint_funset_sep
  (out, xs, sep) = let
//
implement{}
fprint_funset$sep(out) = fprint_string(out, sep)
//
in
  fprint_funset<a> (out, xs)
end // end of [fprint_set]
//
(* ****** ****** *)

implement
{a}(*tmp*)
funset_tabulate
  {n}(n) = res where
{
//
fun
loop
{i:nat | i <= n} .<n-i>.
(
  i: int(i), n: int(n), res: &set(a) >> _
) : void = (
//
if
i < n
then let
//
val x(*a*) = funset_tabulate$fopr<a> (i)
val _(*bool*) = funset_insert<a> (res, x)
//
in
  loop(i+1, n, res)
end // end of [then]
else () // end of [else]
//
) (* end of [loop] *)
//
var
res: set(a) = funset_make_nil ()
//
val ((*void*)) = loop (0, n, res)
//
} (* end of [funset_tabulate] *)

(* ****** ****** *)

implement
{a}(*tmp*)
funset_listize
  (xs) = let
//
implement
funset_flistize$fopr<a><a> (x) = x
//
in
  $effmask_all (funset_flistize (xs))
end // end of [funset_listize]

(* ****** ****** *)

local

staload Q = "libats/SATS/qlist.sats"

in (* in of [local] *)

implement
{a}{b}(*tmp*)
funset_flistize (xs) = let
//
vtypedef tenv = $Q.qstruct (b)
//
implement(env)
funset_foreach$fwork<a><env>
  (x, env) = let
//
val (
  pf, fpf | p
) = $UN.ptr_vtake{tenv}(addr@(env))
val y = funset_flistize$fopr<a><b> (x)
val () = $Q.qstruct_insert<b> (!p, y)
prval () = fpf (pf)
//
in
  // nothing
end (* end of [funset_foreach$fwork] *)
//
var env: $Q.qstruct
val () = $Q.qstruct_initize{b}(env)
val () = funset_foreach_env<a><tenv> (xs, env)
val res = $Q.qstruct_takeout_list (env)
prval () = $Q.qstruct_uninitize{b}(env)
//
prval () = lemma_list_vt_param (res)
//
in
  res
end // end of [funset_flistize]

end // end of [local]

(* ****** ****** *)

(* end of [funset.hats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: May, 2012 *)

(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

implement{a}
fundeque_get_atbeg_opt (xs) =
(
if fundeque_is_cons (xs) then 
  Some_vt{a}(fundeque_get_atbeg<a> (xs))
else None_vt{a}((*void*))
) // end of [fundeque_get_atbeg_opt]

implement{a}
fundeque_get_atend_opt (xs) =
(
if fundeque_is_cons (xs) then 
  Some_vt{a}(fundeque_get_atend<a> (xs))
else None_vt{a}((*void*))
) // end of [fundeque_get_atend_opt]

(* ****** ****** *)

implement{a}
fundeque_takeout_atbeg_opt (xs) =
(
if fundeque_is_cons (xs) then 
  Some_vt{a}(fundeque_uncons<a> (xs))
else None_vt{a}((*void*))
) // end of [fundeque_get_atbeg_opt]

implement{a}
fundeque_takeout_atend_opt (xs) =
(
if fundeque_is_cons (xs) then 
  Some_vt{a}(fundeque_unsnoc<a> (xs))
else None_vt{a}((*void*))
) // end of [fundeque_get_atend_opt]

(* ****** ****** *)

implement{a}
fprint_fundeque (out, xs) = let
//
typedef tenv = int
//
implement
fundeque_foreach$fwork<a><tenv>
  (x, env) = let
//
val () =
if env > 0 then
  fprint_fundeque$sep (out)
// end of [val]
val () = fprint_val<a> (out, x)
val () = env := env + 1
//
in
  // nothing
end // end of [fundeque_foreach$fwork]
//
var env: tenv = 0
val () = fundeque_foreach_env<a><tenv> (xs, env)
//
in
  // nothing
end // end of [fprint_fundeque]

implement{}
fprint_fundeque$sep (out) = fprint (out, ", ")

(* ****** ****** *)

local

staload Q = "libats/SATS/qlist.sats"

in (* in of [local] *)

implement{a}
fundeque_listize
  {n} (xs) = let
//
viewtypedef tenv = $Q.qstruct (a)
//
implement
fundeque_foreach$fwork<a><tenv>
  (x, env) = $Q.qstruct_insert<a> (env, x)
//
var env: $Q.qstruct
val () = $Q.qstruct_initize {a} (env)
val () = $effmask_all (fundeque_foreach_env (xs, env))
val res = $Q.qstruct_takeout_list (env)
val () = $Q.qstruct_uninitize {a} (env)
//
in
  $UN.castvwtp0{list_vt(a,n)}(res)
end // end of [fundeque_listize]

end // end of [local]

(* ****** ****** *)

(* end of [fundeque.hats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: December, 2012 *)

(* ****** ****** *)

implement{key}
equal_key_key = gequal_val_val<key>
implement{key}
compare_key_key = gcompare_val_val<key>

(* ****** ****** *)
//
implement{}
funmap_isnot_nil
  (xs) = not (funmap_is_nil<> (xs))
//
(* ****** ****** *)

implement
{key,itm}
funmap_search_opt
  (map, k0) = let
//
var res: itm?
val ans =
  funmap_search (map, k0, res)
//
in
//
if ans then let
  prval () = opt_unsome{itm}(res)
in
  Some_vt{itm}(res)
end else let
  prval () = opt_unnone{itm}(res)
in
  None_vt{itm}((*void*))
end // end of [if]
//
end // end of [funmap_search_opt]

(* ****** ****** *)

implement
{key,itm}
funmap_insert_opt
  (map, k0, x0) = let
  var res: itm?
  val ans = funmap_insert (map, k0, x0, res)
in
//
if ans then let
  prval () = opt_unsome {itm} (res)
in
  Some_vt{itm}(res)
end else let
  prval () = opt_unnone {itm} (res)
in
  None_vt{itm}((*void*))
end // end of [if]
//
end // end of [funmap_insert_opt]

(* ****** ****** *)

implement
{key,itm}
funmap_takeout_opt
  (map, k0) = let
  var res: itm?
  val ans = funmap_takeout (map, k0, res)
in
//
if ans then let
  prval () = opt_unsome {itm} (res)
in
  Some_vt{itm}(res)
end else let
  prval () = opt_unnone {itm} (res)
in
  None_vt{itm}((*void*))
end // end of [if]
//
end // end of [funmap_takeout_opt]

(* ****** ****** *)

implement
{key,itm}
funmap_remove
  (map, k0) = let
  var res: itm
  val takeout = funmap_takeout<key,itm> (map, k0, res)
  prval () = opt_clear (res)
in
  takeout(*removed*)
end // end of [funmap_remove]

(* ****** ****** *)

implement
{key,itm}
funmap_foreach
  (map) = let
//
var env: void = () in funmap_foreach_env<key,itm><void> (map, env)
//
end // end of [funmap_foreach]

(* ****** ****** *)

implement{}
fprint_funmap$sep (out) = fprint_string (out, "; ")
implement{}
fprint_funmap$mapto (out) = fprint_string (out, "->")

implement
{key,itm}
fprint_funmap
  (out, map) = let
//
implement
funmap_foreach$fwork<key,itm><int>
  (k, x, env) = {
  val () = if env > 0 then fprint_funmap$sep (out)
  val () = env := env + 1
  val () = fprint_val<key> (out, k)
  val () = fprint_funmap$mapto (out)
  val () = fprint_val<itm> (out, x)
} (* end of [funmap_foreach$fwork] *)
//
var env: int = 0
//
in
  funmap_foreach_env<key,itm><int> (map, env)
end // end of [fprint_funmap]

(* ****** ****** *)

implement
{key,itm}
funmap_listize
  (xs) = let
//
typedef ki = @(key, itm)
//
implement
funmap_flistize$fopr<key,itm><ki> (k, x) = @(k, x)
//
in
  $effmask_all (funmap_flistize<key,itm><ki> (xs))
end // end of [funmap_listize]

(* ****** ****** *)

local

staload Q = "libats/SATS/qlist.sats"

in (* in of [local] *)

implement
{key,itm}{ki2}
funmap_flistize
  (map) = let
//
typedef ki = @(key, itm)
//
vtypedef tenv = $Q.qstruct (ki2)
//
implement(env)
funmap_foreach$fwork<key,itm><env>
  (k, x, env) = let
//
val (
  pf, fpf | p
) = $UN.ptr_vtake{tenv}(addr@(env))
//
val ki2 =
  funmap_flistize$fopr<key,itm><ki2> (k, x)
//
val () = $Q.qstruct_insert<ki2> (!p, ki2)
//
prval () = fpf (pf)
//
in
  // nothing
end // end of [funmap_foreach$fwork]
//
var env: $Q.qstruct
val () = $Q.qstruct_initize{ki2}(env)
val () = funmap_foreach_env<key,itm><tenv> (map, env)
val res = $Q.qstruct_takeout_list (env)
prval () = $Q.qstruct_uninitize{ki2}(env)
//
in
  res
end // end of [funmap_flistize]

end // end of [local]

(* ****** ****** *)

(* end of [funmap.hats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: November, 2011 *)

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.linheap_fibonacci"

(* ****** ****** *)

#include "./SHARE/linheap.hats"

(* ****** ****** *)

(* end of [linheap_fibonacci.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
**
** A functional set implementation based on AVL trees
**
** Contributed by Hongwei Xi (hwxi AT cs DOT bu DOT edu)
** Time: May, 2011 // based on a version done in October, 2008
**
*)

(* ****** ****** *)
//
// HX-2012-12: ported to ATS/Postitats from ATS/Anairiats
//
(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.funset_avltree"

(* ****** ****** *)

#include "./SHARE/funset.hats"

(* ****** ****** *)

fun{a:t0p}
funset_avltree_height (xs: set (a)):<> intGte (0)

(* ****** ****** *)

(* end of [funset_avltree.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: May, 2013 *)

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.dynarray"

(* ****** ****** *)

%{#
#include "libats/CATS/dynarray.cats"
%} // end of [%{#]

(* ****** ****** *)
//
// HX: for recapacitizing policy
//
fun{} dynarray$recapacitize ((*void*)): int
//
(* ****** ****** *)

absvtype
dynarray_vtype (a:vt@ype+) = ptr
vtypedef
dynarray (a:vt0p) = dynarray_vtype (a)

(* ****** ****** *)

fun{a:vt0p}
dynarray_make_nil (cap: sizeGte(1)): dynarray(a)

(* ****** ****** *)

fun{}
dynarray_free
  {a:t0p} (DA: dynarray (INV(a))):<!wrt> void
// end of [dynarray_free]

(* ****** ****** *)

fun{a:vt0p}
fprint_dynarray
  (out: FILEref, DA: !dynarray (INV(a))): void
// end of [fprint_dynarray]

(* ****** ****** *)
//
fun{}
dynarray_get_size
  {a:vt0p} (DA: !RD(dynarray (INV(a)))): size_t
fun{}
dynarray_get_capacity
  {a:vt0p} (DA: !RD(dynarray (INV(a)))): size_t
//
(* ****** ****** *)

fun{}
dynarray_get_array{a:vt0p}
(
  DA: !dynarray (INV(a)), n: &size_t? >> size_t(n)
) :<!wrt> #[l:addr;n:int]
(
  array_v (a, l, n), array_v (a, l, n) -<lin,prf> void | ptr l
) // end of [dynarray_get_array]

(* ****** ****** *)

fun{}
dynarray_getfree_arrayptr
  {a:vt0p}
(
  DA: dynarray (INV(a)), n: &size_t? >> size_t(n)
) :<!wrt> #[n:nat] arrayptr (a, n)

(* ****** ****** *)
//
fun{a:t0p}
dynarray_get_at_exn
  (DA: !dynarray(INV(a)), i: size_t):<!exn> a
fun{a:t0p}
dynarray_set_at_exn
  (DA: !dynarray(INV(a)), i: size_t, x: a):<!exnwrt> void
//
overload [] with dynarray_get_at_exn
overload [] with dynarray_set_at_exn
//
(* ****** ****** *)
//
fun{a:vt0p}
dynarray_getref_at
  (DA: !RD(dynarray(INV(a))), i: size_t):<> cPtr0 (a)
//
(* ****** ****** *)

fun{a:vt0p}
dynarray_insert_at
(
  DA: !dynarray (INV(a)), i: size_t, x: a, res: &a? >> opt(a, b)
) : #[b:bool] bool (b) // end of [dynarray_insert_at]

(* ****** ****** *)
//
fun{a:vt0p}
dynarray_insert_at_exn
  (DA: !dynarray (INV(a)), i: size_t, x: a): void
fun{a:vt0p}
dynarray_insert_at_opt
  (DA: !dynarray (INV(a)), i: size_t, x: a): Option_vt(a)
//
(* ****** ****** *)
//
fun{a:vt0p}
dynarray_insert_atbeg_exn (DA: !dynarray (INV(a)), x: a): void
fun{a:vt0p}
dynarray_insert_atbeg_opt (DA: !dynarray (INV(a)), x: a): Option_vt(a)
//
fun{a:vt0p}
dynarray_insert_atend_exn (DA: !dynarray (INV(a)), x: a): void
fun{a:vt0p}
dynarray_insert_atend_opt (DA: !dynarray (INV(a)), x: a): Option_vt(a)
//
(* ****** ****** *)

fun{a:vt0p}
dynarray_insertseq_at
  {n2:int}
(
  DA: !dynarray (INV(a)), i: size_t
, xs: &array(a, n2) >> arrayopt(a, n2, b), n2: size_t (n2)
) : #[b:bool] bool(b) // end-of-fun

(* ****** ****** *)

fun{a:vt0p}
dynarray_takeout_at
(
  DA: !dynarray (INV(a)), i: size_t, res: &a? >> opt(a, b)
) : #[b:bool] bool(b) // end of [dynarray_takeout_at]

(* ****** ****** *)
//
fun{a:vt0p}
dynarray_takeout_at_exn
  (DA: !dynarray (INV(a)), i: size_t): (a)
fun{a:vt0p}
dynarray_takeout_at_opt
  (DA: !dynarray (INV(a)), i: size_t): Option_vt(a)
//
(* ****** ****** *)

fun{a:vt0p}
dynarray_takeout_atbeg_exn (DA: !dynarray (INV(a))): (a)
fun{a:vt0p}
dynarray_takeout_atbeg_opt (DA: !dynarray (INV(a))): Option_vt(a)

(* ****** ****** *)

fun{a:vt0p}
dynarray_takeout_atend_exn (DA: !dynarray (INV(a))): (a)
fun{a:vt0p}
dynarray_takeout_atend_opt (DA: !dynarray (INV(a))): Option_vt(a)

(* ****** ****** *)

fun{a:vt0p}
dynarray_takeoutseq_at
  {n2:int}
(
  DA: !dynarray (INV(a)), i: size_t
, xs: &array(a?, n2) >> arrayopt(a, n2, b), n2: size_t (n2)
) : #[b:bool] bool(b) // end-of-fun

(* ****** ****** *)
//
fun{a:t0p}
dynarray_removeseq_at
  (DA: !dynarray (INV(a)), st: size_t, ln: size_t):<!wrt> size_t
//
(* ****** ****** *)

fun{a:vt0p}
dynarray_reset_capacity
  (DA: !dynarray (INV(a)), m2: sizeGte(1)):<!wrt> bool(*done/ignored*)
// end of [dynarray_reset_capacity]

(* ****** ****** *)

fun{a:vt0p}
dynarray_quicksort$cmp
  (x1: &RD(a), x2: &RD(a)):<> int
fun{a:vt0p}
dynarray_quicksort (DA: !dynarray (INV(a))): void

(* ****** ****** *)

abst@ype
dynarray_struct = $extype"atslib_dynarray_struct"

(* ****** ****** *)

fun{}
dynarray_make2_nil
  {a:vt0p}{l:addr}
(
  pfat: dynarray_struct? @ l | p: ptr l, cap: sizeGte(1)
) : (mfree_ngc_v (l) | dynarray (a))

fun{}
dynarray_getfree2_arrayptr
  {a:vt0p}{l:addr}
(
  pfngc: mfree_ngc_v (l)
| p: ptr l, DA: dynarray (a), n: &size_t? >> size_t(n)
) : #[n:int] (dynarray_struct? @ l | arrayptr (a, n))

(* ****** ****** *)

(* end of [dynarray.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
**
** A hashtable implementation where the buckets
** associated with keys are represented as doubly-linked lists
**
** Contributed by Hongwei Xi (hwxi AT cs DOT bu DOT edu)
** Time: March, 2010 // based on a version done in October, 2008
**
*)

(* ****** ****** *)
//
// HX-2013-01:
//
// ported to ATS/Postitats from ATS/Anairiats
//
(* ****** ****** *)
//
#define
ATS_PACKNAME
"ATSLIB.libats.hashtbl_chain"
//
(* ****** ****** *)

#include "./SHARE/hashtbl.hats"

(* ****** ****** *)

absvtype chain_vtype (key:t@ype, itm:vt@ype+) = ptr

(* ****** ****** *)

vtypedef chain (key:t0p, itm:vt0p) = chain_vtype (key, itm)

(* ****** ****** *)

(* end of [hashtbl_chain.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: hwxiATcsDOTbuDOTedu
// Time: October, 2010
//
(* ****** ****** *)
//
// HX: reasoning about integer sequences
//
(* ****** ****** *)
//
// HX-2012-11-26: ported to ATS/Postiats
//
(* ****** ****** *)

datasort ilist =
  | ilist_nil of () | ilist_cons of (int, ilist)
// end of [ilist]

(* ****** ****** *)

stadef ilist_sing (x:int) = ilist_cons (x, ilist_nil)

(* ****** ****** *)

dataprop ILISTEQ
  (ilist, ilist) = {xs:ilist} ILISTEQ (xs, xs) of ()
// end of [ILISTEQ]

(* ****** ****** *)
//
prfun
ILISTEQ_refl{xs:ilist}(): ILISTEQ(xs, xs)
//
prfun
ILISTEQ_symm
  {xs,ys:ilist}(ILISTEQ(xs, ys)): ILISTEQ(ys, xs)
//
prfun
ILISTEQ_tran
  {xs,ys,zs:ilist}
  (ILISTEQ(xs, ys), ILISTEQ(ys, zs)): ILISTEQ(xs, zs)
//
(* ****** ****** *)

dataprop
ILISTEQ2 (
  ilist, ilist
) =
  | ILISTEQ2nil
    (
      ilist_nil, ilist_nil
    ) of ((*void*))
  | {x:int}
    {xs1,xs2:ilist}
    ILISTEQ2cons
    (
      ilist_cons (x, xs1)
    , ilist_cons (x, xs2)
    ) of (
      ILISTEQ2 (xs1, xs2)
    ) // end of [ILISTEQ2cons]
// end of [ILISTEQ2]

(* ****** ****** *)

prfun
ILISTEQ2_elim
  {xs1,xs2:ilist}
  (pf: ILISTEQ2(xs1, xs2)): ILISTEQ (xs1, xs2)
// end of [ILISTEQ2_elim]

(* ****** ****** *)

dataprop
ISCONS (ilist) =
  {x:int}{xs:ilist} ISCONS (ilist_cons (x, xs))
// end of [ISCONS]

dataprop
ISEMP (ilist, bool) =
  | ISEMPnil (ilist_nil, true)
  | {x:int} {xs:ilist} ISEMPcons (ilist_cons (x, xs), false)
// end of [ISEMP]

(* ****** ****** *)

dataprop
LENGTH (ilist, int) =
  | LENGTHnil(ilist_nil, 0) of ()
  | {x:int}{xs:ilist}{n:nat}
    LENGTHcons(ilist_cons (x, xs), n+1) of LENGTH (xs, n)
// end of [LENGTH]

prfun length_istot {xs:ilist} (): [n:nat] LENGTH (xs, n)
prfun length_isfun {xs:ilist} {n1,n2:int}
  (pf1: LENGTH (xs, n1), pf2: LENGTH (xs, n2)): [n1==n2] void
// end of [length_isfun]

prfun length_isnat
  {xs:ilist} {n:int} (pf: LENGTH (xs, n)): [n>=0] void
// end of [length_isnat]

(* ****** ****** *)

dataprop
SNOC (ilist, int, ilist) =
  | {x:int} SNOCnil (ilist_nil, x, ilist_sing (x)) of ()
  | {x0:int} {xs1:ilist} {x:int} {xs2:ilist}
    SNOCcons (ilist_cons (x0, xs1), x, ilist_cons (x0, xs2)) of SNOC (xs1, x, xs2)
// end of [SNOC]

(* ****** ****** *)

prfun
snoc_istot{xs:ilist}{x:int} (): [xsx:ilist] SNOC (xs, x, xsx)
prfun
snoc_isfun{xs:ilist}{x:int}
  {xsx1,xsx2:ilist} (pf1: SNOC (xs, x, xsx1), pf2: SNOC (xs, x, xsx2)): ILISTEQ (xsx1, xsx2)
// end of [snoc_isfun]

(*
// HX-2012-12-13: proven
*)
prfun
lemma_snoc_length
  {xs:ilist}{x:int}{xsx:ilist}{n:int}
  (pf1: SNOC (xs, x, xsx), pf2: LENGTH (xs, n)): LENGTH (xsx, n+1)
// end of [lemma_snoc_length]

(* ****** ****** *)

dataprop
APPEND (ilist, ilist, ilist) =
  | {ys:ilist} APPENDnil (ilist_nil, ys, ys) of ()
  | {x:int} {xs:ilist} {ys:ilist} {zs:ilist}
    APPENDcons (ilist_cons (x, xs), ys, ilist_cons (x, zs)) of APPEND (xs, ys, zs)
// end of [APPEND]

(* ****** ****** *)
//
prfun
append_istot
  {xs,ys:ilist}(): [zs:ilist] APPEND(xs, ys, zs)
prfun
append_isfun
  {xs,ys:ilist}{zs1,zs2:ilist}
  (pf1: APPEND(xs, ys, zs1), pf2: APPEND(xs, ys, zs2)): ILISTEQ(zs1, zs2)
//
(* ****** ****** *)
(*
// HX-2012-12-13: proven
*)
prfun
append_unit_left
  {xs:ilist}(): APPEND (ilist_nil, xs, xs)
prfun
append_unit_right
  {xs:ilist}(): APPEND (xs, ilist_nil, xs)

(* ****** ****** *)

(*
// HX-2012-12-17: proven
*)
prfun
append_sing
{x:int}{xs:ilist}
(
// argumentless
) : APPEND (ilist_sing(x), xs, ilist_cons (x, xs))
// end of [append_sing]

(* ****** ****** *)
(*
// HX-2012-12-13: proven
*)
prfun
lemma_append_length
  {xs1,xs2:ilist}
  {xs:ilist}
  {n1,n2:int} (
  pf: APPEND (xs1, xs2, xs)
, pf1len: LENGTH (xs1, n1), pf2len: LENGTH (xs2, n2)
) : LENGTH (xs, n1+n2) // end of [lemma_append_length]

(* ****** ****** *)

(*
// HX-2012-12-13: proven
*)
prfun
lemma_append_snoc
  {xs1:ilist}
  {x:int}
  {xs2:ilist}
  {xs1x:ilist}
  {res:ilist}
(
  pf1: APPEND(xs1, ilist_cons(x, xs2), res), pf2: SNOC (xs1, x, xs1x)
) : APPEND (xs1x, xs2, res) // end-of-prfun

(* ****** ****** *)

(*
// HX-2012-12-14: proven
*)
prfun
lemma_append_assoc
  {xs1,xs2,xs3:ilist}
  {xs12,xs23:ilist}
  {xs12_3,xs1_23:ilist}
(
  pf12: APPEND (xs1, xs2, xs12), pf23: APPEND (xs2, xs3, xs23)
, pf12_3: APPEND (xs12, xs3, xs12_3), pf1_23: APPEND (xs1, xs23, xs1_23)
) : ILISTEQ (xs12_3, xs1_23) // end of [lemma_append_assoc]

(* ****** ****** *)

dataprop
REVAPP(ilist, ilist, ilist) =
  | {ys:ilist}
    REVAPPnil (ilist_nil, ys, ys) of ()
  | {x:int}{xs:ilist}{ys:ilist}{zs:ilist}
    REVAPPcons (ilist_cons (x, xs), ys, zs) of REVAPP (xs, ilist_cons (x, ys), zs)
// end of [REVAPP]

propdef REVERSE (xs: ilist, ys: ilist) = REVAPP (xs, ilist_nil, ys)

(* ****** ****** *)
//
prfun
revapp_istot
  {xs,ys:ilist} (): [zs:ilist] REVAPP (xs, ys, zs)
//
prfun
revapp_isfun
  {xs,ys:ilist}{zs1,zs2:ilist}
  (pf1: REVAPP (xs, ys, zs1), pf2: REVAPP (xs, ys, zs2)): ILISTEQ (zs1, zs2)
//
(* ****** ****** *)

prfun
lemma_revapp_length
  {xs,ys,zs:ilist}{m,n:int} (
  pf: REVAPP (xs, ys, zs), pf1len: LENGTH (xs, m), pf2len: LENGTH (ys, n)
) : LENGTH (zs, m+n) // end of [lemma_revapp_length]

(* ****** ****** *)
//
prfun
reverse_istot
  {xs:ilist}(): [ys:ilist] REVERSE(xs, ys)
//
prfun
reverse_isfun
  {xs:ilist}{ys1,ys2:ilist}
  (REVERSE(xs, ys1), REVERSE(xs, ys2)): ILISTEQ(ys1, ys2)
//
(* ****** ****** *)
//
prfun
lemma_reverse_length
  {xs,ys:ilist}{n:int}(REVERSE(xs, ys), LENGTH(xs, n)): LENGTH(ys, n)
//
(* ****** ****** *)

dataprop
NTH (x0:int, ilist, int) =
  | {xs:ilist}
    NTHbas (x0, ilist_cons (x0, xs), 0)
  | {x1:int}{xs:ilist}{n:nat}
    NTHind (x0, ilist_cons (x1, xs), n+1) of NTH (x0, xs, n)
// end of [NTH]
//
// HX: reverse NTH
//
dataprop
RNTH (x0:int, ilist, int) =
  | {xs:ilist}{n:nat}
    RNTHbas (x0, ilist_cons (x0, xs), n) of LENGTH (xs, n)
  | {x1:int}{xs:ilist}{n:nat}
    RNTHind (x0, ilist_cons (x1, xs), n) of RNTH (x0, xs, n)
// end of [RNTH]

(* ****** ****** *)

prfun
lemma_nth_param
  {x0:int}
  {xs:ilist}{i:int}
(
  pf: NTH(x0, xs, i)
) : [y:int;ys:ilist | i >= 0] ILISTEQ(xs, ilist_cons(y, ys))

prfun
lemma_rnth_param
  {x0:int}
  {xs:ilist}{i:int}
(
  pf: RNTH(x0, xs, i)
) : [y:int;ys:ilist | i >= 0] ILISTEQ(xs, ilist_cons(y, ys))

(* ****** ****** *)

prfun
lemma_nth_rnth
  {x:int}{xs:ilist}
  {n:int}{i:int | i < n}
  (pf1: NTH (x, xs, i), pf2: LENGTH (xs, n)): RNTH (x, xs, n-1-i)
// end of [lemma_nth_rnth]

prfun
lemma_rnth_nth
  {x:int}{xs:ilist}
  {n:int}{i:int | i < n}
  (pf1: RNTH (x, xs, i), pf2: LENGTH (xs, n)): NTH (x, xs, n-1-i)
// end of [lemma_rnth_nth]

(* ****** ****** *)

(*
// HX-2012-12-14: proven
*)
prfun
lemma_nth_ilisteq
  {xs1,xs2:ilist}{n:int}
(
  pf1len: LENGTH (xs1, n), pf2len: LENGTH (xs2, n)
, fpf: {x:int}{i:int | i < n} NTH (x, xs1, i) -> NTH (x, xs2, i)
) : ILISTEQ (xs1, xs2) // end of [lemma_nth_ilisteq]

(* ****** ****** *)
//
(*
// HX-2015-08-24: proven
*)
//
prfun
lemma_length_nth
  {xs:ilist}
  {n:int}{i:nat | i < n}
  (pflen: LENGTH(xs, n)): [x:int] NTH(x, xs, i)
//
(* ****** ****** *)

(*
// HX-2012-12-14: proven
*)
prfun
lemma1_revapp_nth
  {xs,ys,zs:ilist}
  {n:int}{x:int}{i:int} (
  REVAPP (xs, ys, zs), LENGTH (xs, n), NTH (x, ys, i)
) : NTH (x, zs, n+i) // end of [lemma1_revapp_nth]

(* ****** ****** *)

(*
// HX-2012-12-14: proven
*)
prfun
lemma2_revapp_nth
  {xs,ys,zs:ilist}
  {n:int}{x:int}{i:int} (
  REVAPP (xs, ys, zs), LENGTH (xs, n), NTH (x, xs, i)
) : NTH (x, zs, n-1-i) // end of [lemma2_revapp_nth]

(* ****** ****** *)

(*
// HX-2012-12-14: proven
*)
prfun
lemma_reverse_nth
  {xs,ys:ilist}
  {n:int}{x:int}{i:int}
(
  pf: REVERSE(xs, ys), pf2: LENGTH(xs, n), pf3: NTH(x, xs, i)
) : NTH (x, ys, n-1-i) // end of [lemma_reverse_nth]
    
(* ****** ****** *)

(*
// HX-2012-12-14: proven
*)
prfun
lemma_reverse_symm{xs,ys:ilist}(REVERSE(xs, ys)): REVERSE(ys, xs)
// end of [lemma_reverse_symm]

(* ****** ****** *)

dataprop
INSERT (
  xi:int, ilist, int, ilist
) = // INSERT (xi, xs, i, ys): insert xi in xs at i = ys
  | {xs:ilist}
    INSERTbas (
      xi, xs, 0, ilist_cons (xi, xs)
    ) of () // end of [INSERTbas]
  | {x:int}{xs:ilist}{i:nat}{ys:ilist}
    INSERTind (
      xi, ilist_cons (x, xs), i+1, ilist_cons (x, ys)
    ) of INSERT (xi, xs, i, ys) // end of [INSERTind]
// end of [INSERT]

(* ****** ****** *)

(*
// HX-2012-12-14: proven
*)
prfun lemma_insert_length
  {xi:int}{xs:ilist}{i:int}{ys:ilist}{n:int}
  (pf1: INSERT (xi, xs, i, ys), pf2: LENGTH (xs, n)): LENGTH (ys, n+1)
// end of [lemma_insert_length]

(* ****** ****** *)

(*
// HX-2012-12-14: proven
*)
prfun
lemma_insert_nth_at
  {xi:int}{xs:ilist}{i:int}{ys:ilist}
  (pf: INSERT (xi, xs, i, ys)): NTH (xi, ys, i)
// end of [lemma_insert_nth_eq]

(*
// HX-2012-12-14: proven
*)
prfun
lemma_insert_nth_lt
  {xi:int}{xs:ilist}{i:int}{ys:ilist}{x:int}{j:int | j < i}
  (pf1: INSERT (xi, xs, i, ys), pf2: NTH (x, xs, j)): NTH (x, ys, j)
// end of [lemma_insert_nth_lt]

(*
// HX-2012-12-14: proven
*)
prfun
lemma_insert_nth_gte
  {xi:int}{xs:ilist}{i:int}{ys:ilist}{x:int}{j:int | j >= i}
  (pf1: INSERT (xi, xs, i, ys), pf2: NTH (x, xs, j)): NTH (x, ys, j+1)
// end of [lemma_insert_nth_lt]

(* ****** ****** *)
(*
// HX-2012-12-14: proven
*)
prfun
lemma_nth_insert
  {x:int}{xs:ilist}{n:int}
  (pf: NTH (x, xs, n)): [ys:ilist] INSERT (x, ys, n, xs)
// end of [lemma_nth_insert]

(* ****** ****** *)
//
// UPDATE (
//   yi, xs, i, ys
// ): ys[i]=yi; xs[k]=ys[k] if k != i
//
dataprop
UPDATE (
  yi: int, ilist, int, ilist
) =
  | {x0:int}{xs:ilist}
    UPDATEbas (
      yi, ilist_cons (x0, xs), 0, ilist_cons (yi, xs)
    ) of () // end of [UPDATEbas]
  | {x:int}{xs:ilist}{i:nat}{ys:ilist}
    UPDATEind (
      yi, ilist_cons (x, xs), i+1, ilist_cons (x, ys)
    ) of UPDATE (yi, xs, i, ys) // end of [UPDATEind]
// end of [UPDATE]

(* ****** ****** *)
//
// INTERCHANGE (xs, i, j, ys) means:
// ys[i]=xs[j]; ys[j]=xs[i]; ys[k]=xs[k] for k != i or j
//
absprop INTERCHANGE (xs:ilist, i:int, j:int, ys:ilist)

(* ****** ****** *)

prfun
lemma_interchange_inv
  {xs:ilist}{i,j:int}{ys:ilist}
  (pf: INTERCHANGE (xs, i, j, ys)): INTERCHANGE (xs, j, i, ys)
// end of [lemma_interchange_inv]

prfun
lemma_interchange_symm
  {xs:ilist}{i,j:int}{ys:ilist}
  (pf: INTERCHANGE (xs, i, j, ys)): INTERCHANGE (ys, i, j, xs)
// end of [lemma_interchange_symm]

(* ****** ****** *)
//
// PERMUTE (xs, ys):
// [ys] is a permutation of [xs]
//
absprop
PERMUTE (xs1:ilist, xs2:ilist)
//
prfun
permute_refl {xs:ilist} (): PERMUTE (xs, xs)
prfun
permute_symm
  {xs1,xs2:ilist} (pf: PERMUTE (xs1, xs2)): PERMUTE (xs2, xs1)
prfun
permute_trans {xs1,xs2,xs3:ilist}
  (pf1: PERMUTE (xs1, xs2), pf2: PERMUTE (xs2, xs3)): PERMUTE (xs1, xs3)
//
(* ****** ****** *)

prfun
lemma_permute_length
  {xs1,xs2:ilist}{n:int}
  (pf1: PERMUTE (xs1, xs2), pf2: LENGTH (xs1, n)): LENGTH (xs2, n)
// end of [lemma_permute_length]

(* ****** ****** *)

prfun
lemma_permute_insert
  {x:int} {xs:ilist} {ys:ilist}
  (pf: PERMUTE (ilist_cons (x, xs), ys)): [ys1:ilist;i:nat] INSERT (x, ys1, i, ys)
// end of [lemma_permute_insert]

(* ****** ****** *)

prfun
lemma_interchange_permute
  {xs:ilist}{i,j:int}{ys:ilist}
  (pf: INTERCHANGE (xs, i, j, ys)): PERMUTE (xs, ys)
// end of [lemma_interchange_permute]

(* ****** ****** *)

absprop LTB
  (x: int, xs: ilist) // [x] is a strict lower bound for [xs]
// end of [LTB]

prfun ltb_istot {xs:ilist} (): [x:int] LTB (x, xs)

prfun ltb_nil {x:int} (): LTB (x, ilist_nil)

prfun ltb_cons
  {x0:int}
  {x:int | x0 < x}
  {xs:ilist}
  (pf: LTB (x0, xs)): LTB (x0, ilist_cons (x, xs))
// end of [ltb_cons]

prfun ltb_cons_elim
  {x0:int}
  {x:int}
  {xs:ilist}
  (pf: LTB (x0, ilist_cons (x, xs))): [x0 < x] LTB (x0, xs)
// end of [ltb_cons_elim]

prfun ltb_dec
  {x1:int}{x2:int | x2 <= x1}{xs:ilist} (pf: LTB (x1, xs)): LTB (x2, xs)
// end of [ltb_dec]

(* ****** ****** *)

absprop LTEB
  (x: int, xs: ilist) // [x] is a lower bound for [xs]
// end of [LTEB]

prfun lteb_istot {xs:ilist} (): [x:int] LTEB (x, xs)

prfun lteb_nil {x:int} (): LTEB (x, ilist_nil)

prfun lteb_cons
  {x0:int}
  {x:int | x0 <= x}
  {xs:ilist}
  (pf: LTEB (x0, xs)): LTEB (x0, ilist_cons (x, xs))
// end of [lteb_cons]

prfun lteb_cons_elim
  {x0:int}
  {x:int}
  {xs:ilist}
  (pf: LTEB (x0, ilist_cons (x, xs))): [x0 <= x] LTEB (x0, xs)
// end of [lteb_cons_elim]

prfun lteb_dec
  {x1:int}{x2:int | x2 <= x1}{xs:ilist} (pf: LTEB (x1, xs)): LTEB (x2, xs)
// end of [lteb_dec]

(* ****** ****** *)

dataprop
ISORD (ilist) =
  | ISORDnil (ilist_nil) of ()
  | {x:int} {xs:ilist}
    ISORDcons (ilist_cons (x, xs)) of (ISORD xs, LTEB (x, xs))
// end of [ISORD]

(* ****** ****** *)

prfun
lemma_ltb_permute {x:int}
  {xs1,xs2:ilist} (pf1: LTB (x, xs1), pf2: PERMUTE (xs1, xs2)): LTB (x, xs2)
// end of [lemma_ltb_permute]

prfun
lemma_lteb_permute {x:int}
  {xs1,xs2:ilist} (pf1: LTEB (x, xs1), pf2: PERMUTE (xs1, xs2)): LTEB (x, xs2)
// end of [lemma_lteb_permute]

(* ****** ****** *)
//
// SORT (xs, ys):
// [ys] is a sorted version of [xs]
//
absprop
SORT (xs: ilist, ys: ilist)
//
prfun
sort_elim {xs,ys:ilist}
  (pf: SORT (xs, ys)): @(ISORD ys, PERMUTE (xs, ys))
prfun
sort_make {xs,ys:ilist}
  (pf1: ISORD ys, pf2: PERMUTE (xs, ys)): SORT (xs, ys)
//
(* ****** ****** *)

(* end of [ilist_prf.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: hwxiATcsDOTbuDOTedu
// Time: October, 2010
//
(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.linset_avltree"

(* ****** ****** *)

#include "./SHARE/linset.hats"
#include "./SHARE/linset_node.hats"

(* ****** ****** *)

fun{a:t0p}
linset_avltree_height (!set(INV(a))):<> intGte (0)

(* ****** ****** *)

(* end of [linset_avltree.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2015 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmmhwxiATgmailDOTcom
// Start Time: September, 2015
//
(* ****** ****** *)
//
(*
// HX-2015-09-28:
// Some templates for getters
*)
//
(* ****** ****** *)
//
#define
ATS_PACKNAME "ATSLIB.libats.theGetters"
//
(* ****** ****** *)
//
exception
Exception_the_get_elt_exn of ((*void*))
//
(* ****** ****** *)
//
fun{}
the_getall_asz_hint((*void*)): sizeGte(1)
//
(* ****** ****** *)
//
fun{a:vt0p}
the_get_elt
(
  x: &a? >> opt(a,b)
) : #[b:bool] bool(b)
//
fun{a:vt0p}
the_getall_list(): List0_vt(a)
fun{a:vt0p}
the_getall_arrayptr
  (asz: &size_t? >> size_t(n)): #[n:int] arrayptr(a, n)
//
(* ****** ****** *)
//
fun{a:vt0p}
the_get_elt_exn(): (a)
fun{a:vt0p}
the_getall_list_exn(): List0_vt(a)
fun{a:vt0p}
the_getall_rlist_exn(): List0_vt(a)
//
fun{a:vt0p}
the_getall_arrayptr_exn
  (asz: &size_t? >> size_t(n)): #[n:int] arrayptr(a, n)
//
(* ****** ****** *)

(* end of [theGetters.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: November, 2011 *)

(* ****** ****** *)
//
// HX-2012-12: ported to ATS/Postiats
//
(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.linheap_binomial"

(* ****** ****** *)

#include "./SHARE/linheap.hats"

(* ****** ****** *)

(* end of [linheap_binomial.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: December, 2012 *)

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.linmap_skiplist"

(* ****** ****** *)

#include "./SHARE/linmap.hats"
#include "./SHARE/linmap_node.hats"

(* ****** ****** *)

fun linmap_skiplist_initize (): void

(* ****** ****** *)

(* end of [linmap_skiplist.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: July, 2013 *)

(* ****** ****** *)
//
// HX-2013-07:
// For matrices
// (that is, 2D-arrays) of column-major style
//
(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.gmatcol"

(* ****** ****** *)

staload "libats/SATS/gvector.sats"
staload "libats/SATS/gmatrix.sats"

(* ****** ****** *)

praxi
lemma_gmatcol_param
  {a:t0p}{m,n:int}{ld:int}
  (M: &GMC(a, m, n, ld)): [m >= 1; n >= 0; ld >= m] void
praxi
lemma_gmatcol_v_param
  {a:t0p}{l:addr}{m,n:int}{ld:int}
  (pf: !GMC(a, l, m, n, ld)): [m >= 1; n >= 0; ld >= m] void

(* ****** ****** *)
//
// HX: 0 for row
//
praxi
gmatcol_v_renil0
  {a1,a2:t0p}
  {l:addr}{n:int}{ld:int} (GMC(a1, l, 0, n, ld)): GMC(a2, l, 0, n, ld)
//
praxi
gmatcol_v_cons0
  {a:t0p}{l:addr}
  {m,n:int}{ld:int}
(
  GVT(a, l, n, ld)
, GMC(a, l+sizeof(a), m, n, ld)
) : GMC(a, l, m+1, n, ld)
praxi
gmatcol_v_uncons0
  {a:t0p}{l:addr}
  {m,n:int | m > 0}{ld:int}
(
  pf: GMC(a, l, m, n, ld)
) :
(
  GVT(a, l, n, ld), GMC(a, l+sizeof(a), m-1, n, ld)
) (* end of [gmatcol_v_uncons0] *)
//
(* ****** ****** *)
//
// HX: 1 for col
//
praxi
gmatcol_v_renil1
  {a1,a2:t0p}
  {l:addr}{m:int}{ld:int} (GMC(a1, l, m, 0, ld)): GMC(a2, l, m, 0, ld)
//
praxi
gmatcol_v_cons1
  {a:t0p}{l:addr}
  {m,n:int}{ld:int}
(
  GVT(a, l, m, 1)
, GMC(a, l+ld*sizeof(a), m, n, ld)
) : GMC(a, l, m, n+1, ld)
praxi
gmatcol_v_uncons1
  {a:t0p}{l:addr}
  {m,n:int | n > 0}{ld:int}
(
  pf: GMC(a, l, m, n, ld)
) :
(
  GVT(a, l, m, 1), GMC(a, l+ld*sizeof(a), m, n-1, ld)
) (* end of [gmatcol_v_uncons1] *)
//
(* ****** ****** *)

praxi
gmatcol_v_split_2x1
  {a:t0p}{l:addr}
  {m,n:int}{ld:int}
  {i,j:nat | i <= m}
(
  GMC(a, l, m, n, ld), int i
) :
(
  GMC(a, l            , i  , n, ld)
, GMC(a, l+i*sizeof(a), m-i, n, ld)
) (* end of [gmatcol_v_split_2x1] *)

praxi
gmatcol_v_unsplit_2x1
  {a:t0p}{l:addr}
  {i,i2,n:int}{ld:int}
(
  GMC(a, l            , i , n, ld)
, GMC(a, l+i*sizeof(a), i2, n, ld)
) : GMC(a, l, i+i2, n, ld) // end of [praxi]

(* ****** ****** *)

praxi
gmatcol_v_split1x2
  {a:t0p}{l:addr}
  {m,n:int}{ld:int}
  {j:nat | j <= n}
(
  GMC(a, l, m, n, ld), int j
) :
(
  GMC(a, l               , m, j  , ld)
, GMC(a, l+j*ld*sizeof(a), m, n-j, ld)
) (* end of [gmatcol_v_split1x2] *)

praxi
gmatcol_v_unsplit1x2
  {a:t0p}{l:addr}
  {m,j,j2:int}{ld:int}
(
  GMC(a, l               , m, j , ld)
, GMC(a, l+j*ld*sizeof(a), m, j2, ld)
) : GMC(a, l, m, j+j2, ld) // end of [praxi]

(* ****** ****** *)

praxi
gmatcol_v_split_2x2
  {a:t0p}{l:addr}
  {m,n:int}{ld:int}
  {i,j:nat | i <= m; j <= n}
(
  GMC(a, l, m, n, ld), int i, int j
) :
(
  GMC(a, l                           , i  , j  , ld)
, GMC(a, l            +j*ld*sizeof(a), i  , n-j, ld)
, GMC(a, l+i*sizeof(a)               , m-i, j  , ld)
, GMC(a, l+i*sizeof(a)+j*ld*sizeof(a), m-i, n-j, ld)
) (* end of [gmatcol_v_split_2x2] *)

praxi
gmatcol_v_unsplit_2x2
  {a:t0p}{l:addr}
  {i,i2,j,j2:int}{ld:int}
(
  GMC(a, l                           , i , j , ld)
, GMC(a, l            +j*ld*sizeof(a), i , j2, ld)
, GMC(a, l+i*sizeof(a)               , i2, j , ld)
, GMC(a, l+i*sizeof(a)+j*ld*sizeof(a), i2, j2, ld)
) : GMC(a, l, i+i2, j+j2, ld) // end of [praxi]

(* ****** ****** *)

fun{a:t0p}
gmatcol_get_at
  {m,n:int}{ld:int}
(
  M: &GMC(a, m, n, ld), int(ld), i: natLt(m), j: natLt(n)
) : (a) // end of [gmatcol_get_at]
fun{a:t0p}
gmatcol_set_at
  {m,n:int}{ld:int}
(
  M: &GMC(a, m, n, ld), int(ld), i: natLt(m), j: natLt(n), x: a
) : void // end of [gmatcol_set_at]

(* ****** ****** *)

fun{a:t0p}
gmatcol_getref_at
  {m,n:int}{ld:int}
(
  M: &GMC(a, m, n, ld), int(ld), i: natLt(m), j: natLt(n)
) : cPtr1(a) // end of [gmatcol_getref_at]

(* ****** ****** *)

fun{a:t0p}
gmatcol_getref_row_at
  {m,n:int}{ld:int}
(
  M: &GMC(a, m, n, ld), int(ld), i: natLt(m)
) : cPtr1(GVT(a, n, ld)) // endfun

fun{a:t0p}
gmatcol_getref_col_at
  {m,n:int}{ld:int}
(
  M: &GMC(a, m, n, ld), int(ld), j: natLt(n)
) : cPtr1(GVT(a, m, 1(*d*))) // endfun

(* ****** ****** *)

fun{a:t0p}
gmatcol_interchange_row
  {m,n:int}{ld:int}
(
  M: &GMC(a, m, n, ld)
, n: int n, int(ld), i1: natLt(m), i2: natLt(m)
) : void // end of [gmatcol_interchange_row]
fun{a:t0p}
gmatcol_interchange_col
  {m,n:int}{ld:int}
(
  M: &GMC(a, m, n, ld)
, m: int m, int(ld), j1: natLt(n), j2: natLt(n)
) : void // end of [gmatcol_interchange_col]

(* ****** ****** *)

fun{a:t0p}
gmatcol_copyto
  {m,n:int}{ld1,ld2:int}
(
  M1: &GMC(a, m, n, ld1)
, M2: &GMC(a?, m, n, ld2) >> GMC(a, m, n, ld2)
, int(m), int(n), int(ld1), int(ld2)
) : void // end of [gmatcol_copyto]

fun{a:t0p}
gmatcol_transpto
  {m,n:int}{ld1,ld2:int}
(
  M1: &GMC(a, m, n, ld1)
, M2: &GMC(a?, n, m, ld2) >> GMC(a, n, m, ld2)
, int(m), int(n), int(ld1), int(ld2)
) : void // end of [gmatcol_transpto]

(* ****** ****** *)

fun{a:t0p}
gmatcol_ptr_split_2x2
  {l:addr}
  {m,n:int}{ld:int}
  {i,j:nat | i <= m; j <= n}
(
  pf: GMC(a, l, m, n, ld) | ptr(l), int(ld), int(i), int(j)
) : [l01,l10,l11:addr]
(
  GMC(a, l  , i  , j  , ld)
, GMC(a, l01, i  , n-j, ld)
, GMC(a, l10, m-i, j  , ld)
, GMC(a, l11, m-i, n-j, ld)
, (
  GMC(a, l  , i  , j  , ld)
, GMC(a, l01, i  , n-j, ld)
, GMC(a, l10, m-i, j  , ld)
, GMC(a, l11, m-i, n-j, ld)
) -<prf> GMC(a, l, m, n, ld)
| ptr(l01), ptr(l10), ptr(l11)
) (* end of [gmatcol_ptr_split_2x2] *)

(* ****** ****** *)

fun{
a:t0p}{env:vt0p
} gmatcol_foreachcol$fwork{m:int}
(
  col: &GVT (a, m, 1) >> _, m: int m, env: &(env) >> _
) : void // end of [gmatcol_foreachcol$fwork]

fun{
a:t0p
} gmatcol_foreachcol{m,n:int}{ld:int}
(
  M: &gmatcol(a, m, n, ld) >> _, int(m), int(n), int(ld)
) : void // end of [gmatcol_foreachcol]
fun{
a:t0p}{env:vt0p
} gmatcol_foreachcol_env{m,n:int}{ld:int}
(
  M: &gmatcol(a, m, n, ld) >> _, int(m), int(n), int(ld), env: &(env) >> _
) : void // end of [gmatcol_foreachcol_env]

(* ****** ****** *)

fun{
a1,a2:t0p}{env:vt0p
} gmatcol_foreachcol2$fwork{m:int}
(
  col1: &GVT (a1, m, 1) >> _
, col2: &GVT (a2, m, 1) >> _
, m: int (m), env: &(env) >> _
) : void // end of [gmatcol_foreachcol$fwork]

fun{
a1,a2:t0p
} gmatcol_foreachcol2
  {m,n:int}{ld1,ld2:int}
(
  M1: &gmatcol(a1, m, n, ld1) >> _
, M2: &gmatcol(a2, m, n, ld2) >> _
, int(m), int(n), int(ld1), int(ld2)
) : void // end of [gmatcol_foreachcol]
fun{
a1,a2:t0p}{env:vt0p
} gmatcol_foreachcol2_env
  {m,n:int}{ld1,ld2:int}
(
  M1: &gmatcol(a1, m, n, ld1) >> _
, M2: &gmatcol(a2, m, n, ld2) >> _
, int(m), int(n), int(ld1), int(ld2)
, env: &(env) >> _
) : void // end of [gmatcol_foreachcol2_env]

(* ****** ****** *)

(* end of [gmatrix_col.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: February, 2014 *)

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.linheap_array"

(* ****** ****** *)

#include "./SHARE/linheap.hats"

(* ****** ****** *)

(* end of [linheap_array.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2015 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
**
** Functional mset
** based on ordered lists
**
** Contributed by
** Hongwei Xi (hwxiATcsDOTbuDOTedu)
** Time: May 18, 2011
**
*)

(* ****** ****** *)
//
// HX-2015-09:
// ported to ATS/Postitats from ATS/Anairiats
//
(* ****** ****** *)
//
#define
ATS_PACKNAME
"ATSLIB.libats.funmset_listord"
//
(* ****** ****** *)

#include "./SHARE/funmset.hats"

(* ****** ****** *)
//
castfn
funmset2list{a:t0p}
  (xs: mset(INV(a))):<> List0 @(intGt(1), a)
//
(* ****** ****** *)

(* end of [funmset_listord.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// HX-2013-09:
// A collection of hash functions
//
(* ****** ****** *)

%{#
#include "libats/CATS/hashfun.cats"
%} // end of [%{#]

(* ****** ****** *)

fun{}
inthash_jenkins (uint32):<> uint32

(* ****** ****** *)
/*
** HX:
** res(0) = H0
** res(i+1) = K*res(i) + str[i]
*/
fun{}
string_hash_multiplier
  (K: ulint, H0: ulint, str: string):<> ulint
// end of [string_hash_multiplier]

(* ****** ****** *)

(* end of [hashfun.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmmhwxiATgmailDOTcom
// Start Time: May, 2014
//
(* ****** ****** *)
//
// An abstract thread interface
//
(* ****** ****** *)
//
#define
ATS_PACKNAME "ATSLIB.libats.athread"
//
(* ****** ****** *)

absview locked_v (l:addr)

(* ****** ****** *)

abstype
spin_type (l:addr) = ptr(l)
typedef spin (l:addr) = spin_type(l)
typedef spin0 = [l:agez] spin_type(l)
typedef spin1 = [l:addr | l > null] spin_type(l)

(* ****** ****** *)

absvtype
spin_vtype (l:addr) = ptr(l)
vtypedef spin_vt (l:addr) = spin_vtype(l)
vtypedef spin0_vt = [l:agez] spin_vtype(l)
vtypedef spin1_vt = [l:addr | l > null] spin_vtype(l)

(* ****** ****** *)
//
castfn
spin2ptr{l:addr} (spin(l)):<> ptr (l)
castfn
spin2ptr_vt{l:addr} (!spin_vt(l)):<> ptr (l)
//
overload ptrcast with spin2ptr
overload ptrcast with spin2ptr_vt
//
(* ****** ****** *)

castfn
unsafe_spin_t2vt{l:addr}(spin(l)): spin_vt(l)
castfn
unsafe_spin_vt2t{l:addr}(!spin_vt(l)): spin(l)

(* ****** ****** *)
//
fun{} spin_create ((*void*)): spin0
fun{} spin_create_exn ((*void*)): spin1
//
(* ****** ****** *)

fun{} spin_vt_destroy{l:addr}(spin_vt(l)): void

(* ****** ****** *)
//
fun{}
spin_lock{l:agz} (x: spin(l)):<!wrt> (locked_v(l) | void)
fun{}
spin_trylock{l:agz}
  (x: spin(l)): [b:bool] (option_v(locked_v(l), b) | bool(b))
fun{}
spin_unlock{l:addr} (pf: locked_v(l) | x: spin(l)):<!wrt> void
//
(* ****** ****** *)

abstype
mutex_type (l:addr) = ptr(l)
typedef mutex (l:addr) = mutex_type(l)
typedef mutex0 = [l:agez] mutex_type(l)
typedef mutex1 = [l:addr | l > null] mutex_type(l)

(* ****** ****** *)

absvtype
mutex_vtype (l:addr) = ptr(l)
vtypedef mutex_vt (l:addr) = mutex_vtype(l)

(* ****** ****** *)
//
castfn
mutex2ptr{l:addr} (mutex(l)):<> ptr (l)
castfn
mutex2ptr_vt{l:addr} (!mutex_vt(l)):<> ptr (l)
//
overload ptrcast with mutex2ptr
overload ptrcast with mutex2ptr_vt
//
(* ****** ****** *)

castfn
unsafe_mutex_t2vt{l:addr}(mutex(l)): mutex_vt(l)
castfn
unsafe_mutex_vt2t{l:addr}(!mutex_vt(l)): mutex(l)

(* ****** ****** *)
//
fun{} mutex_create ((*void*)): mutex0
fun{} mutex_create_exn ((*void*)): mutex1
//
(* ****** ****** *)

fun{} mutex_vt_destroy{l:addr}(mutex_vt(l)): void

(* ****** ****** *)
//
fun{}
mutex_lock{l:agz} (m: mutex(l)):<!wrt> (locked_v(l) | void)
fun{}
mutex_trylock{l:agz}
  (m: mutex(l)): [b:bool] (option_v(locked_v(l), b) | bool(b))
fun{}
mutex_unlock{l:addr} (pf: locked_v(l) | m: mutex(l)):<!wrt> void
//
(* ****** ****** *)
//
abstype
condvar_type(l:addr) = ptr(l)
typedef condvar (l:addr) = condvar_type(l)
typedef condvar0 = [l:agez] condvar_type(l)
typedef condvar1 = [l:addr | l > null] condvar_type(l)
//
(* ****** ****** *)

absvtype
condvar_vtype (l:addr) = ptr(l)
vtypedef condvar_vt (l:addr) = condvar_vtype(l)

(* ****** ****** *)

castfn
condvar2ptr{l:addr} (condvar(l)):<> ptr (l)
overload ptrcast with condvar2ptr
castfn
condvar2ptr_vt{l:addr} (!condvar_vt(l)):<> ptr (l)
overload ptrcast with condvar2ptr_vt

(* ****** ****** *)

castfn
unsafe_condvar_t2vt{l:addr}(condvar(l)): condvar_vt(l)
castfn
unsafe_condvar_vt2t{l:addr}(!condvar_vt(l)): condvar(l)

(* ****** ****** *)
//
fun{} condvar_create (): condvar0
fun{} condvar_create_exn (): condvar1
//
(* ****** ****** *)

fun{} condvar_vt_destroy{l:addr}(condvar_vt(l)): void

(* ****** ****** *)
//
fun{} condvar_signal (cvr: condvar1): void
fun{} condvar_broadcast (cvr: condvar1): void
//
fun{} condvar_wait{l:addr}
  (pf: !locked_v(l) | cvr: condvar1, p: mutex (l)): void
//
(* ****** ****** *)
  
typedef tid = lint
  
(* ****** ****** *)
//
fun{}
athread_create_funenv
  {env:vtype}
(
  tid: &tid? >> _
, fwork: (env) -> void, env: env
) : int(*err*)
//
fun{}
athread_create_cloptr
(
  tid: &tid? >> _, fwork: () -<lincloptr1> void
) : int(*err*)
fun{}
athread_create_cloptr_exn
  (fwork: ((*void*)) -<lincloptr1> void): lint(*tid*)
//
(* ****** ****** *)

(* end of [athread.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
**
** An array-based deque implementation
**
*)

(* ****** ****** *)

(*
**
** Author: Hongwei Xi
** Authoremail: gmhwxi AT gmail DOT com
** Start time: September, 2013
**
*)

(* ****** ****** *)

#define
ATS_PACKNAME "ATSLIB.libats.deqarray"
#define
ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

%{#
#include "libats/CATS/deqarray.cats"
%} // end of [%{#]

(* ****** ****** *)
//
absvtype
deqarray_vtype (a:vt@ype+, m:int, n:int) = ptr
//
(* ****** ****** *)
//
stadef deqarray = deqarray_vtype
//
vtypedef
deqarray (a:vt0p) = [m,n:int] deqarray_vtype (a, m, n)
//
(* ****** ****** *)

abst@ype
deqarray_tsize = $extype"atslib_deqarray_struct"

(* ****** ****** *)

praxi
lemma_deqarray_param
  {a:vt0p}{m,n:int}
  (!deqarray (INV(a), m, n)): [m >= n; n >= 0] void
// end of [lemma_deqarray_param]

(* ****** ****** *)

fun{a:vt0p}
deqarray_make_cap
  {m:int} (cap: size_t(m)):<!wrt> deqarray (a, m, 0)
// end of [deqarray_make_cap]

(* ****** ****** *)

fun
deqarray_make_ngc__tsz
  {a:vt0p}
  {l:addr}{m:int}
(
  deqarray_tsize? @ l
| ptr(l), arrayptr(a?, m+1), size_t(m), sizeof_t(a)
) :<!wrt> (mfree_ngc_v (l) | deqarray (a, m, 0)) = "mac#%"

(* ****** ****** *)

fun
deqarray_free_nil
  {a:vt0p}{m:int}
  (deq: deqarray (a, m, 0)):<!wrt> void = "mac#%"
// end of [deqarray_free_nil]

(* ****** ****** *)
//
fun{a:vt0p}
deqarray_get_size
  {m,n:int} (deq: !deqarray (INV(a), m, n)):<> size_t(n)
fun{a:vt0p}
deqarray_get_capacity
  {m,n:int} (deq: !deqarray (INV(a), m, n)):<> size_t(m)
//
(* ****** ****** *)
//
fun
deqarray_is_nil
  {a:vt0p}{m,n:int}
  (deq: !deqarray (INV(a), m, n)):<> bool (n==0) = "mac#%"
fun
deqarray_isnot_nil
  {a:vt0p}{m,n:int}
  (deq: !deqarray (INV(a), m, n)):<> bool (n > 0) = "mac#%"
//
(* ****** ****** *)
//
fun{a:vt0p}
deqarray_is_full{m,n:int}
  (deq: !deqarray (INV(a), m, n)):<> bool (m==n) = "mac#%"
fun{a:vt0p}
deqarray_isnot_full{m,n:int}
  (deq: !deqarray (INV(a), m, n)):<> bool (m > n) = "mac#%"
//
(* ****** ****** *)

fun{}
fprint_deqarray$sep (out: FILEref): void
fun{a:vt0p}
fprint_deqarray
  (out: FILEref, q: !deqarray (INV(a))): void
fun{a:vt0p}
fprint_deqarray_sep
  (out: FILEref, q: !deqarray (INV(a)), sep: string): void
overload fprint with fprint_deqarray
overload fprint with fprint_deqarray_sep

(* ****** ****** *)

fun{a:vt0p}
deqarray_insert_atbeg
  {m,n:int | m > n}
(
  deq: !deqarray (INV(a),m,n) >> deqarray (a,m,n+1), x0: a
) :<!wrt> void // endfun

fun{a:vt0p}
deqarray_insert_atbeg_opt
  (deq: !deqarray (INV(a)) >> _, x0: a):<!wrt> Option_vt (a)
// end of [deqarray_insert_atbeg_opt]

(* ****** ****** *)

fun{a:vt0p}
deqarray_insert_atend
  {m,n:int | m > n}
(
  deq: !deqarray (INV(a),m,n) >> deqarray (a,m,n+1), x0: a
) :<!wrt> void // end-of-fun

fun{a:vt0p}
deqarray_insert_atend_opt
  (deq: !deqarray (INV(a)) >> _, x0: a):<!wrt> Option_vt (a)
// end of [deqarray_insert_atend_opt]

(* ****** ****** *)

fun{a:vt0p}
deqarray_takeout_atbeg
  {m,n:int | n > 0}
(
  deq: !deqarray (INV(a),m,n) >> deqarray (a,m,n-1)
) :<!wrt> (a) // end-of-fun

fun{a:vt0p}
deqarray_takeout_atbeg_opt
  (deq: !deqarray (INV(a)) >> _):<!wrt> Option_vt (a)
// end of [deqarray_takeout_atbeg_opt]

(* ****** ****** *)

fun{a:vt0p}
deqarray_takeout_atend
  {m,n:int | n > 0}
(
  deq: !deqarray (INV(a),m,n) >> deqarray (a,m,n-1)
) :<!wrt> (a) // end-of-fun

fun{a:vt0p}
deqarray_takeout_atend_opt
  (deq: !deqarray (INV(a)) >> _):<!wrt> Option_vt (a)
// end of [deqarray_takeout_atend_opt]

(* ****** ****** *)
//
fun{a:t0p}
deqarray_get_at
  {m,n:int}
  (deq: !deqarray (INV(a), m, n), i: sizeLt(n)):<> (a)
//
fun{a:t0p}
deqarray_set_at
  {m,n:int}
  (deq: !deqarray (INV(a), m, n), i: sizeLt(n), x: a):<!wrt> void
//
(* ****** ****** *)
//
fun{a:vt0p}
deqarray_getref_at
  {m,n:int}
  (deq: !deqarray(INV(a), m, n), i: sizeLt(n)):<> cPtr1 (a)
//
(* ****** ****** *)

fun{
a:vt0p}{env:vt0p
} deqarray_foreach$cont (x: &a, env: &env): bool
fun{
a:vt0p}{env:vt0p
} deqarray_foreach$fwork (x: &a >> _, env: &(env) >> _): void
fun{
a:vt0p
} deqarray_foreach{m,n:int}
  (deq: !deqarray (INV(a), m, n)): void
fun{
a:vt0p}{env:vt0p
} deqarray_foreach_env{m,n:int}
  (deq: !deqarray (INV(a), m, n), env: &(env) >> _): void

(* ****** ****** *)

(* end of [deqarray.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: July, 2013 *)

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.gmatrix"

(* ****** ****** *)

staload "libats/SATS/gvector.sats"

(* ****** ****** *)
//
sortdef mord = int
//
stadef mrow: mord = 0 // row-major
stadef mcol: mord = 1 // col-major
//
datatype MORD (int) =
  | MORDrow (mrow) of () | MORDcol (mcol) of ()
//
typedef MORD = [mo:mord] MORD(mo)
//
(* ****** ****** *)
//
datasort transp = tpn | tpt | tpc
datatype TRANSP (transp) =
  | TPN (tpn) of () | TPT (tpt) of () | TPC (tpc) of ()
//
typedef TRANSP = [tp:transp] TRANSP(tp)
//
(* ****** ****** *)

dataprop
transpdim
(
  transp
, int // row
, int // col
, int // row_new
, int // col_new
) =
  | {m,n:int} TPDIM_N (tpn, m, n, m, n) of ()
  | {m,n:int} TPDIM_T (tpt, m, n, n, m) of ()
  | {m,n:int} TPDIM_C (tpc, m, n, n, m) of ()
// end of [transpdim]

(* ****** ****** *)
//
// HX: [transp] is inverse
//
prfun
transpdim_transp
  {tp:transp}{m1,n1:int}{m2,n2:int}
  (pf: transpdim (tp, m1, n1, m2, n2)): transpdim (tp, n1, m1, n2, m2)
// end of [transpdim_transp]

(* ****** ****** *)

sortdef uplo = int
stadef uplo_l: uplo = 0 // lo
stadef uplo_u: uplo = 1 // up
datatype UPLO (uplo) = UPLO_L (uplo_l) | UPLO_U (uplo_u) of ()

(* ****** ****** *)

sortdef diag = int
stadef diag_n: diag = 0 // non
stadef diag_u: diag = 1 // unit
datatype DIAG (diag) = DIAG_N (diag_n) | DIAG_U (diag_u) of ()

(* ****** ****** *)

sortdef side = int
stadef side_l: side = 0 // left
stadef side_r: side = 1 // right
datatype SIDE (side) = SIDE_L (side_l) | SIDE_R (side_r) of ()

(* ****** ****** *)
//
// HX-2013-07:
// generic matrix:
// element, row, col, ord, ld
//
abst@ype
gmatrix_t0ype
  (a:t@ype, mo:mord, m:int, n:int, ld:int) (* irregular *)
//
typedef gmatrix
  (a:t0p, mo:mord, m:int, n:int, ld:int) = gmatrix_t0ype (a, mo, m, n, ld)
viewdef gmatrix_v
  (a:t0p, mo:mord, l:addr, m:int, n:int, ld:int) = gmatrix_t0ype (a, mo, m, n, ld) @ l
//
stadef GMX = gmatrix
stadef GMX = gmatrix_v
//
(* ****** ****** *)
//
typedef gmatrow
  (a:t0p, m:int, n:int, ld:int) = gmatrix_t0ype (a, mrow, m, n, ld)
viewdef gmatrow_v
  (a:t0p, l:addr, m:int, n:int, ld:int) = gmatrix_t0ype (a, mrow, m, n, ld) @ l
//
stadef GMR = gmatrow
stadef GMR = gmatrow_v
//
(* ****** ****** *)
//
typedef gmatcol
  (a:t0p, m:int, n:int, ld:int) = gmatrix_t0ype (a, mcol, m, n, ld)
viewdef gmatcol_v
  (a:t0p, l:addr, m:int, n:int, ld:int) = gmatrix_t0ype (a, mcol, m, n, ld) @ l
//
stadef GMC = gmatcol
stadef GMC = gmatcol_v
//
(* ****** ****** *)

praxi
lemma_gmatrix_param
  {a:t0p}{mo:mord}
  {m,n:int}{ld:int}
  (M: &GMX (a, mo, m, n, ld))
: [0 <= mo; mo <= 1; 0 <= m; 0 <= n; 0 <= ld] void
praxi
lemma_gmatrix_v_param
  {a:t0p}{mo:mord}
  {l:addr}{m,n:int}{ld:int}
  (pf: !GMX (a, mo, l, m, n, ld))
: [0 <= mo; mo <= 1; 0 <= m; 0 <= n; 0 <= ld] void

(* ****** ****** *)
//
(*
// HX-2013-07:
// Don't use [gmatrix_initize]
// unless you know what you are doing
*)
praxi
gmatrix_initize
  {a:t0p}{mo:mord}{m,n:int}{ld:int}
  (&GMX(a?, mo, m, n, ld) >> GMX(a, mo, m, n, ld)): void
praxi
gmatrix_uninitize
  {a:t0p}{mo:mord}{m,n:int}{ld:int}
  (&GMX(a, mo, m, n, ld) >> GMX(a?, mo, m, n, ld)): void
//
(* ****** ****** *)
//
praxi
gmatrix_flipord
  {a:t0p}{mo:mord}
  {m,n:int}{ld:int}
  (M: &GMX(a, mo, m, n, ld) >> GMX(a, 1-mo, n, m, ld)): void
praxi
gmatrix_v_flipord
  {a:t0p}{mo:mord}
  {l:addr}{m,n:int}{ld:int}
  (pf: !GMX(a, mo, l, m, n, ld) >> GMX(a, 1-mo, l, n, m, ld)): void
//
(* ****** ****** *)

fun{}
fprint_gmatrix$sep1 (out: FILEref): void
fun{}
fprint_gmatrix$sep2 (out: FILEref): void
fun{a:t0p}
fprint_gmatrix
  {mo:mord}{m,n:int}{ld:int}
(
  FILEref
, V: &GMX(a, mo, m, n, ld), MORD(mo), int(m), int(n), int(ld)
) : void // end of [fprint_gmatrix]

fun{a:t0p}
fprint_gmatrix_sep
  {mo:mord}{m,n:int}{ld:int}
(
  FILEref
, V: &GMX(a, mo, m, n, ld)
, MORD(mo), int(m), int(n), int(ld), sep1: string, sep: string
) : void // end of [fprint_gmatrix_sep]

(* ****** ****** *)

fun{
a:t0p}{env:vt0p
} gmatrix_iforeach$fwork{n:int}
(
  i: int, j: int, x: &(a) >> _, env: &(env) >> _
) : void // end of [gmatrix_iforeach$fwork]

fun{
a:t0p
} gmatrix_iforeach
  {mo:mord}{m,n:int}{ld:int}
(
  M: &GMX(a, mo, m, n, ld) >> _, MORD(mo), int m, int n, int ld
) : void // end of [gmatrix_iforeach]
fun{
a:t0p}{env:vt0p
} gmatrix_iforeach_env
  {mo:mord}{m,n:int}{ld:int}
(
  M: &GMX(a, mo, m, n, ld) >> _, MORD(mo), int m, int n, int ld, env: &(env) >> _
) : void // end of [gmatrix_iforeach_env]

(* ****** ****** *)

fun{a:t0p}
gmatrix_imake$fopr
  (i: int, j: int, x: a): a

fun{a:t0p}
gmatrix_imake_arrayptr
  {mo:mord}{m,n:int}{ld:int}
(
  M: &GMX(a, mo, m, n, ld), mo: MORD(mo), int m, int n, int(ld)
) : arrayptr (a, m*n) // end of [gmatrix_imake_arrayptr]
fun{a:t0p}
gmatrix_imake_matrixptr
  {mo:mord}{m,n:int}{ld:int}
(
  M: &GMX(a, mo, m, n, ld), mo: MORD(mo), int m, int n, int(ld)
) : matrixptr (a, m, n) // end of [gmatrix_imake_matrixptr]

(* ****** ****** *)

abst@ype
trmatrix_t0ype
(
  a:t@ype
, mo: mord, ul: uplo, dg: diag, n:int, ld: int
)
typedef trmatrix
(
  a:t0p, mo:mord, ul: uplo, dg: diag, n:int, ld:int
) = trmatrix_t0ype (a, mo, ul, dg, n, ld)
viewdef trmatrix_v
(
  a:t0p, mo:mord, ul: uplo, dg: diag, l:addr, n:int, ld:int
) = trmatrix_t0ype (a, mo, ul, dg, n, ld) @ l
//
stadef TRMX = trmatrix
stadef TRMX = trmatrix_v
//
(* ****** ****** *)
//
praxi
trmatrix_flipord
  {a:t0p}
  {mo:mord}
  {ul:uplo}
  {dg:diag}
  {n:int}{ld:int}
  (M: &TRMX(a, mo, ul, dg, n, ld) >> TRMX(a, 1-mo, 1-ul, dg, n, ld)): void
praxi
trmatrix_v_flipord
  {a:t0p}
  {mo:mord}
  {ul:uplo}
  {dg:diag}
  {l:addr}
  {n:int}{ld:int}
  (pf: !TRMX(a, mo, ul, dg, l, n, ld) >> TRMX(a, 1-mo, 1-ul, dg, l, n, ld)): void
//
(* ****** ****** *)

(* end of [gmatrix.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: January, 2013 *)

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.linralist_nested"

(* ****** ****** *)

#include "./SHARE/linralist.hats"

(* ****** ****** *)

(* end of [linralist_nested.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
**
** A functional map implementation based on AVL trees
**
** Contributed by Hongwei Xi (hwxi AT cs DOT bu DOT edu)
** Time: May, 2011 // based on a version done in October, 2008
**
*)

(* ****** ****** *)
//
// HX-2012-12:
// It is ported to ATS/Postitats from ATS/Anairiats
//
(* ****** ****** *)
//
#define
ATS_PACKNAME
"ATSLIB.libats.funmap_avltree"
//
(* ****** ****** *)

#include "./SHARE/funmap.hats"

(* ****** ****** *)
//
// HX: for the purpose of gathering statics
//
fun{
key:t0p;itm:t0p
} funmap_avltree_height (map: map (key, itm)):<> intGte(0)
//
(* ****** ****** *)

(* end of [funmap_avltree.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// AuthorEmail: hwxi AT cs DOT bu DOT edu
// Start time: December, 2012
//
(* ****** ****** *)
//
// HX: there is no involvement of malloc/free
// HX: generic nodes: singly-linked, doubly-linked, ...
//
(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.gnode"

(* ****** ****** *)

sortdef tk = tkind
sortdef t0p = t@ype and vt0p = vt@ype

(* ****** ****** *)
//
abstype
gnode (tk:tk, a:vt@ype+, l:addr) = ptr
//
typedef
gnode (tk:tk, a:vt0p) = [l:addr] gnode (tk, a, l)
typedef
gnode0 (tk:tk, a:vt0p) = [l:addr | l >= null] gnode (tk, a, l)
typedef
gnode1 (tk:tk, a:vt0p) = [l:addr | l >  null] gnode (tk, a, l)
//
(* ****** ****** *)

praxi
lemma_gnode
  {tk:tk}{a:vt0p}{l:addr} (nx: gnode (tk, a, l)): [l >= null] void
// end of [lemma_gnode]

(* ****** ****** *)

castfn
gnode2ptr {tk:tk}{a:vt0p}{l:addr} (nx: gnode (tk, a, l)):<> ptr (l)

(* ****** ****** *)

fun{
} gnode_null
  {tk:tk}{a:vt0p} ():<> gnode (tk, a, null)
// end of [gnode_null]

(* ****** ****** *)

fun{
} gnode_is_null
  {tk:tk}{a:vt0p}{l:addr} (nx: gnode (tk, INV(a), l)):<> bool (l==null)
// end of [gnode_is_null]

fun{
} gnode_isnot_null
  {tk:tk}{a:vt0p}{l:addr} (nx: gnode (tk, INV(a), l)):<> bool (l > null)
// end of [gnode_isnot_null]

(* ****** ****** *)

fun{
tk:tk}{a:t0p
} gnode_get_elt (nx: gnode1 (tk, INV(a))):<> (a)
fun{
tk:tk}{a:t0p
} gnode_set_elt (nx: gnode1 (tk, INV(a)), x0: a):<!wrt> void

fun{
tk:tk}{a:vt0p
} gnode_getref_elt (nx: gnode1 (tk, INV(a))):<> cPtr1 (a)

(* ****** ****** *)

fun{
tk:tk}{a:vt0p // implemented
} gnode_get_next (nx: gnode1 (tk, INV(a))):<> gnode0 (tk, a)
fun{
tk:tk}{a:vt0p // implemented
} gnode_set_next (nx: gnode1 (tk, INV(a)), nx2: gnode (tk, a)):<!wrt> void
fun{
tk:tk}{a:vt0p // implemented
} gnode0_set_next (nx: gnode0 (tk, INV(a)), nx2: gnode (tk, a)):<!wrt> void
fun{
tk:tk}{a:vt0p
} gnode_set_next_null (nx: gnode1 (tk, INV(a))):<!wrt> void
fun{
tk:tk}{a:vt0p
} gnode0_set_next_null (nx: gnode0 (tk, INV(a))):<!wrt> void

fun{
tk:tk}{a:vt0p
} gnode_getref_next (nx: gnode1 (tk, INV(a))):<> cPtr1 (gnode0(tk, a))

(* ****** ****** *)

fun{
tk:tk}{a:vt0p
} gnode_get_prev (nx: gnode1 (tk, INV(a))):<> gnode0 (tk, a)
fun{
tk:tk}{a:vt0p
} gnode_set_prev (nx: gnode1 (tk, INV(a)), nx2: gnode (tk, a)):<!wrt> void
fun{
tk:tk}{a:vt0p
} gnode0_set_prev (nx: gnode0 (tk, INV(a)), nx2: gnode (tk, a)):<!wrt> void
fun{
tk:tk}{a:vt0p
} gnode_set_prev_null (nx: gnode1 (tk, INV(a))):<!wrt> void
fun{
tk:tk}{a:vt0p
} gnode0_set_prev_null (nx: gnode0 (tk, INV(a))):<!wrt> void

fun{
tk:tk}{a:vt0p
} gnode_getref_prev (nx: gnode1 (tk, INV(a))):<> cPtr1 (gnode0 (tk, a))

(* ****** ****** *)

(*
fun{
tk:tk}{a:vt0p
} gnode_link (nx1: gnode1 (tk, INV(a)), nx2: gnode1 (tk, a)):<!wrt> void
*)
fun{
tk:tk}{a:vt0p
} gnode_link00 (nx1: gnode0 (tk, INV(a)), nx2: gnode0 (tk, a)):<!wrt> void
fun{
tk:tk}{a:vt0p
} gnode_link01 (nx1: gnode0 (tk, INV(a)), nx2: gnode1 (tk, a)):<!wrt> void
fun{
tk:tk}{a:vt0p
} gnode_link10 (nx1: gnode1 (tk, INV(a)), nx2: gnode0 (tk, a)):<!wrt> void
fun{
tk:tk}{a:vt0p
} gnode_link11 (nx1: gnode1 (tk, INV(a)), nx2: gnode1 (tk, a)):<!wrt> void

(* ****** ****** *)

fun{
tk:tk}{a:vt0p
} gnode_insert_next
  (nx1: gnode1 (tk, INV(a)), nx2: gnode1 (tk, a)):<!wrt> void
// end of [gnode_insert_next]

fun{
tk:tk}{a:vt0p
} gnode_insert_prev
  (nx1: gnode1 (tk, INV(a)), nx2: gnode1 (tk, a)):<!wrt> void
// end of [gnode_insert_prev]

(* ****** ****** *)

fun{
tk:tk}{a:vt0p
} gnode_remove (nx: gnode1 (tk, INV(a))):<!wrt> gnode1 (tk, a)
fun{
tk:tk}{a:vt0p
} gnode_remove_next (nx: gnode1 (tk, INV(a))):<!wrt> gnode0 (tk, a)
fun{
tk:tk}{a:vt0p
} gnode_remove_prev (nx: gnode1 (tk, INV(a))):<!wrt> gnode0 (tk, a)

(* ****** ****** *)

macdef
gnodelst_is_nil (nxs) = gnode_is_null (,(nxs))
macdef
gnodelst_is_cons (nxs) = gnode_isnot_null (,(nxs))

(* ****** ****** *)

fun{
tk:tk}{a:vt0p
} gnodelst_length (nxs: gnode0 (tk, INV(a))):<> intGte(0)

fun{
tk:tk}{a:vt0p
} gnodelst_rlength (nxs: gnode0 (tk, INV(a))):<> intGte(0)

(* ****** ****** *)

fun{
tk:tk}{a:vt0p
} gnodelst_next_all (nxs: gnode1 (tk, INV(a))):<> gnode1 (tk, a)
fun{
tk:tk}{a:vt0p
} gnodelst_prev_all (nxs: gnode1 (tk, INV(a))):<> gnode1 (tk, a)

(* ****** ****** *)

(* end of [gnode.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: February, 2012 *)

(* ****** ****** *)
//
// HX-2012-12: ported to ATS/Postiats from ATS/Anairiats
//
(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.dllist"

(* ****** ****** *)

typedef SHR(a:type) = a // for commenting purpose
typedef NSH(a:type) = a // for commenting purpose

(* ****** ****** *)
(*
**
** HX-2012-02-29:
** dllist (a, f, r) means that there are f elements in
** front of the current one while r-1 elements after it. So the
** total number of elements is f+r. If f=r=0, then the list is
** empty.
**
*)
absvtype
dllist_vtype
  (a: viewt@ype+, f: int, r: int) = ptr // HX: f: front; r: rear
stadef dllist = dllist_vtype
//
vtypedef Dllist (a) = [f,r:int] dllist (a, f, r)
vtypedef Dllist0 (a) = [f,r:int | r >= 0] dllist (a, f, r)
vtypedef Dllist1 (a) = [f,r:int | r >= 1] dllist (a, f, r)
//
(* ****** ****** *)

castfn
dllist2ptr {a:vt0p} (xs: !Dllist (INV(a))):<> Ptr0
castfn
dllist2ptr1 {a:vt0p} (xs: !Dllist1 (INV(a))):<> Ptr1

(* ****** ****** *)

praxi
lemma1_dllist_param {a:vt0p}
  {f,r:int} (xs: !dllist (INV(a), f, r)): [f >= 0;r >= 0] void
// end of [lemma_dllist_param]

praxi
lemma2_dllist_param
  {a:vt0p} {f,r:int | f > 0} (xs: !dllist (INV(a), f, r)): [r > 0] void
// end of [lemma2_dllist_param]

praxi
lemma3_dllist_param
  {a:vt0p} {f,r:int | r <= 0} (xs: !dllist (INV(a), f, r)): [f == 0] void
// end of [lemma3_dllist_param]

(* ****** ****** *)

fun{}
dllist_nil {a:vt0p} ():<> dllist (a, 0, 0)

(* ****** ****** *)

praxi
dllist_free_nil
  {a:vt0p}{f:int} (xs: dllist (INV(a), f, 0)): void
// end of [dllist_free_nil]

(* ****** ****** *)

fun{a:vt0p}
dllist_sing (x: a):<!wrt> dllist (a, 0, 1)

(* ****** ****** *)

fun{a:vt0p}
dllist_cons{r:int}
  (x: a, xs: dllist (INV(a), 0, r)):<!wrt> dllist (a, 0, r+1)
// end of [dllist_cons]

fun{a:vt0p}
dllist_uncons{r:int | r > 0}
  (xs: &dllist (INV(a), 0, r) >> dllist (a, 0, r-1)):<!wrt> (a)
// end of [dllist_uncons]

(* ****** ****** *)

fun{a:vt0p}
dllist_snoc{f:int}
  (xs: dllist (INV(a), f, 1), x: a):<!wrt> dllist (a, f+1, 1)
// end of [dllist_snoc]

fun{a:vt0p}
dllist_unsnoc{f:int | f > 0}
  (xs: &dllist (INV(a), f, 1) >> dllist (a, f-1, 1)):<!wrt> (a)
// end of [dllist_unsnoc]

(* ****** ****** *)

fun{a:t0p}
dllist_make_list
  {n:int} (xs: list (INV(a), n)):<!wrt> dllist (a, 0, n)
// end of [dllist_make_list]

(* ****** ****** *)

fun{
} dllist_is_nil
  {a:vt0p}{f,r:int} (xs: !dllist (INV(a), f, r)):<> bool (r==0)
// end of [dllist_is_nil]

fun{
} dllist_is_cons
  {a:vt0p}{f,r:int} (xs: !dllist (INV(a), f, r)):<> bool (r > 0)
// end of [dllist_is_cons]

(* ****** ****** *)

fun{a:vt0p}
dllist_is_atbeg
  {f,r:int}
  (xs: !dllist (INV(a), f, r)):<> bool (f==0)
// end of [dllist_is_atbeg]
fun{a:vt0p}
dllist_is_atend
  {f,r:int | r > 0}
  (xs: !dllist (INV(a), f, r)):<> bool (r==1)
// end of [dllist_is_atend]

fun{a:vt0p}
rdllist_is_atbeg
  {f,r:int | r > 0}
  (xs: !dllist (INV(a), f, r)):<> bool (r==1)
// end of [rdllist_is_atend]
fun{a:vt0p}
rdllist_is_atend
  {f,r:int}
  (xs: !dllist (INV(a), f, r)):<> bool (f==0)
// end of [rdllist_is_atend]

(* ****** ****** *)

fun{a:vt0p}
dllist_getref_elt (xs: !Dllist1 (INV(a))):<> cPtr1 (a)

(* ****** ****** *)

fun{a:vt0p}
dllist_getref_next (xs: !Dllist1 (INV(a))):<> Ptr1
fun{a:vt0p}
dllist_getref_prev (xs: !Dllist1 (INV(a))):<> Ptr1

(* ****** ****** *)

fun{a:t0p}
dllist_get_elt (xs: !Dllist1 (INV(a))): a

fun{a:t0p}
dllist_set_elt (xs: !Dllist1 (INV(a)), x0: a): void

(* ****** ****** *)

fun{a:vt0p}
dllist_length
  {f,r:int} (xs: !dllist (INV(a), f, r)):<> int (r)
// end of [dllist_length]

fun{a:vt0p}
rdllist_length
  {f,r:int} (xs: !dllist (INV(a), f, r)):<> int (f)
// end of [rdllist_length]

(* ****** ****** *)

fun{a:vt0p}
dllist_move
  {f,r:int | r > 1}
  (xs: dllist (INV(a), f, r)):<> dllist (a, f+1, r-1)
fun{a:vt0p}
dllist_move_all
  {f,r:int | r > 0}
  (xs: dllist (INV(a), f, r)):<> dllist (a, f+r-1, 1)
// end of [dllist_move_all]

(* ****** ****** *)

fun{a:vt0p}
rdllist_move
  {f,r:int | f > 0}
  (xs: dllist (INV(a), f, r)):<> dllist (a, f-1, r+1)
fun{a:vt0p}
rdllist_move_all
  {f,r:int | r >= 0}
  (xs: dllist (INV(a), f, r)):<> dllist (a, 0(*front*), f+r)
// end of [rdllist_move_all]

(* ****** ****** *)

fun{a:vt0p}
dllist_insert_next
  {f,r:int | r > 0}
  (xs: dllist (INV(a), f, r), x0: a):<!wrt> dllist (a, f, r+1)
// end of [dllist_insert_next]

fun{a:vt0p}
dllist_insert_prev
  {f,r:int | r > 0}
  (xs: dllist (INV(a), f, r), x0: a):<!wrt> dllist (a, f, r+1)
// end of [dllist_insert]

(* ****** ****** *)

fun{a:vt0p}
dllist_takeout
  {f,r:int | r > 1}
  (xs: &dllist (INV(a), f, r) >> dllist (a, f, r-1)):<!wrt> (a)
// end of [dllist_takeout]

fun{a:vt0p}
dllist_takeout_next
  {f,r:int | r > 1}
  (xs: &dllist (INV(a), f, r) >> dllist (a, f, r-1)):<!wrt> (a)
// end of [dllist_takeout_next]

(* ****** ****** *)

fun{a:vt0p}
rdllist_insert
  {f,r:int | r > 0}
  (xs: dllist (INV(a), f, r), x0: a):<!wrt> dllist (a, f+1, r)
// end of [rdllist_insert]

fun{a:vt0p}
rdllist_takeout
  {f,r:int | f > 0}
  (xs: &dllist (INV(a), f, r) >> dllist (a, f-1, r)):<!wrt> (a)
// end of [rdllist_takeout]

(* ****** ****** *)

fun{a:vt0p}
dllist_append
  {f1,r1:int}{f2,r2:int} (
  xs1: dllist (INV(a), f1, r1), xs2: dllist (a, f2, r2)
) :<!wrt> dllist (a, f1, r1+f2+r2) // end of [dllist_append]

fun{a:vt0p}
rdllist_append
  {f1,r1:int}{f2,r2:int | r2 > 0} (
  xs1: dllist (INV(a), f1, r1), xs2: dllist (a, f2, r2)
) :<!wrt> dllist (a, f1+r1+f2, r2) // end of [rdllist_append]

(* ****** ****** *)

fun{a:vt0p}
dllist_reverse
  {f,r:int} (xs: dllist (INV(a), f, r)):<!wrt> dllist (a, f, r)
// end of [dllist_reverse]

fun{a:vt0p}
rdllist_reverse
  {f,r:int} (xs: dllist (INV(a), f, r)):<!wrt> dllist (a, f, r)
// end of [rdllist_reverse]

(* ****** ****** *)

fun{a:t0p}
dllist_free
  {r:int} (xs: dllist (INV(a), 0, r)):<!wrt> void
// end of [dllist_free]

fun{a:vt0p}
dllist_freelin$clear (x: &a >> a?):<!wrt> void
fun{a:vt0p}
dllist_freelin {r:int} (xs: dllist (INV(a), 0, r)):<!wrt> void

(* ****** ****** *)

fun{
a:vt0p}{env:vt0p
} dllist_foreach$cont (x: &a, env: &env): bool
fun{
a:vt0p}{env:vt0p
} dllist_foreach$fwork (x: &a, env: &env >> _): void

fun{a:vt0p}
dllist_foreach (xs: !Dllist (INV(a))): void
fun{
a:vt0p}{env:vt0p
} dllist_foreach_env
  (xs: !Dllist (INV(a)), env: &env >> _): void
// end of [dllist_foreach_env]

(* ****** ****** *)

fun{
a:vt0p}{env:vt0p
} rdllist_foreach$cont (x: &a, env: &env): bool
fun{
a:vt0p}{env:vt0p
} rdllist_foreach$fwork (x: &a, env: &env >> _): void

fun{a:vt0p}
rdllist_foreach (xs: !Dllist (INV(a))): void
fun{
a:vt0p}{env:vt0p
} rdllist_foreach_env
  (xs: !Dllist (INV(a)), env: &env >> _): void
// end of [rdllist_foreach_env]

(* ****** ****** *)
//
fun{}
fprint_dllist$sep (out: FILEref): void
fun{a:vt0p}
fprint_dllist (out: FILEref, xs: !Dllist (INV(a))): void
//
overload fprint with fprint_dllist
//
(* ****** ****** *)
//
fun{}
fprint_rdllist$sep (out: FILEref): void
fun{a:vt0p}
fprint_rdllist (out: FILEref, xs: !Dllist (INV(a))): void
//
(* ****** ****** *)
//
// HX-2013-05: functions of ngc-version
//
(* ****** ****** *)

staload "libats/SATS/gnode.sats"

(* ****** ****** *)

stadef mytkind = $extkind"libats_dllist"

(* ****** ****** *)

typedef g2node0 (a:vt0p) = gnode0 (mytkind, a)
typedef g2node1 (a:vt0p) = gnode1 (mytkind, a)

(* ****** ****** *)

fun{a:vt0p}
dllist_cons_ngc{r:int}
  (x: g2node1 (a), xs: dllist (INV(a), 0, r)):<!wrt> dllist (a, 0, r+1)
// end of [dllist_cons_ngc]

fun{a:vt0p}
dllist_uncons_ngc{r:int | r > 0}
  (xs: &dllist (INV(a), 0, r) >> dllist (a, 0, r-1)):<!wrt> g2node1 (a)
// end of [dllist_uncons_ngc]

(* ****** ****** *)

fun{a:vt0p}
dllist_snoc_ngc{f:int}
  (xs: dllist (INV(a), f, 1), nx: g2node1 (a)):<!wrt> dllist (a, f+1, 1)
// end of [dllist_snoc_ngc]

fun{a:vt0p}
dllist_unsnoc_ngc{f:int | f > 0}
  (xs: &dllist (INV(a), f, 1) >> dllist (a, f-1, 1)):<!wrt> g2node1 (a)
// end of [dllist_unsnoc_ngc]

(* ****** ****** *)

(* end of [dllist.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: December, 2012 *)

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.linmap_randbst"

(* ****** ****** *)

#include "./SHARE/linmap.hats"
#include "./SHARE/linmap_node.hats"

(* ****** ****** *)

fun{} linmap_randbst_initize (): void

(* ****** ****** *)

fun{} linmap_randbst_random_m_n
  {m,n:nat} (m: int m, n: int n): natLt (2)
// end of [linmap_randbst_random_m_n]

(* ****** ****** *)

(* end of [linmap_randbst.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2013 *)

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.sllist"

(* ****** ****** *)

typedef SHR(a:type) = a // for commenting purpose
typedef NSH(a:type) = a // for commenting purpose

(* ****** ****** *)

(*
**
** HX-2013-03:
** sllist (a, n) means that there are n elements in the list.
**
*)
absvtype
sllist_vtype (a:viewt@ype+, n:int) = ptr
stadef sllist = sllist_vtype // HX: shorthand
//
vtypedef Sllist (a:vt0p) = [n:int] sllist (a, n)
vtypedef Sllist0 (a:vt0p) = [n:int | n >= 0] sllist (a, n)
vtypedef Sllist1 (a:vt0p) = [n:int | n >= 1] sllist (a, n)
//
(* ****** ****** *)

castfn
sllist2ptr {a:vt0p} (xs: !Sllist (INV(a))):<> Ptr0
castfn
sllist2ptr1 {a:vt0p} (xs: !Sllist1 (INV(a))):<> Ptr1

(* ****** ****** *)

praxi
lemma_sllist_param {a:vt0p}
  {n:int} (xs: !sllist (INV(a), n)): [n >= 0] void
// end of [lemma_sllist_param]

(* ****** ****** *)

fun{}
sllist_nil {a:vt0p} ():<> sllist (a, 0)

(* ****** ****** *)

praxi
sllist_free_nil
  {a:vt0p} (xs: sllist (INV(a), 0)): void

(* ****** ****** *)

fun{a:vt0p}
sllist_sing (x: a):<!wrt> sllist (a, 1)

(* ****** ****** *)

fun{a:vt0p}
sllist_cons{n:int}
  (x: a, xs: sllist (INV(a), n)):<!wrt> sllist (a, n+1)
// end of [sllist_cons]

fun{a:vt0p}
sllist_uncons{n:int | n > 0}
  (xs: &sllist (INV(a), n) >> sllist (a, n-1)):<!wrt> (a)
// end of [sllist_uncons]

(* ****** ****** *)

fun{a:vt0p}
sllist_snoc{n:int}
  (xs: sllist (INV(a), n), x: a):<!wrt> sllist (a, n+1)
// end of [sllist_snoc]

fun{a:vt0p}
sllist_unsnoc{n:int | n > 0}
  (xs: &sllist (INV(a), n) >> sllist (a, n-1)):<!wrt> (a)
// end of [sllist_unsnoc]

(* ****** ****** *)

fun{a:t0p}
sllist_make_list
  {n:int} (xs: list (INV(a), n)):<!wrt> sllist (a, n)
// end of [sllist_make_list]

(* ****** ****** *)

fun{a:t0p}
sllist_make_list_vt
  {n:int} (xs: list_vt (INV(a), n)):<!wrt> sllist (a, n)
// end of [sllist_make_list_vt]

(* ****** ****** *)

fun{
} sllist_is_nil
  {a:vt0p}{n:int} (xs: !sllist (INV(a), n)):<> bool (n==0)
fun{
} sllist_is_cons
  {a:vt0p}{n:int} (xs: !sllist (INV(a), n)):<> bool (n > 0)
//
overload iseqz with sllist_is_nil
overload isneqz with sllist_is_cons
//
(* ****** ****** *)

fun{a:vt0p}
sllist_length
  {n:int} (xs: !sllist (INV(a), n)):<> int (n)
//
overload length with sllist_length
//
(* ****** ****** *)

fun{a:t0p}
sllist_get_elt (xs: !Sllist1 (INV(a))): (a)
fun{a:t0p}
sllist_set_elt (xs: !Sllist1 (INV(a)), x0: a): void
fun{a:vt0p}
sllist_getref_elt (xs: !Sllist1 (INV(a))):<> cPtr1 (a)

(* ****** ****** *)

fun{a:vt0p}
sllist_getref_next (xs: !Sllist1 (INV(a))):<> Ptr1

(* ****** ****** *)

fun{a:vt0p}
sllist_getref_elt_at {n:int}
  (xs: !sllist (INV(a), n), i: natLt(n)):<> cPtr1 (a)
// end of [sllist_getref_elt_at]

(* ****** ****** *)

fun{a:t0p}
sllist_get_elt_at {n:int}
  (xs: !sllist (INV(a), n), i: natLt(n)):<> (a)
overload [] with sllist_get_elt_at
fun{a:t0p}
sllist_set_elt_at {n:int}
  (xs: !sllist (INV(a), n), i: natLt(n), x0: a):<!wrt> void
overload [] with sllist_set_elt_at

(* ****** ****** *)

fun{a:vt0p}
sllist_getref_at{n:int}
  (xs: &sllist (INV(a), n), i: natLte(n)):<> Ptr1
// end of [sllist_getref_at]

fun{a:vt0p}
sllist_insert_at {n:int}
  (xs: sllist (INV(a), n), i: natLte(n), x0: a):<!wrt> sllist (a, n+1)
// end of [sllist_insert_at]

fun{a:vt0p}
sllist_takeout_at {n:int}
  (xs: &sllist (INV(a), n) >> sllist (a, n-1), i: natLt(n)):<!wrt> (a)
// end of [sllist_takeout_at]

(* ****** ****** *)

fun{a:vt0p}
sllist_append
  {n1,n2:int} (
  xs1: sllist (INV(a), n1), xs2: sllist (a, n2)
) :<!wrt> sllist (a, n1+n2) // end of [sllist_append]

(* ****** ****** *)

fun{a:vt0p}
sllist_reverse
  {n:int} (xs: sllist (INV(a), n)):<!wrt> sllist (a, n)
// end of [sllist_reverse]

(* ****** ****** *)

fun{a:vt0p}
sllist_reverse_append
  {n1,n2:int} (
  xs1: sllist (INV(a), n1), xs2: sllist (a, n2)
) :<!wrt> sllist (a, n1+n2) // end of [sllist_reverse_append]

(* ****** ****** *)

fun{a:t0p}
sllist_free (xs: Sllist (INV(a))):<!wrt> void

fun{a:vt0p}
sllist_freelin$clear (x: &a >> a?):<!wrt> void
fun{a:vt0p}
sllist_freelin (xs: Sllist (INV(a))):<!wrt> void

(* ****** ****** *)

fun{
a:vt0p}{b:vt0p
} sllist_map$fopr (x: &a): b
fun{
a:vt0p}{b:vt0p
} sllist_map {n:int} (xs: !sllist (a, n)): sllist (b, n)

(* ****** ****** *)
//
fun{
a:vt0p}{env:vt0p
} sllist_foreach$cont (x: &a, env: &env): bool
fun{
a:vt0p}{env:vt0p
} sllist_foreach$fwork (x: &a, env: &env >> _): void
//
fun{a:vt0p}
sllist_foreach (xs: !Sllist (INV(a))): void
fun{
a:vt0p}{env:vt0p
} sllist_foreach_env
  (xs: !Sllist (INV(a)), env: &env >> _): void
// end of [sllist_foreach_env]
//
(* ****** ****** *)
//
fun{}
fprint_sllist$sep (out: FILEref): void
//
fun{a:vt0p}
fprint_sllist
  (out: FILEref, xs: !Sllist (INV(a))): void
// end of [fprint_sllist]
//
overload fprint with fprint_sllist
//
(* ****** ****** *)
//
// HX-2013-05: functions of ngc-version
//
(* ****** ****** *)

staload "libats/SATS/gnode.sats"

(* ****** ****** *)

stadef mytkind = $extkind"libats_sllist"

(* ****** ****** *)

typedef g2node0 (a:vt0p) = gnode0 (mytkind, a)
typedef g2node1 (a:vt0p) = gnode1 (mytkind, a)

(* ****** ****** *)

(*
** HX: this is O(1)-time
*)
fun{a:vt0p}
sllist_cons_ngc{n:int}
  (nx: g2node1(a), xs: sllist(INV(a), n)):<!wrt> sllist (a, n+1)
// end of [sllist_cons_ngc]

(*
** HX: this is O(1)-time
*)
fun{a:vt0p}
sllist_uncons_ngc{n:pos}
  (xs: &sllist (INV(a), n) >> sllist (a, n-1)):<!wrt> g2node1 (a)
// end of [sllist_uncons_ngc]

(* ****** ****** *)

(*
** HX: this is O(n)-time
*)
fun{a:vt0p}
sllist_snoc_ngc{n:int}
  (xs: sllist(INV(a), n), nx: g2node1(a)):<!wrt> sllist (a, n+1)
// end of [sllist_snoc_ngc]

(*
** HX: this is O(n)-time
*)
fun{a:vt0p}
sllist_unsnoc_ngc{n:pos}
  (xs: &sllist (INV(a), n) >> sllist (a, n-1)):<!wrt> g2node1 (a)
// end of [sllist_unsnoc_ngc]

(* ****** ****** *)

(* end of [sllist.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** A functional map implementation based on lists
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: December, 2012 *)

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.funmap_list"

(* ****** ****** *)

#include "./SHARE/funmap.hats"

(* ****** ****** *)

(* end of [funmap_list.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// HX-2013-05: linear deque based on circular doubly-linked list (dllist)
//
(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.lindeque_dllist"

(* ****** ****** *)

#include "./SHARE/lindeque.hats"

(* ****** ****** *)
//
// HX-2013-05: functions of ngc-version
//
(* ****** ****** *)

staload "libats/SATS/dllist.sats"

(* ****** ****** *)
//
fun{a:vt0p}
lindeque_insert_at_ngc
  {n:int}{i:nat | i <= n}
(
  dq: &deque (INV(a), n) >> deque (a, n+1), i: int i, x: g2node1(a)
) : void // end of [lindeque_insert_at_ngc]
//
fun{a:vt0p}
lindeque_insert_atbeg_ngc{n:int}
(
  dq: &deque (INV(a), n) >> deque (a, n+1), nx: g2node1(a)
) :<!wrt> void // end of [lindeque_insert_atbeg_ngc]
fun{a:vt0p}
lindeque_insert_atend_ngc{n:int}
(
  dq: &deque (INV(a), n) >> deque (a, n+1), nx: g2node1(a)
) :<!wrt> void // end of [lindeque_insert_atend_ngc]
//
(* ****** ****** *)
//
fun{a:vt0p}
lindeque_takeout_at_ngc{n:int}{i:nat | i < n}
(
  dq: &deque (INV(a), n) >> deque (a, n-1), i: int i
) : g2node1(a) // end of [lindeque_takeout_at_ngc]
//
fun{a:vt0p}
lindeque_takeout_atbeg_ngc{n:pos}
  (dq: &deque (INV(a), n) >> deque (a, n-1)):<!wrt> g2node1(a)
fun{a:vt0p}
lindeque_takeout_atend_ngc{n:pos}
  (dq: &deque (INV(a), n) >> deque (a, n-1)):<!wrt> g2node1(a)
//
(* ****** ****** *)

fun{a:vt0p}
lindeque2dllist{n:int} (dq: deque (INV(a), n)):<!wrt> dllist (a, 0, n)
// end of [fun]

(* ****** ****** *)

(* end of [lindeque_dllist.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: July, 2013 *)

(* ****** ****** *)
//
// HX-2013-07:
// For matrices
// (that is, 2D-arrays) of column-major style
//
(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.gmatrow"

(* ****** ****** *)

staload "libats/SATS/gvector.sats"
staload "libats/SATS/gmatrix.sats"

(* ****** ****** *)

praxi
lemma_gmatrow_param
  {a:t0p}{m,n:int}{ld:int}
  (M: &GMR(a, m, n, ld)): [m >= 0; n >= 1; ld >= n] void
praxi
lemma_gmatrow_v_param
  {a:t0p}{l:addr}{m,n:int}{ld:int}
  (pf: !GMR(a, l, m, n, ld)): [m >= 0; n >= 1; ld >= n] void

(* ****** ****** *)

praxi
matrix2gmatrow
  {a:t0p}{l:addr}{m,n:int}
  (A: &matrix (INV(a), m, n) >> GMR(a, m, n, n)): void
praxi
matrix2gmatrow_v
  {a:t0p}{l:addr}{m,n:int}
  (pf: matrix_v (INV(a), l, m, n)):<prf> GMR(a, l, m, n, n)
// end [matrix2gmatrow_v]

(* ****** ****** *)

praxi
gmatrow2matrix
  {a:t0p}{l:addr}{m,n:int}
  (V: &GMR(a, m, n, n) >> matrix (a, m, n)): void
// end [gmatrow2matrix]
praxi
gmatrow2matrix_v
  {a:t0p}{l:addr}{m,n:int}
  (pf: GMR(a, l, m, n, n)):<prf> matrix_v (a, l, m, n)
// end [gmatrow2matrix_v]

(* ****** ****** *)
//
// HX: 0 for row
//
praxi
gmatrow_v_renil0
  {a1,a2:t0p}
  {l:addr}{n:int}{ld:int} (GMR(a1, l, 0, n, ld)): GMR(a2, l, 0, n, ld)
//
praxi
gmatrow_v_cons0
  {a:t0p}{l:addr}
  {m,n:int}{ld:int}
(
  GVT(a, l, n, 1)
, GMR(a, l+ld*sizeof(a), m, n, ld)
) : GMR(a, l, m+1, n, ld)
praxi
gmatrow_v_uncons0
  {a:t0p}{l:addr}
  {m,n:int | m > 0}{ld:int}
  (GMR(a, l, m, n, ld))
:
(
  GVT(a, l, n, 1), GMR(a, l+ld*sizeof(a), m-1, n, ld)
) (* end of [gmatrow_v_uncons0] *)
//
(* ****** ****** *)
//
// HX: 1 for col
//
praxi
gmatrow_v_renil1
  {a1,a2:t0p}
  {l:addr}{m:int}{ld:int} (GMR(a1, l, m, 0, ld)): GMR(a2, l, m, 0, ld)
//
praxi
gmatrow_v_cons1
  {a:t0p}{l:addr}
  {m,n:int}{ld:int}
(
  GVT(a, l, m, ld)
, GMR(a, l+sizeof(a), m, n, ld)
) : GMR(a, l, m, n+1, ld) // end of [gmatrow_v_cons2]
praxi
gmatrow_v_uncons1
  {a:t0p}{l:addr}
  {m,n:int | n > 0}{ld:int}
  (GMR(a, l, m, n, ld))
: (GVT(a, l, m, ld), GMR(a, l+sizeof(a), m, n-1, ld))
//
(* ****** ****** *)

praxi
gmatrow_v_split1x2
  {a:t0p}{l:addr}
  {m,n:int}{ld:int}
  {j:nat | j <= n}
(
  GMR(a, l, m, n, ld), int j
) :
(
  GMR(a, l            , m, j  , ld)
, GMR(a, l+j*sizeof(a), m, n-j, ld)
) (* end of [gmatrow_v_split1x2] *)

praxi
gmatrow_v_unsplit1x2
  {a:t0p}{l:addr}
  {m,j,j2:int}{ld:int}
(
  GMR(a, l            , m, j , ld)
, GMR(a, l+j*sizeof(a), m, j2, ld)
) : GMR(a, l, m, j+j2, ld) // end of [praxi]

(* ****** ****** *)

praxi
gmatrow_v_split_2x1
  {a:t0p}{l:addr}
  {m,n:int}{ld:int}
  {i,j:nat | i <= m}
(
  GMR(a, l, m, n, ld), int i
) :
(
  GMR(a, l               , i  , n, ld)
, GMR(a, l+i*ld*sizeof(a), m-i, n, ld)
) (* end of [gmatrow_v_split_2x1] *)

praxi
gmatrow_v_unsplit_2x1
  {a:t0p}{l:addr}
  {i,i2,n:int}{ld:int}
(
  GMR(a, l               , i , n, ld)
, GMR(a, l+i*ld*sizeof(a), i2, n, ld)
) : GMR(a, l, i+i2, n, ld) // end of [praxi]

(* ****** ****** *)

praxi
gmatrow_v_split_2x2
  {a:t0p}{l:addr}
  {m,n:int}{ld:int}
  {i,j:nat | i <= m; j <= n}
(
  GMR(a, l, m, n, ld), int i, int j
) :
(
  GMR(a, l                           , i  , j  , ld)
, GMR(a, l               +j*sizeof(a), i  , n-j, ld)
, GMR(a, l+i*ld*sizeof(a)            , m-i, j  , ld)
, GMR(a, l+i*ld*sizeof(a)+j*sizeof(a), m-i, n-j, ld)
) (* end of [gmatrow_v_split_2x2] *)

praxi
gmatrow_v_unsplit_2x2
  {a:t0p}{l:addr}
  {i,i2,j,j2:int}{ld:int}
(
  GMR(a, l                           , i , j , ld)
, GMR(a, l               +j*sizeof(a), i , j2, ld)
, GMR(a, l+i*ld*sizeof(a)            , i2, j , ld)
, GMR(a, l+i*ld*sizeof(a)+j*sizeof(a), i2, j2, ld)
) : GMR(a, l, i+i2, j+j2, ld) // end of [praxi]

(* ****** ****** *)

fun{a:t0p}
gmatrow_get_at
  {m,n:int}{ld:int}
(
  M: &GMR(a, m, n, ld), int(ld), i: natLt(m), j: natLt(n)
) : (a) // end of [gmatrow_get_at]
fun{a:t0p}
gmatrow_set_at
  {m,n:int}{ld:int}
(
  M: &GMR(a, m, n, ld), int(ld), i: natLt(m), j: natLt(n), x: a
) : void // end of [gmatrow_set_at]

(* ****** ****** *)

fun{a:t0p}
gmatrow_getref_at
  {m,n:int}{ld:int}
(
  M: &GMR(a, m, n, ld), int(ld), i: natLt(m), j: natLt(n)
) : cPtr1(a) // end of [gmatrow_getref_at]

(* ****** ****** *)

fun{a:t0p}
gmatrow_getref_row_at
  {m,n:int}{ld:int}
(
  M: &GMR(a, m, n, ld), int(ld), i: natLt(m)
) : cPtr1(GVT(a, n, 1(*d*))) // endfun

fun{a:t0p}
gmatrow_getref_col_at
  {m,n:int}{ld:int}
(
  M: &GMR(a, m, n, ld), int(ld), j: natLt(n)
) : cPtr1(GVT(a, m, ld)) // endfun

(* ****** ****** *)

fun{a:t0p}
gmatrow_interchange_row
  {m,n:int}{ld:int}
(
  M: &GMR(a, m, n, ld)
, n: int n, int(ld), i1: natLt(m), i2: natLt(m)
) : void // end of [gmatrow_interchange_row]
fun{a:t0p}
gmatrow_interchange_col
  {m,n:int}{ld:int}
(
  M: &GMR(a, m, n, ld)
, m: int m, int(ld), j1: natLt(n), j2: natLt(n)
) : void // end of [gmatrow_interchange_col]

(* ****** ****** *)

fun{a:t0p}
gmatrow_copyto
  {m,n:int}{ld1,ld2:int}
(
  M1: &GMR(a, m, n, ld1)
, M2: &GMR(a?, m, n, ld2) >> GMR(a, m, n, ld2)
, int(m), int(n), int(ld1), int(ld2)
) : void // end of [gmatrow_copyto]

fun{a:t0p}
gmatrow_transpto
  {m,n:int}{ld1,ld2:int}
(
  M1: &GMR(a, m, n, ld1)
, M2: &GMR(a?, n, m, ld2) >> GMR(a, n, m, ld2)
, int(m), int(n), int(ld1), int(ld2)
) : void // end of [gmatrow_transpto]

(* ****** ****** *)

fun{a:t0p}
gmatrow_ptr_split_2x2
  {l:addr}
  {m,n:int}{ld:int}
  {i,j:nat | i <= m; j <= n}
(
  pf: GMR(a, l, m, n, ld) | ptr(l), int(ld), int(i), int(j)
) : [l01,l10,l11:addr]
(
  GMR(a, l  , i  , j  , ld)
, GMR(a, l01, i  , n-j, ld)
, GMR(a, l10, m-i, j  , ld)
, GMR(a, l11, m-i, n-j, ld)
, (
  GMR(a, l  , i  , j  , ld)
, GMR(a, l01, i  , n-j, ld)
, GMR(a, l10, m-i, j  , ld)
, GMR(a, l11, m-i, n-j, ld)
) -<prf> GMR(a, l, m, n, ld)
| ptr(l01), ptr(l10), ptr(l11)
) (* end of [gmatrow_ptr_split_2x2] *)

(* ****** ****** *)

fun{
a:t0p}{env:vt0p
} gmatrow_foreachrow$fwork{n:int}
(
  row: &GVT (a, n, 1) >> _, n: int n, env: &(env) >> _
) : void // end of [gmatrow_foreachrow$fwork]

fun{
a:t0p
} gmatrow_foreachrow{m,n:int}{ld:int}
(
  M: &gmatrow(a, m, n, ld) >> _, int(m), int(n), int(ld)
) : void // end of [gmatrow_foreachrow]
fun{
a:t0p}{env:vt0p
} gmatrow_foreachrow_env{m,n:int}{ld:int}
(
  M: &gmatrow(a, m, n, ld) >> _, int(m), int(n), int(ld), env: &(env) >> _
) : void // end of [gmatrow_foreachrow_env]

(* ****** ****** *)

fun{
a1,a2:t0p}{env:vt0p
} gmatrow_foreachrow2$fwork{n:int}
(
  row1: &GVT (a1, n, 1) >> _
, row2: &GVT (a2, n, 1) >> _
, n: int (n), env: &(env) >> _
) : void // end of [gmatrow_foreachrow$fwork]

fun{
a1,a2:t0p
} gmatrow_foreachrow2
  {m,n:int}{ld1,ld2:int}
(
  M1: &gmatrow(a1, m, n, ld1) >> _
, M2: &gmatrow(a2, m, n, ld2) >> _
, int(m), int(n), int(ld1), int(ld2)
) : void // end of [gmatrow_foreachrow]
fun{
a1,a2:t0p}{env:vt0p
} gmatrow_foreachrow2_env
  {m,n:int}{ld1,ld2:int}
(
  M1: &gmatrow(a1, m, n, ld1) >> _
, M2: &gmatrow(a2, m, n, ld2) >> _
, int(m), int(n), int(ld1), int(ld2)
, env: &(env) >> _
) : void // end of [gmatrow_foreachrow2_env]

(* ****** ****** *)

(* end of [gmatrix_row.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmmhwxiATgmailDOTcom
// Time: October, 2010
//
(* ****** ****** *)
//
// HX: generic lists (fully indexed)
//
(* ****** ****** *)
//
// HX-2012-11-27:
// ported to ATS/Postiats from ATS/Anairiats
//
(* ****** ****** *)

#define
ATS_PACKNAME "ATSLIB.libats.gflist"

(* ****** ****** *)

staload "libats/SATS/ilist_prf.sats" // for intseqs

(* ****** ****** *)

(*
// HX: [stamped_t] is introduced in prelude/basics_pre.sats
// HX: [stamped_vt] is introduced in prelude/basics_pre.sats
*)

(* ****** ****** *)

datatype
gflist (
  a:t@ype+, ilist(*ind*)
) =
  | gflist_nil
      (a, ilist_nil) of ()
    // end of [gflist_nil]
  | {x:int}
    {xs:ilist}
    gflist_cons
      (a, ilist_cons (x, xs)) of (stamped_t (a, x), gflist (a, xs))
    // end of [gflist_cons]
// end of [gflist]

(* ****** ****** *)

datavtype
gflist_vt (
  a:vt@ype+, ilist(*ind*)
) =
  | gflist_vt_nil
      (a, ilist_nil) of ()
    // end of [gflis_vt_nil]
  | {x:int}
    {xs:ilist}
    gflist_vt_cons
      (a, ilist_cons (x, xs)) of (stamped_vt (a, x), gflist_vt (a, xs))
    // end of [gflist_vt_cons]
// end of [gflist_vt]

(* ****** ****** *)
//
#define
gflist_sing(x) gflist_cons(x, gflist_nil())
#define
gflist_vt_sing(x) gflist_vt_cons(x, gflist_vt_nil())
//
(* ****** ****** *)

castfn
gflist2list
  {a:t@ype}{xs:ilist}
(
  gflist(INV(a), xs)
) :<> [n:nat] (LENGTH (xs, n) | list (a, n))
// end of [gflist2list]

castfn
list2gflist
  {a:t@ype}{n:int}
(
  xs: list(INV(a), n)
) :<> [xs:ilist] (LENGTH(xs, n) | gflist (a, xs))
// end of [list2gflist]

(* ****** ****** *)

castfn
gflist2list_vt
  {a:vt@ype}{xs:ilist}
(
  gflist_vt(INV(a), xs)
) :<> [n:nat] (LENGTH (xs, n) | list_vt (a, n))
// end of [gflist2list_vt]

castfn
list2gflist_vt
  {a:vt@ype}{n:int}
(
  xs: list_vt(INV(a), n)
) :<> [xs:ilist] (LENGTH(xs, n) | gflist_vt (a, xs))
// end of [list2gflist_vt]

(* ****** ****** *)

castfn
gflist_vt2t
  {a:t@ype}{xs:ilist}
  (xs: gflist_vt(INV(a), xs)):<!wrt> gflist (a, xs)
// end of [gflist_vt2t]

(* ****** ****** *)

fun{a:t0p}
gflist_length
  {xs:ilist}
(
  xs: gflist(INV(a), xs)
) :<> [n:nat] (LENGTH (xs, n) | int n)
// end of [gflist_length]

(* ****** ****** *)

fun{a:t0p}
gflist_snoc
  {xs:ilist}{x0:int}
(
  xs: gflist (a, xs), x0: stamped_t (a, x0)
) : [xsx:ilist] (SNOC (xs, x0, xsx) | gflist_vt (a, xsx))

(* ****** ****** *)
//
fun{a:t0p}
gflist_copy
  {xs:ilist}
  (xs: gflist(INV(a), xs)):<> gflist_vt (a, xs)
//
(* ****** ****** *)

fun{a:t0p}
gflist_append
  {xs1,xs2:ilist}
(
  xs1: gflist (INV(a), xs1), xs2: gflist (a, xs2)
) :<> [res:ilist] (APPEND (xs1, xs2, res) | gflist (a, res))
// end of [gflist_append]

(* ****** ****** *)

fun{a:t0p}
gflist_revapp
  {xs1,xs2:ilist}
(
  xs1: gflist (INV(a), xs1), xs2: gflist (a, xs2)
) :<> [res:ilist] (REVAPP (xs1, xs2, res) | gflist (a, res))
// end of [gflist_revapp]

(* ****** ****** *)

fun{a:t0p}
gflist_revapp1_vt
  {xs1,xs2:ilist}
(
  xs1: gflist_vt (INV(a), xs1), xs2: gflist (a, xs2)
) :<!wrt> [res:ilist] (REVAPP (xs1, xs2, res) | gflist (a, res))
// end of [gflist_revapp1_vt]

fun{a:t0p}
gflist_revapp2_vt
  {xs1,xs2:ilist}
(
  xs1: gflist (INV(a), xs1), xs2: gflist_vt (a, xs2)
) :<!wrt> [res:ilist] (REVAPP (xs1, xs2, res) | gflist_vt (a, res))
// end of [gflist_revapp2_vt]

(* ****** ****** *)

fun{a:t0p}
gflist_reverse
  {xs:ilist}
(
  xs: gflist (INV(a), xs)
) :<> [ys:ilist] (REVERSE (xs, ys) | gflist_vt (a, ys))
// end of [gflist_reverse]

(* ****** ****** *)
//
fun{a:t0p}
gflist_get_at
  {xs:ilist}{x0:int}{i:int}
(
  pf: NTH(x0, xs, i) | xs: gflist(INV(a), xs), i: int(i)
) : stamped_t(a, x0) // end-of-function
//
(* ****** ****** *)
//
fun{a:t0p}
gflist_mergesort
  {xs:ilist}
(
  xs: gflist (INV(a), xs)
) : [ys:ilist] (SORT (xs, ys) | gflist_vt (a, ys))
//
fun{a:t0p}
gflist_mergesort$cmp
  {x1,x2:int}
  (x1: stamped_t (a, x1), x2: stamped_t (a, x2)): int(sgn(x1-x2))
//
(* ****** ****** *)

(* end of [gflist.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
**
** A list-based queue implementation
**
*)

(* ****** ****** *)

(*
**
** Author: Hongwei Xi
** Authoremail: hwxiATcsDOTbuDOTedu
** Time: July, 2010
** It is based on an earlier version done in October, 2008
**
*)

(* ****** ****** *)
//
// HX-2012-12: ported to ATS/Postitats from ATS/Anairiats
//
(* ****** ****** *)

%{#
#include "libats/CATS/qlist.cats"
%} // end of [%{#]

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.qlist"

(* ****** ****** *)
//
absvtype
qlist_vtype (a:vt@ype+, n:int) = ptr
//
vtypedef
qlist (a:vt0p, n:int) = qlist_vtype (a, n)
//
vtypedef
qlist (a:vt0p) = [n:int] qlist_vtype (a, n)
//
vtypedef
qlist0 (a:vt0p) = [n:int | n >= 0] qlist (a, n)
//
(* ****** ****** *)

praxi
lemma_qlist_param
  {a:vt0p}{n:int} (q: !qlist (INV(a), n)): [n>=0] void
// end of [lemma_qlist_param]

(* ****** ****** *)

fun{}
qlist_make_nil {a:vt0p} (): qlist (a, 0)
fun{}
qlist_free_nil {a:vt0p} (q: qlist (a, 0)):<!wrt> void

(* ****** ****** *)

fun{a:vt0p}
qlist_is_nil
  {n:int} (q: !qlist (a, n)):<> bool (n == 0)
fun{a:vt0p}
qlist_isnot_nil
  {n:int} (q: !qlist (INV(a), n)):<> bool (n > 0)
//
overload iseqz with qlist_is_nil
overload isneqz with qlist_isnot_nil
//
(* ****** ****** *)

fun{a:vt0p}
qlist_length {n:int} (q: !qlist (INV(a), n)):<> int (n)
//
overload length with qlist_length
//
(* ****** ****** *)

fun{}
fprint_qlist$sep (out: FILEref): void
fun{a:vt0p}
fprint_qlist (out: FILEref, q: !qlist (INV(a))): void
fun{a:vt0p}
fprint_qlist_sep (out: FILEref, q: !qlist (INV(a)), sep: string): void
overload fprint with fprint_qlist
overload fprint with fprint_qlist_sep

(* ****** ****** *)

fun{a:vt0p}
qlist_insert{n:int}
(
  q: !qlist (INV(a), n) >> qlist (a, n+1), x: a
) :<!wrt> void // end of [qlist_insert]

(* ****** ****** *)

fun{a:vt0p}
qlist_takeout{n:pos}
  (q: !qlist (INV(a), n) >> qlist (a, n-1)):<!wrt> (a)
fun{a:vt0p}
qlist_takeout_opt (q: !qlist (INV(a)) >> _):<!wrt> Option_vt(a)

(* ****** ****** *)

(*
** HX: this operation is O(1)
*)
fun{
} qlist_takeout_list
  {a:vt0p}{n:int}
  (q: !qlist (INV(a), n) >> qlist (a, 0)):<!wrt> list_vt (a, n)
// end of [qlist_takeout_list]

(* ****** ****** *)
//
fun{
a:vt0p
} qlist_foreach (q: !qlist (INV(a))): void
fun{
a:vt0p}{env:vt0p
} qlist_foreach_env (q: !qlist (INV(a)), env: &(env) >> _): void
//
fun{
a:vt0p}{env:vt0p
} qlist_foreach$cont (x: &a, env: &env): bool
fun{
a:vt0p}{env:vt0p
} qlist_foreach$fwork (x: &a >> _, env: &(env) >> _): void
//
(* ****** ****** *)
//
abst@ype
qstruct_tsize = $extype"atslib_qlist_struct"
absvt@ype
qstruct_vt0ype (a:vt@ype+, n:int) = qstruct_tsize
//
stadef qstruct = qstruct_vt0ype
stadef qstruct = qstruct_tsize // HX: order significant
//
viewtypedef
qstruct (a:vt0p) = [n:int] qstruct (a, n)
viewtypedef
qstruct0 (a:vt0p) = [n:nat] qstruct (a, n)
//
(* ****** ****** *)

fun{
} qstruct_initize
  {a:vt0p} (q: &qstruct? >> qstruct (a, 0)):<!wrt> void
// end of [qstruct_initize]

praxi
qstruct_uninitize
  {a:vt0p} (q: &qstruct (a, 0) >> qstruct?) :<prf> void
// end of [qstruct_uninitize]

(* ****** ****** *)

praxi
qstruct_objfize
  {a:vt0p}{l:addr}{n:int}
(
  pf: qstruct (INV(a), n) @ l | p: !ptrlin l >> qlist (a, n)
) :<prf> mfree_ngc_v (l) // endfun

praxi
qstruct_unobjfize
  {a:vt0p}{l:addr}{n:int}
(
  pf: mfree_ngc_v (l) | p: ptr l, q: !qlist (INV(a), n) >> ptrlin l
) :<prf> qstruct (a, n) @ l // endfun

(* ****** ****** *)

fun{a:vt0p}
qstruct_insert{n:int}
  (q: &qstruct (INV(a), n) >> qstruct (a, n+1), x: a):<!wrt> void
// end of [qstruct_insert]

(* ****** ****** *)
//
fun{a:vt0p}
qstruct_takeout{n:pos}
  (q: &qstruct (INV(a), n) >> qstruct (a, n-1)):<!wrt> (a)
//
(* ****** ****** *)

fun{}
qstruct_takeout_list
  {a:vt0p}{n:int}
  (q: &qstruct (INV(a), n) >> qstruct (a, 0)):<!wrt> list_vt (a, n)
// end of [qstruct_takeout_list]

(* ****** ****** *)
//
// HX: ngc-functions do not make use of malloc/free
//
(* ****** ****** *)

absvtype
qlist_node_vtype (a:vt@ype+, l:addr) = ptr

(* ****** ****** *)

stadef mynode = qlist_node_vtype
vtypedef mynode (a) = [l:addr] mynode (a, l)
vtypedef mynode0 (a) = [l:addr | l >= null] mynode (a, l)
vtypedef mynode1 (a) = [l:addr | l >  null] mynode (a, l)

(* ****** ****** *)

castfn
mynode2ptr
  {a:vt0p}{l:addr} (nx: !mynode (INV(a), l)):<> ptr (l)
// end of [mynode2ptr]

(* ****** ****** *)
//
fun{}
mynode_null {a:vt0p} (): mynode (a, null)
//
praxi
mynode_free_null {a:vt0p} (nx: mynode (a, null)): void
//
(* ****** ****** *)

fun{a:vt0p}
mynode_make_elt (x: a):<!wrt> mynode1 (a)

fun{a:vt0p}
mynode_getref_elt (nx: !mynode1 (INV(a))):<> cPtr1 (a)

fun{a:vt0p}
mynode_free_elt
  (nx: mynode1 (INV(a)), res: &(a?) >> a):<!wrt> void
// end of [mynode_free_elt]

fun{a:vt0p}
mynode_getfree_elt (nx: mynode1 (INV(a))):<!wrt> a

(* ****** ****** *)

fun{a:vt0p}
qlist_insert_ngc (*last*)
  {n:int} (
  q: !qlist (INV(a), n) >> qlist (a, n+1), nx: mynode1 (a)
) :<!wrt> void // end of [qlist_insert_ngc]

(* ****** ****** *)

fun{a:vt0p}
qlist_takeout_ngc (*first*)
  {n:int | n > 0}
  (q: !qlist (INV(a), n) >> qlist (a, n-1)):<!wrt> mynode1 (a)
// end of [qlist_takeout_ngc]

(* ****** ****** *)

(* end of [qlist.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: July, 2013 *)

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.refcount"

(* ****** ****** *)
//
absvtype // invariant
refcnt_vt0ype_vtype(a:vt@ype) = ptr
//
stadef refcnt = refcnt_vt0ype_vtype
//
(* ****** ****** *)

fun
{a:vt0p}
refcnt(x0: a): refcnt(a)
fun{a:vt0p}
refcnt_make_elt(x0: a): refcnt(a)

(* ****** ****** *)
//
fun{a:vt0p}
refcnt_get_count(!refcnt(a)): intGte(1)
//
(* ****** ****** *)

fun{a:vt0p}
refcnt_incref (!refcnt(a)): refcnt(a)

(* ****** ****** *)

fun{a:vt0p}
refcnt_decref
(
  rfc: refcnt(a), x: &a? >> opt(a, b)
) : #[b:bool] bool(b) // end-of-fun

fun{a:vt0p}
refcnt_decref_opt (rfc: refcnt(a)): Option_vt(a)

(* ****** ****** *)

fun{a:vt0p}
refcnt_vtakeout
  (rfc: !refcnt(a))
: [l:addr] (a @ l, a @ l -<lin,prf> void | ptr l)
// end of [refcnt_vtakeout]

(* ****** ****** *)

(* end of [refcount.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
**
** An array-based stack implementation
**
*)

(* ****** ****** *)

(*
**
** Author: Hongwei Xi
** Authoremail: gmhwxi AT gmail DOT com
** Start time: September, 2013
**
*)

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.stkarray"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

%{#
#include "libats/CATS/stkarray.cats"
%} // end of [%{#]

(* ****** ****** *)
//
absvtype
stkarray_vtype (a:vt@ype+, m:int, n:int) = ptr
//
(* ****** ****** *)
//
stadef stkarray = stkarray_vtype
//
vtypedef
stkarray
  (a:vt0p) = [m,n:int] stkarray_vtype (a, m, n)
//
(* ****** ****** *)

abst@ype
stkarray_tsize = $extype"atslib_stkarray_struct"

(* ****** ****** *)

praxi
lemma_stkarray_param
  {a:vt0p}{m,n:int}
  (!stkarray (INV(a), m, n)): [m >= n; n >= 0] void
// end of [lemma_stkarray_param]

(* ****** ****** *)

fun{a:vt0p}
stkarray_make_cap
  {m:int} (cap: size_t(m)):<!wrt> stkarray (a, m, 0)
// end of [stkarray_make_cap]

(* ****** ****** *)

fun
stkarray_make_ngc__tsz
  {a:vt0p}
  {l:addr}{m:int}
(
  stkarray_tsize? @ l
| ptr(l), arrayptr(a?, m), size_t(m), sizeof_t(a)
) :<!wrt> (mfree_ngc_v (l) | stkarray (a, m, 0)) = "mac#%"

(* ****** ****** *)

fun
stkarray_free_nil
  {a:vt0p}{m:int}
  (stk: stkarray (a, m, 0)):<!wrt> void = "mac#%"
// end of [stkarray_free_nil]

fun
stkarray_getfree_arrayptr
  {a:vt0p}{m,n:int}
  (stk: stkarray (a, m, n)):<!wrt> arrayptr (a, n) = "mac#%"
// end of [stkarray_getfree_arrayptr]

(* ****** ****** *)
//
fun{a:vt0p}
stkarray_get_size
  {m,n:int} (stk: !stkarray (INV(a), m, n)):<> size_t(n)
fun{a:vt0p}
stkarray_get_capacity
  {m,n:int} (stk: !stkarray (INV(a), m, n)):<> size_t(m)
//
(* ****** ****** *)

fun stkarray_get_ptrbeg{a:vt0p}
  {m,n:int} (stk: !stkarray (INV(a), m, n)):<> Ptr1 = "mac#%"
// end of [stkarray_get_ptrbeg]

(* ****** ****** *)
//
fun
stkarray_is_nil
  {a:vt0p}{m,n:int}
  (stk: !stkarray (INV(a), m, n)):<> bool (n==0) = "mac#%"
fun
stkarray_isnot_nil
  {a:vt0p}{m,n:int}
  (stk: !stkarray (INV(a), m, n)):<> bool (n > 0) = "mac#%"
//
(* ****** ****** *)
//
fun
stkarray_is_full
  {a:vt0p}{m,n:int}
  (stk: !stkarray (INV(a), m, n)):<> bool (m==n) = "mac#%"
fun
stkarray_isnot_full
  {a:vt0p}{m,n:int}
  (stk: !stkarray (INV(a), m, n)):<> bool (m > n) = "mac#%"
//
(* ****** ****** *)

fun{}
fprint_stkarray$sep (out: FILEref): void
fun{a:vt0p}
fprint_stkarray
  (out: FILEref, stk: !stkarray (INV(a))): void
fun{a:vt0p}
fprint_stkarray_sep
  (out: FILEref, stk: !stkarray (INV(a)), sep: string): void
overload fprint with fprint_stkarray
overload fprint with fprint_stkarray_sep

(* ****** ****** *)

fun{a:vt0p}
stkarray_insert
  {m,n:int | m > n}
(
  stk: !stkarray (INV(a), m, n) >> stkarray (a, m, n+1), x0: a
) :<!wrt> void // endfun

(* ****** ****** *)

fun{a:vt0p}
stkarray_insert_opt
  (stk: !stkarray (INV(a)) >> _, x0: a):<!wrt> Option_vt (a)
// end of [stkarray_insert_opt]

(* ****** ****** *)

fun{a:vt0p}
stkarray_takeout
  {m,n:int | n > 0}
(
  stk: !stkarray (INV(a), m, n) >> stkarray (a, m, n-1)
) :<!wrt> (a) // endfun

fun{a:vt0p}
stkarray_takeout_opt
  (stk: !stkarray (INV(a)) >> _):<!wrt> Option_vt (a)
// end of [stkarray_takeout_opt]

(* ****** ****** *)

fun{a:vt0p}
stkarray_getref_top
  {m,n:int | n > 0} (stk: !stkarray (INV(a), m, n)):<> cPtr1 (a)
// end of [stkarray_getref_top]

(* ****** ****** *)
//
symintr stkarray_getref_at
//
fun{a:vt0p}
stkarray_getref_at_int
  {m,n:int}{i:nat | i < n}
  (stk: !stkarray(INV(a), m, n), i: int(i)):<> cPtr1 (a)
//
fun{a:vt0p}
stkarray_getref_at_size
  {m,n:int}{i:nat | i < n}
  (stk: !stkarray(INV(a), m, n), i: size_t(i)):<> cPtr1 (a)
//
overload stkarray_getref_at with stkarray_getref_at_int
overload stkarray_getref_at with stkarray_getref_at_size
//
(* ****** ****** *)

fun{
a:vt0p}{env:vt0p
} stkarray_foreach$cont (x: &a, env: &env): bool
fun{
a:vt0p}{env:vt0p
} stkarray_foreach$fwork (x: &a >> _, env: &(env) >> _): void
fun{
a:vt0p
} stkarray_foreach{m,n:int}
  (stk: !stkarray (INV(a), m, n)): sizeLte(n)
fun{
a:vt0p}{env:vt0p
} stkarray_foreach_env{m,n:int}
  (stk: !stkarray (INV(a), m, n), env: &(env) >> _): sizeLte(n)

(* ****** ****** *)

(* end of [stkarray.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi (hwxi AT cs DOT bu DOT edu)
// Time: December, 2012
//
(* ****** ****** *)
//
// HX: generic arrays (fully indexed)
//
(* ****** ****** *)
//
// HX-2012-11-30: ported to ATS/Postiats from ATS/Anairiats
//
(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.gfarray"

(* ****** ****** *)

staload "libats/SATS/ilist_prf.sats" // for handling integer sequences

(* ****** ****** *)

(*
// HX: [stamped_vt] is introduced in prelude/basics_pre.sats
*)

(* ****** ****** *)

dataview
gfarray_v
(
  a:vt@ype+, addr, ilist
) =
  | {l:addr}
    gfarray_v_nil (a, l, ilist_nil) of ()
  | {x:int}{xs:ilist}{l:addr}
    gfarray_v_cons (a, l, ilist_cons (x, xs)) of
      (stamped_vt (a, x) @ l, gfarray_v (a, l+sizeof(a), xs))
    // end of [gfarray_v_cons]
// end of [gfarray_v]

(* ****** ****** *)

prfun
gfarray2array_v
  {a:vt@ype}{xs:ilist}{l:addr}
  (pf: gfarray_v (a, l, xs)): [n:nat] (LENGTH (xs, n), array_v (a, l, n))
// end of [gfarray2array_v]

(* ****** ****** *)

prfun
gfarray_v_sing
  {a:vt@ype}{l:addr}{x:int}
  (pf: stamped_vt (a, x) @ l): gfarray_v (a, l, ilist_sing(x))
// end of [gfarray_v_sing]

prfun
gfarray_v_unsing
  {a:vt@ype}{l:addr}{x:int}
  (pf: gfarray_v (a, l, ilist_sing(x))): stamped_vt (a, x) @ l
// end of [gfarray_v_unsing]

(* ****** ****** *)

prfun
gfarray_v_split
  {a:vt0p}
  {l:addr}
  {xs:ilist}
  {n:int}
  {i:nat | i <= n}
(
  pflen: LENGTH (xs, n)
, pfarr: gfarray_v (a, l, xs)
) : [xs1,xs2:ilist]
(
  LENGTH (xs1, i)
, LENGTH (xs2, n-i)
, APPEND (xs1, xs2, xs)
, gfarray_v (a, l, xs1)
, gfarray_v (a, l+i*sizeof(a), xs2)
) // end of [gfarray_v_split]

(* ****** ****** *)

prfun
gfarray_v_unsplit
  {a:vt0p}
  {l:addr}
  {xs1,xs2:ilist}
  {n1:int} (
  pflen: LENGTH (xs1, n1)
, pfarr1: gfarray_v (a, l, xs1)
, pfarr2: gfarray_v (a, l+n1*sizeof(a), xs2)
) : [xs:ilist]
(
  APPEND (xs1, xs2, xs), gfarray_v (a, l, xs)
) // end of [gfarray_v_unsplit]

(* ****** ****** *)

prfun
gfarray_v_extend
  {a:vt0p}
  {l:addr}
  {xs:ilist}{x:int}{xsx:ilist}
  {n:nat}
(
  pflen: LENGTH (xs, n)
, pfsnoc: SNOC (xs, x, xsx)
, pfat: stamped_vt (a, x) @ l+n*sizeof(a)
, pfarr: gfarray_v (a, l, xs)
) : gfarray_v (a, l, xsx) // endfun

(* ****** ****** *)

prfun
gfarray_v_unextend
  {a:vt0p}
  {l:addr}
  {xs:ilist}
  {n:int | n > 0}
(
  pflen: LENGTH (xs, n)
, pfarr: gfarray_v (a, l, xs)
) : [xsf:ilist;x:int] // xsf: the front
(
  SNOC (xsf, x, xs)
, stamped_vt (a, x) @ l+(n-1)*sizeof(a), gfarray_v (a, l, xsf)
) (* end of [gfarray_v_unextend] *)

(* ****** ****** *)

fun
{a:t0p}
gfarray_get_at
  {l:addr}
  {x0:int}{xs:ilist}
  {i0:int}
(
  pf1: NTH(x0, xs, i0)
, pf2: !gfarray_v (a, l, xs)
| gp0: ptr (l), i0: size_t (i0)
) :<> stamped_t (a, x0) // end

(* ****** ****** *)

fun
{a:t0p}
gfarray_set_at
  {l:addr}
  {x0:int}{xs1:ilist}{xs2:ilist}
  {i0:int}
(
  pf1: UPDATE(x0, xs1, i0, xs2)
, pf2: !gfarray_v(a, l, xs1) >> gfarray_v(a, l, xs2)
| gp0: ptr (l), i0: size_t (i0), x0: stamped_t (a, x0)
) :<!wrt> void // end of [gfarray_set_at]

(* ****** ****** *)

fun
{a:vt0p}
gfarray_exch_at
  {l:addr}
  {x0:int}{x1:int}
  {xs1:ilist}{xs2:ilist}
  {i:int}
(
  pf1: NTH(x1, xs1, i)
, pf2: UPDATE(x0, xs1, i, xs2)
, pf3: !gfarray_v (a, l, xs1) >> gfarray_v (a, l, xs2)
| p: ptr l, i: size_t i, x0: &stamped_vt (a, x0) >> stamped_vt (a, x1)
) :<!wrt> void // end of [gfarray_exch_at]

(* ****** ****** *)

(* end of [gfarray.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: December, 2012 *)

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.linmap_avltree"

(* ****** ****** *)

#include "./SHARE/linmap.hats"
#include "./SHARE/linmap_node.hats"

(* ****** ****** *)

fun{
key:t0p;itm:vt0p
} linmap_avltree_height (map: !map (key, itm)):<> intGte (0)

(* ****** ****** *)

(* end of [linmap_avltree.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.fundeque_fngtree"

(* ****** ****** *)

#include "./SHARE/fundeque.hats"

(* ****** ****** *)

(* end of [fundeque_fngtree.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
**
** A hashtable implementation based on linear probing
**
** Contributed by Hongwei Xi (hwxi AT cs DOT bu DOT edu)
** Time: March, 2010
**
*)

(* ****** ****** *)
//
// HX-2014-05:
// ported to ATS/Postitats from ATS/Anairiats
//
(* ****** ****** *)

#define
ATS_PACKNAME "ATSLIB.libats.hashtbl_linprb"

(* ****** ****** *)

#include "./SHARE/hashtbl.hats"

(* ****** ****** *)
//
// HX-2014-05:
// these functions are special for hashtbl_linprb
//
fun{
key,itm:vt0p
} hashtbl_linprb_keyitm_nullize (&(key,itm)? >> _): void
fun{
key,itm:vt0p
} hashtbl_linprb_keyitm_is_null (kx: &(key, itm)): bool
//
(* ****** ****** *)

(* end of [hashtbl_linprb.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2015 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: gmmhwxiATgmailDOTcom
// Start Time: March, 2015
//
(* ****** ****** *)
//
abstype Z() // 0
abstype S(type) // n+1
//
(* ****** ****** *)
//
#define fS(n)
  if n > 0 then S(fS(n-1)) else Z()
//
(* ****** ****** *)
//
dataprop
tieq(type, int) =
  | TIEQZ (Z(), 0)
  | {t:type}{n:nat}
    TIEQS(S(t), n+1) of tieq(t, n)
//
fun
{t:type}
tieq2int
  {n:int}
  (pf: tieq(t, n) | (*void*)): int(n)
//
(* ****** ****** *)
//
abstype B0(type) // 2*n+0
abstype B1(type) // 2*n+1
//
dataprop
ti2eq(type, int) =
  | TI2EQZ (Z(), 0)
  | {t:type}{n:nat}
    TI2EQB0(B0(t), 2*n) of ti2eq(t, n)
  | {t:type}{n:nat}
    TI2EQB1(B1(t), 2*n+1) of ti2eq(t, n)
//
fun
{t:type}
ti2eq2int
  {n:int}
  (pf: ti2eq(t, n) | (*void*)): int(n)
//
(* ****** ****** *)
//
fun
{a:vt0p}
{t:type}
sarray_foreach
  {n:int}
(
  pf: tieq(t, n)| A0: &array(a, n), env: ptr
) : void // end-of-fun
//
fun
{a:vt0p}
sarray_foreach$fwork(x: &a >> _, env: ptr): void
//
(* ****** ****** *)
//
fun
{a:vt0p}
{t:type}
sarray_foreach2
  {n:int}
(
  pf: tieq(t, n)
| A0: &array(a, n), A1: &array(a, n), env: ptr
) : void // end-of-fun
//
fun
{a:vt0p}
sarray_foreach2$fwork(x0: &a >> _, x1: &a >> _, env: ptr): void
//
(* ****** ****** *)

(* end of [typeval.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: December, 2012 *)

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.linmap_list"

(* ****** ****** *)

#include "./SHARE/linmap.hats"
#include "./SHARE/linmap_node.hats"

(* ****** ****** *)

(* end of [linmap_list.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: July, 2013 *)

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.stringbuf"
#define ATS_EXTERN_PREFIX "atslib_" // prefix for external names

(* ****** ****** *)

%{#
#include "libats/CATS/stringbuf.cats"
%} // end of [%{#]

(* ****** ****** *)

absvtype stringbuf_vtype = ptr
vtypedef stringbuf = stringbuf_vtype

(* ****** ****** *)
//
// HX: for recapacitizing policy
//
fun{} stringbuf$recapacitize ((*void*)): int
//
(* ****** ****** *)

fun{}
stringbuf_make_nil (cap: sizeGte(1)): stringbuf

(* ****** ****** *)

fun{}
stringbuf_free (sbf: stringbuf):<!wrt> void

fun{}
stringbuf_getfree_strptr (sbf: stringbuf):<!wrt> Strptr1

fun{}
stringbuf_getfree_strnptr
  (sbf: stringbuf, n: &size_t? >> size_t(n)):<!wrt> #[n:nat] strnptr(n)
// end of [stringbuf_getfree_strnptr]

(* ****** ****** *)

fun{}
stringbuf_get_size (sbf: !stringbuf):<> size_t
fun{}
stringbuf_get_capacity (sbf: !stringbuf):<> size_t

(* ****** ****** *)

fun{}
stringbuf_get_bufptr (sbf: !stringbuf):<> Ptr1
fun{}
stringbuf_get_strptr (sbf: !stringbuf):<!wrt> vStrptr1

(* ****** ****** *)

fun{}
stringbuf_takeout_strbuf
(
  sbf: !stringbuf, n: &size_t? >> size_t(n)
) :<!wrt> #[l:addr;n:nat]
(
  bytes_v (l, n), bytes_v (l, n) -<lin,prf> void | ptr(l)
) (* end of [stringbuf_takeout_strbuf] *)

(* ****** ****** *)

fun{}
stringbuf_reset_capacity
  (sbf: !stringbuf, m2: sizeGte(1)):<!wrt> bool(*done/ignored*)
// end of [stringbuf_reset_capacity]

(* ****** ****** *)
//
// HX: (-1) indicates error of bounds-checking
//
fun{}
stringbuf_get_at (sbf: !stringbuf, i: size_t): int
fun{}
stringbuf_rget_at (sbf: !stringbuf, i: sizeGte(1)): int

(* ****** ****** *)

symintr stringbuf_insert

(* ****** ****** *)

fun{}
stringbuf_insert_char (!stringbuf, x: charNZ): int
fun{}
stringbuf_insert_string (!stringbuf, x: string): int
fun{}
stringbuf_insert_strlen{n:int} (!stringbuf, string(n), size_t(n)): int
fun{}
stringbuf_insert_bool (sbf: !stringbuf, x: bool): int

(* ****** ****** *)

overload stringbuf_insert with stringbuf_insert_char
overload stringbuf_insert with stringbuf_insert_string
overload stringbuf_insert with stringbuf_insert_bool

(* ****** ****** *)

fun{}
stringbuf_insert_int (sbf: !stringbuf, x: int): int
fun{}
stringbuf_insert_uint (sbf: !stringbuf, x: uint): int
fun{}
stringbuf_insert_lint (sbf: !stringbuf, x: lint): int
fun{}
stringbuf_insert_ulint (sbf: !stringbuf, x: ulint): int

(* ****** ****** *)

overload stringbuf_insert with stringbuf_insert_int
overload stringbuf_insert with stringbuf_insert_uint
overload stringbuf_insert with stringbuf_insert_lint
overload stringbuf_insert with stringbuf_insert_ulint

(* ****** ****** *)

fun{}
stringbuf_insert_fread
  (sbf: !stringbuf, inp: FILEref, nbyte: int): int
// end of [stringbuf_insert_fread]

(* ****** ****** *)

fun{}
stringbuf_insert_fgets
(
  sbf: !stringbuf, inp: FILEref, last: &char(0) >> char
) : int // end of [stringbuf_insert_fgets]

(* ****** ****** *)
(*
//
fun
stringbuf_insert_snprintf
  (sbf: !stringbuf, recap: int, fmt: string, ...) = "mac#%"
//
*)
(* ****** ****** *)

fun{a:t0p}
stringbuf_insert_val (sbf: !stringbuf, x: a): int

(* ****** ****** *)

fun{a:t0p}
stringbuf_insert_list (sbf: !stringbuf, x: List(a)): int

(* ****** ****** *)
//
// HX-2014-07:
// taking out the first [i] chars, and
// moving the rest of chars to the front
//
fun{}
stringbuf_takeout
  (sbf: !stringbuf, i: size_t):<!wrt> Strptr1
//
fun{}
stringbuf_takeout_all (sbf: !stringbuf):<!wrt> Strptr1
//
(* ****** ****** *)
//
fun{}
stringbuf_remove
  (sbf: !stringbuf, i: size_t):<!wrt> void
//
fun{}
stringbuf_remove_all (sbf: !stringbuf):<!wrt> void
//
(* ****** ****** *)

fun{}
stringbuf_truncate
  (sbf: !stringbuf, n2: size_t):<!wrt> bool(*done/ignored*)
// end of [stringbuf_truncate]

(* ****** ****** *)
//
// HX-2014:
// taking out the truncated porting
//
fun{}
stringbuf_truncout
  (sbf: !stringbuf, n2: size_t):<!wrt> Strptr0
//
// HX-2014:
// it does the same as [stringbuf_takeout_all]
//
fun{}
stringbuf_truncout_all (sbf: !stringbuf):<!wrt> Strptr1
//
(* ****** ****** *)

(* end of [stringbuf.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
**
** A standard bit-vector implementation
**
*)

(* ****** ****** *)
//
// HX-2014-12:
// ported to ATS/Postitats from ATS/Anairiats
//
(* ****** ****** *)
//
#define
ATS_PACKNAME "ATSLIB.libats.bitvec"
//
(* ****** ****** *)
//
abst@ype
bitvec_t0ype(n:int)
//
typedef bitvec (n:int) = bitvec_t0ype(n)
//
(* ****** ****** *)

typedef bit = natLt(2)

(* ****** ****** *)
//
absvtype
bitvecptr_vtype(l:addr, n:int) = ptr(l)
vtypedef
bitvecptr (l:addr, n:int) = bitvecptr_vtype(l, n)
//
(* ****** ****** *)
//
vtypedef bitvecptr (n:int) = [l:addr] bitvecptr(l, n)
//
(* ****** ****** *)
//
castfn
bitvecptr2ptr
  {l:addr}{n:int}
  (bvp: !bitvecptr(l, n)):<> ptr(l)
//
overload ptrcast with bitvecptr2ptr
//
(* ****** ****** *)
//
fun{}
bitvec_get_wordsize ():<> intGt(0)
fun{}
bitvec_get_wordsize_log ():<> intGte(0)
//
(* ****** ****** *)
//
fun{}
bitvecptr_make_none
  {n:nat}(n: int(n)):<!wrt> bitvecptr(n)
fun{}
bitvecptr_make_full
  {n:nat}(n: int(n)):<!wrt> bitvecptr(n)
//
(* ****** ****** *)

fun{}
bitvecptr_free{n:int}(bitvecptr(n)):<!wrt> void

(* ****** ****** *)
//
fun{}
bitvec_get_at{n:int}
  (vec: &bitvec(n), i: natLt(n)): bit
fun{}
bitvec_set_at{n:int}
  (vec: &bitvec(n) >> _, i: natLt(n), b: bit): void
fun{}
bitvec_flip_at{n:int}
  (vec: &bitvec(n) >> _, i: natLt(n)): void
//
(* ****** ****** *)
//
fun{}
bitvecptr_get_at
  {l:addr}{n:int}
  (bvp: !bitvecptr(l, n), i: natLt(n)): bit
fun{}
bitvecptr_set_at
  {l:addr}{n:int}
  (bvp: !bitvecptr(l, n) >> _, i: natLt(n), b: bit): void
fun{}
bitvecptr_flip_at
  {l:addr}{n:int}
  (bvp: !bitvecptr(l, n) >> _, i: natLt(n)): void
//
(* ****** ****** *)

overload [] with bitvec_get_at
overload [] with bitvec_set_at
overload [] with bitvecptr_get_at
overload [] with bitvecptr_set_at

(* ****** ****** *)
//
fun{}
bitvec_is_none
  {n:int}(&bitvec(n), int(n)):<> bool
fun{}
bitvecptr_is_none
  {l:addr}{n:int}(!bitvecptr(n), int(n)):<> bool
//
fun{}
bitvec_is_full
  {n:int}(&bitvec(n), int(n)):<> bool
fun{}
bitvecptr_is_full
  {l:addr}{n:int}(!bitvecptr(l,n), int(n)):<> bool
//  
(* ****** ****** *)
//
fun{}
bitvec_equal{n:int}
  (&bitvec(n), &bitvec(n), int(n)):<> bool
fun{}
bitvec_notequal{n:int}
  (&bitvec(n), &bitvec(n), int(n)):<> bool
//
fun{}
bitvecptr_equal
  {l1,l2:addr}{n:int}
  (x1: !bitvecptr(l1, n), x2: !bitvecptr(l2, n), int(n)):<> bool
fun{}
bitvecptr_notequal
  {l1,l2:addr}{n:int}
  (x1: !bitvecptr(l1, n), x2: !bitvecptr(l2, n), int(n)):<> bool
//
(* ****** ****** *)
//
fun{}
bitvec_copy{n:int}
  (x1: &bitvec(n) >> _, x2: &bitvec(n), int(n)):<!wrt> void
//
(* ****** ****** *)
//
fun{}
bitvec_lnot
  {n:int}(x: &bitvec(n) >> _, int(n)):<!wrt> void
fun{}
bitvecptr_lnot{l:addr}
  {n:int}(x: !bitvecptr(l, n) >> _, int(n)):<!wrt> void
//
(* ****** ****** *)
//
fun{}
bitvec_lor{n:int}
  (x1: &bitvec(n) >> _, x2: &bitvec(n), int(n)):<!wrt> void
fun{}
bitvec_lxor{n:int}
  (x1: &bitvec(n) >> _, x2: &bitvec(n), int(n)):<!wrt> void
fun{}
bitvec_land{n:int}
  (x1: &bitvec(n) >> _, x2: &bitvec(n), int(n)):<!wrt> void
//
fun{}
bitvecptr_lor{l1,l2:addr}{n:int}
(
  x1: !bitvecptr(l1, n) >> _, x2: !bitvecptr(l2, n), int(n)
) :<!wrt> void // end-of-function
fun{}
bitvecptr_lxor{l1,l2:addr}{n:int}
(
  x1: !bitvecptr(l1, n) >> _, x2: !bitvecptr(l2, n), int(n)
) :<!wrt> void // end-of-function
fun{}
bitvecptr_land{l1,l2:addr}{n:int}
(
  x1: !bitvecptr(l1, n) >> _, x2: !bitvecptr(l2, n), int(n)
) :<!wrt> void // end-of-function
//
(* ****** ****** *)
//
fun{}
fprint_bitvec$word(out: FILEref, w: uintptr): void
fun{}
fprint_bitvec{n:int}
  (out: FILEref, vec: &bitvec(n), n: int(n)): void
fun{}
fprint_bitvecptr{l:addr}{n:int}
  (out: FILEref, bvp: !bitvecptr(l, n), n: int(n)): void
//
(* ****** ****** *)
//
fun{}
bitvec_tabulate$fopr(i: intGte(0)): bit
fun{}
bitvecptr_tabulate{n:nat}(nbit: int(n)): bitvecptr(n)
//
(* ****** ****** *)
//
fun{}
bitvec_foreach{n:int}
  (vec: &bitvec(n), n: int(n)): void
fun{
env:vt0p
} bitvec_foreach_env{n:int}
  (vec: &bitvec(n), n: int(n), env: &env >> _): void
//
fun{
env:vt0p
} bitvec_foreach$fwork{n:nat}
  (w: &uintptr >> _, n: int(n), env: &(env) >> _): void
fun{
env:vt0p
} bitvec_foreach$fworkbit (b: bit, env: &(env) >> _): void
//
(* ****** ****** *)
//
fun{}
bitvecptr_foreach
  {l:addr}{n:int}
  (bvp: !bitvecptr(l, n) >> _, n: int(n)): void
fun{
env:vt0p
} bitvecptr_foreach_env
  {l:addr}{n:int}
  (bvp: !bitvecptr(l, n) >> _, n: int(n), env: &env >> _): void
//
(* ****** ****** *)

(* end of [bitvec.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
** A red-black tree implementation
**
** The insertion operation is based on the algorithm in the following
** paper by Chris Okasaki:
**
** Red-Black Trees in a Functional Setting (Functional Pearls)
**
** J. of Functional Programming, vol. 9 (4), pp. 471-477, January, 1993
**
** The removal operation, which seems novel in its implementation, is by
** Hongwei Xi
**
** Contributed by Hongwei Xi (hwxi AT cs DOT bu DOT edu)
** Time: September, 2011 // based on a version done in October, 2008
*)

(* ****** ****** *)
//
// HX-2015-06:
// It is ported to ATS/Postitats from ATS/Anairiats
//
(* ****** ****** *)
//
#define
ATS_PACKNAME
"ATSLIB.libats.funmap_rbtree"
//
(* ****** ****** *)

#include "./SHARE/funmap.hats"

(* ****** ****** *)
//
// HX: for the purpose of gathering statics
//
fun{
key:t0p;itm:t0p
} funmap_rbtree_height (map: map (key, itm)):<> intGte(0)
//
fun{
key:t0p;itm:t0p
} funmap_rbtree_bheight (map: map (key, itm)):<> intGte(0)
//
(* ****** ****** *)

(* end of [funmap_avltree.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: hwxiATcsDOTbuDOTedu
// Time: October, 2010
//
(* ****** ****** *)
//
// HX: generic linear lists (fully indexed)
//
(* ****** ****** *)
//
// HX-2012-11-27: ported to ATS/Postiats from ATS/Anairiats
//
(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.gflist_vt"

(* ****** ****** *)

staload "libats/SATS/ilist_prf.sats" // for handling integer sequences

(* ****** ****** *)

staload "libats/SATS/gflist.sats"

(* ****** ****** *)

fun{a:vt0p}
gflist_vt_length
  {xs:ilist}
  (xs: !gflist_vt (INV(a), xs)):<> [n:nat] (LENGTH (xs, n) | int n)
// end of [gflist_vt_length]

(* ****** ****** *)

fun{a:vt0p}
gflist_vt_snoc
  {xs:ilist}{x0:int}
(
  xs: gflist_vt (a, xs), x0: stamped_vt (a, x0)
) : [xsx:ilist] (SNOC (xs, x0, xsx) | gflist_vt (a, xsx))

(* ****** ****** *)

fun{a:vt0p}
gflist_vt_append
  {xs1,xs2:ilist}
(
  xs1: gflist_vt (INV(a), xs1), xs2: gflist_vt (a, xs2)
) :<!wrt> [res:ilist] (APPEND (xs1, xs2, res) | gflist_vt (a, res))
// end of [gflist_vt_append]

(* ****** ****** *)

fun{a:vt0p}
gflist_vt_revapp
  {xs1,xs2:ilist}
(
  xs1: gflist_vt (INV(a), xs1), xs2: gflist_vt (a, xs2)
) :<!wrt> [res:ilist] (REVAPP (xs1, xs2, res) | gflist_vt (a, res))
// end of [gflist_vt_revapp]

fun{a:vt0p}
gflist_vt_reverse
  {xs:ilist} (
  xs: gflist_vt (INV(a), xs)
) :<!wrt> [ys:ilist] (REVERSE (xs, ys) | gflist_vt (a, ys))
// end of [gflist_vt_reverse]

(* ****** ****** *)
//
fun{a:vt0p}
gflist_vt_mergesort
  {xs:ilist}
(
  xs: gflist_vt (INV(a), xs)
) : [ys:ilist] (SORT (xs, ys) | gflist_vt (a, ys))
// end of [gflist_vt_mergesort]
//
fun{a:vt0p}
gflist_vt_mergesort$cmp
  {x1,x2:int}
  (x1: &stamped_vt (a, x1), x2: &stamped_vt (a, x2)): int(sgn(x1-x2))
//
(* ****** ****** *)

(* end of [gflist_vt.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: July, 2013 *)

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.gvector"

(* ****** ****** *)
//
// HX-2013-07:
// generic vector:
// element type, length/size, delta
//
abst@ype
gvector_t0ype (a:t@ype, n:int, d:int) (*irregular*)
//
typedef
gvector (a:t0p, n:int, d:int) = gvector_t0ype (a, n, d)
//
(* ****** ****** *)
//
viewdef
gvector_v
  (a:t0p, l:addr, n:int, d:int) = gvector (a, n, d) @ l
//
(* ****** ****** *)

stadef GVT = gvector
stadef GVT = gvector_v

(* ****** ****** *)
//
praxi
lemma_gvector_param
  {a:t0p}{n:int}{d:int}
  (v: &GVT(a, n, d)): [n >= 0; d >= 1] void
praxi
lemma_gvector_v_param
  {a:t0p}{l:addr}{n:int}{d:int}
  (pf: !GVT(a, l, n, d)): [n >= 0; d >= 1] void
//
(* ****** ****** *)
//
(*
// HX-2013-07:
// Don't use [gmatrix_initize]
// unless you know what you are doing
*)
praxi
gvector_initize
  {a:t0p}{n:int}{d:int}
  (&GVT(a?, n, d) >> GVT(a, n, d)): void
praxi
gvector_uninitize
  {a:t0p}{n:int}{d:int}
  (&GVT(a, n, d) >> GVT(a?, n, d)): void
//
(* ****** ****** *)

praxi
array2gvector
  {a:t0p}{l:addr}{n:int}
  (A: &array(INV(a), n) >> GVT(a, n, 1)): void
// end [array2gvector]
praxi
array2gvector_v
  {a:t0p}{l:addr}{n:int}
  (pf: array_v(INV(a), l, n)):<prf> GVT(a, l, n, 1)
// end [array2gvector_v]

(* ****** ****** *)

praxi
gvector2array
  {a:t0p}{l:addr}{n:int}
  (V: &GVT(a, n, 1) >> array (a, n)): void
// end [gvector2array]
praxi
gvector2array_v
  {a:t0p}{l:addr}{n:int}
  (pf: GVT(a, l, n, 1)):<prf> array_v (a, l, n)
// end [gvector2array_v]

(* ****** ****** *)
//
praxi
gvector_v_renil
  {a1,a2:t0p}
  {l:addr}{n:int}{d:int} (pf: GVT(a1, l, 0, d)): GVT(a2, l, 0, d)
//
praxi
gvector_v_cons
  {a:t0p}{l:addr}{n:int}{d:int}
(
  pf1: a @ l, pf2: GVT(a, l+d*sizeof(a), n, d)
) : GVT(a, l, n+1, d) // endfun
praxi
gvector_v_uncons
  {a:t0p}{l:addr}
  {n:int | n > 0}{d:int}
  (pf: GVT(a, l, n, d)): (a @ l, GVT(a, l+d*sizeof(a), n-1, d))
//
(* ****** ****** *)

praxi
gvector_v_split
  {a:t0p}
  {l:addr}
  {n:int}{d:int}
  {i:nat | i <= n}
  (GVT(a, l, n, d)): (GVT(a, l, i, d), GVT(a, l+i*d*sizeof(a), n-i, d))
// end of [gvector_v_split]
praxi
gvector_v_unsplit
  {a:t0p}
  {l:addr}
  {n1,n2:int}{d:int}
  (GVT(a, l, n1, d), GVT(a, l+n1*d*sizeof(a), n2, d)): GVT(a, l, n1+n2, d)
// end of [gvector_v_unsplit]

(* ****** ****** *)

fun{a:t0p}
gvector_get_at
  {n:int}{d:int}
(
  V: &GVT(a, n, d), d: int d, i: natLt(n)
) : a // end of [gvector_get_at]
fun{a:t0p}
gvector_set_at
  {n:int}{d:int}
(
  V: &GVT(a, n, d), d: int d, i: natLt(n), x: a
) : void // end of [gvector_set_at]

fun{a:t0p}
gvector_getref_at
  {n:int}{d:int}
  (V: &GVT(a, n, d), d: int d, i: natLt(n)): cPtr1(a)
// end of [gvector_getref_at]

(* ****** ****** *)

fun{}
fprint_gvector$sep (out: FILEref): void

fun{a:t0p}
fprint_gvector{n:int}{d:int}
(
  out: FILEref, V: &GVT(a, n, d), int n, int d
) : void // end of [fprint_gvector]

(* ****** ****** *)

fun{a:t0p}
gvector_copyto
  {n:int}{d1,d2:int}
(
  V1: &GVT(a, n, d1)
, V2: &GVT(a?, n, d2) >> GVT(a, n, d2), int(n), int(d1), int(d2)
) : void // end of [gvector_copyto]

fun{a:t0p}
gvector_exchange
  {n:int}{d1,d2:int}
(
  V1: &GVT(a, n, d1), V2: &GVT(a, n, d2), int(n), int(d1), int(d2)
) : void // end of [gvector_exchange]

(* ****** ****** *)
//
fun{
a:t0p}{env:vt0p
} gvector_foreach$cont
  {n:int}{d:int} (x: &a, env: &env): bool
fun{
a:t0p}{env:vt0p
} gvector_foreach$fwork
  {n:int}{d:int} (x: &a >> _, env: &env >> _): void
//
fun{a:t0p}
gvector_foreach{n:int}{d:int}
  (V: &GVT(a, n, d) >> _, n: int n, d: int d): natLte(n)
fun{
a:t0p}{env:vt0p
} gvector_foreach_env{n:int}{d:int}
(
  V: &GVT(a, n, d) >> _, n: int n, d: int d, env: &(env) >> _
) : natLte(n) // end of [gvector_foreach_env]
//
(* ****** ****** *)
//
fun{
a,b:t0p}{env:vt0p
} gvector_foreach2$cont
  {n:int}{d:int} (x: &a, y: &b, env: &env): bool
fun{
a,b:t0p}{env:vt0p
} gvector_foreach2$fwork
  {n:int}{d:int} (x: &a >> _, y: &b >> _, env: &env >> _): void
//
fun{a,b:t0p}
gvector_foreach2
  {n:int}{d1,d2:int}
(
  V1: &GVT(a, n, d1) >> _
, V2: &GVT(b, n, d2) >> _
, n: int (n), d1: int (d1), d2: int (d2)
) : natLte(n) // end of [gvector_foreach2]
fun{
a,b:t0p}{env:vt0p
} gvector_foreach2_env
  {n:int}{d1,d2:int}
(
  V1: &GVT(a, n, d1) >> _
, V2: &GVT(b, n, d2) >> _
, n: int (n), d1: int (d1), d2: int (d2)
, env: &env >> _
) : natLte(n) // end of [gvector_foreach2_env]
//
(* ****** ****** *)

(* end of [gvector.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
**
** Functional set
** based on ordered lists
**
** Contributed by
** Hongwei Xi (hwxiATcsDOTbuDOTedu)
** Time: May 18, 2011
**
*)

(* ****** ****** *)
//
// HX-2012-12:
// ported to ATS/Postitats from ATS/Anairiats
//
(* ****** ****** *)

#define
ATS_PACKNAME
"ATSLIB.libats.funset_listord"

(* ****** ****** *)

#include "./SHARE/funset.hats"

(* ****** ****** *)
//
castfn
funset2list{a:t0p} (xs: set(INV(a))):<> List0 (a)
//
(* ****** ****** *)

(* end of [funset_listord.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: May, 2012 *)

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.funralist_nested"

(* ****** ****** *)

#include "./SHARE/funralist.hats"

(* ****** ****** *)

(* end of [funralist_nested.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// Author: Hongwei Xi
// Authoremail: hwxiATcsDOTbuDOTedu
// Time: October, 2010
//
(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.linset_listord"

(* ****** ****** *)

#include "./SHARE/linset.hats"
#include "./SHARE/linset_node.hats"

(* ****** ****** *)

castfn
linset2list {a:t0p} (xs: set (INV(a))):<> List0_vt (a)

(* ****** ****** *)

(* end of [linset_listord.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: April, 2012 *)

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.strobjref"
#define ATS_EXTERN_PREFIX "atslib_" // for extern names

(* ****** ****** *)
//
absvtype
strobjref_vtype (l:addr)
vtypedef
strobjref (l:addr) = strobjref_vtype (l)
//
vtypedef
Strobjref = [l:addr] strobjref (l)
vtypedef
Strobjref0 = [l:agez] strobjref (l)
vtypedef
Strobjref1 = [l:addr | l > null] strobjref (l)
//
(* ****** ****** *)
//
castfn
strobjref2ptr
  {l:addr} (x: !strobjref (l)): ptr (l)
//
overload ptrcast with strobjref2ptr
//
(* ****** ****** *)

fun strobjref_make_nil ():<> strobjref (null)
fun strobjref_make_strptr0 (x: Strptr0):<> Strobjref0
fun strobjref_make_strptr1 (x: Strptr1):<> Strobjref1

(* ****** ****** *)

fun strobjref_incref
  {l:addr} (x: !strobjref l): strobjref l
// end of [strobjref_ref]

fun strobjref_decref (x: Strobjref0): void

(* ****** ****** *)

fun
strobjref_get0_strptr
  {l:agz}
(
  x: !strobjref l
) :<> #[l1:agz]
(
  minus (strobjref l, strptr l1) | strptr (l1)
) // end of [strobjref_get0_strptr]

fun strobjref_get1_strptr (x: !Strobjref1): Strptr1

(* ****** ****** *)
//
fun
lt_strobjref_strobjref
  (x1: !Strobjref, x2: !Strobjref):<> bool = "mac#%"
fun
lte_strobjref_strobjref
  (x1: !Strobjref, x2: !Strobjref):<> bool = "mac#%"
//
overload < with lt_strobjref_strobjref
overload <= with lte_strobjref_strobjref
//
fun
gt_strobjref_strobjref
  (x1: !Strobjref, x2: !Strobjref):<> bool = "mac#%"
fun
gte_strobjref_strobjref
  (x1: !Strobjref, x2: !Strobjref):<> bool = "mac#%"
//
overload > with gt_strobjref_strobjref
overload >= with gte_strobjref_strobjref
//
fun
eq_strobjref_strobjref
  (x1: !Strobjref, x2: !Strobjref):<> bool = "mac#%"
fun
neq_strobjref_strobjref
  (x1: !Strobjref, x2: !Strobjref):<> bool = "mac#%"
//
overload = with eq_strobjref_strobjref
overload != with neq_strobjref_strobjref
overload <> with neq_strobjref_strobjref
//
(* ****** ****** *)
//
fun
compare_strobjref_strobjref
  (x1: !Strobjref, x2: !Strobjref):<> Sgn = "mac#%"
//
overload
compare with compare_strobjref_strobjref
//
(* ****** ****** *)
//
fun
print_strobjref (x: !Strobjref): void
fun
prerr_strobjref (x: !Strobjref): void
fun
fprint_strobjref (out: FILEref, x: !Strobjref): void
//
overload print with print_strobjref
overload prerr with prerr_strobjref
overload fprint with fprint_strobjref
//
(* ****** ****** *)

(* end of [strobjref.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2015 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

sortdef t0p = t@ype

(* ****** ****** *)
//
abstype
mset_type (a:t@ype+) = ptr
typedef mset (a:t0p) = mset_type (a)
//
(* ****** ****** *)

fun{a:t0p}
compare_elt_elt (x1: a, x2: a):<> int

(* ****** ****** *)

fun{}
funmset_nil {a:t0p} ():<> mset(a)
fun{}
funmset_make_nil {a:t0p} ():<> mset(a)

(* ****** ****** *)
//
fun{a:t0p}
funmset_sing
  (x0: a):<> mset(a) // singleton mset
fun{a:t0p}
funmset_make_sing
  (x0: a):<> mset(a) // singleton mset
//
(* ****** ****** *)

fun{a:t0p}
funmset_make_list (xs: List(INV(a))):<> mset(a)

(* ****** ****** *)

fun{}
funmset_is_nil {a:t0p} (xs: mset(INV(a))):<> bool
fun{}
funmset_isnot_nil {a:t0p} (xs: mset(INV(a))):<> bool

(* ****** ****** *)

fun{a:t0p}
funmset_size (xs: mset(INV(a))):<> size_t

(* ****** ****** *)
//
fun{a:t0p}
funmset_get_ntime
  (xs: mset(INV(a)), x0: a): intGte(0)
//
fun{a:t0p}
funmset_is_member(xs: mset(INV(a)), x0: a): bool
fun{a:t0p}
funmset_isnot_member(xs: mset(INV(a)), x0: a): bool
//
(* ****** ****** *)
//
fun{a:t0p}
funmset_insert(xs: &mset(INV(a)) >> _, x0: a): intGte(0)
fun{a:t0p}
funmset_remove(xs: &mset(INV(a)) >> _, x0: a): intGte(0)
//
(* ****** ****** *)
//
fun{a:t0p}
funmset_insert2
  (xs: &mset(INV(a)) >> _, n0: intGt(0), x0: a): intGte(0)
fun{a:t0p}
funmset_remove2
  (xs: &mset(INV(a)) >> _, n0: intGt(0), x0: a): intGte(0)
//
(* ****** ****** *)
//
fun{a:t0p}
funmset_union(xs: mset(INV(a)), ys: mset(a)): mset(a)
fun{a:t0p}
funmset_intersect(xs: mset(INV(a)), ys: mset(a)): mset(a)
//
(* ****** ****** *)
//
fun
{a:t0p}
funmset_foreach(xs: mset(INV(a))): void
fun
{a:t0p}
{env:vt0p}
funmset_foreach_env(xs: mset(INV(a)), env: &(env) >> _): void
//
fun{
a:t0p}{env:vt0p
} funmset_foreach$fwork
  (n: intGt(0), x: a, env: &(env) >> _): void
//
(* ****** ****** *)
//
fun{}
fprint_funmset$sep
  (out: FILEref): void // ", "
//
fun{a:t0p}
fprint_funmset(out: FILEref, xs: mset(INV(a))): void
fun{a:t0p}
fprint_funmset_sep(out: FILEref, xs: mset(INV(a)), sep: string): void
//
overload fprint with fprint_funmset
//
(* ****** ****** *)

(* end of [funmset.hats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: August, 2013 *)

(* ****** ****** *)
//
absvtype
hashtbl_vtype (k:t@ype, i:vt@ype+) = ptr
//
vtypedef hashtbl (k:t0p, i:vt0p) = hashtbl_vtype (k, i)
//
(* ****** ****** *)

fun{key:t0p}
hash_key (x: key):<> ulint
fun{key:t0p}
equal_key_key (x1: key, x2: key):<> bool

(* ****** ****** *)
//
// HX: for recapacitizing policy
//
fun{} hashtbl$recapacitize (): int
//
(* ****** ****** *)

fun{
key:t0p;itm:vt0p
} hashtbl_make_nil (cap: sizeGte(1)): hashtbl (key, itm)

(* ****** ****** *)
//
// HX: the number of stored elements
//
fun{} hashtbl_get_size
  {key:t0p;itm:vt0p} (p: !hashtbl (key, INV(itm))):<> size_t
// end of [hashtbl_get_size]

(* ****** ****** *)
//
// HX: the array size of the hashtable
//
fun{} hashtbl_get_capacity
  {key:t0p;itm:vt0p} (p: !hashtbl (key, INV(itm))):<> sizeGte(1)
// end of [hashtbl_get_capacity]

(* ****** ****** *)

fun{
key:t0p;itm:t0p
} hashtbl_search (
  tbl: !hashtbl (key, INV(itm))
, k0: key, res: &itm? >> opt (itm, b)
) : #[b:bool] bool (b)(*found*) // end of [hashtbl_search]

fun{
key:t0p;itm:vt0p
} hashtbl_search_ref
  (tbl: !hashtbl (key, INV(itm)), k0: key): cPtr0 (itm)
// end of [hashtbl_search_ref]

fun{
key:t0p;itm:t0p
} hashtbl_search_opt
  (tbl: !hashtbl (key, INV(itm)), k0: key): Option_vt (itm)
// end of [hashtbl_search_opt]

(* ****** ****** *)

fun{
key:t0p;itm:vt0p
} hashtbl_insert (
  tbl: !hashtbl (key, INV(itm))
, k0: key, x0: itm, res: &itm? >> opt (itm, b)
) : #[b:bool] bool (b) // endfun
fun{
key:t0p;itm:vt0p
} hashtbl_insert_opt
  (tbl: !hashtbl (key, INV(itm)), key, itm): Option_vt (itm)
// end of [hashtbl_insert_opt]

(* ****** ****** *)

fun{
key:t0p;itm:vt0p
} hashtbl_insert_any
  (!hashtbl (key, INV(itm)), key, itm): void
// end of [hashtbl_insert_any]

(* ****** ****** *)

fun{
key:t0p;itm:vt0p
} hashtbl_takeout (
  tbl: !hashtbl (key, INV(itm))
, k0: key, res: &itm? >> opt (itm, b)
) : #[b:bool] bool (b) // endfun
fun{
key:t0p;itm:vt0p
} hashtbl_takeout_opt
  (!hashtbl (key, INV(itm)), key): Option_vt (itm)
// end of [hashtbl_takeout_opt]

(* ****** ****** *)

fun{
key:t0p;itm:t0p
} hashtbl_remove
  (tbl: !hashtbl (key, INV(itm)), k0: key): bool
// end of [hashtbl_remove]

(* ****** ****** *)

fun{
key:t0p;itm:vt0p
} hashtbl_takeout_all
  (tbl: !hashtbl (key, INV(itm))): List0_vt @(key, itm)
// end of [hashtbl_takeout_all]

(* ****** ****** *)

fun{
key:t0p;itm:vt0p
} hashtbl_reset_capacity
  (tbl: !hashtbl (key, INV(itm)), cap2: sizeGte(1)): bool
// end of [hashtbl_reset_capacity]

(* ****** ****** *)

fun{
key:t0p;itm:vt0p
} hashtbl_adjust_capacity (!hashtbl (key, INV(itm))): bool

(* ****** ****** *)
//
fun{
key,itm:t@ype
} fprint_hashtbl
  (out: FILEref, tbl: !hashtbl (key, INV(itm))): void
//
overload fprint with fprint_hashtbl
//
fun{}
fprint_hashtbl$sep (out: FILEref): void // default: fprint("; ")
fun{}
fprint_hashtbl$mapto (out: FILEref): void // default: fprint("->")
//
(* ****** ****** *)
//
fun
{key:t0p
;itm:vt0p}
hashtbl_foreach (tbl: !hashtbl (key, INV(itm))): void
fun
{key:t0p
;itm:vt0p}
{env:vt0p}
hashtbl_foreach_env
  (tbl: !hashtbl (key, INV(itm)), env: &env >> _): void
//
fun
{key:t0p
;itm:vt0p}
{env:vt0p}
hashtbl_foreach$fwork (k: key, x: &itm >> _, &env >> _): void
//
(* ****** ****** *)

fun
{key:t0p
;itm:t0p}
hashtbl_free (tbl: hashtbl (key, INV(itm))): void

(* ****** ****** *)
//
fun
{key:t0p
;itm:vt0p}
{ki2:vt0p}
hashtbl_flistize$fopr (k: key, x: itm): ki2
fun
{key:t0p
;itm:vt0p}
{ki2:vt0p}
hashtbl_flistize
  (tbl: hashtbl (key, INV(itm))):<!wrt> List0_vt (ki2)
//
(* ****** ****** *)

fun
{key:t0p
;itm:vt0p}
hashtbl_listize
  (tbl: hashtbl (key, INV(itm))):<!wrt> List0_vt @(key, itm)
// end of [hashtbl_listize]

fun{
key,itm:t0p
} hashtbl_listize1
  (tbl: !hashtbl (key, INV(itm))):<!wrt> List0_vt @(key, itm)
// end of [hashtbl_listize1]

(* ****** ****** *)

(* end of [hashtbl.hats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: November, 2011 *)

(* ****** ****** *)

absvtype heap_vtype (a:vt@ype+) = ptr
vtypedef heap (a:vt0p) = heap_vtype (a)

(* ****** ****** *)

fun{a:vt0p}
compare_elt_elt (x1: &a, x2: &a):<> int

(* ****** ****** *)

fun{} linheap_nil {a:vt0p} ():<> heap (a)
fun{} linheap_make_nil {a:vt0p} ():<> heap (a)

(* ****** ****** *)

fun{
} linheap_is_nil{a:vt0p}(hp: !heap (INV(a))):<> bool
fun{
} linheap_isnot_nil{a:vt0p}(hp: !heap (INV(a))):<> bool

(* ****** ****** *)

fun{a:vt0p}
linheap_size (hp: !heap (INV(a))):<> size_t

(* ****** ****** *)

fun{a:vt0p}
linheap_insert (hp: &heap (INV(a)) >> _, x: a): void

(* ****** ****** *)

fun{a:t0p}
linheap_getmin
(
  hp: !heap (INV(a)), res: &a? >> opt (a, b)
) : #[b:bool] bool (b) // endfun

fun{a:vt0p}
linheap_getmin_ref (hp: !heap (INV(a))): cPtr0 (a)

fun{a:t0p}
linheap_getmin_opt (hp: !heap (INV(a))): Option_vt (a)

(* ****** ****** *)

fun{a:vt0p}
linheap_delmin
(
  hp: &heap (INV(a)) >> _, res: &a? >> opt (a, b)
) : #[b:bool] bool b // endfun

fun{a:vt0p}
linheap_delmin_opt (hp: &heap (INV(a)) >> _): Option_vt (a)

(* ****** ****** *)

fun{a:vt0p}
linheap_merge
  (hp1: heap (INV(a)), hp2: heap (a)): heap (a)
// end of [linheap_merge]

(* ****** ****** *)

fun{a:t0p}
linheap_free (hp: heap (INV(a))):<!wrt> void

(* ****** ****** *)

fun{x:vt0p}
linheap_freelin$clear
  (x: &x >> x?):<!wrt> void
fun{a:vt0p}
linheap_freelin (hp: heap (INV(a))):<!wrt> void

(* ****** ****** *)
//
// HX: a heap is freed only if it is empty
//
fun{a:vt0p}
linheap_free_ifnil
  (hp: !heap (INV(a)) >> opt (heap (a), b)) :<> #[b:bool] bool(b)
// end of [linheap_free_ifnil]

(* ****** ****** *)

(* end of [linheap.hats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: December, 2012 *)

(* ****** ****** *)
//
// HX: shared by linmap_list
//
(* ****** ****** *)

absvtype
linmap_node_vtype
  (key:t@ype, itm:vt@ype+, l:addr) = ptr(l)
// end of [linmap_node_vtype]

(* ****** ****** *)
//
stadef mynode = linmap_node_vtype // HX: local shorthand
//
vtypedef
mynode (key:t0p, itm:vt0p) = [l:addr] mynode (key, itm, l)
vtypedef
mynode0 (key:t0p, itm:vt0p) = [l:addr | l >= null] mynode (key, itm, l)
vtypedef
mynode1 (key:t0p, itm:vt0p) = [l:addr | l >  null] mynode (key, itm, l)
//
(* ****** ****** *)

castfn
mynode2ptr
  {key:t0p;itm:vt0p}
  {l:addr} (nx: !mynode (key, INV(itm), l)):<> ptr (l)
// end of [mynode2ptr]

(* ****** ****** *)
//
fun{}
mynode_null
  {key:t0p;itm:vt0p} ():<> mynode (key, itm, null)
//
praxi
mynode_free_null
  {key:t0p;itm:vt0p} (nx: mynode (key, itm, null)): void
//
(* ****** ****** *)

fun{
key:t0p;itm:vt0p
} mynode_make_keyitm
  (k: key, x: itm):<!wrt> mynode1 (key, itm)
// end of [mynode_make_keyitm]

(* ****** ****** *)

fun{
key:t0p;itm:vt0p
} mynode_get_key
  (nx: !mynode1 (key, INV(itm))):<> key
fun{
key:t0p;itm:vt0p
} mynode_getref_itm
  (nx: !mynode1 (key, INV(itm))):<> cPtr1 (itm)

(* ****** ****** *)

fun{
key:t0p;itm:vt0p
} mynode_free_keyitm
(
  nx: mynode1(key, INV(itm)), k0: &key? >> _, x0: &itm? >> _
) :<!wrt> void // end of [mynode_free_keyitm]

fun{
key:t0p;itm:vt0p
} mynode_getfree_itm (nx: mynode1 (key, INV(itm))):<!wrt> itm

(* ****** ****** *)

fun{
key:t0p;itm:vt0p
} linmap_search_ngc
  (map: !map (key, INV(itm)), k0: key): Ptr0(*mynode*)
// end of [linmap_search_ngc]

(* ****** ****** *)

fun{
key:t0p;itm:vt0p
} linmap_insert_ngc
(
  map: &map (key, INV(itm)) >> _, nx: mynode1 (key, itm)
) : mynode0 (key, itm) // endfun

fun{
key:t0p;itm:vt0p
} linmap_insert_any_ngc
(
  map: &map (key, INV(itm)) >> _, nx: mynode1 (key, itm)
) : void // end of [linmap_insert_any_ngc]

(* ****** ****** *)

fun{
key:t0p;itm:vt0p
} linmap_takeout_ngc
  (map: &map (key, INV(itm)) >> _, k0: key): mynode0 (key, itm)
// end of [linmap_takeout_ngc]

(* ****** ****** *)

(* end of [linmap_node.hats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: December, 2012 *)

(* ****** ****** *)
//
// HX: shared by linset_listord (* ordered list *)
// HX: shared by linset_avltree (* AVL-tree-based *)
//
(* ****** ****** *)

absvtype
linset_node_vtype (a:t@ype+, l:addr) = ptr

(* ****** ****** *)
//
// HX: local shorthand
//
stadef mynode = linset_node_vtype
//
vtypedef
mynode (a:t0p) = [l:addr] mynode (a, l)
vtypedef
mynode0 (a:t0p) = [l:addr | l >= null] mynode (a, l)
vtypedef
mynode1 (a:t0p) = [l:addr | l >  null] mynode (a, l)
//
(* ****** ****** *)

castfn
mynode2ptr
  {a:t0p}{l:addr} (nx: !mynode (INV(a), l)):<> ptr (l)
// end of [mynode2ptr]

overload ptrcast with mynode2ptr

(* ****** ****** *)
//
fun{}
mynode_null{a:t0p} ():<> mynode (a, null)
//
praxi
mynode_free_null{a:t0p} (nx: mynode (a, null)): void
//
(* ****** ****** *)

fun{a:t0p}
mynode_make_elt (x: a):<!wrt> mynode1 (a)

(* ****** ****** *)

fun{}
mynode_free{a:t0p} (mynode1 (a)):<!wrt> void

(* ****** ****** *)

fun{a:t0p}
mynode_get_elt (nx: !mynode1 (INV(a))):<> a
fun{a:t0p}
mynode_set_elt{l:agz}
  (nx: !mynode (a?, l) >> mynode (a, l), x0: a):<!wrt> void
// end of [mynode_set_elt]

(* ****** ****** *)

fun{a:t0p}
mynode_getfree_elt (nx: mynode1 (INV(a))):<!wrt> a

(* ****** ****** *)

fun{a:t0p}
linset_insert_ngc
(
  set: &set(INV(a)) >> _, nx0: mynode1 (a)
) :<!wrt> mynode0 (a) // endfun

(* ****** ****** *)

fun{a:t0p}
linset_takeout_ngc
  (set: &set(INV(a)) >> _, x0: a):<!wrt> mynode0 (a)
// end of [linset_takeout_ngc]

(* ****** ****** *)

fun{a:t0p}
linset_takeoutmax_ngc
  (set: &set(INV(a)) >> _):<!wrt> mynode0 (a)
// end of [linset_takeoutmax]

(* ****** ****** *)

fun{a:t0p}
linset_takeoutmin_ngc
  (set: &set(INV(a)) >> _):<!wrt> mynode0 (a)
// end of [linset_takeoutmin]

(* ****** ****** *)

(* end of [linset_node.hats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: December, 2012 *)

(* ****** ****** *)
//
// HX: shared by linmap_avltree
// HX: shared by linmap_list (* unordered list *)
// HX: shared by linmap_randbst
// HX: shared by linmap_skiplst
//
(* ****** ****** *)

absvtype
map_vtype (key:t@ype, itm:vt@ype+) = ptr
stadef map = map_vtype

(* ****** ****** *)

sortdef t0p = t@ype and vt0p = vt@ype

(* ****** ****** *)

fun{key:t0p}
equal_key_key (x1: key, x2: key):<> bool
fun{key:t0p}
compare_key_key (x1: key, x2: key):<> int

(* ****** ****** *)

fun{}
linmap_nil {key:t0p;itm:vt0p} ():<> map (key, itm)
fun{}
linmap_make_nil {key:t0p;itm:vt0p} ():<!wrt> map (key, itm)

(* ****** ****** *)

fun{
} linmap_is_nil
  {key:t0p;itm:vt0p} (map: !map (key, INV(itm))):<> bool
// end of [listmap_is_nil]

fun{
} linmap_isnot_nil
  {key:t0p;itm:vt0p} (map: !map (key, INV(itm))):<> bool
// end of [listmap_isnot_nil]

(* ****** ****** *)
//
// HX: this function is O(1)
//
fun{
key:t0p;itm:vt0p
} linmap_size (map: !map (key, INV(itm))):<> size_t
//
(* ****** ****** *)

fun{
key:t0p;itm:t0p
} linmap_search
(
  !map (key, INV(itm)), key, res: &itm? >> opt (itm, b)
) : #[b:bool] bool(b) (*found*) // endfun

fun{
key:t0p;itm:vt0p
} linmap_search_ref
  (map: !map (key, INV(itm)), k0: key): cPtr0 (itm)
// end of [linmap_search_ref]

fun{
key:t0p;itm:t0p
} linmap_search_opt
  (map: !map (key, INV(itm)), k0: key): Option_vt (itm)
// end of [linmap_search_opt]

(* ****** ****** *)
//
// HX-2012-12:
// if [k0] occurs in [map], [x0] replaces the
// item associated with [k0] in [map] while the
// item is stored in [res] instead.
//
fun{
key:t0p;itm:vt0p
} linmap_insert
(
  &map (key, INV(itm)) >> _, key, itm, res: &itm? >> opt (itm, b)
) : #[b:bool] bool(b) // endfun
fun{
key:t0p;itm:vt0p
} linmap_insert_opt
  (map: &map (key, INV(itm)) >> _, k0: key, x0: itm): Option_vt (itm)
// end of [linmap_insert_opt]

(* ****** ****** *)
//
// HX-2012-12:
// insertion always happens regardless whether
// [k0] is associated with some item in [map]
//
fun{
key:t0p;itm:vt0p
} linmap_insert_any
  (map: &map (key, INV(itm)) >> _, k0: key, x0: itm): void
// end of [linmap_insert_any]

(* ****** ****** *)

fun{
key:t0p;itm:vt0p
} linmap_takeout
(
  &map (key, INV(itm)) >> _, key, res: &itm? >> opt (itm, b)
) : #[b:bool] bool(b) // endfun
fun{
key:t0p;itm:vt0p
} linmap_takeout_opt
  (map: &map (key, INV(itm)) >> _, k0: key): Option_vt (itm)
// end of [linmap_takeout_opt]

(* ****** ****** *)

fun{
key:t0p;itm:t0p
} linmap_remove (
  map: &map (key, INV(itm)) >> _, k0: key): bool
// end of [linmap_remove]

(* ****** ****** *)
//
fun{
} fprint_linmap$sep (out: FILEref): void // "; "
fun{
} fprint_linmap$mapto (out: FILEref): void // "->"
//
fun{
key,itm:t@ype
} fprint_linmap
  (out: FILEref, map: !map (key, INV(itm))): void
//
overload fprint with fprint_linmap
//
(* ****** ****** *)

fun
{key:t0p
;itm:vt0p}
{env:vt0p}
linmap_foreach$fwork
  (k: key, x: &itm >> _, env: &(env) >> _): void
// end of [linmap_foreach$fwork]

fun{
key:t0p;itm:vt0p
} linmap_foreach (map: !map (key, INV(itm))): void
// end of [linmap_foreach]

fun
{key:t0p
;itm:vt0p}
{env:vt0p}
linmap_foreach_env
  (map: !map (key, INV(itm)), env: &(env) >> _): void
// end of [linmap_foreach_env]

(* ****** ****** *)

fun{
key:t0p;itm:t0p
} linmap_free (map: map (key, INV(itm))):<!wrt> void

(* ****** ****** *)

fun{
itm:vt0p
} linmap_freelin$clear (x: &itm >> _?):<!wrt> void
fun{
key:t0p;itm:vt0p
} linmap_freelin (map: map (key, INV(itm))):<!wrt> void

(* ****** ****** *)
//
// HX-2013:
// a linmap can be properly freed only if it is empty
//
fun{
key:t0p;itm:vt0p
} linmap_free_ifnil
(
  map: !map (key, INV(itm)) >> opt (map (key, itm), b)
) :<!wrt> #[b:bool] bool(b) (*~freed*) // endfun
//
(* ****** ****** *)
//
// HX: traversal fashion is unspecified
//
(* ****** ****** *)
//
fun
{key:t0p
;itm:vt0p}
{ki2:vt0p}
linmap_flistize$fopr (k: key, x: itm): ki2
fun
{key:t0p
;itm:vt0p}
{ki2:vt0p}
linmap_flistize (map: map (key, INV(itm))): List_vt (ki2)
//
(* ****** ****** *)

fun
{key:t0p
;itm:vt0p}
linmap_listize
  (map: map (key, INV(itm))):<!wrt> List_vt @(key, itm)
// end of [linmap_listize]
fun{
key,itm:t0p
} linmap_listize1
  (map: !map (key, INV(itm))):<!wrt> List_vt @(key, itm)
// end of [linmap_listize1]

(* ****** ****** *)

(* end of [linmap.hats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: December, 2012 *)

(* ****** ****** *)
//
// HX: shared by linset_listord (* ordered list *)
// HX: shared by linset_avltree (* AVL-tree-based *)
//
(* ****** ****** *)
//
// HX-2013-02:
// for sets of nonlinear elements
//
absvtype set_vtype (a:t@ype+) = ptr
//
(* ****** ****** *)

vtypedef set (a:t0p) = set_vtype (a)

(* ****** ****** *)

fun{a:t0p}
compare_elt_elt (x1: a, x2: a):<> int

(* ****** ****** *)

fun{} linset_nil{a:t0p} ():<> set(a)
fun{} linset_make_nil{a:t0p} ():<> set(a)

(* ****** ****** *)

fun{a:t0p} linset_sing (x: a):<!wrt> set(a)
fun{a:t0p} linset_make_sing (x: a):<!wrt> set(a)

(* ****** ****** *)

fun{a:t0p}
linset_make_list (xs: List(INV(a))):<!wrt> set(a)

(* ****** ****** *)

fun{}
linset_is_nil {a:t0p} (xs: !set(INV(a))):<> bool
fun{}
linset_isnot_nil {a:t0p} (xs: !set(INV(a))):<> bool

(* ****** ****** *)

fun{a:t0p} linset_size (!set(INV(a))): size_t

(* ****** ****** *)

fun{a:t0p}
linset_is_member (xs: !set(INV(a)), x0: a):<> bool
fun{a:t0p}
linset_isnot_member (xs: !set(INV(a)), x0: a):<> bool

(* ****** ****** *)

fun{a:t0p}
linset_copy (!set(INV(a))):<!wrt> set(a)
fun{a:t0p}
linset_free (xs: set(INV(a))):<!wrt> void

(* ****** ****** *)
//
fun{a:t0p}
linset_insert
  (xs: &set(INV(a)) >> _, x0: a):<!wrt> bool
//
(* ****** ****** *)
//
fun{a:t0p}
linset_takeout
(
  &set(INV(a)) >> _, a, res: &(a?) >> opt(a, b)
) :<!wrt> #[b:bool] bool(b) // endfun
fun{a:t0p}
linset_takeout_opt (&set(INV(a)) >> _, a):<!wrt> Option_vt(a)
//
(* ****** ****** *)
//
fun{a:t0p}
linset_remove
  (xs: &set(INV(a)) >> _, x0: a):<!wrt> bool
//
(* ****** ****** *)
//
// HX: choosing an element in an unspecified manner
//
fun{a:t0p}
linset_choose
(
  xs: !set(INV(a)), x: &a? >> opt (a, b)
) :<!wrt> #[b:bool] bool(b)
//
fun{a:t0p}
linset_choose_opt (xs: !set(INV(a))):<!wrt> Option_vt(a)
//
(* ****** ****** *)

fun{a:t0p}
linset_takeoutmax
(
  xs: &set(INV(a)) >> _, res: &a? >> opt(a, b)
) :<!wrt> #[b:bool] bool (b)
fun{a:t0p}
linset_takeoutmax_opt (xs: &set(INV(a)) >> _):<!wrt> Option_vt(a)

(* ****** ****** *)

fun{a:t0p}
linset_takeoutmin
(
  xs: &set(INV(a)) >> _, res: &a? >> opt(a, b)
) :<!wrt> #[b:bool] bool (b)
fun{a:t0p}
linset_takeoutmin_opt (xs: &set(INV(a)) >> _):<!wrt> Option_vt(a)

(* ****** ****** *)
//
fun{}
fprint_linset$sep (FILEref): void // ", "
//
fun{a:t0p}
fprint_linset (out: FILEref, xs: !set(INV(a))): void
//
overload fprint with fprint_linset
//
(* ****** ****** *)
//
fun{
a:t0p}{env:vt0p
} linset_foreach$fwork
  (x: a, env: &(env) >> _): void
//
fun{a:t0p}
linset_foreach (set: !set(INV(a))): void
fun{
a:t0p}{env:vt0p
} linset_foreach_env
  (set: !set(INV(a)), env: &(env) >> _): void
// end of [linset_foreach_env]
//
(* ****** ****** *)

fun{a:t0p}
linset_listize (xs: set(INV(a))): List0_vt (a)

(* ****** ****** *)

fun{a:t0p}
linset_listize1 (xs: !set(INV(a))): List0_vt (a)

(* ****** ****** *)

(* end of [linset.hats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: May, 2012 *)

(* ****** ****** *)
//
// HX: shared by funralist_nested
//
(* ****** ****** *)
//
// HX-2013-01:
// the time-complexity for various functions operating on
// random-access lists:
//
// funralist_cons: O(1) // amortized
// funralist_uncons: O(1) // amortized
//
// funralist_length: O(log(n))
//
// funralist_lookup: O(log(n))
// funralist_update: O(log(n))
//
(* ****** ****** *)
//
// HX: indexed by list length
//
abstype
ralist_type (a:t@ype+, n:int) = ptr
//
(* ****** ****** *)
//
stadef ralist = ralist_type
typedef ralist (a:t0p) = [n:int] ralist (a, n)
typedef Ralist (a:t0p) = [n:int] ralist (a, n)
//
(* ****** ****** *)

prfun lemma_ralist_param
  {a:t0p}{n:int} (xs: ralist (INV(a), n)): [n >= 0] void
// end of [lemma_ralist_param]

(* ****** ****** *)

fun{}
funralist_nil{a:t0p}():<> ralist (a, 0)
fun{}
funralist_make_nil{a:t0p}():<> ralist (a, 0)

(* ****** ****** *)

fun{a:t0p}
funralist_make_list
  {n:int}(xs: list (INV(a), n)): ralist (a, n)
// end of [funralist_make_list]

(* ****** ****** *)

fun{a:t0p}
funralist_cons{n:int}
  (x: a, xs: ralist (INV(a), n)):<> ralist (a, n+1)
// end of [funralist_cons]

fun{a:t0p}
funralist_uncons{n:pos}
  (xs: &ralist (INV(a), n) >> ralist (a, n-1)):<!wrt> a
// end of [funralist_uncons]

(* ****** ****** *)

fun{
} funralist_is_nil
  {a:t0p}{n:int} (xs: ralist (INV(a), n)):<> bool(n==0)
// end of [funralist_is_nil]

fun{
} funralist_is_cons
  {a:t0p}{n:int} (xs: ralist (INV(a), n)):<> bool(n > 0)
// end of [funralist_is_cons]

(* ****** ****** *)

fun{
} funralist_length
  {a:t0p}{n:nat} (xs: ralist (INV(a), n)):<> int (n)
// end of [funralist_length]

(* ****** ****** *)

fun{a:t0p}
funralist_head
  {n:pos} (xs: ralist (INV(a), n)):<> a
fun{a:t0p}
funralist_tail
  {n:pos} (xs: ralist (INV(a), n)):<> ralist (a, n-1)
// end of [funralist_tail]

(* ****** ****** *)

fun{a:t0p}
funralist_get_at{n:int}
  (xs: ralist (INV(a), n), i: natLt n):<> a
fun{a:t0p}
funralist_lookup{n:int}
  (xs: ralist (INV(a), n), i: natLt n):<> a
//
overload [] with funralist_get_at
//
(* ****** ****** *)

fun{a:t0p}
funralist_set_at{n:int}
(
  xs: ralist (INV(a), n), i: natLt n, x0: a
) :<> ralist (a, n) // endfun
fun{a:t0p}
funralist_update{n:int}
(
  xs: ralist (INV(a), n), i: natLt n, x0: a
) :<> ralist (a, n) // endfun

(* ****** ****** *)

fun{}
fprint_funralist$sep (out: FILEref): void
fun{a:t0p}
fprint_funralist
  (out: FILEref, xs: Ralist(INV(a))): void
overload fprint with fprint_funralist

(* ****** ****** *)
//
fun{a:t0p}{env:vt0p}
funralist_foreach$fwork (x: a, env: &(env) >> _): void
//
fun{a:t0p}
funralist_foreach (xs: Ralist (INV(a))): void
fun{a:t0p}{env:vt0p}
funralist_foreach_env (xs: Ralist (INV(a)), env: &(env)>>env): void
//
(* ****** ****** *)

fun{a:t0p}
funralist_listize
  {n:int} (xs: ralist (INV(a), n)):<!wrt> list_vt (a, n)
// end of [funralist_listize]

(* ****** ****** *)

(* end of [funralist.hats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

absvtype
deque_vtype (a:vt@ype+, n:int) = ptr

(* ****** ****** *)

stadef deque = deque_vtype
vtypedef deque (a:vt0p, n:int) = deque_vtype (a, n)
vtypedef Deque (a:vt0p) = [n:int] deque (a, n)

(* ****** ****** *)

praxi
lemma_deque_param
  {a:vt0p}{n:int} (dq: !deque (INV(a), n)): [n >= 0] void
// end of [lemma_deque_param]

(* ****** ****** *)

fun{} lindeque_nil{a:vt0p} ():<> deque (a, 0)

(* ****** ****** *)

prfun lindeque_free_nil{a:vt0p} (dq: deque (a, 0)): void

(* ****** ****** *)
//
fun{} lindeque_is_nil
  {a:vt0p}{n:int} (dq: !deque (INV(a), n)):<> bool (n==0)
fun{} lindeque_isnot_nil
  {a:vt0p}{n:int} (dq: !deque (INV(a), n)):<> bool (n > 0)
//
(* ****** ****** *)

fun{a:vt0p}
lindeque_length {n:int} (dq: !deque (INV(a), n)):<> int (n)

(* ****** ****** *)
//
fun{a:vt0p}
lindeque_insert_at
  {n:int}{i:nat | i <= n}
(
  dq: &deque (INV(a), n) >> deque (a, n+1), i: int i, x: a
) : void // end of [lindeque_insert_at]
//
fun{a:vt0p}
lindeque_insert_atbeg{n:int}
  (dq: &deque (INV(a), n) >> deque (a, n+1), x: a): void
fun{a:vt0p}
lindeque_insert_atend{n:int}
  (dq: &deque (INV(a), n) >> deque (a, n+1), x: a): void
//
(* ****** ****** *)
//
fun{a:vt0p}
lindeque_takeout_at
  {n:int}{i:nat | i < n}
(
  dq: &deque (INV(a), n) >> deque (a, n-1), i: int i
) : a // end of [lindeque_takeout_at]
//
fun{a:vt0p}
lindeque_takeout_atbeg{n:pos}
  (dq: &deque (INV(a), n) >> deque (a, n-1)): (a)
fun{a:vt0p}
lindeque_takeout_atend{n:pos}
  (dq: &deque (INV(a), n) >> deque (a, n-1)): (a)
//
(* ****** ****** *)

(* end of [lindeque.hats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: January, 2013 *)

(* ****** ****** *)
//
// HX: shared by linralist_nested
//
(* ****** ****** *)
//
// HX-2013-01:
// the time-complexity for various functions operating on
// random-access lists:
//
// linralist_cons: O(1) // amortized
// linralist_uncons: O(1) // amortized
//
// linralist_length: O(log(n))
//
// linralist_get_at: O(log(n))
// linralist_set_at: O(log(n))
//
(* ****** ****** *)
//
// HX: indexed by list length
//
absvtype
ralist_vtype (a:vt@ype+, n:int)
//
stadef ralist = ralist_vtype
//
vtypedef ralist (a:vt0p) = [n:int] ralist (a, n)
vtypedef Ralist (a:vt0p) = [n:int] ralist (a, n)
//
(* ****** ****** *)

prfun lemma_ralist_param
  {a:vt0p}{n:int} (xs: !ralist (INV(a), n)): [n >= 0] void
// end of [lemma_ralist_param]

(* ****** ****** *)

fun{}
linralist_nil{a:vt0p}():<> ralist (a, 0)
fun{}
linralist_make_nil{a:vt0p}():<> ralist (a, 0)

(* ****** ****** *)

fun{a:vt0p}
linralist_cons {n:int}
  (x: a, xs: ralist (INV(a), n)):<> ralist (a, n+1)
// end of [linralist_cons]

fun{a:vt0p}
linralist_uncons {n:pos}
  (xs: &ralist (INV(a), n) >> ralist (a, n-1)):<!wrt> a
// end of [linralist_uncons]

(* ****** ****** *)
//
fun{a:t0p}
linralist_head
  {n:pos} (xs: !ralist (INV(a), n)):<> a
fun{a:t0p}
linralist_tail
  {n:pos} (xs: ralist (INV(a), n)):<!wrt> ralist (a, n-1)
//
(* ****** ****** *)
//
fun{}
linralist_is_nil{a:vt0p}
  {n:int} (xs: !ralist (INV(a), n)):<> bool(n==0)
fun{}
linralist_is_cons{a:vt0p}
  {n:int} (xs: !ralist (INV(a), n)):<> bool(n > 0)
//
(* ****** ****** *)

fun
linralist_length{a:vt0p}
  {n:nat} (xs: !ralist (INV(a), n)):<> int (n)
// end of [linralist_length]

(* ****** ****** *)

fun{a:vt0p}
linralist_getref_at{n:int}
  (xs: !ralist (INV(a), n), i: natLt n):<> cPtr1 (a)
// end of [linralist_getref_at]

(* ****** ****** *)
//
fun{a:t0p}
linralist_get_at{n:int}
  (xs: !ralist (INV(a), n), i: natLt n):<> a
overload [] with linralist_get_at
//
fun{a:t0p}
linralist_set_at{n:int}
  (xs: !ralist (INV(a), n), i: natLt n, x: a):<!wrt> void
overload [] with linralist_set_at
//
(* ****** ****** *)

fun{a:t0p}
linralist_listize
  {n:int} (xs: !ralist (INV(a), n)):<!wrt> list_vt (a, n)
// end of [linralist_listize]

fun{a:vt0p}
linralist_listize_free
  {n:int} (xs: ralist (INV(a), n)):<!wrt> list_vt (a, n)
// end of [linralist_listize_free]

(* ****** ****** *)

(* end of [linralist.hats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

sortdef t0p = t@ype

(* ****** ****** *)
//
abstype
set_type (a:t@ype+) = ptr
typedef set (a:t0p) = set_type (a)
//
(* ****** ****** *)

fun{a:t0p}
compare_elt_elt (x1: a, x2: a):<> int

(* ****** ****** *)

fun{}
funset_nil {a:t0p} ():<> set(a)
fun{}
funset_make_nil {a:t0p} ():<> set(a)

fun{a:t0p}
funset_sing (x0: a):<> set(a) // singleton set
fun{a:t0p}
funset_make_sing (x0: a):<> set(a) // singleton set

(* ****** ****** *)

fun{a:t0p}
funset_make_list (xs: List(INV(a))):<> set(a)

(* ****** ****** *)

fun{}
funset_is_nil {a:t0p} (xs: set(INV(a))):<> bool
fun{}
funset_isnot_nil {a:t0p} (xs: set(INV(a))):<> bool

(* ****** ****** *)

fun{a:t0p}
funset_size (xs: set(INV(a))):<> size_t

(* ****** ****** *)

fun{a:t0p}
funset_is_member (xs: set(INV(a)), x0: a):<> bool
fun{a:t0p}
funset_isnot_member (xs: set(INV(a)), x0: a):<> bool

(* ****** ****** *)

fun{a:t0p}
funset_insert
  (xs: &set(INV(a)) >> _, x0: a):<!wrt> bool(*[x0] in [xs]*)
// end of [funset_insert]

fun{a:t0p}
funset_remove
  (xs: &set(INV(a)) >> _, x0: a):<!wrt> bool(*[x0] in [xs]*)
// end of [funset_remove]

(* ****** ****** *)

fun{a:t0p}
funset_getmax
(
  xs: set(INV(a)), x0: &a? >> opt(a, b)
) :<!wrt> #[b:bool] bool(b) // endfun
fun{a:t0p}
funset_getmax_opt (xs: set(INV(a))):<> Option_vt (a)

fun{a:t0p}
funset_getmin
(
  xs: set(INV(a)), x0: &a? >> opt(a, b)
) :<!wrt> #[b:bool] bool(b) // endfun
fun{a:t0p}
funset_getmin_opt (xs: set(INV(a))):<> Option_vt (a)

(* ****** ****** *)

fun{a:t0p}
funset_takeoutmax
(
  xs: &set(INV(a)) >> _, x0: &a? >> opt(a, b)
) :<!wrt> #[b:bool] bool (b)
fun{a:t0p}
funset_takeoutmax_opt (xs: &set(INV(a)) >> _):<> Option_vt(a)

(* ****** ****** *)

fun{a:t0p}
funset_takeoutmin
(
  xs: &set(INV(a)) >> _, x0: &a? >> opt(a, b)
) :<!wrt> #[b:bool] bool (b)
fun{a:t0p}
funset_takeoutmin_opt (xs: &set(INV(a)) >> _):<> Option_vt(a)

(* ****** ****** *)

fun{a:t0p}
funset_union (xs1: set(INV(a)), xs2: set(a)):<> set(a)
fun{a:t0p}
funset_intersect (xs1: set(INV(a)), xs2: set(a)):<> set(a)
fun{a:t0p}
funset_differ (xs1: set(INV(a)), xs2: set(a)):<> set(a)
fun{a:t0p}
funset_symdiff (xs1: set(INV(a)), xs2: set(a)):<> set(a)

(* ****** ****** *)

fun{a:t0p}
funset_equal (xs1: set(INV(a)), xs2: set(a)):<> bool

(* ****** ****** *)
//
// set ordering induced by the ordering on elements
//
fun{a:t0p}
funset_compare (xs1: set(INV(a)), xs2: set(a)):<> Sgn
//
(* ****** ****** *)

fun{a:t0p}
funset_is_subset (xs1: set(INV(a)), xs2: set(a)):<> bool
fun{a:t0p}
funset_is_supset (xs1: set(INV(a)), xs2: set(a)):<> bool

(* ****** ****** *)
//
fun{}
fprint_funset$sep
  (out: FILEref): void // ", "
//
fun{a:t0p}
fprint_funset
  (out: FILEref, xs: set(INV(a))): void
fun{a:t0p}
fprint_funset_sep
  (out: FILEref, xs: set(INV(a)), sep: string): void
//
overload fprint with fprint_funset
//
(* ****** ****** *)
//
fun{
a:t0p}{env:vt0p
} funset_foreach$fwork
  (x: a, env: &(env) >> _): void
//
fun{a:t0p}
funset_foreach (set: set(INV(a))): void
fun{
a:t0p}{env:vt0p
} funset_foreach_env
  (set: set(INV(a)), env: &(env) >> _): void
// end of [funset_foreach_env]
//
(* ****** ****** *)
//
fun
{a:t0p}
funset_tabulate{n:nat}(n: int(n)): set(a)
fun
{a:t0p}
funset_tabulate$fopr (index: intGte(0)): (a)
//
(* ****** ****** *)

fun{a:t0p}
funset_listize (xs: set(INV(a))):<!wrt> List0_vt (a)

(* ****** ****** *)

fun{
a:t0p}{b:t0p
} funset_flistize$fopr (x: a): b
fun{
a:t0p}{b:t0p
} funset_flistize (xs: set(INV(a))): List0_vt (b)

(* ****** ****** *)

(* end of [funset.hats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// HX: shared by fundeque_fngtree
//
(* ****** ****** *)
//
// HX: indexed by deque size
//
abstype
deque_type (elt:t@ype+, n:int) = ptr
//
(* ****** ****** *)
//
stadef deque = deque_type
typedef deque (a:t0p) = [n:int] deque (a, n)
typedef Deque (a:t0p) = [n:int] deque (a, n)
//
(* ****** ****** *)

prfun lemma_deque_size
  {a:t0p}{n:int} (xs: deque (INV(a), n)): int (n)
// end of [lemma_deque_size]

prfun lemma_deque_param
  {a:t0p}{n:int} (xs: deque (INV(a), n)): [n >= 0] void
// end of [lemma_deque_param]

(* ****** ****** *)

fun{}
fundeque_nil{a:t0p} ():<> deque (a, 0)

(* ****** ****** *)

fun{a:t0p}
fundeque_cons{n:int}
  (x: a, xs: deque (INV(a), n)):<> deque (a, n+1)
// end of [fundeque_cons]

fun{a:t0p}
fundeque_uncons{n:pos}
  (xs: &deque (INV(a), n) >> deque (a, n-1)):<!wrt> (a)
// end of [fundeque_uncons]

(* ****** ****** *)

fun{a:t0p}
fundeque_snoc{n:int}
  (xs: deque (INV(a), n), x: a):<> deque (a, n+1)
// end of [fundeque_snoc]

fun{a:t0p}
fundeque_unsnoc{n:pos}
  (xs: &deque (INV(a), n) >> deque (a, n-1)):<!wrt> (a)
// end of [fundeque_unsnoc]

(* ****** ****** *)

fun{
} fundeque_is_nil
  {a:t0p}{n:int} (xs: deque (INV(a), n)):<> bool (n==0)
// end of [fundeque_is_nil]

fun{
} fundeque_is_cons
  {a:t0p}{n:int} (xs: deque (INV(a), n)):<> bool (n > 0)
// end of [fundeque_is_cons]

(* ****** ****** *)

fun fundeque_size
  {a:t0p}{n:int} (xs: deque (INV(a), n)):<> size_t (n)
// end of [fundeque_size]

(* ****** ****** *)

fun{a:t0p}
fundeque_get_atbeg {n:pos} (xs: deque (INV(a), n)):<> (a)
fun{a:t0p}
fundeque_get_atbeg_opt (xs: Deque (INV(a))):<> Option_vt(a)

(* ****** ****** *)

fun{a:t0p}
fundeque_get_atend {n:pos} (xs: deque (INV(a), n)):<> (a)
fun{a:t0p}
fundeque_get_atend_opt (xs: Deque (INV(a))):<> Option_vt(a)

(* ****** ****** *)

fun{a:t0p}
fundeque_takeout_atbeg_opt
  (xs: &Deque (INV(a)) >> _):<!wrt> Option_vt (a)
// end of [fundeque_takeout_atbeg_opt]

fun{a:t0p}
fundeque_takeout_atend_opt
  (xs: &Deque (INV(a)) >> _):<!wrt> Option_vt (a)
// end of [fundeque_takeout_atend_opt]

(* ****** ****** *)

fun fundeque_append
  {a:t0p}{n1,n2:int}
(
  xs1: deque (INV(a), n1), xs2: deque (a, n2)
) :<> deque (a, n1+n2) // endfun

(* ****** ****** *)

fun{}
fprint_fundeque$sep (out: FILEref): void
fun{a:t0p}
fprint_fundeque
  (out: FILEref, xs: Deque (INV(a))): void
overload fprint with fprint_fundeque

(* ****** ****** *)
//
fun{
a:t0p}{env:vt0p
} fundeque_foreach$fwork (x: a, env: &env>>_): void
//
fun{a:t0p}
fundeque_foreach (xs: Deque (INV(a))): void
fun{
a:t0p}{env:vt0p
} fundeque_foreach_env (xs: Deque (INV(a)), env: &(env)>>_): void
//
(* ****** ****** *)
//
fun{
a:t0p}{env:vt0p
} fundeque_rforeach$fwork (x: a, env: &env>>_): void
//
fun{a:t0p}
fundeque_rforeach (xs: Deque (INV(a))): void
fun{
a:t0p}{env:vt0p
} fundeque_rforeach_env (xs: Deque (INV(a)), env: &(env)>>_): void
//
(* ****** ****** *)

fun{a:t0p}
fundeque_listize
  {n:int} (xs: deque (INV(a), n)):<!wrt> list_vt (a, n)
// end of [fundeque_listize]

(* ****** ****** *)

(* end of [fundeque.hats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: December, 2012 *)

(* ****** ****** *)

sortdef t0p = t@ype

(* ****** ****** *)
//
// HX-2012-12:
// for maps associating keys with items
// of types [key] and [itm], respectively
//
abstype map_type (key:t@ype, itm:t@ype+) = ptr
typedef map (key:t0p, itm:t0p) = map_type (key, itm)

(* ****** ****** *)

fun{key:t0p}
equal_key_key (x1: key, x2: key):<> bool
fun{key:t0p}
compare_key_key (x1: key, x2: key):<> int

(* ****** ****** *)

fun{
} funmap_nil {key,itm:t0p} ():<> map (key, itm)
fun{
} funmap_make_nil {key,itm:t0p} ():<> map (key, itm)

(* ****** ****** *)

fun{
} funmap_is_nil
  {key,itm:t0p} (map: map (key, INV(itm))):<> bool
fun{
} funmap_isnot_nil
  {key,itm:t0p} (map: map (key, INV(itm))):<> bool

(* ****** ****** *)
//
// HX-2012-12: this function is O(n)-time
//
fun{
key,itm:t@ype
} funmap_size (map: map (key, INV(itm))):<> size_t
//
(* ****** ****** *)

fun{
key,itm:t0p
} funmap_search
(
  map: map (key, INV(itm))
, k0: key, res: &itm? >> opt (itm, b)
) : #[b:bool] bool (b)

fun{
key,itm:t0p
} funmap_search_opt
  (map: map (key, INV(itm)), k0: key): Option_vt (itm)
// end of [funmap_search_opt]

(* ****** ****** *)
//
// HX-2012-12:
// if [k0] occurs in [map], [x0] replaces the
// item associated with [k0] in [map] while the
// item is stored in [res] instead.
//
fun{
key,itm:t0p
} funmap_insert
(
  map: &map (key, INV(itm)) >> _
, k0: key, x0: itm, res: &itm? >> opt (itm, b)
) : #[b:bool] bool (b)

fun{
key,itm:t0p
} funmap_insert_opt
(
  map: &map (key, INV(itm)) >> _, k0: key, x0: itm
) : Option_vt (itm) // endfun

(* ****** ****** *)
//
// HX-2012-12:
// insertion always happens regardless whether
// [k0] is associated with some item in [map]
//
fun{
key,itm:t0p
} funmap_insert_any
  (map: &map (key, INV(itm)) >> _, k0: key, x0: itm): void
// end of [funmap_insert_any]

(* ****** ****** *)
//
fun{
key,itm:t0p
} funmap_takeout (
  &map (key, INV(itm)) >> _, k0: key, res: &itm? >> opt (itm, b)
) : #[b:bool] bool (b) // end-of-function
//
fun{
key,itm:t0p
} funmap_takeout_opt
  (map: &map (key, INV(itm)) >> _, k0: key) : Option_vt (itm)
//
(* ****** ****** *)

fun{
key,itm:t0p
} funmap_remove
  (map: &map (key, INV(itm)) >> _, k0: key): bool
// end of [funmap_remove]

(* ****** ****** *)
//
fun{}
fprint_funmap$sep (out: FILEref): void // "; "
fun{}
fprint_funmap$mapto (out: FILEref): void // "->"
//
fun{
key,itm:t@ype
} fprint_funmap
  (out: FILEref, map: map (key, INV(itm))): void
//
overload fprint with fprint_funmap
//
(* ****** ****** *)
//
fun
{key:t0p
;itm:t0p}
{env:vt0p}
funmap_foreach$fwork
  (k: key, x: itm, env: &(env) >> _): void
// end of [funmap_foreach$fwork]
//
fun{
key,itm:t0p
} funmap_foreach(map: map (key, INV(itm))): void
//
fun
{key:t0p
;itm:t0p}
{env:vt0p}
funmap_foreach_env
  (map: map (key, INV(itm)), env: &(env) >> _): void
// end of [funmap_foreach_env]
//
(* ****** ****** *)

fun{
key,itm:t0p
} funmap_listize
  (xs: map (key, INV(itm))):<!wrt> List_vt @(key, itm)
// end of [funmap_listize]

(* ****** ****** *)
//
fun
{key:t0p
;itm:t0p}
{ki2:t0p}
funmap_flistize$fopr (k: key, i: itm): ki2
fun
{key:t0p
;itm:t0p}
{ki2:t0p}
funmap_flistize(xs: map (key, INV(itm))): List_vt (ki2)
//
(* ****** ****** *)

(* end of [funmap.hats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(*                              Hongwei Xi                             *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS - Unleashing the Potential of Types!
** Copyright (C) 2002-2011 Hongwei Xi, Boston University
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
**
** A functional map implementation based on ordered lists
**
** Contributed by Hongwei Xi (hwxi AT cs DOT bu DOT edu)
** Time: May 18, 2011
**
*)

(* ****** ****** *)

#define ATS_DYNLOADFLAG 0 // no dynloading

(* ****** ****** *)

staload "libats/ATS1/SATS/funset_listord.sats"

(* ****** ****** *)
//
implement{a}
compare_elt_elt (x1, x2, cmp) = cmp (x1, x2)
//
(* ****** ****** *)

assume
set_t0ype_type (a:t0p) = List0 (a)

(* ****** ****** *)
//
// HX:
// a set is represented as a sorted list in descending order;
// note that descending order is chosen to faciliate set comparison
//
(* ****** ****** *)

implement{}
funset_make_nil () = list_nil ()

(* ****** ****** *)

implement{a}
funset_make_sing (x) = list_cons{a}(x, list_nil)

(* ****** ****** *)

implement{a}
funset_make_list
  (xs, cmp) = let
//
fun loop1
  {m:pos} .<m,0>.
(
  xs: list_vt (a, m)
, ys: List0_vt (a), cmp: cmp a
) :<!wrt> List0_vt (a) = let
  val-@list_vt_cons (x, xs1) = xs
  val x_ = x and xs1_ = xs1
  val ((*void*)) = xs1 := ys
  prval ((*void*)) = fold@ (xs)
in
  loop2 (x_, xs1_, xs, cmp)
end // end of [loop1]
//
and loop2
  {n:nat} .<n,1>.
(
  x0: a
, xs: list_vt (a, n)
, ys: List0_vt (a), cmp: cmp a
) :<!wrt> List0_vt (a) = let
in
//
case+ xs of
| @list_vt_cons
    (x, xs1) => let
    val sgn =
      compare_elt_elt<a> (x0, x, cmp)
    // end of [val]
  in
    if sgn < 0 then let // HX: [xs] is ascending!
      prval () = fold@ (xs) in loop1 (xs, ys, cmp)
    end else let
      val xs1_ = xs1
      val () = free@{a}{0}(xs) in loop2 (x0, xs1_, ys, cmp)
    end // end of [if]
  end (* end of [list_vt_cons] *)
| ~list_vt_nil ((*void*)) => ys
//
end (* end of [loop2] *)
//
local
implement
list_mergesort$cmp<a>
  (x1, x2) = compare_elt_elt<a> (x1, x2, cmp)
in(*in-of-local*)
val xs2 = list_mergesort<a> (xs) // [xs2] is ascending!
end // end of [local]
//
in
//
case+ xs2 of
| list_vt_cons _ => let
    val ys = loop1 (xs2, list_vt_nil, cmp)
  in
    list_vt2t (ys)
  end // end of [list_vt_cons]
| ~list_vt_nil () => list_nil ()
//
end // end of [funset_make_list]

(* ****** ****** *)

implement{a}
funset_size (xs) = i2sz(list_length(xs))

(* ****** ****** *)

implement{a}
funset_is_member
  (xs, x0, cmp) = let
//
fun loop
  {n:nat} .<n>.
(
  xs: list (a, n)
) :<cloref> bool =
(
  case+ xs of
  | list_cons
      (x, xs) => let
      val sgn =
        compare_elt_elt<a> (x0, x, cmp)
      // end of [val]
    in
      if sgn > 0
        then false
        else (if sgn < 0 then loop (xs) else true)
      // end of [if]
    end // end of [list_cons]
  | list_nil ((*void*)) => false
) (* end of [loop] *)
//
in
  loop (xs)
end // end of [funset_is_member]

implement{a}
funset_isnot_member
  (xs, x0, cmp) = not (funset_is_member (xs, x0, cmp))
// end of [funset_isnot_member]

(* ****** ****** *)

implement{a}
funset_is_equal
  (xs1, xs2, cmp) = let
//
fun aux // tail-recursive
  {n1,n2:nat} .<n1>. (
  xs1: list (a, n1), xs2: list (a, n2)
) :<cloref> bool =
(
  case+ xs1 of
  | list_cons (x1, xs1) => (
    case+ xs2 of
    | list_cons (x2, xs2) => let
        val sgn = compare_elt_elt<a> (x1, x2, cmp)
      in
        if sgn = 0 then aux (xs1, xs2) else false
      end
    | list_nil () => false
    ) // end of [list_cons]
  | list_nil () => (
    case+ xs2 of
      list_cons _ => false | list_nil () => true
    // end of [case]
    ) // end of [list_nil]
) (* end of [aux] *)
in
  aux (xs1, xs2)
end // end of [funset_is_equal]

(* ****** ****** *)

implement{a}
funset_is_subset
  (xs1, xs2, cmp) = let
//
fun aux // tail-recursive
  {n1,n2:nat} .<n1+n2>. (
  xs1: list (a, n1), xs2: list (a, n2)
) :<cloref> bool =
(
  case+ xs1 of
  | list_cons (x1, xs11) => (
    case+ xs2 of
    | list_cons (x2, xs21) => let
        val sgn =
          compare_elt_elt<a> (x1, x2, cmp)
        // end of [val]
      in
        if sgn > 0 then false
        else if sgn < 0 then aux (xs1, xs21)
        else aux (xs11, xs21)
      end
    | list_nil () => false
    ) // end of [list_cons]
  | list_nil ((*void*)) => true
) (* end of [aux] *)
//
in
  aux (xs1, xs2)
end // end of [funset_is_subset]

(* ****** ****** *)

implement{a}
funset_compare
  (xs1, xs2, cmp) = let
//
fun aux // tail-recursive
  {n1,n2:nat} .<n1>. (
  xs1: list (a, n1), xs2: list (a, n2)
) :<cloref> int = (
  case+ xs1 of
  | list_cons (x1, xs1) => (
    case+ xs2 of
    | list_cons (x2, xs2) => let
        val sgn = compare_elt_elt<a> (x1, x2, cmp)
      in
        if sgn > 0 then 1 else (
          if sgn < 0 then ~1 else aux (xs1, xs2)
        ) // end of [if]
      end // end of [list_cons]
    | list_nil () => 1
    ) // end of [list_cons]
  | list_nil ((*void*)) => (
    case+ xs2 of list_cons _ => ~1 | list_nil _ => 0
    ) (* end of [list_nil] *)
) (* end of [aux] *)
//
in
  aux (xs1, xs2)
end // end of [funset_compare]

(* ****** ****** *)

implement{a}
funset_insert
  (xs, x0, cmp) = let
//
fun ins
  {n:nat} .<n>.
(
  xs: list (a, n), flag: &int
) :<!wrt> List0 (a) =
(
  case+ xs of
  | list_cons (x, xs1) => let
      val sgn =
        compare_elt_elt<a> (x0, x, cmp)
      // end of [val]
    in
      if sgn > 0 then let
        val () = flag := flag + 1 in list_cons{a}(x0, xs)
      end else if sgn < 0 then let
        val flag0 = flag
        val xs1 = ins (xs1, flag)
      in
        if flag = flag0 then xs else list_cons{a}(x, xs1)
      end else xs // end of [if]
    end // end of [list_cons]
  | list_nil () => let
      val () = flag := flag + 1 in list_cons{a}(x0, list_nil)
    end // end of [val]
) (* end of [ins] *)
//
var flag: int = 0
val () = xs := ins (xs, flag)
//
in
  if flag = 0 then true else false
end // end of [funset_insert]

(* ****** ****** *)

implement{a}
funset_remove
  (xs, x0, cmp) = let
//
fun rem
  {n:nat} .<n>.
(
  xs: list (a, n), flag: &int
) :<!wrt> List0 (a) =
(
  case xs of
  | list_cons (x, xs1) => let
      val sgn =
        compare_elt_elt<a> (x0, x, cmp)
      // end of [val]
    in
      if sgn > 0 then xs
      else if sgn < 0 then let
        val flag0 = flag
        val xs1 = rem (xs1, flag)
      in
        if flag = flag0 then xs else list_cons{a}(x, xs1)
      end else let
        val () = flag := flag + 1 in xs1
      end (* end of [if] *)
    end // end of [list_cons]
  | list_nil () => list_nil ()
) (* end of [rem] *)
//
var flag: int = 0
val () = xs := rem (xs, flag)
//
in
  if flag > 0 then true else false
end // end of [funset_remove]

(* ****** ****** *)

implement{a}
funset_union
  (xs1, xs2, cmp) = let
//
fun aux // non-tail-recursive
  {n1,n2:nat} .<n1+n2>. (
  xs1: list (a, n1), xs2: list (a, n2)
) :<cloref> List0 (a) =
(
  case xs1 of
  | list_cons (x1, xs11) => (
      case+ xs2 of
      | list_cons (x2, xs21) => let
          val sgn = compare_elt_elt<a> (x1, x2, cmp)
        in
          if sgn > 0 then
            list_cons{a}(x1, aux (xs11, xs2))
          else if sgn < 0 then
            list_cons{a}(x2, aux (xs1, xs21))
          else
            list_cons{a}(x1, aux (xs11, xs21))
          // end of [if]
        end // end of [list_cons]
      | list_nil () => xs1
    ) // end of [list_cons]
  | list_nil ((*void*)) => xs2
) (* end of [aux] *)
//
in
  aux (xs1, xs2)
end // end of [funset_union]

(* ****** ****** *)

implement{a}
funset_intersect
  (xs1, xs2, cmp) = let
//
fun aux // non-tail-recursive
  {n1,n2:nat} .<n1+n2>. (
  xs1: list (a, n1), xs2: list (a, n2)
) :<cloref> List0 (a) =
(
  case xs1 of
  | list_cons (x1, xs11) => (
      case+ xs2 of
      | list_cons (x2, xs21) => let
          val sgn = compare_elt_elt<a> (x1, x2, cmp)
        in
          if sgn > 0 then
            aux (xs11, xs2)
          else if sgn < 0 then
            aux (xs1, xs21)
          else
            list_cons{a}(x1, aux (xs11, xs21))
          // end of [if]
        end // end of [list_cons]
      | list_nil () => list_nil ()
    ) // end of [list_cons]
  | list_nil ((*void*)) => list_nil ()
) (* end of [aux] *)
//
in
  aux (xs1, xs2)
end // end of [funset_intersect]

(* ****** ****** *)

implement{a}
funset_diff
  (xs1, xs2, cmp) = let
//
fun aux // non-tail-recursive
  {n1,n2:nat} .<n1+n2>. (
  xs1: list (a, n1), xs2: list (a, n2)
) :<cloref> List0 (a) =
(
  case xs1 of
  | list_cons (x1, xs11) => (
      case+ xs2 of
      | list_cons (x2, xs21) => let
          val sgn =
            compare_elt_elt<a> (x1, x2, cmp)
          // end of [val]
        in
          if sgn > 0 then
            list_cons{a}(x1, aux (xs11, xs2))
          else if sgn < 0 then
            aux (xs1, xs21)
          else
            aux (xs11, xs21)
          // end of [if]
        end // end of [list_cons]
      | list_nil () => xs1
    ) // end of [list_cons]
  | list_nil ((*void*)) => xs2
) (* end of [aux] *)
//
in
  aux (xs1, xs2)
end // end of [funset_diff]

(* ****** ****** *)

implement{a}
funset_symdiff
  (xs1, xs2, cmp) = let
//
fun aux // non-tail-recursive
  {n1,n2:nat} .<n1+n2>. (
  xs1: list (a, n1), xs2: list (a, n2)
) :<cloref> List0 (a) =
(
  case xs1 of
  | list_cons (x1, xs11) => (
    case+ xs2 of
    | list_cons (x2, xs21) => let
        val sgn =
          compare_elt_elt<a> (x1, x2, cmp)
        // end of [val]
      in
        if sgn > 0 then
          list_cons{a}(x1, aux (xs11, xs2))
        else if sgn < 0 then
          list_cons{a}(x2, aux (xs1, xs21))
        else
          aux (xs11, xs21)
        // end of [if]
      end // end of [list_cons]
    | list_nil () => xs1
  ) // end of [list_cons]
  | list_nil ((*void*)) => xs2
) (* end of [aux] *)
//
in
  aux (xs1, xs2)
end // end of [funset_symdiff]

(* ****** ****** *)

implement{a}
funset_foreach_funenv
  {v}{vt}(pf | xs, f, env) = let
//
fun loop
(
  pf: !v
| xs: set(INV(a))
, f: (!v | a, !vt) -> void, env: !vt
) : void = (
//
case+ xs of
| list_cons (x, xs) =>
    (f (pf | x, env); loop (pf | xs, f, env))
| list_nil ((*void*)) => ()
//
) (* end of [loop] *)
//
in
  loop (pf | xs, f, env)
end (* end of [funset_foreach_funenv] *)

(* ****** ****** *)

implement{a}
funset_listize (xs) = list_copy<a> (xs)

(* ****** ****** *)

(* end of [funset_listord.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(*                              Hongwei Xi                             *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS - Unleashing the Potential of Types!
** Copyright (C) 2002-2011 Hongwei Xi, Boston University
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
**
** A functional heap implementation based on Braun trees
**
** Contributed by Hongwei Xi (hwxi AT cs DOT bu DOT edu)
** Time: April, 2010 // based on a version done in November, 2008
**
*)

(* ****** ****** *)
//
// HX-2014-01-15: Porting to ATS2
//
(* ****** ****** *)

#define ATS_DYNLOADFLAG 0 // no dynloading

(* ****** ****** *)

staload "libats/ATS1/SATS/funheap_braun.sats"

(* ****** ****** *)
//
implement{a}
compare_elt_elt (x1, x2, cmp) = cmp (x1, x2)
//
(* ****** ****** *)

datatype
brauntree (a:t@ype+, int) =
  | {n1,n2:nat | n2 <= n1; n1 <= n2+1}
    B (a, n1+n2+1) of (a, brauntree (a, n1), brauntree (a, n2))
  | E (a, 0) of ((*void*))
// end of [brauntree]

stadef bt = brauntree // an abbreviation

(* ****** ****** *)

assume
heap_t0ype_type (a:t@ype) = [n:nat] brauntree (a, n)

(* ****** ****** *)

implement{} funheap_make_nil () = E ()

(* ****** ****** *)

implement{a}
funheap_size (hp) = size (hp) where {
//
// this algorithm is taken from a paper by Chris Okasaki
//
  fun diff
    {nl,nr:nat |
     nr <= nl && nl <= nr+1} .<nr>.
    (nr: size_t nr, t: bt (a, nl)):<> int (nl-nr) =
  (
    case+ t of
    | B (_, tl, tr) =>
      (
        if nr > 0 then let
          val nr2 = half (nr)
        in
          if nr > nr2 + nr2 then diff (nr2, tl) else diff (nr2-1, tr)
        end else begin
          1 // return value
        end // end of [if]
      ) (* end of [B] *)
    | E ((*void*)) => 0
  ) (* end of [diff] *)
//
  fun size {n:nat} .<n>.
    (t: bt (a, n)):<> size_t n = case+ t of
    | B (_, tl, tr) => let
        val nr = size tr; val d1 = diff (nr, tl) + 1
      in
        nr + nr + i2sz(d1)
      end // end of [B]
    | E ((*void*)) => i2sz(0)
  // end of [size]
} // end of [funheap_size]

(* ****** ****** *)

implement{a}
funheap_height (hp) =
  loop (hp, 0) where {
//
fun loop {n:nat} .<n>.
  (t: bt (a, n), res: intGte(0)):<> intGte(0) =
(
  case+ t of B (_, tl, _) => loop (tl, res + 1) | E () => res
) (* end of [loop] *)
//
} (* end of [funheap_height] *)

(* ****** ****** *)

implement{a}
funheap_insert
  (hp, x, cmp) = () where {
//
fun insert {n:nat} .<n>.
  (t: bt (a, n), x: a):<cloref> bt (a, n+1) =
  case+ t of
  | E () => B{a}(x, E (), E ())
  | B (x0, t1, t2) => let
      val sgn = compare_elt_elt<a> (x0, x, cmp)
    in
      if sgn >= 0 then
        B{a}(x, insert (t2, x0), t1) else B{a}(x0, insert (t2, x), t1)
      // end of [if]
    end // end of [B]
// end of [insert]
//
val () = hp := insert (hp, x)
//
} (* end of [funheap_insert] *)

(* ****** ****** *)

fun{a:t@ype}
brauntree_leftrem{n:pos} .<n>.
  (t: bt (a, n), x_r: &a? >> a):<!wrt> bt (a, n-1) = let
//
val+B (x, t1, t2) = t
//
in
//
case+ t1 of
| B _ => let
    val t1 = brauntree_leftrem (t1, x_r) in B{a}(x, t2, t1)
  end // end of [B]
| E () => (x_r := x; E ())
//
end // end of [brauntree_leftrem]

(* ****** ****** *)

fn{a:t@ype}
brauntree_siftdn
  {nl,nr:nat |
   nr <= nl; nl <= nr+1}
(
  x: a
, tl: bt (a, nl), tr: bt (a, nr)
, cmp: cmp a
) :<> bt (a, nl+nr+1) =
  siftdn (x, tl, tr) where {
//
fun siftdn
  {nl,nr:nat | nr <= nl; nl <= nr+1} .<nl+nr>.
  (x: a, tl: bt (a, nl), tr: bt (a, nr))
  :<cloref> bt (a, nl+nr+1) = case+ (tl, tr) of
  | (B (xl, tll, tlr), B (xr, trl, trr)) =>
    (
      if compare_elt_elt<a> (xl, x, cmp) >= 0 then begin // xl >= x
        if compare_elt_elt<a> (xr, x, cmp) >= 0
          then B{a}(x, tl, tr) else B{a}(xr, tl, siftdn (x, trl, trr))
        // end of [if]
      end else begin // xl < x
        if compare_elt_elt<a> (xr, x, cmp) >= 0 then B{a}(xl, siftdn (x, tll, tlr), tr)
        else begin // xr < x
          if compare_elt_elt<a> (xl, xr, cmp) >= 0
            then B{a}(xr, tl, siftdn (x, trl, trr)) else B{a}(xl, siftdn (x, tll, tlr), tr)
          // end of [if]
        end // end of [if]
      end (* end of [if] *)
    ) (* end of [B _, B _] *)
  | (_, _) =>> (
    case+ tl of
    | B (xl, _, _) =>
        if compare_elt_elt<a> (xl, x, cmp) >= 0 then B{a}(x, tl, E) else B{a}(xl, B{a}(x, E, E), E)
      // end of [B]
    | E ((*void*)) => B{a}(x, E (), E ())
    ) (* end of [_, _] *)
// end of [siftdn]
//
} (* end of [brauntree_siftdn] *)

(* ****** ****** *)

implement{a}
funheap_delmin
  (hp0, cmp, res) = let
//
fun delmin{n:pos} .<>.
(
  t: bt (a, n), res: &a? >> a
) :<!wrt> bt (a, n-1) = let
  val+B (x, t1, t2) = t; val () = res := x in
  case+ t1 of
  | B _ => let
      var x_lrm: a // uninitialized
      val t1 = brauntree_leftrem<a> (t1, x_lrm) in
      brauntree_siftdn<a> (x_lrm, t2, t1, cmp)
    end // end of [B]
  | E ((*void*)) => E ()
end // end of [demin]
//
in
//
case+ hp0 of
| B _ => let
    val () = hp0 := delmin (hp0, res)
    prval () = opt_some {a} (res) in true (*removed*)
  end // end of [B_]
| E _ => let
    prval () = opt_none {a} (res) in false(*notremoved*)
  end // end of [E]
//
end // end of [funheap_delmin]

(* ****** ****** *)

implement{a}
funheap_delmin_opt
  (hp0, cmp) = let
//
var res: a? // uninitized
val ans = funheap_delmin<a> (hp0, cmp, res)
//
in
//
if ans
  then let
    prval () = opt_unsome{a}(res) in Some_vt{a}(res)
  end // end of [then]
  else let
    prval () = opt_unnone{a}(res) in None_vt{a}(*void*)
  end // end of [else]
// end of [if]
//
end // end of [funheap_delmin_opt]

(* ****** ****** *)

(* end of [funheap_brauntree.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(*                              Hongwei Xi                             *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS - Unleashing the Potential of Types!
** Copyright (C) 2002-2011 Hongwei Xi, Boston University
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

#define ATS_DYNLOADFLAG 0 // no dynloading

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libats/ATS1/SATS/funheap_binomial.sats"

(* ****** ****** *)
//
implement{a}
compare_elt_elt (x1, x2, cmp) = cmp (x1, x2)
//
(* ****** ****** *)

(*
** binomial trees:
** btree(a, n) is for a binomial tree of rank(n)
*)
datatype
btree (a:t@ype+, int(*rank*)) =
  | {n:nat} btnode (a, n) of (int (n), a, btreelst (a, n))
// end of [btree]

and
btreelst (a:t@ype+, int(*rank*)) =
  | btlst_nil (a, 0) of ((*void*))
  | {n:nat} btlst_cons (a, n+1) of (btree (a, n), btreelst (a, n))
// end of [btreelst]

(* ****** ****** *)

fun{
a:t0p
} btree_rank
  {n:nat} .<>. (
  bt: btree (a, n)
) :<> int (n) = let
  val btnode (n, _, _) = bt in n
end // end of [btree_rank]

(* ****** ****** *)

datatype
bheap (
  a:t@ype+, int(*rank*), int(*size*)
) =
  | {n:nat}
    bheap_nil (a, n, 0) of ()
  | {n:nat}{p:int}{sz:nat}{n1:int | n1 > n}
    bheap_cons (a, n, p+sz) of (EXP2 (n, p) | btree (a, n), bheap (a, n1, sz))
// end of [bheap]

(* ****** ****** *)

fun{a:t0p}
btree_btree_merge
  {n:nat} .<>. (
  bt1: btree (a, n)
, bt2: btree (a, n)
, cmp: cmp a
) :<> btree (a, n+1) = let
  val+btnode (n, x1, bts1) = bt1
  val+btnode (n, x2, bts2) = bt2
  val sgn = compare_elt_elt<a> (x1, x2, cmp)
in
  if sgn <= 0 then
    btnode{a}(n+1, x1, btlst_cons{a}(bt2, bts1))
  else
    btnode{a}(n+1, x2, btlst_cons{a}(bt1, bts2))
  // end of [if]
end // end of [btree_btree_merge]

(* ****** ****** *)

fun{a:t0p}
btree_bheap_merge{sz:nat}
  {n,n1:nat | n <= n1}{p:int} .<sz>.
(
  pf: EXP2 (n, p)
| bt: btree (a, n), n: int (n), hp: bheap (a, n1, sz)
, cmp: cmp (a)
) :<> [n2:int | n2 >= min(n, n1)] bheap (a, n2, sz+p) =
  case+ hp of
  | bheap_cons
      (pf1 | bt1, hp1) => let
      val n1 = btree_rank<a> (bt1)
    in
      if n < n1 then let
        // nothing
      in
        bheap_cons{a}(pf | bt, hp)
      end else if n > n1 then let
        val hp1 =
          btree_bheap_merge<a> (pf | bt, n, hp1, cmp)
        // end of [val]
      in
        bheap_cons{a}(pf1 | bt1, hp1)
      end else let
        prval () = exp2_ispos (pf1)
        prval () = exp2_isfun (pf, pf1)
        val bt = btree_btree_merge<a> (bt, bt1, cmp)
      in
        btree_bheap_merge<a> (EXP2ind (pf) | bt, n+1, hp1, cmp)
      end // end of [if]
    end (* end of [bheap_cons] *)
  | bheap_nil () =>
      bheap_cons{a}(pf | bt, bheap_nil{a}{n+1}())
    // end of [bheap_nil]
// end of [btree_bheap_merge]

(* ****** ****** *)

fun{a:t0p}
bheap_bheap_merge
  {n1,n2:nat}
  {sz1,sz2:nat} .<sz1+sz2>.
(
  hp1: bheap (a, n1, sz1)
, hp2: bheap (a, n2, sz2)
, cmp: cmp a
) :<> [n:int | n >= min(n1, n2)] bheap (a, n, sz1+sz2) =
(
  case+ hp1 of
  | bheap_cons
      (pf1 | bt1, hp11) => (
    case+ hp2 of
    | bheap_nil () => hp1
    | bheap_cons (pf2 | bt2, hp21) => let
//
        prval () = exp2_ispos (pf1)
        prval () = exp2_ispos (pf2)
//
        val n1 = btree_rank<a> (bt1)
        val n2 = btree_rank<a> (bt2)
      in
        if n1 < n2 then
          bheap_cons{a}(pf1 | bt1, bheap_bheap_merge<a> (hp11, hp2, cmp))
        else if n1 > n2 then
          bheap_cons{a}(pf2 | bt2, bheap_bheap_merge<a> (hp1, hp21, cmp))
        else let
          prval () = exp2_isfun (pf1, pf2)
          val bt12 = btree_btree_merge<a> (bt1, bt2, cmp)
        in
          btree_bheap_merge<a> (EXP2ind (pf1) | bt12, n1+1, bheap_bheap_merge<a> (hp11, hp21, cmp), cmp)
        end // end of [if]
      end (* end of [bheap_cons] *)
    ) // end of [bheap_cons]
  | bheap_nil ((*void*)) => hp2
) (* end of [bheap_bheap_merge] *)

(* ****** ****** *)

fun{a:t0p}
bheap_find_min
  {n:nat}{sz:pos} .<>. (
  hp0: bheap (a, n, sz), cmp: cmp a
) :<!wrt> a = x0 where
{
//
fun find
  {n:nat}
  {sz:nat} .<sz>.
(
  hp: bheap (a, n, sz), x0: &a, cmp: cmp a
) :<!wrt> void =
(
  case+ hp of
  | bheap_cons
      (pf | bt, hp) => let
      prval () = exp2_ispos (pf)
      val+btnode (_, x, _) = bt
      val ((*void*)) =
        if compare_elt_elt<a> (x0, x, cmp) > 0 then (x0 := x)
      // end of [val]
    in
      find (hp, x0, cmp)
    end
  | bheap_nil ((*void*)) => ()
) (* end of [find] *)
//
val+bheap_cons
  (pf0 | bt0, hp1) = hp0
val+btnode (_, x0, _) = bt0
var x0: a = x0
val () = find (hp1, x0, cmp)
//
} (* end of [bheap_find_min] *)

(* ****** ****** *)

fun{a:t0p}
bheap_remove_min
  {n:nat}{sz:pos} .<>. (
  hp0: bheap (a, n, sz), cmp: cmp a
) :<!wrt> [
  n1,n2,p:int | n1 >= n; n2 >= n;sz >= p
] (
  EXP2 (n2, p)
| bheap (a, n1, sz-p), btree (a, n2)
) = let
//
  val+bheap_cons
    (pf0 | bt0, hp1) = hp0
  val+btnode (_, x0, _) = bt0
//
// HX: [find] and [remove] can be merged into one
//
  fun find
    {n:nat}{sz:nat} .<sz>.
  (
    hp0: bheap (a, n, sz)
  , x0: &a, pos: &intGte(0) >> _, cmp: cmp a
  ) :<!wrt> void =
    case+ hp0 of
    | bheap_cons (pf | bt, hp) => let
        prval () = exp2_ispos (pf)
        val+ btnode (_, x, _) = bt
        val sgn = compare_elt_elt<a> (x0, x, cmp)
        val () = if sgn > 0 then (x0 := x; pos := pos+1)
      in
        find (hp, x0, pos, cmp)
      end // [bheap_cons]
    | bheap_nil ((*void*)) => ()
  (* end of [find] *)
//
  var x0: a = x0 and pos: Nat = 0
  val () = find (hp1, x0, pos, cmp)
//
  fun remove
    {n:nat}{sz:nat}
    {pos:nat} .<pos>. (
    hp0: bheap (a, n, sz), pos: int (pos)
  , btmin: &btree(a, 0)? >> btree (a, n2)
  ) :<!wrt> #[
    n1,n2,p:int | n1 >= n; n2 >= n; sz >= p
  ] (
    EXP2 (n2, p) | bheap (a, n1, sz-p)
  ) = let
//
    prval () = __assert () where {
      extern praxi __assert (): [sz > 0] void
    } // end of [prval]
//
    val+ bheap_cons (pf | bt, hp) = hp0
    prval () = exp2_ispos (pf)
  in
    if pos > 0 then let
      val (pfmin | hp) = remove (hp, pos-1, btmin)
    in
      (pfmin | bheap_cons{a}(pf | bt, hp))
    end else let
      val () = btmin := bt in (pf | hp)
    end // end of [if]
  end (* end of [remove] *)
//
  var btmin: btree (a, 0)?
  val (pf | hp) = remove (hp0, pos, btmin)
//
in
  (pf | hp, btmin)
end // end of [bheap_remove_min]

(* ****** ****** *)

assume
heap_t0ype_type (a:t0p) = [n,sz:nat] bheap (a, n, sz)

(* ****** ****** *)

implement{}
funheap_make_nil{a}((*void*)) = bheap_nil{a}{0}()

(* ****** ****** *)

local

fun{}
pow2{n:nat} .<>.
(
  n: int n
) :<> [p:pos] (EXP2 (n, p) | size_t (p)) = let
//
val res = (1 << n)
val [p:int] res = $UN.cast{sizeGt(0)}(res)
//
in
  ($UN.castview0{EXP2(n, p)}(0) | res)
end // end of [pow2]

in (* in of [local] *)

implement{a}
funheap_size (hp) = let
//
  fun aux
    {n:nat}{sz:nat} .<sz>.
    (hp: bheap (a, n, sz)):<> size_t (sz) =
    case+ hp of
    | bheap_cons (pf | bt, hp) => let
        val btnode (n, _, _) = bt; val (pf1 | p) = pow2 (n)
        prval () = exp2_isfun (pf, pf1)
      in
        p + aux (hp)
      end // end of [bheap_cons]
    | bheap_nil ((*void*)) => i2sz(0)
  (* end of [aux] *)
//
in
  aux (hp)
end // end of [funheap_size]

end // end of [local]

(* ****** ****** *)

implement{a}
funheap_insert
  (hp, x0, cmp) = let
  val bt = btnode{a}(0, x0, btlst_nil ())
in
  hp := btree_bheap_merge<a> (EXP2bas () | bt, 0, hp, cmp)
end // end of [funheap_insert]

(* ****** ****** *)

implement
funheap_is_empty{a}(hp) =
(
  case+ hp of
  | bheap_cons (_ | _, _) => false | bheap_nil () => true
) // end of [funheap_is_empty]

implement
funheap_isnot_empty{a}(hp) =
(
  case+ hp of
  | bheap_cons (_ | _, _) => true | bheap_nil () => false
) // end of [funheap_isnot_empty]

(* ****** ****** *)

implement{a}
funheap_getmin
  (hp0, cmp, res) = let
in
//
case+ hp0 of
| bheap_cons
    (pf0 | _, _) => let
    prval () = exp2_ispos (pf0)
    val () = res := bheap_find_min<a> (hp0, cmp)
    prval () = opt_some{a}(res)
  in
    true
  end // end of [bheap_cons]
| bheap_nil () => let
    prval () = opt_none{a}(res) in false
  end // end of [bheap_nil]
//
end // end of [funheap_getmin]

(* ****** ****** *)

implement{a}
funheap_delmin
  (hp0, cmp, res) = let
in
//
case+ hp0 of
| bheap_cons
    (pf0 | _, _) => let
    prval () = exp2_ispos (pf0)
    val (_ | hp_new, btmin) =
      bheap_remove_min<a> (hp0, cmp)
    val btnode (_, x, bts) = btmin
    val ((*void*)) = res := x
    prval ((*void*)) = opt_some{a}(res)
    val hp1 = let
      fun loop
        {n:nat}{sz:nat} .<n>.
      (
        bts: btreelst (a, n), hp: bheap (a, n, sz)
      ) :<> [sz:nat] bheap (a, 0, sz) =
      (
        case+ bts of
        | btlst_cons
            (bt, bts) => let
            prval pf = exp2_istot ()
          in
            loop (bts, bheap_cons{a}(pf | bt, hp))
          end // end of [btlst_cons]
        | btlst_nil ((*void*)) => (hp)
      ) (* end of [loop] *)
    in
      loop (bts, bheap_nil)
    end // end of [val]
    val ((*void*)) =
      hp0 := bheap_bheap_merge<a> (hp_new, hp1, cmp)
    // end of [val]
  in
    true
  end // end of [bheap_cons]
| bheap_nil () => let
    prval () = opt_none{a}(res) in false
  end // end of [bheap_nil]
// end of [case]
//
end // end of [funheap_delmin]

(* ****** ****** *)

implement{a}
funheap_delmin_opt
  (hp0, cmp) = let
//
var res: a? // uninitized
val ans = funheap_delmin<a> (hp0, cmp, res)
//
in
//
if ans
  then let
    prval () = opt_unsome{a}(res) in Some_vt{a}(res)
  end // end of [then]
  else let
    prval () = opt_unnone{a}(res) in None_vt{a}(*void*)
  end // end of [else]
// end of [if]
//
end // end of [funheap_delmin_opt]

(* ****** ****** *)

implement{a}
funheap_merge
  (hp1, hp2, cmp) = bheap_bheap_merge<a> (hp1, hp2, cmp)
// end of [funheap_merge]

(* ****** ****** *)

(* end of [funheap_binomail.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(*                              Hongwei Xi                             *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS - Unleashing the Potential of Types!
** Copyright (C) 2002-2011 Hongwei Xi, Boston University
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
**
** A functional map implementation based on ordered lists
**
** Contributed by Hongwei Xi (hwxi AT cs DOT bu DOT edu)
** Time: May 18, 2011
**
*)

(* ****** ****** *)

#define ATS_DYNLOADFLAG 0 // no dynloading

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"
staload _(*anon*) = "prelude/DATS/list.dats"

(* ****** ****** *)

staload "libats/ATS1/SATS/funmset_listord.sats"

(* ****** ****** *)
//
implement{a}
compare_elt_elt (x1, x2, cmp) = cmp (x1, x2)
//
(* ****** ****** *)

typedef intGt0 = intGt(0)

(* ****** ****** *)

assume
mset_t0ype_type (a: t@ype) = List0 @(intGt0, a)

(* ****** ****** *)
//
// HX:
// mset is represented as a sorted mlist in descending order;
// note that desending order is chosen to facilitate mset comparion
//
(* ****** ****** *)

implement{}
funmset_make_nil () = list_nil ()

(* ****** ****** *)

implement{a}
funmset_make_sing (x) = let
  typedef nx = (intGt0, a) in list_vt2t(list_make_sing<nx>((1, x)))
end // end of [funmset_make_sing]

implement{a}
funmset_make_pair
  (x1, x2, cmp) = let
//
typedef nx = (intGt0, a)
//
val sgn = compare_elt_elt<a> (x1, x2, cmp)
//
in
//
if sgn > 0 then let
  val nx1 = (1, x1) and nx2 = (1, x2)
in
  list_vt2t(list_make_pair<nx> (nx1, nx2))
end else if sgn < 0 then let
  val nx1 = (1, x1) and nx2 = (1, x2)
in
  list_vt2t(list_make_pair<nx> (nx2, nx1))
end else let
  val nx = @(2, x1) in list_vt2t(list_make_sing<nx> (nx))
end // end of [if]
//
end // end of [funmset_make_pair]

(* ****** ****** *)

implement{a}
funmset_make_list
  (xs, cmp) = let
//
typedef nx = (intGt0, a)
//
fun ntimes
  {k:nat} .<k>.
(
  xs: list_vt (a, k), x0: a, n: &intGt0 >> _
) :<!wrt> [k1:nat | k1 <= k] list_vt (a, k1) =
(
  case+ xs of
    | @list_vt_cons
        (x, xs1) => let
        val sgn =
          compare_elt_elt<a> (x0, x, cmp)
        // end of [val]
      in
        if sgn > 0 then let
          prval () = fold@ (xs) in xs
        end else let
          val xs1 = xs1
          val () = n := n + 1
          val () = free@{a}{0}(xs)
        in
          ntimes (xs1, x0, n)
        end // end of [if]
      end // end of [list_vt_cons]
    | list_vt_nil ((*void*)) => xs
) (* end of [ntimes] *)
//
fun loop{k:nat} .<k>.
(
  xs: list_vt (a, k), res: &mset(a)? >> mset(a)
) :<!wrt> void =
(
  case+ xs of
  | ~list_vt_cons
      (x0, xs) => let
      var n: intGt0 = 1
      val xs = ntimes (xs, x0, n)
      val nx0 = @(n, x0)
      val () = res := list_cons{nx}{0} (nx0, _)
      val+list_cons (_, res1) = res
      val ((*void*)) = loop (xs, res1)
      prval ((*void*)) = fold@ (res)
    in
      // nothing
    end // end of [list_vt_cons]
  | ~list_vt_nil () => let
      val () = res := list_nil () in (*nothing*)
    end // end of [list_vt_nil]
) (* end of [loop] *)
//
val xs = list_copy (xs)
prval () = lemma_list_vt_param (xs)
//
// HX: ~cmp: descending order
//
val xs = list_vt_mergesort_fun (xs, lam (x1, x2) => ~cmp (x1, x2))
//
var res: mset(a)
val () = loop (xs, res)
//
in
  res
end // end of [funmset_make_list]

(* ****** ****** *)

implement{a}
funmset_size (nxs) = let
  typedef nx = @(intGt0, a)
  fun loop {k:nat} .<k>.
    (nxs: list (nx, k), res: Size):<> Size =
    case+ nxs of
    | list_cons (nx, nxs) => loop (nxs, res + nx.0) | list_nil () => res
  // end of [loop]
in
  loop (nxs, i2sz(0))
end // end of [funmset_size]

(* ****** ****** *)

implement{a}
funmset_get_ntime
  (nxs, x0, cmp) = let
//
typedef nx = @(intGt0, a)
//
fun loop
  {k:nat} .<k>.
(
  nxs: list (nx, k)
) :<> intGte(0) =
  case+ nxs of
  | list_nil ((*void*)) => 0
  | list_cons (nx, nxs) => let
      val sgn = compare_elt_elt<a> (x0, nx.1, cmp) in
      if sgn > 0 then 0 else (if sgn < 0 then loop (nxs) else nx.0)
    end // end of [list_cons]
// end of [loop]
//
in
  loop (nxs)
end // end of [funmset_get_ntime]

(* ****** ****** *)

implement{a}
funmset_is_member
  (xs, x0, cmp) = funmset_get_ntime (xs, x0, cmp) > 0
// end of [funmset_is_member]

implement{a}
funmset_isnot_member
  (xs, x0, cmp) = funmset_get_ntime (xs, x0, cmp) = 0
// end of [funmset_isnot_member]

(* ****** ****** *)

implement{a}
funmset_is_subset
  (nxs1, nxs2, cmp) = let
//
typedef nx = (int, a)
fun aux // tail-recursive
  {k1,k2:nat} .<k1+k2>. (
  nxs1: list (nx, k1), nxs2: list (nx, k2)
) :<cloref> bool =
  case+ nxs1 of
  | list_cons
      (nx1, nxs11) => (
    case+ nxs2 of
    | list_cons
        (nx2, nxs21) => let
        val sgn = compare_elt_elt<a> (nx1.1, nx2.1, cmp)
      in
        if sgn > 0 then false
        else if sgn < 0 then aux (nxs1, nxs21)
        else (
          if nx1.0 <= nx2.0 then aux (nxs11, nxs21) else false
        ) // end of [if]
      end // end of [list_cons]
    | list_nil ((*void*)) => false
    ) // end of [list_cons]
  | list_nil ((*void*)) => true
// end of [aux]
in
  aux (nxs1, nxs2)
end // end of [funmset_is_subset]

implement{a}
funmset_is_equal
  (nxs1, nxs2, cmp) = let
//
typedef nx = (int, a)
fun aux // tail-recursive
  {k1,k2:nat} .<k1>. (
  nxs1: list (nx, k1), nxs2: list (nx, k2)
) :<cloref> bool = (
  case+ nxs1 of
  | list_cons
      (nx1, nxs1) => (
    case+ nxs2 of
    | list_cons
        (nx2, nxs2) => let
        val sgn = compare_elt_elt<a> (nx1.1, nx2.1, cmp)
      in
        if sgn = 0 then (
          if nx1.0 = nx2.0 then aux (nxs1, nxs2) else false
        ) else false // end of [if]
      end // end of [list_cons]
    | list_nil ((*void*)) => false
    ) // end of [list_cons]
  | list_nil ((*void*)) => (
      case+ nxs2 of | list_cons _ => false | list_nil () => true
    ) (* end of [list_nil] *)
) (* end of [aux] *)
//
in
  aux (nxs1, nxs2)
end // end of [funmset_is_equal]

(* ****** ****** *)

implement{a}
funmset_compare
  (nxs1, nxs2, cmp) = let
//
typedef nx = (int, a)
//
fun aux // tail-recursive
  {k1,k2:nat} .<k1>. (
  nxs1: list (nx, k1), nxs2: list (nx, k2)
) :<cloref> int = (
  case+ nxs1 of
  | list_cons
      (nx1, nxs1) => (
    case+ nxs2 of
    | list_cons
        (nx2, nxs2) => let
        val sgn =
          compare_elt_elt<a> (nx1.1, nx2.1, cmp)
        // end of [val]
      in
        if sgn > 0 then 1
        else if sgn < 0 then ~1
        else let
          val n1 = nx1.0 and n2 = nx2.0
        in
          if n1 > n2 then 1
          else if n1 < n2 then ~1
          else aux (nxs1, nxs2)
        end (* end of [if] *)
      end // end of [list_cons]
    | list_nil ((*void*)) => 1
    ) // end of [list_cons]
  | list_nil ((*void*)) =>
    (
      case+ nxs2 of list_cons _ => ~1 | list_nil _ => 0
    ) (* end of [list_nil] *)
) (* end of [aux] *)
//
in
  aux (nxs1, nxs2)
end // end of [funmset_compare]

(* ****** ****** *)

implement{a}
funmset_insert
  (nxs, x0, cmp) = let
//
typedef nx = @(intGt0, a)
//
fun loop
  {k:nat} .<k>. (
  nxs: list (nx, k)
) :<cloref> List0 (nx) =
  case+ nxs of
  | list_cons
      (nx, nxs1) => let
      val sgn = compare_elt_elt<a> (x0, nx.1, cmp)
    in
      if sgn > 0 then
        list_cons{nx}((1, x0), nxs)
      else if sgn < 0 then let
        val nxs1 = loop (nxs1) in list_cons{nx}(nx, nxs1)
      end else let
        val nx = (nx.0 + 1, nx.1) in list_cons{nx}(nx, nxs1)
      end (* end of [if] *)
    end // end of [list_cons]
  | list_nil () => list_cons{nx}((1, x0), list_nil())
// end of [loop]
//
in
  nxs := loop (nxs)
end // end of [funmset_insert]

(* ****** ****** *)

implement{a}
funmset_remove
  (nxs, x0, cmp) = let
//
typedef nx = @(intGt0, a)
//
fun loop
  {k:nat} .<k>.
(
  nxs: list (nx, k), flag: &int >> _
) :<!wrt> List0 (nx) =
  case nxs of
  | list_cons
      (nx, nxs1) => let
      val sgn = compare_elt_elt<a> (x0, nx.1, cmp)
    in
      if sgn > 0 then nxs
      else if sgn < 0 then let
        val flag0 = flag
        val nxs1 = loop (nxs1, flag)
      in
        if flag = flag0 then nxs else list_cons{nx}(nx, nxs1)
      end else let
        val n1 = nx.0 - 1
        val () = flag := flag + 1
      in
        if n1 > 0 then list_cons{nx}((n1, nx.1), nxs1) else nxs1
      end (* end of [if] *)
   end // end of [list_cons]
  | list_nil () => list_nil ()
// end of [aux]
//
var flag: int = 0
val () = nxs := loop (nxs, flag)
//
in
  if flag > 0 then true else false
end // end of [funmset_remove]

(* ****** ****** *)

implement{a}
funmset_union
  (nxs1, nxs2, cmp) = let
//
typedef nx = @(intGt0, a)
//
fun aux
  {k1,k2:nat} .<k1+k2>.
(
  nxs1: list (nx, k1)
, nxs2: list (nx, k2)
) :<cloref> List0 (nx) =
(
  case nxs1 of
  | list_cons
      (nx1, nxs11) => (
    case+ nxs2 of
    | list_cons
        (nx2, nxs21) => let
        val sgn =
          compare_elt_elt<a> (nx1.1, nx2.1, cmp)
        // end of [val]
      in
        if sgn > 0 then
          list_cons{nx}(nx1, aux (nxs11, nxs2))
        else if sgn < 0 then
          list_cons{nx}(nx2, aux (nxs1, nxs21))
        else let
          val nx12 = (nx1.0 + nx2.0, nx1.1)
        in
          list_cons{nx}(nx12, aux (nxs11, nxs21))
        end (* end of [if] *)
      end // end of [list_cons]
    | list_nil ((*void*)) => nxs1
  ) (* end of [list_cons] *)
  | list_nil ((*void*)) => nxs2
) (* end of [aux] *)
in
  aux (nxs1, nxs2)
end // end of [funmset_union]

(* ****** ****** *)

implement{a}
funmset_intersect
  (nxs1, nxs2, cmp) = let
//
typedef nx = @(intGt0, a)
//
fun aux
  {k1,k2:nat} .<k1+k2>.
(
  nxs1: list (nx, k1)
, nxs2: list (nx, k2)
) :<cloref> List0 (nx) = let
in
//
case nxs1 of
| list_cons
    (nx1, nxs11) => (
  case+ nxs2 of
  | list_cons
      (nx2, nxs21) => let
      val sgn =
        compare_elt_elt<a> (nx1.1, nx2.1, cmp)
      // end of [val]
    in
      if sgn > 0 then
        aux (nxs11, nxs2)
      else if sgn < 0 then
        aux (nxs1, nxs21)
      else let
        val nx12 =
        (
          if nx1.0 <= nx2.0 then nx1 else nx2
        ) : nx // end of [val]
      in
        list_cons{nx}(nx1, aux (nxs11, nxs21))
      end // end of [if]
    end // end of [list_cons]
  | list_nil ((*void*)) => list_nil ()
  ) (* end of [list_cons] *)
| list_nil ((*void*)) => list_nil ()
//
end (* end of [aux] *)
//
in
  aux (nxs1, nxs2)
end // end of [funmset_intersect]

(* ****** ****** *)
(*
** HX: the returned list is in descending order
*)
implement{a}
funmset_listize (nxs) = let
  typedef nx = @(intGt0, a)
  viewtypedef res = List_vt (a)
in
  list_map_fun<nx><a> (nxs, lam (nx) =<0> nx.1)
end // end of [funmset_listize]

(* ****** ****** *)
//
(*
** HX: the returned list is in descending order
*)
//
implement{a}
funmset_mlistize
  (nxs) = res where
{
//
typedef nx = @(intGt0, a)
vtypedef res = List0_vt (a)
//
fnx loop1{k:nat} .<k,0>.
(
  nxs: list (nx, k), res: &res? >> res
) :<!wrt> void =
(
  case+ nxs of
  | list_cons
      (nx, nxs) => loop2 (nx.0, nx.1, nxs, res)
  | list_nil ((*void*)) => (res := list_vt_nil)
) (* end of [loop1] *)
//
and loop2{k,n:nat} .<k,n+1>.
(
  n: int n, x: a, nxs: list (nx, k), res: &res? >> res
) :<!wrt> void =
(
  if n > 0 then let
    val () =
      res := list_vt_cons{a}{0}(x, _)
    // end of [val]
    val+list_vt_cons (_, res1) = res
    val () = loop2 (n-1, x, nxs, res1)
    prval ((*void*)) = fold@{a}(res)
  in
    // nothing
  end else
    loop1 (nxs, res)
  // end of [if]
) (* end of [loop2] *)
//
var res: ptr
val () = loop1 (nxs, res)
//
} (* end of [funmset_mlistize] *)
//  
(* ****** ****** *)

(* end of [funmset_listord.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(*                              Hongwei Xi                             *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS - Unleashing the Potential of Types!
** Copyright (C) 2002-2011 Hongwei Xi, Boston University
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
**
** A linear set implementation based on ordered lists
**
** Contributed by Hongwei Xi (hwxi AT cs DOT bu DOT edu)
** Time: February 17, 2012
**
*)

(* ****** ****** *)
//
// HX-2014-01-17: Porting to ATS2
//
(* ****** ****** *)

#define
ATS_DYNLOADFLAG 0 // no dynloading

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)
//
staload
"libats/ATS1/SATS/linset_listord.sats"
//
(* ****** ****** *)
//
implement{a}
compare_elt_elt (x1, x2, cmp) = cmp (x1, x2)
//
(* ****** ****** *)

assume
set_t0ype_vtype (a:t0p) = List0_vt (a)

(* ****** ****** *)
//
// HX:
// a set is represented as a sorted list in descending order;
// note that descending order is chosen to faciliate set comparison
//
(* ****** ****** *)

implement{}
linset_nil () = list_vt_nil ()
implement{}
linset_make_nil () = list_vt_nil ()

(* ****** ****** *)

implement{a}
linset_make_sing (x) = list_make_sing<a> (x)

(* ****** ****** *)

implement{a}
linset_size (xs) = i2sz(list_vt_length (xs))

(* ****** ****** *)

implement{a}
linset_is_member
  (xs, x0, cmp) = let
//
fun loop
  {n:nat} .<n>. (
  xs: !list_vt (a, n)
) :<cloref> bool =
(
  case+ xs of
  | list_vt_cons
      (x, xs1) => let
      val sgn =
        compare_elt_elt<a> (x0, x, cmp)
      // end of [val]
    in
      if sgn > 0
        then false else (if sgn < 0 then loop (xs1) else true)
      // end of [if]
    end // end of [list_vt_cons]
  | list_vt_nil () => false
) (* end of [loop] *)
//
in
  loop (xs)
end // end of [linset_is_member]

(* ****** ****** *)

implement{a}
linset_isnot_member
  (xs, x0, cmp) = ~linset_is_member<a> (xs, x0, cmp)
// end of [linset_isnot_member]

(* ****** ****** *)

implement{a}
linset_is_subset
  (xs1, xs2, cmp) = let
//
fun loop
  {n1,n2:nat} .<n1+n2>.
(
  xs1: list (a, n1), xs2: list (a, n2)
) :<cloref> bool =
(
  case+ xs1 of
  | list_cons
      (x1, xs11) => (
    case+ xs2 of
    | list_cons
        (x2, xs21) => let
        val sgn =
          compare_elt_elt<a> (x1, x2, cmp)
        // end of [val]
      in
        if sgn > 0 then false
        else if sgn < 0 then loop (xs1, xs21)
        else loop (xs11, xs21)
      end
    | list_nil ((*void*)) => false
    ) // end of [list_cons]
  | list_nil ((*void*)) => true
) (* end of [loop] *)
//
in
  loop ($UN.list_vt2t(xs1), $UN.list_vt2t(xs2))
end // end of [linset_is_subset]

(* ****** ****** *)

implement{a}
linset_is_supset
  (xs1, xs2, cmp) = linset_is_subset<a> (xs2, xs1, cmp)
// end of [linset_is_supset]

(* ****** ****** *)

implement{a}
linset_is_equal
  (xs1, xs2, cmp) = let
//
fun loop
  {n1,n2:nat} .<n1+n2>.
(
  xs1: list (a, n1), xs2: list (a, n2)
) :<cloref> bool =
(
  case+ xs1 of
  | list_cons
      (x1, xs11) => (
    case+ xs2 of
    | list_cons
        (x2, xs21) => let
        val sgn =
          compare_elt_elt<a> (x1, x2, cmp)
        // end of [val]
      in
        if sgn = 0 then loop (xs11, xs21) else false
      end // end of [list_cons]
    | list_nil ((*void*)) => false
    ) // end of [list_cons]
  | list_nil ((*void*)) =>
    (
      case+ xs2 of list_cons _ => false | list_nil () => true
    ) (* end of [list_nil] *)
) (* end of [loop] *)
//
in
  loop ($UN.list_vt2t(xs1), $UN.list_vt2t(xs2))
end // end of [linset_is_equal]

(* ****** ****** *)
//
implement{a} linset_copy (xs) = list_vt_copy<a> (xs)
//
implement{a} linset_free (xs) = list_vt_free<a> (xs)
//
(* ****** ****** *)

implement{a}
linset_insert
  (xs, x0, cmp) = let
//
fun ins{n:nat} .<n>. ( // tail-recursive
  xs: &list_vt (a, n) >> list_vt (a, n1)
) :<!wrt> #[n1:nat | n <= n1; n1 <= n+1] bool =
(
  case+ xs of
  | @list_vt_cons
      (x, xs1) => let
      val sgn =
        compare_elt_elt<a> (x0, x, cmp)
      // end of [val]
    in
      if sgn > 0 then let
        prval () = fold@ (xs)
        val () = xs := list_vt_cons{a}(x0, xs)
      in
        false
      end else if sgn < 0 then let
        val res = ins (xs1); prval () = fold@ (xs) in res
      end else let // x0 = x
        prval () = fold@ (xs) in true // [x0] is already in [xs]
      end // end of [if]
    end (* end of [list_vt_cons] *)
  | ~list_vt_nil () => let
      val () = xs := list_make_sing<a> (x0) in false
    end // end of [list_vt_nil]
) (* end of [ins] *)
//
in
  ins (xs)  
end // end of [linset_insert]

(* ****** ****** *)

implement{a}
linset_remove
  (xs, x0, cmp) = let
//
fun rem {n:nat} .<n>. ( // tail-recursive
  xs: &list_vt (a, n) >> list_vt (a, n1)
) :<!wrt> #[n1:nat | n1 <= n; n <= n1+1] bool =
(
  case+ xs of
  | @list_vt_cons
      (x, xs1) => let
      val sgn =
         compare_elt_elt<a> (x0, x, cmp)
      // end of [val]
    in
      if sgn > 0 then let
        prval () = fold@{a}(xs) in false
      end else if sgn < 0 then let
        val res = rem (xs1); prval () = fold@{a}(xs) in res
      end else let // x0 = x
        val xs1_ = xs1
        val () = free@{a}{0}(xs)
        val () = xs := xs1_
      in
        true // [x0] is removed from [xs]
      end // end of [if]
    end (* end of [list_vt_cons] *)
  | list_vt_nil ((*void*)) => false
) (* end of [rem] *)
//
in
  rem (xs)  
end // end of [linset_remove]

(* ****** ****** *)

(*
** By Brandon Barker
*)
implement
{a}(*tmp*)
linset_choose
  (xs, x0) = let
in
//
case+ xs of
| list_vt_cons
    (x, xs1) => let
    val () = x0 := x
    prval () = opt_some{a}(x0)
  in
    true
  end // end of [list_vt_cons]
| list_vt_nil () => let
    prval () = opt_none{a}(x0)
  in
    false
  end // end of [list_vt_nil]
//
end // end of [linset_choose]

(* ****** ****** *)

implement{a}
linset_choose_opt
  (xs) = let
//
var x0: a?
val ans = linset_choose<a> (xs, x0)
//
in
//
if ans then let
  prval () = opt_unsome{a}(x0) in Some_vt{a}(x0)
end else let
  prval () = opt_unnone{a}(x0) in None_vt(*void*)
end (* end of [if] *)
//
end // end of [linset_choose_opt]

(* ****** ****** *)

implement{a}
linset_chooseout
  (xs0, x0) = let
in
//
case+ xs0 of
| ~list_vt_cons
    (x, xs) => let
    val () = x0 := x
    prval () = opt_some{a}(x0)
    val () = xs0 := xs
  in
    true
  end // end of [list_vt_cons]
| list_vt_nil () => let
    prval () = opt_none{a}(x0)
  in
    false
  end // end of [list_vt_nil]
//
end // end of [linset_chooseout]

(* ****** ****** *)

implement{a}
linset_chooseout_opt
  (xs) = let
//
var x0: a?
val ans = linset_chooseout<a> (xs, x0)
//
in
//
if ans then let
  prval () = opt_unsome{a}(x0) in Some_vt{a}(x0)
end else let
  prval () = opt_unnone{a}(x0) in None_vt(*void*)
end (* end of [if] *)
//
end // end of [linset_chooseout_opt]

(* ****** ****** *)

implement
{a}(*tmp*)
linset_union
  (xs1, xs2, cmp) = let
//
vtypedef res = List0_vt (a)
//
fun loop
  {n1,n2:nat} .<n1+n2>.
(
  xs1: list_vt (a, n1)
, xs2: list_vt (a, n2), res: &res? >> res
) :<!wrt> void =
(
  case+ xs1 of
  | @list_vt_cons
      (x1, xs11) => (
    case+ xs2 of
    | @list_vt_cons
        (x2, xs21) => let
        val sgn =
          compare_elt_elt<a> (x1, x2, cmp)
        // end of [val]
      in
        if sgn > 0 then let
          val xs11_ = xs11
          prval () = fold@{a}(xs2)
          val () = loop (xs11_, xs2, xs11)
          prval () = fold@{a}(xs1)
        in
          res := xs1
        end else if sgn < 0 then let
          prval () = fold@{a}(xs1)
          val xs21_ = xs21
          val () = loop (xs1, xs21_, xs21)
          prval () = fold@{a}(xs2)
        in
          res := xs2
        end else let // x1 = x2
          val xs11_ = xs11
          val xs21_ = xs21
          val () = free@{a}{0}(xs2)
          val () = loop (xs11_, xs21_, xs11)
          prval () = fold@{a}(xs1)
        in
          res := xs1
        end // end of [if]
      end // end of [list_vt_cons]
    | ~list_vt_nil ((*void*)) =>
        let prval () = fold@{a}(xs1) in res := xs1 end
    ) // end of [list_vt_cons]
  | ~list_vt_nil ((*void*)) => (res := xs2)
) (* end of [loop] *)
//
var res: res // uninitialized
val ((*void*)) = loop (xs1, xs2, res)
//
in
  res
end // end of [linset_union]

(* ****** ****** *)

implement{a}
fprint_linset_sep
  (out, xs, sep) = fprint_list_vt_sep (out, xs, sep)
// end of [fprint_linset_sep]

(* ****** ****** *)

implement{a}
linset_foreach_funenv
  {v}{vt}(pf | xs, f, env) = let
//
fun loop
(
  pf: !v
| xs: !set(INV(a))
, f: (!v | a, !vt) -> void, env: !vt
) : void = (
//
case+ xs of
| list_vt_cons (x, xs) =>
    (f (pf | x, env); loop (pf | xs, f, env))
| list_vt_nil ((*void*)) => ()
//
) (* end of [loop] *)
//
in
  loop (pf | xs, f, env)
end (* end of [linset_foreach_funenv] *)

(* ****** ****** *)

implement{a} linset_listize (xs) = xs

(* ****** ****** *)

implement{a}
linset_listize1 (xs) = list_vt_copy<a> (xs)

(* ****** ****** *)

(* end of [linset_listord.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(*                              Hongwei Xi                             *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS - Unleashing the Potential of Types!
** Copyright (C) 2002-2011 Hongwei Xi, Boston University
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
**
** A functional heap implementation based on Braun trees
**
** Contributed by Hongwei Xi (hwxi AT cs DOT bu DOT edu)
** Time: April, 2010 // based on a version done in November, 2008
**
*)

(* ****** ****** *)
//
// HX-2011-11-13:
// This style of heap is VERY inefficient! Please use funheap_binomial
// instead, which is about 20 times faster for a heap of the size 1M.
//
(* ****** ****** *)
//
// HX-2014-01-15:
// Porting to ATS2 from ATS1
//
(* ****** ****** *)
//
abstype
heap_t0ype_type (a:t@ype+) = ptr
//
typedef
heap(a:t0p) = heap_t0ype_type (a)
//
(* ****** ****** *)

typedef
cmp (a:t0p) = (a, a) -<cloref> int

(* ****** ****** *)

fun{a:t0p}
compare_elt_elt
  (x1: a, x2: a, cmp: cmp a):<> int
// end of [compare_elt_elt]

(* ****** ****** *)

fun{} funheap_make_nil{a:t0p} ():<> heap (a)

(* ****** ****** *)
//
fun{a:t0p}
funheap_size (heap(INV(a))):<> Size
//
(* ****** ****** *)
//
// HX: primarily for statistics
//
fun{a:t0p}
funheap_height (hp: heap(INV(a))):<> intGte(0)
//
(* ****** ****** *)

fun{a:t0p}
funheap_insert
  (hp: &heap(INV(a)) >> _, x: a, cmp: cmp a):<!wrt> void

(* ****** ****** *)

fun{a:t@ype}
funheap_getmin (
  hp: heap (INV(a)), cmp: cmp a, res: &a? >> opt (a, b)
) :<!wrt> #[b:bool] bool b // end of [funheap_getmin]

fun{a:t0p}
funheap_getmin_opt
  (hp: heap(INV(a)), cmp: cmp a):<!wrt> Option_vt (a)
// end of [funheap_getmin_opt]

(* ****** ****** *)

fun{a:t0p}
funheap_delmin (
  hp: &heap(INV(a)) >> _, cmp: cmp a, res: &a? >> opt (a, b)
) :<!wrt> #[b:bool] bool b // end of [funheap_delim]

fun{a:t0p}
funheap_delmin_opt
  (hp: &heap(INV(a)) >> _, cmp: cmp a):<!wrt> Option_vt (a)
// end of [funheap_delmin_opt]

(* ****** ****** *)

(* end of [funheap_braun.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(*                              Hongwei Xi                             *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS - Unleashing the Potential of Types!
** Copyright (C) 2002-2011 Hongwei Xi, Boston University
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// HX-2014-01-15:
// Porting to ATS2 from ATS1
//
(* ****** ****** *)
//
abstype
heap_t0ype_type (a:t@ype+) = ptr
//
typedef heap(a:t0p) = heap_t0ype_type(a)
//
(* ****** ****** *)
//
typedef cmp (a:t0p) = (a, a) -<cloref> int
//
fun{a:t0p}
compare_elt_elt (x1: a, x2: a, cmp: cmp a):<> int
//
(* ****** ****** *)

fun{} funheap_make_nil{a:t0p} ():<> heap (a)

(* ****** ****** *)

fun{a:t0p} funheap_size (hp: heap(INV(a))):<> Size

(* ****** ****** *)

fun
funheap_is_empty{a:t0p} (hp: heap(INV(a))):<> bool
fun
funheap_isnot_empty{a:t0p} (hp: heap(INV(a))):<> bool

(* ****** ****** *)

fun{a:t0p}
funheap_insert
  (hp: &heap(INV(a)) >> _, x: a, cmp: cmp a):<!wrt> void
// end of [funheap_insert]

(* ****** ****** *)

fun{a:t0p}
funheap_getmin (
  hp: heap(INV(a)), cmp: cmp a, res: &a? >> opt (a, b)
) :<!wrt> #[b:bool] bool b // end of [funheap_getmin]

(* ****** ****** *)

fun{a:t0p}
funheap_delmin (
  hp: &heap(INV(a)) >> _, cmp: cmp a, res: &a? >> opt (a, b)
) :<!wrt> #[b:bool] bool b // end of [funheap_delmin]

fun{a:t0p}
funheap_delmin_opt
  (hp: &heap(INV(a)) >> _, cmp: cmp a):<!wrt> Option_vt (a)
// end of [funheap_delmin_opt]

(* ****** ****** *)

fun{a:t0p}
funheap_merge
  (hp1: heap(INV(a)), hp2: heap (a), cmp: cmp a):<> heap (a)
// end of [funheap_merge]

(* ****** ****** *)

(* end of [funheap_binomial.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(*                              Hongwei Xi                             *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS - Unleashing the Potential of Types!
** Copyright (C) 2002-2011 Hongwei Xi, Boston University
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
**
** A functional map implementation based on ordered lists
**
** Contributed by Hongwei Xi (hwxi AT cs DOT bu DOT edu)
** Time: May 18, 2011
**
*)

(* ****** ****** *)
//
// HX-2014-01-15: Porting to ATS2
//
(* ****** ****** *)
//
abstype
mset_t0ype_type (a:t@ype+) = ptr
//
typedef mset(a:t@ype) = mset_t0ype_type(a)
//
(* ****** ****** *)

typedef cmp (a:t@ype) = (a, a) -<cloref> int

fun{a:t@ype}
compare_elt_elt (x1: a, x2: a, cmp: cmp (a)):<> int

(* ****** ****** *)
//
fun{}
funmset_make_nil
  {a:t@ype} ((*void*)):<> mset (a)
//
fun{a:t@ype}
funmset_make_sing (x: a): mset (a)
fun{a:t@ype}
funmset_make_pair
  (x1: a, x2: a, cmp: cmp a): mset (a)
//
fun{a:t@ype}
funmset_make_list (xs: List a, cmp: cmp a): mset (a)
//
(* ****** ****** *)

fun{a:t@ype}
funmset_size (xs: mset(INV(a))):<> Size

(* ****** ****** *)

fun{a:t@ype}
funmset_get_ntime
  (xs: mset(INV(a)), x0: a, cmp: cmp a):<> intGte(0)
// end of [funmset_get_ntime]

(* ****** ****** *)

fun{a:t@ype}
funmset_is_member (xs: mset(INV(a)), x0: a, cmp: cmp a):<> bool
fun{a:t@ype}
funmset_isnot_member (xs: mset(INV(a)), x0: a, cmp: cmp a):<> bool

(* ****** ****** *)

fun{a:t@ype}
funmset_is_equal
  (xs1: mset(INV(a)), mxs2: mset (a), cmp: cmp (a)):<> bool
// end of [funmset_is_equal]

(* ****** ****** *)

fun{a:t@ype}
funmset_is_subset
  (xs1: mset(INV(a)), xs2: mset (a), cmp: cmp (a)):<> bool
// end of [funmset_is_subset]

(* ****** ****** *)
(*
** multiset ordering induced by the ordering on elements
*)
fun{a:t@ype}
funmset_compare
  (xs1: mset(INV(a)), xs2: mset (a), cmp: cmp (a)):<> int
// end of [funmset_compare]

(* ****** ****** *)

fun{a:t@ype}
funmset_insert
(
  xs: &mset(INV(a)) >> _, x0: a, cmp: cmp (a)
) :<!wrt> void // end of [funmset_insert]

fun{a:t@ype}
funmset_remove
(
  xs: &mset(INV(a)) >> _, x0: a, cmp: cmp (a)
) :<!wrt> bool(*removed/not: true/false*)
// end of [funmset_remove]

(* ****** ****** *)

fun{a:t@ype}
funmset_union
  (xs1: mset(INV(a)), xs2: mset (a), cmp: cmp (a)): mset (a)
fun{a:t@ype}
funmset_intersect
  (xs1: mset(INV(a)), xs2: mset (a), cmp: cmp (a)): mset (a)

(* ****** ****** *)
//
fun{a:t@ype}
funmset_listize (xs: mset(INV(a))): List0_vt (a) // no repeats
//
fun{a:t@ype} // if an element occurs n times, then it is repeated
funmset_mlistize (xs: mset (INV(a))): List0_vt (a) // n times in the output
//
(* ****** ****** *)

(* end of [funmset_listord.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(*                              Hongwei Xi                             *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS - Unleashing the Potential of Types!
** Copyright (C) 2002-2011 Hongwei Xi, Boston University
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
**
** A functional map implementation based on ordered lists
**
** Contributed by Hongwei Xi (hwxi AT cs DOT bu DOT edu)
** Time: May 18, 2011
**
*)

(* ****** ****** *)

abstype
set_t0ype_type (a:t@ype+) = ptr
typedef set (a:t0p) = set_t0ype_type (a)

(* ****** ****** *)

typedef cmp (a:t0p) = (a, a) -<cloref> int

fun{a:t0p}
compare_elt_elt (x1: a, x2: a, cmp: cmp(a)):<> int

(* ****** ****** *)

fun{}
funset_make_nil{a:t0p} ():<> set (a)
fun{a:t0p}
funset_make_sing (x0: a):<> set (a) // singleton set
fun{a:t0p}
funset_make_list (xs: List(INV(a)), cmp: cmp a):<!wrt> set (a)

(* ****** ****** *)

fun{a:t0p}
funset_size (xs: set(INV(a))):<> sizeGte(0)

(* ****** ****** *)

fun{a:t0p}
funset_is_member
  (xs: set(INV(a)), x0: a, cmp: cmp a):<> bool
fun{a:t0p}
funset_isnot_member
  (xs: set(INV(a)), x0: a, cmp: cmp a):<> bool

(* ****** ****** *)

fun{a:t0p}
funset_is_equal
  (xs1: set(INV(a)), xs2: set (a), cmp: cmp (a)):<> bool
// end of [funset_is_equal]

fun{a:t0p}
funset_is_subset
  (xs1: set(INV(a)), xs2: set (a), cmp: cmp (a)):<> bool
// end of [funset_is_subset]

(* ****** ****** *)
(*
** set ordering induced by the ordering on elements
*)
fun{a:t0p}
funset_compare
  (xs1: set(INV(a)), xs2: set(a), cmp: cmp (a)):<> int
// end of [funset_compare]

(* ****** ****** *)

fun{a:t0p}
funset_insert (
  xs: &set(INV(a)) >> _, x0: a, cmp: cmp (a)
) :<!wrt> bool (* [x0] alreay exists in [xs] *)

fun{a:t0p}
funset_remove (
  xs: &set(INV(a)) >> _, x0: a, cmp: cmp (a)
) :<!wrt> bool(* removed/~removed: true/false *)

(* ****** ****** *)

fun{a:t0p}
funset_union
  (xs1: set(INV(a)), xs2: set(a), cmp: cmp (a)):<> set (a)
fun{a:t0p} funset_intersect
  (xs1: set(INV(a)), xs2: set(a), cmp: cmp (a)):<> set (a)
fun{a:t0p} funset_diff
  (xs1: set(INV(a)), xs2: set(a), cmp: cmp (a)):<> set (a)
fun{a:t0p} funset_symdiff
  (xs1: set(INV(a)), xs2: set(a), cmp: cmp (a)):<> set (a)

(* ****** ****** *)

fun{a:t0p}
funset_foreach_funenv
  {v:view}{vt:vtype}
(
  pf: !v  | xs: set(INV(a)), f: (!v | a, !vt) -> void, env: !vt
) : void // end of [funset_foreach_funenv]

(* ****** ****** *)
//
castfn
funset2list{a:t0p} (xs: set(INV(a))):<> List (a)
//
fun{a:t0p}
funset_listize (xs: set (a)):<!wrt> List0_vt (a) // = list_copy
//
(* ****** ****** *)

(* end of [funset_listord.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(*                              Hongwei Xi                             *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS - Unleashing the Potential of Types!
** Copyright (C) 2002-2011 Hongwei Xi, Boston University
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(*
**
** A linear map implementation based on ordered lists
**
** Contributed by Hongwei Xi (hwxi AT cs DOT bu DOT edu)
** Time: February 17, 2012
**
*)

(* ****** ****** *)
//
// HX-2014-01-17:
// Porting to ATS2 from ATS1
//
(* ****** ****** *)

absvtype
set_t0ype_vtype (a:t@ype+) = ptr
vtypedef
set (a:t0p) = set_t0ype_vtype (a)

(* ****** ****** *)

typedef
cmp (a:t0p) = (a, a) -<cloref> int

(* ****** ****** *)

fun{a:t0p}
compare_elt_elt
  (x1: a, x2: a, cmp: cmp (a)):<> int
// end of [compare_elt_elt]

(* ****** ****** *)

fun{} linset_nil{a:t0p} ():<> set (a)
fun{} linset_make_nil{a:t0p} ():<> set (a)

(* ****** ****** *)

fun{a:t0p}
linset_make_sing (x: a):<!wrt> set (a) // singleton set

(* ****** ****** *)

fun{
} linset_is_empty {a:t0p} (xs: !set(INV(a))):<> bool
fun{
} linset_isnot_empty {a:t0p} (xs: !set(INV(a))):<> bool

(* ****** ****** *)
//
// HX: the time complexity of this function is O(n)
//
fun{a:t0p} linset_size (xs: !set(INV(a))):<> sizeGte(0)
//
(* ****** ****** *)

fun{a:t0p}
linset_is_member (xs: !set(INV(a)), x0: a, cmp: cmp a):<> bool
fun{a:t0p}
linset_isnot_member (xs: !set(INV(a)), x0: a, cmp: cmp a):<> bool

(* ****** ****** *)

fun{a:t0p}
linset_is_subset // xs2 contains xs1
  (xs1: !set(INV(a)), xs2: !set(a), cmp: cmp a):<> bool
// end of [linset_is_subset]

fun{a:t0p}
linset_is_supset // xs1 contains xs2
  (xs1: !set(INV(a)), xs2: !set(a), cmp: cmp a):<> bool
// end of [linset_is_supset]

fun{a:t0p}
linset_is_equal
  (xs1: !set(INV(a)), xs2: !set(a), cmp: cmp a):<> bool
// end of [linset_is_equal]

(* ****** ****** *)
//
fun{a:t0p}
linset_copy (!set(INV(a))):<!wrt> set (a)
//
fun{a:t0p}
linset_free (xs: set(INV(a))):<!wrt> void
//
(* ****** ****** *)

fun{a:t0p}
linset_insert
  (xs: &set(INV(a)) >> _, x0: a, cmp: cmp a) :<!wrt> bool
// end of [linset_insert]

(* ****** ****** *)

fun{a:t0p}
linset_remove
  (xs: &set(INV(a)) >> _, x0: a, cmp: cmp (a)):<!wrt> bool
// end of [linset_remove]

(* ****** ****** *)
//
// HX: choosing an element in an unspecified manner
//
fun{a:t0p}
linset_choose (
  xs: !set(INV(a)), x: &a? >> opt (a, b)
) :<!wrt> #[b:bool] bool (b) // end of [linset_choose]

fun{a:t0p}
linset_choose_opt (xs: !set(INV(a))):<!wrt> Option_vt(a)

(* ****** ****** *)
//
// HX: removing an element chosen in an unspecified manner
//
fun{a:t0p}
linset_chooseout (
  xs: &set(INV(a)) >> _, x: &a? >> opt (a, b)
) :<!wrt> #[b:bool] bool (b) // end of [linset_chooseout]
//
fun{a:t0p}
linset_chooseout_opt (xs: &set(INV(a)) >> _):<!wrt> Option_vt(a)
//
(* ****** ****** *)

fun{a:t0p}
linset_union
  (xs1: set(INV(a)), xs2: set(a), cmp: cmp a):<!wrt> set (a)
(*
fun{a:t0p}
linset_intersect
  (xs1: set(INV(a)), xs2: set(a), cmp: cmp a):<!wrt> set (a)
fun{a:t0p}
linset_diff
  (xs1: set(INV(a)), xs2: set(a), cmp: cmp a):<!wrt> set (a)
fun{a:t0p}
linset_symdiff
  (xs1: set(INV(a)), xs2: set(a), cmp: cmp a):<!wrt> set (a)
*)
(* ****** ****** *)

fun{a:t0p}
linset_listize (xs: set(INV(a))):<!wrt> List0_vt (a)
fun{a:t0p}
linset_listize1 (xs: !set(INV(a))):<!wrt> List0_vt (a)

(* ****** ****** *)

fun{a:t0p}
fprint_linset_sep
  (out: FILEref, xs: !set(INV(a)), sep: string): void
// end of [fprint_linset_sep]

(* ****** ****** *)

fun{a:t0p}
linset_foreach_funenv
  {v:view}{vt:viewtype}
(
  pf: !v 
| xs: !set(INV(a)), f: (!v | a, !vt) -> void, env: !vt
) : void // end of [linset_foreach_funenv]

(* ****** ****** *)

fun{a:t0p}
linset_foreach_fun
(
  xs: !set(INV(a)), f: (a) -<fun1> void
) : void // end of [linset_foreach_fun]

fun{a:t0p}
linset_foreach_cloref
(
  xs: !set(INV(a)), f: (a) -<cloref1> void
) : void // end of [linset_foreach_cloref]

(* ****** ****** *)

(* end of [linset_listord.sats] *)
/* ******************************************************************* */
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/* ******************************************************************* */

/*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2013 *)
*/

/* ****** ****** */

#ifndef ATSHOME_LIBATS_CATS_QLIST
#define ATSHOME_LIBATS_CATS_QLIST

/* ****** ****** */

typedef
struct {
  atstype_ptr qlist_nxf ; // the front pointer
  atstype_ref qlist_nxr ; // the address of rear pointer
} atslib_qlist_struct ;

/* ****** ****** */

#endif // ifndef ATSHOME_LIBATS_CATS_QLIST

/* ****** ****** */

/* end of [qlist.cats] */
/* ******************************************************************* */
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/* ******************************************************************* */

/*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: November, 2013 *)
*/

/* ****** ****** */

#ifndef ATSHOME_LIBATS_CATS_STRINGBUF
#define ATSHOME_LIBATS_CATS_STRINGBUF

/* ****** ****** */

#include <stdarg.h>
#include <string.h>

/* ****** ****** */

#define atslib_stringbuf_memcpy memcpy
#define atslib_stringbuf_memmove memmove

/* ****** ****** */

extern
atstype_int
atslib_stringbuf_insert_snprintf
  (atstype_ptr sbf, atstype_int recap, atstype_string fmt, ...) ;
extern
atstype_int
atslib_stringbuf_insert_vsnprintf
(
  atstype_ptr sbf, atstype_int recap, atstype_string fmt, va_list ap
) ; // end of [atslib_stringbuf_insert_vsnprintf]

/* ****** ****** */

#endif // ifndef ATSHOME_LIBATS_CATS_STRINGBUF

/* ****** ****** */

/* end of [stringbuf.cats] */
/* ******************************************************************* */
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/* ******************************************************************* */

/*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-20?? Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: September, 2013 *)
*/

/* ****** ****** */

#ifndef ATSHOME_LIBATS_CATS_STKARRAY
#define ATSHOME_LIBATS_CATS_STKARRAY

/* ****** ****** */

typedef
struct {
  atstype_ptr stkarray_beg ; // the beg pointer
  atstype_ptr stkarray_end ; // the end pointer
  atstype_ref stkarray_cur ; // the current pointer
} atslib_stkarray_struct ;

/* ****** ****** */

ATSinline()
atstype_ptr
atslib_stkarray_make_ngc__tsz
(
  atstype_ptr p
, atstype_ptr A
, atstype_size m
, atstype_size tsz
) {
  atslib_stkarray_struct *p_stk ;
  p_stk = (atslib_stkarray_struct*)p ;
  p_stk->stkarray_beg = A ;
  p_stk->stkarray_end = (char*)A + m * tsz ;
  p_stk->stkarray_cur = A ;
  return p_stk ;
} // end of [atslib_stkarray_make_ngc__tsz]

/* ****** ****** */

ATSinline()
atstype_size
atslib_stkarray_get_size__tsz
(
  atstype_ptr p, atstype_size tsz
) {
  atslib_stkarray_struct *p_stk ;
  p_stk = (atslib_stkarray_struct*)p ;
  return ((char*)(p_stk->stkarray_cur) - (char*)(p_stk->stkarray_beg)) / tsz ;
} // end of [atslib_stkarray_get_size__tsz]

ATSinline()
atstype_size
atslib_stkarray_get_capacity__tsz
(
  atstype_ptr p, atstype_size tsz
) {
  atslib_stkarray_struct *p_stk ;
  p_stk = (atslib_stkarray_struct*)p ;
  return ((char*)(p_stk->stkarray_end) - (char*)(p_stk->stkarray_beg)) / tsz ;
} // end of [atslib_stkarray_get_capacity__tsz]

/* ****** ****** */

ATSinline()
atstype_ptr
atslib_stkarray_get_ptrbeg
  (atstype_ptr p)
{
  return ((atslib_stkarray_struct*)p)->stkarray_beg ;
} // end of [atslib_stkarray_get_ptrbeg]

/* ****** ****** */

ATSinline()
atstype_ptr
atslib_stkarray_get_ptrcur
  (atstype_ptr p)
{
  return ((atslib_stkarray_struct*)p)->stkarray_cur ;
} // end of [atslib_stkarray_get_ptrcur]

ATSinline()
atsvoid_t0ype
atslib_stkarray_set_ptrcur
  (atstype_ptr p, atstype_ptr p2)
{
  ((atslib_stkarray_struct*)p)->stkarray_cur = p2 ; return ;
} // end of [atslib_stkarray_set_ptrcur]

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atslib_stkarray_free_nil
  (atstype_ptr p)
{
  atstype_ptr p_beg ;
  p_beg = ((atslib_stkarray_struct*)p)->stkarray_beg ;
  ATS_MFREE(p) ; ATS_MFREE(p_beg) ;
  return ;
} // end of [atslib_stkarray_free_nil]

/* ****** ****** */

ATSinline()
atstype_ptr
atslib_stkarray_getfree_arrayptr
  (atstype_ptr p)
{
  atstype_ptr p_beg ;
  p_beg = ((atslib_stkarray_struct*)p)->stkarray_beg ;
  ATS_MFREE(p) ;
  return p_beg ;
} // end of [atslib_stkarray_getfree_arrayptr]

/* ****** ****** */

ATSinline()
atstype_bool
atslib_stkarray_is_nil
  (atstype_ptr p)
{
  atslib_stkarray_struct *p_stk ;
  p_stk = (atslib_stkarray_struct*)p ;
  return (p_stk->stkarray_beg==p_stk->stkarray_cur ? atsbool_true : atsbool_false) ;
} // end of [atslib_stkarray_is_nil]
ATSinline()
atstype_bool
atslib_stkarray_isnot_nil
  (atstype_ptr p)
{
  atslib_stkarray_struct *p_stk ;
  p_stk = (atslib_stkarray_struct*)p ;
  return (p_stk->stkarray_beg < p_stk->stkarray_cur ? atsbool_true : atsbool_false) ;
} // end of [atslib_stkarray_isnot_nil]

/* ****** ****** */

ATSinline()
atstype_bool
atslib_stkarray_is_full
  (atstype_ptr p)
{
  atslib_stkarray_struct *p_stk ;
  p_stk = (atslib_stkarray_struct*)p ;
  return (p_stk->stkarray_cur==p_stk->stkarray_end ? atsbool_true : atsbool_false) ;
} // end of [atslib_stkarray_is_full]
ATSinline()
atstype_bool
atslib_stkarray_isnot_full
  (atstype_ptr p)
{
  atslib_stkarray_struct *p_stk ;
  p_stk = (atslib_stkarray_struct*)p ;
  return (p_stk->stkarray_cur < p_stk->stkarray_end ? atsbool_true : atsbool_false) ;
} // end of [atslib_stkarray_isnot_full]

/* ****** ****** */

#endif // ifndef ATSHOME_LIBATS_CATS_STKARRAY

/* ****** ****** */

/* end of [stkarray.cats] */
/* ******************************************************************* */
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/* ******************************************************************* */

/*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-20?? Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: October, 2013 *)
*/

/* ****** ****** */

#ifndef ATSHOME_LIBATS_CATS_DEQARRAY
#define ATSHOME_LIBATS_CATS_DEQARRAY

/* ****** ****** */

typedef
struct {
  atstype_ptr deqarray_beg ; // the beg pointer
  atstype_ptr deqarray_end ; // the end pointer
  atstype_ref deqarray_frnt ; // the frontal pointer
  atstype_ref deqarray_rear ; // the rear pointer
} atslib_deqarray_struct ;

/* ****** ****** */

ATSinline()
atstype_ptr
atslib_deqarray_make_ngc__tsz
(
  atstype_ptr p
, atstype_ptr A
, atstype_size m
, atstype_size tsz
) {
  atslib_deqarray_struct *p_deq ;
  p_deq = (atslib_deqarray_struct*)p ;
//
  p_deq->deqarray_beg = A ;
  p_deq->deqarray_end = (char*)A + (m+1) * tsz ;
  p_deq->deqarray_frnt = A ;
  p_deq->deqarray_rear = A ;
//
  return p_deq ;
//
} // end of [atslib_deqarray_make_ngc__tsz]

/* ****** ****** */

ATSinline()
atstype_size
atslib_deqarray_get_size__tsz
(
  atstype_ptr p, atstype_size tsz
) {
  atslib_deqarray_struct *p_deq ;
  p_deq = (atslib_deqarray_struct*)p ;
//
  void *p_frnt = p_deq->deqarray_frnt ;
  void *p_rear = p_deq->deqarray_rear ;
//
  if (p_frnt >= p_rear)
  {
    return ((char*)p_frnt-(char*)p_rear)/tsz ;
  } else {
    return ((char*)p_frnt-(char*)p_deq->deqarray_beg+(char*)p_deq->deqarray_end-(char*)p_rear)/tsz ;
  } /* end of [if] */
} // end of [atslib_deqarray_get_size__tsz]

/* ****** ****** */

ATSinline()
atstype_size
atslib_deqarray_get_capacity__tsz
(
  atstype_ptr p, atstype_size tsz
) {
  atslib_deqarray_struct *p_deq ;
  p_deq = (atslib_deqarray_struct*)p ;
  return (((char*)(p_deq->deqarray_end)-(char*)(p_deq->deqarray_beg))/tsz)-1;
} // end of [atslib_deqarray_get_capacity__tsz]

/* ****** ****** */

ATSinline()
atstype_ptr
atslib_deqarray_get_ptrbeg
  (atstype_ptr p)
{
  return ((atslib_deqarray_struct*)p)->deqarray_beg ;
} // end of [atslib_deqarray_get_ptrbeg]

ATSinline()
atstype_ptr
atslib_deqarray_get_ptrend
  (atstype_ptr p)
{
  return ((atslib_deqarray_struct*)p)->deqarray_end ;
} // end of [atslib_deqarray_get_ptrend]

/* ****** ****** */

ATSinline()
atstype_ptr
atslib_deqarray_get_ptrfrnt
  (atstype_ptr p)
{
  return ((atslib_deqarray_struct*)p)->deqarray_frnt ;
} // end of [atslib_deqarray_get_ptrfrnt]

ATSinline()
atsvoid_t0ype
atslib_deqarray_set_ptrfrnt
  (atstype_ptr p, atstype_ptr p2)
{
  ((atslib_deqarray_struct*)p)->deqarray_frnt = p2 ; return ;
} // end of [atslib_deqarray_set_ptrfrnt]

/* ****** ****** */

ATSinline()
atstype_ptr
atslib_deqarray_get_ptrrear
  (atstype_ptr p)
{
  return ((atslib_deqarray_struct*)p)->deqarray_rear ;
} // end of [atslib_deqarray_get_ptrrear]

ATSinline()
atsvoid_t0ype
atslib_deqarray_set_ptrrear
  (atstype_ptr p, atstype_ptr p2)
{
  ((atslib_deqarray_struct*)p)->deqarray_rear = p2 ; return ;
} // end of [atslib_deqarray_set_ptrrear]

/* ****** ****** */

ATSinline()
atsvoid_t0ype
atslib_deqarray_free_nil
  (atstype_ptr p)
{
  atstype_ptr p_beg ;
  p_beg = ((atslib_deqarray_struct*)p)->deqarray_beg ;
  ATS_MFREE(p) ; ATS_MFREE(p_beg) ;
  return ;
} // end of [atslib_deqarray_free_nil]

/* ****** ****** */

ATSinline()
atstype_bool
atslib_deqarray_is_nil
  (atstype_ptr p)
{
  atslib_deqarray_struct *p_deq ;
  p_deq = (atslib_deqarray_struct*)p ;
  return (p_deq->deqarray_frnt == p_deq->deqarray_rear ? atsbool_true : atsbool_false) ;
} // end of [atslib_deqarray_is_nil]
ATSinline()
atstype_bool
atslib_deqarray_isnot_nil
  (atstype_ptr p)
{
  atslib_deqarray_struct *p_deq ;
  p_deq = (atslib_deqarray_struct*)p ;
  return (p_deq->deqarray_frnt != p_deq->deqarray_rear ? atsbool_true : atsbool_false) ;
} // end of [atslib_deqarray_isnot_nil]

/* ****** ****** */

ATSinline()
atstype_ptr
atslib_deqarray_ptr_succ__tsz
(
  atstype_ptr p
, atstype_ptr p_elt, atstype_size tsz
) {
  atslib_deqarray_struct *p_deq ;
  p_deq = (atslib_deqarray_struct*)p ;
  char *p1_elt = (char*)p_elt+tsz ;
  return (p1_elt < (char*)p_deq->deqarray_end) ? p1_elt : p_deq->deqarray_beg ;
} // end of [atslib_deqarray_ptr_succ__tsz]

/* ****** ****** */

ATSinline()
atstype_ptr
atslib_deqarray_ptr_pred__tsz
(
  atstype_ptr p
, atstype_ptr p_elt, atstype_size tsz
) {
  atslib_deqarray_struct *p_deq ;
  p_deq = (atslib_deqarray_struct*)p ;
  char *p_beg = (char*)p_deq->deqarray_beg ;
  return ((char*)p_elt > p_beg) ? (char*)p_elt-tsz : (char*)p_deq->deqarray_end-tsz ;
} // end of [atslib_deqarray_ptr_pred__tsz]

/* ****** ****** */

ATSinline()
atstype_bool
atslib_deqarray_is_full__tsz
  (atstype_ptr p, atstype_size tsz)
{
  atslib_deqarray_struct *p_deq ;
  p_deq = (atslib_deqarray_struct*)p ;
//
  void *p_frnt = p_deq->deqarray_frnt ;
  void *p_rear = p_deq->deqarray_rear ;
//
  void *p1_frnt =
  atslib_deqarray_ptr_succ__tsz(p_deq, p_frnt, tsz) ;
//
  return (p1_frnt==p_rear ? atsbool_true : atsbool_false) ;
} // end of [atslib_deqarray_is_full__tsz]

#if(0)
ATSinline()
atstype_bool
atslib_deqarray_isnot_full__tsz
  (atstype_ptr p, atstype_size tsz)
{
  return (atslib_deqarray_is_full__tsz(p, tsz)) ? atsbool_false : atsbool_true ;
} // end of [atslib_deqarray_isnot_full__tsz]
#endif

/* ****** ****** */

ATSinline()
atstype_ptr
atslib_deqarray_getref_at__tsz
(
  atstype_ptr p
, atstype_size i, atstype_size tsz
)
{
  atslib_deqarray_struct *p_deq ;
  p_deq = (atslib_deqarray_struct*)p ;
//
  void *p_rear_i = (char*)p_deq->deqarray_rear + i * tsz ;
//
  if (p_rear_i >= p_deq->deqarray_end)
    p_rear_i = (char*)p_deq->deqarray_beg + (p_rear_i - p_deq->deqarray_end) ;
//
  return p_rear_i ;
//
} // end of [atslib_deqarray_getref_at__tsz]

/* ****** ****** */

#endif // ifndef ATSHOME_LIBATS_CATS_DEQARRAY

/* ****** ****** */

/* end of [deqarray.cats] */
/* ******************************************************************* */
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/* ******************************************************************* */

/*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-20?? Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: hwxi AT cs DOT bu DOT edu *)
(* Start time: March, 2013 *)
*/

/* ****** ****** */

#ifndef ATSHOME_LIBATS_CATS_DYNARRAY
#define ATSHOME_LIBATS_CATS_DYNARRAY

/* ****** ****** */

#include <string.h>

/* ****** ****** */

#define atslib_dynarray_memcpy memcpy
#define atslib_dynarray_memmove memmove

/* ****** ****** */

#endif // ifndef ATSHOME_LIBATS_CATS_DYNARRAY

/* ****** ****** */

/* end of [dynarray.cats] */
/* ******************************************************************* */
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/* ******************************************************************* */

/*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: March, 2014 *)
*/

/* ****** ****** */

#ifndef ATSHOME_LIBATS_CATS_HASHFUN
#define ATSHOME_LIBATS_CATS_HASHFUN

/* ****** ****** */

ATSinline()
atstype_uint32
atslib_inthash_jenkins
  (atstype_uint32 a)
{
  a = (a+0x7ed55d16) + (a<<12);
  a = (a^0xc761c23c) ^ (a>>19);
  a = (a+0x165667b1) + (a<< 5);
  a = (a+0xd3a2646c) ^ (a<< 9);
  a = (a+0xfd7046c5) + (a<< 3);
  a = (a^0xb55a4f09) ^ (a>>16);
  return a;
} /* end of [atslib_inthash_jenkins] */

/* ****** ****** */

#endif // ifndef ATSHOME_LIBATS_CATS_HASHFUN

/* ****** ****** */

/* end of [hashfun.cats] */
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: June, 2012 *)

(* ****** ****** *)

#define ATS_DYNLOADFLAG 0
  
(* ****** ****** *)
  
staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libats/ML/SATS/basis.sats"
staload "libats/ML/SATS/list0.sats"

(* ****** ****** *)
//
implement
{a}(*tmp*)
list0_make_sing (x) =
  list0_cons{a}(x, list0_nil)
implement{a}
list0_make_pair (x1, x2) =
  list0_cons{a}(x1, list0_cons{a}(x2, list0_nil))
//
(* ****** ****** *)

implement
{a}(*tmp*)
list0_make_elt
  (n, x) = let
//
val n = g1ofg0(n)
//
in
//
if
n >= 0
then let
  val xs =
    $effmask_wrt (list_make_elt (n, x))
  // end of [val]
in
  list0_of_list_vt (xs)
end // end of [then]
else let
in
  $raise (IllegalArgExn"list0_make_elt:n")
end // end of [else]
//
end // end of [list0_make_elt]

(* ****** ****** *)

implement{}
list0_make_intrange_lr
  (l, r) = let
  val d = (
    if l <= r then 1 else ~1
  ) : int // end of [val]
in
  $effmask_exn (list0_make_intrange_lrd (l, r, d))
end // end of [list0_make_intrange_lr]

implement{}
list0_make_intrange_lrd
  (l, r, d) = let
//
typedef res = list0 (int)
//
fun loop1 // d > 0
(
  l: int, r: int, d: int, res: &ptr? >> res
) : void = let
in
//
if l < r then let
  val () =
  (
    res := list0_cons{int}(l, _)
  )
  val+list0_cons (_, res1) = res
  val () = loop1 (l+d, r, d, res1)
  prval () = fold@ (res)
in
  // nothing
end else (res := list0_nil)
//
end // end of [loop1]
//
fun loop2 // d < 0
(
  l: int, r: int, d: int, res: &ptr? >> res
) : void = let
in
//
if l > r then let
  val () =
  (
    res := list0_cons{int}(l, _)
  )
  val+ list0_cons (_, res1) = res
  val () = loop2 (l+d, r, d, res1)
  prval () = fold@ (res)
in
  // nothing
end else (res := list0_nil)
//
end // end of [loop2]
//
in
//
$effmask_all (
if d > 0 then (
  if l < r then let
    var res: ptr? // uninitialized
    val () = loop1 (l, r, d, res) in res
  end else list0_nil ()
) else if d < 0 then (
  if l > r then let
    var res: ptr? // uninitialized
    val () = loop2 (l, r, d, res) in res
  end else list0_nil ()
) else (
  $raise IllegalArgExn("list0_make_intrange_lrd:d")
) // end of [if]
) // end of [$effmask_all]
//
end // end of [list0_make_intrange_lrd]

(* ****** ****** *)

implement
{a}(*tmp*)
list0_make_arrpsz
  (psz) = list0_of_list_vt (list_make_arrpsz (psz))
// end of [list0_make_arrpsz]

(* ****** ****** *)

implement
{a}(*tmp*)
print_list0 (xs) = fprint_list0<a> (stdout_ref, xs)
implement
{a}(*tmp*)
prerr_list0 (xs) = fprint_list0<a> (stderr_ref, xs)

implement
{a}(*tmp*)
fprint_list0 (out, xs) = fprint_list<a> (out, g1ofg0(xs))

implement
{a}(*tmp*)
fprint_list0_sep (out, xs, sep) = let
  val xs = g1ofg0(xs) in fprint_list_sep<a> (out, xs, sep)
end // end of [fprint_list0_sep]

(* ****** ****** *)

(*
//
// HX: they have been declared as macros:
//
implement
{a}(*tmp*)
list0_sing (x) = list0_cons{a}(x, list0_nil)
implement
{a}(*tmp*)
list0_pair (x1, x2) = list0_cons{a}(x1, list0_cons{a}(x2, list0_nil))
*)

(* ****** ****** *)

implement
{a}(*tmp*)
list0_is_nil (xs) = (
  case+ xs of
  | list0_cons _ => false | list0_nil () => true
) // end of [list0_is_nil]

implement
{a}(*tmp*)
list0_is_cons (xs) = (
  case+ xs of
  | list0_cons _ => true | list0_nil () => false
) // end of [list0_is_cons]

(* ****** ****** *)

implement
{a}(*tmp*)
list0_is_empty (xs) = list0_is_nil<a> (xs)

implement
{a}(*tmp*)
list0_isnot_empty (xs) = list0_is_cons<a> (xs)

(* ****** ****** *)

implement
{a}(*tmp*)
list0_head_exn
  (xs) = let
in
  case+ xs of
  | list0_cons (x, _) => x
  | list0_nil _ => $raise ListSubscriptExn()
end // end of [list0_head_exn]

implement
{a}(*tmp*)
list0_head_opt
  (xs) = let
in
//
case+ xs of
| list0_nil () => None_vt()
| list0_cons (x, _) => Some_vt{a}(x)
//
end // end of [list0_head_opt]

(* ****** ****** *)

implement{a}
list0_tail_exn
  (xs) = let
in
  case+ xs of
  | list0_cons (_, xs) => xs
  | list0_nil _ => $raise ListSubscriptExn()
end // end of [list0_tail_exn]

implement{a}
list0_tail_opt
  (xs) = let
in
//
case+ xs of
| list0_nil () => None_vt()
| list0_cons (_, xs) => Some_vt{list0(a)}(xs)
//
end // end of [list0_tail_opt]

(* ****** ****** *)

implement{a}
list0_last_exn
  (xs) = let
//
val xs = g1ofg0_list(xs)
//
in
//
case+ xs of
| list_cons _ => list_last (xs)
| list_nil () => $raise ListSubscriptExn()
//
end // end of [list0_last_exn]

implement{a}
list0_last_opt
  (xs) = let
//
val xs = g1ofg0_list(xs)
//
in
//
case+ xs of
| list_nil () => None_vt()
| list_cons _ => Some_vt{a}(list_last(xs))
//
end // end of [list0_last_opt]

(* ****** ****** *)

local

fun{a:t0p}
loop{i:nat} .<i>.
(
  xs: list0 (a), i: int i
) :<!exn> a = let
in
//
case+ xs of
| list0_cons
    (x, xs) =>
  (
    if i > 0 then loop<a> (xs, i-1) else x
  ) // end of [list0_cons]
| list0_nil () => $raise ListSubscriptExn()
//
end // end of [loop]

in (* in of [local] *)

implement{a}
list0_nth_exn
  (xs, i) = let
//
val i = g1ofg0_int (i)
//
in
  if i >= 0 then
    loop<a> (xs, i) else $raise ListSubscriptExn()
  // end of [if]
end // end of [list0_nth_exn]

implement{a}
list0_nth_opt
  (xs, i) = let
//
val i = g1ofg0(i)
//
in
//
if i >= 0 then (
  $effmask_exn (
    try Some_vt{a}(loop<a> (xs, i)) with ~ListSubscriptExn() => None_vt()
  ) // end of [$effmask_exn]
) else None_vt () // end of [if]
//
end // end of [list0_nth_opt]

end // end of [local]

(* ****** ****** *)

implement{a}
list0_get_at_exn (xs, i) = list0_nth_exn (xs, i)

(* ****** ****** *)

implement{a}
list0_insert_at_exn
  (xs, i, x0) = let
//
fun aux {i:nat} .<i>. (
  xs: list0 a, i: int i, x0: a
) :<!exn> list0 a = let
in
//
if i > 0 then
(
  case+ xs of
  | list0_cons (x, xs) =>
    (
      list0_cons{a}(x, aux (xs, i-1, x0))
    )
  | list0_nil () => $raise ListSubscriptExn()
) else (
  list0_cons{a}(x0, xs)
) (* end of [if] *)
//
end // end of [aux]
//
val i = g1ofg0_int (i)
//
in
  if i >= 0 then
    aux (xs, i, x0)
  else
    $raise IllegalArgExn("list0_insert_at_exn:i")
  // end of [if]
end // end of [list0_insert_at_exn]

(* ****** ****** *)

local

fun{
a:t0p
} auxlst {i:nat} .<i>.
(
  xs: list0 (a), i: int i, x0: &a? >> a
) :<!exnwrt> list0 a = let
//
extern praxi __assert : (&a? >> a) -<prf> void
//
in
//
case+ xs of
| list0_cons
    (x, xs) => let
  in
    if i > 0 then
      list0_cons{a}(x, auxlst<a> (xs, i-1, x0))
    else let
      val () = x0 := x in xs
    end (* end of [if] *)
  end // end of [list0_cons]
| list0_nil () => let
    prval () = __assert (x0) in $raise ListSubscriptExn()
  end // end of [list0_nil]
//
end // end of [auxlst]

in (* in of [local] *)

implement{a}
list0_remove_at_exn
  (xs, i) = let
//
var x0: a?
val i = g1ofg0_int (i)
//
in
$effmask_wrt
(
  if i >= 0 then
    auxlst<a> (xs, i, x0)
  else (
    $raise IllegalArgExn("list0_remove_at_exn:i")
  ) // end of [if]
)
end // end of [list0_remove_at_exn]

implement{a}
list0_takeout_at_exn
  (xs, i, x0) = let
//
val i = g1ofg0_int (i)
//
extern praxi __assert : (&a? >> a) -<prf> void
//
in
(
  if i >= 0 then
    auxlst<a> (xs, i, x0)
  else let
    prval () = __assert (x0)
  in
    $raise IllegalArgExn("list0_takeout_at_exn:i")
  end // end of [if]
)
end // end of [list0_takeout_at_exn]

end // end of [local]

(* ****** ****** *)

implement{a}
list0_length (xs) = list_length<a> (g1ofg0(xs))

(* ****** ****** *)

implement{a}
list0_append (xs, ys) = let
in
  list0_of_list (list_append<a> (g1ofg0(xs), g1ofg0(ys)))
end // end of [list0_append]

(* ****** ****** *)

implement{a}
list0_reverse (xs) =
  list0_reverse_append<a> (xs, list0_nil)
// end of [list0_reverse]

implement{a}
list0_reverse_append (xs, ys) = let
  val xs = g1ofg0(xs) and ys = g1ofg0(ys)
in
  list0_of_list (list_reverse_append<a> (xs, ys))
end // end of [list0_reverse_append]

(* ****** ****** *)

implement{a}
list0_concat
  (xss) = let
  typedef xss = List(List(a))
  val ys = $effmask_wrt (list_concat<a> ($UN.cast{xss}(xss)))
in
  list0_of_list_vt (ys)
end // end of [list0_concat]

(* ****** ****** *)

implement{a}
list0_take_exn
  (xs, i) = let
//
val i = g1ofg0_int (i)
val xs = g1ofg0_list (xs)
//
in
  if i >= 0 then let
    val res =
      $effmask_wrt (list_take_exn (xs, i))
    // end of [val]
  in
    list0_of_list_vt (res)
  end else
    $raise (IllegalArgExn"list0_take_exn:i")
  // end of [if]
end // end of [list0_take_exn]

implement{a}
list0_drop_exn
  (xs, i) = let
//
val i = g1ofg0_int (i)
val xs = g1ofg0_list (xs)
//
in
  if i >= 0 then
    list0_of_list (list_drop_exn (xs, i))
  else
    $raise (IllegalArgExn"list0_drop_exn:i")
  // end of [if]
end // end of [list0_drop_exn]

(* ****** ****** *)

implement{a}
list0_app (xs, f) = list0_foreach (xs, f)

(* ****** ****** *)

implement{a}
list0_foreach (xs, f) = let
in
  case+ xs of
  | list0_cons (x, xs) =>
      (f (x); list0_foreach (xs, f))
  | list0_nil () => ()
end // end of [list0_foreach]

implement{a}
list0_iforeach
  (xs, f) = let
  fun loop (
    i: int, xs: list0 (a), f: cfun2 (int, a, void)
  ) : int =
    case+ xs of
    | list0_cons (x, xs) =>
        (f (i, x); loop (i+1, xs, f))
    | list0_nil () => i
  // end of [loop]
in
  loop (0, xs, f)
end // end of [list0_iforeach]

(* ****** ****** *)

implement
{a1,a2}
list0_foreach2
  (xs1, xs2, f) = let
  var sgn: int // uninitialized
in
  list0_foreach2_eq (xs1, xs2, f, sgn)
end // end of [list0_foreach2]

implement
{a1,a2}
list0_foreach2_eq
  (xs1, xs2, f, sgn) = let
in
  case+ xs1 of
  | list0_cons (x1, xs1) => (
    case+ xs2 of
    | list0_cons (x2, xs2) =>
        (f (x1, x2); list0_foreach2_eq (xs1, xs2, f, sgn))
    | list0_nil () => (sgn := 1)
    )
  | list0_nil () => (
    case+ xs2 of
    | list0_cons _ => (sgn := ~1) | list0_nil () => (sgn := 0)
    )
end // end of [list0_foreach2_eq]

(* ****** ****** *)

implement
{a}{res}
list0_foldleft (xs, ini, f) = let
in
  case+ xs of
  | list0_cons (x, xs) => let
      val ini = f (ini, x) in list0_foldleft (xs, ini, f)
    end // end of [list0_cons]
  | list0_nil () => ini
end // end of [list0_foldleft]

implement
{a}{res}
list0_ifoldleft
  (xs, ini, f) = let
  fun loop (
    i: int, xs: list0 (a), ini: res, f: cfun3 (res, int, a, res)
  ) : res =
    case+ xs of
    | list0_cons (x, xs) => let
        val init = f (ini, i, x) in loop (i+1, xs, ini, f)
      end // end of [list0_cons]
    | list0_nil () => ini
  // end of [loop]
in
  loop (0, xs, ini, f)
end // end of [list0_ifoldleft]

(* ****** ****** *)

implement
{a1,a2}{res}
list0_foldleft2
  (xs1, xs2, ini, f) = let
in
  case+ xs1 of
  | list0_cons (x1, xs1) => (
    case+ xs2 of
    | list0_cons (x2, xs2) => let
        val init = f (ini, x1, x2) in list0_foldleft2 (xs1, xs2, ini, f)
      end // end of [list0_cons]
    | list0_nil () => ini
    )
  | list0_nil () => ini
end // end of [list0_foldleft2]

(* ****** ****** *)

implement
{a}{res}
list0_foldright
  (xs, f, snk) = let
in
  case+ xs of
  | list0_cons (x, xs) =>
      f (x, list0_foldright (xs, f, snk))
  | list0_nil () => snk
end // end of [list0_foldright]

(* ****** ****** *)

implement{a}
list0_exists (xs, p) = let
in
  case+ xs of
  | list0_cons (x, xs) =>
      if p (x) then true else list0_exists (xs, p)
  | list0_nil () => false
end // end of [list0_exists]

implement
{a1,a2}
list0_exists2
  (xs1, xs2, p) = let
in
  case+ xs1 of
  | list0_cons (x1, xs1) => (
    case+ xs2 of
    | list0_cons (x2, xs2) =>
        if p (x1, x2) then true else list0_exists2 (xs1, xs2, p)
    | list0_nil () => false
    )
  | list0_nil () => false
end // end of [list0_exists2]

(* ****** ****** *)

implement{a}
list0_forall (xs, p) = let
in
  case+ xs of
  | list0_cons (x, xs) =>
      if p (x) then list0_forall (xs, p) else false
  | list0_nil () => true
end // end of [list0_forall]

(* ****** ****** *)

implement
{a1,a2}
list0_forall2
  (xs1, xs2, p) = let
  var sgn: int // uninitialized
in
  list0_forall2_eq (xs1, xs2, p, sgn)
end // end of [list0_forall2]

implement
{a1,a2}
list0_forall2_eq
  (xs1, xs2, p, sgn) = let
in
  case+ xs1 of
  | list0_cons (x1, xs1) => (
    case+ xs2 of
    | list0_cons (x2, xs2) =>
        if p (x1, x2) then
          list0_forall2_eq (xs1, xs2, p, sgn) else (sgn := 0; false)
        // end of [if]
    | list0_nil () => (sgn := 1; true)
    )
  | list0_nil () => (
    case+ xs2 of
    | list0_cons _ => (sgn := ~1; true) | list0_nil () => (sgn := 0; true)
    )
end // end of [list0_forall2_eq]

(* ****** ****** *)

implement{a}
list0_equal
  (xs1, xs2, eqfn) =
  case+ (xs1, xs2) of
  | (list0_cons (x1, xs1),
     list0_cons (x2, xs2)) =>
      if eqfn (x1, x2) then list0_equal (xs1, xs2, eqfn) else false
  | (list0_nil (), list0_nil ()) => true
  | (_, _) => false
// end of [list0_equal]

(* ****** ****** *)

implement
{a}(*tmp*)
list0_find_exn
  (xs, p) = let
in
//
case+ xs of
| list0_cons
    (x, xs) =>
    if p (x) then x else list0_find_exn (xs, p)
| list0_nil ((*void*)) => $raise NotFoundExn()
//
end // end of [list0_find_exn]

implement
{a}(*tmp*)
list0_find_opt
  (xs, p) = let
in
//
case+ xs of
| list0_cons (x, xs) =>
  (
    if p (x) then Some_vt{a}(x) else list0_find_opt (xs, p)
  ) (* end of [list_cons] *)
| list0_nil ((*void*)) => None_vt ()
//
end // end of [list0_find_opt]

(* ****** ****** *)

implement
{a,b}(*tmp*)
list0_assoc_exn
  (xys, x0, eq) = let
in
//
case+ xys of
| list0_cons
    (xy, xys) =>
    if eq (x0, xy.0)
      then xy.1 else list0_assoc_exn<a,b> (xys, x0, eq)
    // end of [if]
| list0_nil ((*void*)) => $raise NotFoundExn()
//
end // end of [list0_assoc_exn]

implement
{a,b}(*tmp*)
list0_assoc_opt
  (xys, x0, eq) = let
in
//
case+ xys of
| list0_cons (xy, xys) =>
  (
    if eq (x0, xy.0)
      then Some_vt{b}(xy.1) else list0_assoc_opt<a,b> (xys, x0, eq)
    // end of [if]
  ) (* end of [list_cons] *)
| list0_nil ((*void*)) => None_vt ()
//
end // end of [list0_assoc_opt]

(* ****** ****** *)

(*
implement
{a}{b}
list0_map (xs, f) = let
  viewdef v = unit_v
  viewtypedef vt = cfun (a, b)
  fun app .<>.
    (pfu: !unit_v | x: a, f: !vt): b = f (x)
  // end of [fun]
  prval pfu = unit_v ()
  var f = f
  val ys = list_map_funenv<a><b> {v}{vt} (pfu | g1ofg0(xs), app, f)
  prval () = topize (f)
  prval unit_v () = pfu
in
  list0_of_list_vt (ys)
end // end of [list0_map]
*)
implement
{a}{b}
list0_map (xs, f) = let
//
implement
{a2}{b2}
list_map$fopr (x) =
  $UN.castvwtp0{b2}(f($UN.cast{a}(x)))
//
val ys = list_map<a><b> (g1ofg0_list(xs))
//
in
  list0_of_list_vt (ys)
end // end of [list0_map]

(* ****** ****** *)

implement
{a}{b}
list0_mapopt
  (xs, f) = res where
{
//
fun loop
(
  xs: list0 (a)
, res: &ptr? >> List0_vt (b)
) : void = let
in
//
case+ xs of
| list0_cons
    (x, xs) => (
  case+ f(x) of
  | ~Some_vt y => let
      val () =
      (
      res :=
      list_vt_cons{b}{0}(y, _)
      )
      val+list_vt_cons (_, res1) = res
      val () = loop (xs, res1)
      prval () = fold@ (res)
    in
      // nothing
    end // end of [Some0]
  | ~None_vt () => loop (xs, res)
  ) (* end of [list0_cons] *)
| list0_nil () => (
    res := list_vt_nil ()
  ) (* end of [list0_nil] *)
//
end // end of [loop]
//
var res: ptr
val () = loop (xs, res)
val res = list0_of_list_vt (res)
//
} // end of [list0_mapopt]

(* ****** ****** *)

implement
{a}(*tmp*)
list0_mapcons
  (x0, xss) = let
//
implement
list_map$fopr<list0(a)><list0(a)> (xs) = list0_cons(x0, xs)
//
val xss = g1ofg0 (xss)
val res = list_map<list0(a)><list0(a)> (xss)
//
in
  list0_of_list_vt (res)
end // end of [list0_mapcons]

(* ****** ****** *)

implement
{a}{b}
list0_imap (xs, f) = let
//
implement
{a2}{b2}
list_imap$fopr (i, x) =
  $UN.castvwtp0{b2}(f (i, $UN.cast{a}(x)))
val ys = list_imap<a><b> (g1ofg0_list(xs))
//
in
  list0_of_list_vt (ys)
end // end of [list0_imap]

(* ****** ****** *)

(*
implement
{a1,a2}{b}
list0_map2
  (xs1, xs2, f) = let
  viewdef v = unit_v
  viewtypedef vt = cfun2 (a1, a2, b)
  val xs1 = g1ofg0_list(xs1)
  val xs2 = g1ofg0_list(xs2)
  fun app .<>.
    (pfu: !unit_v | x1: a1, x2: a2, f: !vt): b = f (x1, x2)
  // end of [fun]
  prval pfu = unit_v ()
  var f = f
  val ys = list_map2_funenv<a1,a2><b> {v}{vt} (pfu | xs1, xs2, app, f)
  prval () = topize (f)
  prval unit_v () = pfu
in
  list0_of_list_vt (ys)
end // end of [list0_map2]
*)
implement
{a1,a2}{b}
list0_map2
  (xs1, xs2, f) = let
//
implement
{a11,a12}{b2}
list_map2$fopr (x1, x2) =
$UN.castvwtp0{b2}(f($UN.cast{a1}(x1), $UN.cast{a2}(x2)))
//
in
  list0_of_list_vt(list_map2<a1,a2><b> (g1ofg0(xs1), g1ofg0(xs2)))
end // end of [list0_map2]

(* ****** ****** *)

implement
{a}(*tmp*)
list0_filter
  (xs, p) = let
//
implement{a2}
list_filter$pred
  (x) = p ($UN.cast{a}(x))
val ys = list_filter<a> (g1ofg0(xs))
//
in
  list0_of_list_vt (ys)
end // end of [list0_filter]

(* ****** ****** *)

implement{a}
list0_tabulate
  (n, f) = let
//
implement{a2}
list_tabulate$fopr
  (i) = $UN.castvwtp0{a2}(f(i))
//
val n = g1ofg0_int (n)
//
in
  if n >= 0 then
    list0_of_list_vt (list_tabulate<a> (n))
  else
    $raise IllegalArgExn("list0_tabulate:n")
  // end of [if]
end // end of [list0_tabulate]

(* ****** ****** *)

implement{a}
list0_tabulate_opt
  (n, f) = res where
{
//
fun loop
(
  i: int
, res: &ptr? >> List0_vt (a)
) : void = let
in
//
if n > i then
(
case+ f(i) of
| ~Some_vt x => let
    val () =
    (
    res :=
    list_vt_cons{a}{0}(x, _)
    )
    val+list_vt_cons (_, res1) = res
    val () = loop (i+1, res1)
    prval () = fold@ (res)
  in
    // nothing
  end // end of [Some0]
| ~None_vt () => loop (i+1, res)
) else (
  res := list_vt_nil ()
) (* end of [if] *)
//
end // end of [loop]
//
var res: ptr
val () = loop (0, res)
val res = list0_of_list_vt (res)
//
} // end of [list0_tabulate_opt]

(* ****** ****** *)

implement
{x,y}
list0_zip (xs, ys) = let
  val xs = g1ofg0(xs) and ys = g1ofg0(ys)
  val xys = $effmask_wrt (list_zip<x,y> (xs, ys))
in
  list0_of_list_vt (xys)
end // end of [list0_zip]

(* ****** ****** *)

implement
{x,y}
list0_cross (xs, ys) = let
  val xs = g1ofg0(xs) and ys = g1ofg0(ys)
  val xys = $effmask_wrt (list_cross<x,y> (xs, ys))
in
  list0_of_list_vt (xys)
end // end of [list0_cross]

(* ****** ****** *)

implement
{x,y}{z}
list0_crosswith
  (xs, ys, f) = let
//
implement
{x2,y2}{z2}
list_crosswith$fopr(x, y) =
  $UN.castvwtp0{z2}(f($UN.cast{x}(x), $UN.cast{y}(y)))
//
val xs = g1ofg0(xs) and ys = g1ofg0(ys)
val zs = $effmask_wrt (list_crosswith<x,y><z> (xs, ys))
//
in
  list0_of_list_vt (zs)
end // end of [list0_crosswith]

(* ****** ****** *)

implement{a}
list0_quicksort (xs, cmp) = let
//
implement
list_quicksort$cmp<a> (x, y) = cmp (x, y)
//
val ys = $effmask_wrt (list_quicksort<a> (g1ofg0(xs)))
//
in
  list0_of_list_vt (ys)
end // end of [list0_quicksort]

(* ****** ****** *)

implement{a}
list0_mergesort (xs, cmp) = let
//
implement
list_mergesort$cmp<a> (x, y) = cmp (x, y)
//
val ys = $effmask_wrt (list_mergesort<a> (g1ofg0(xs)))
//
in
  list0_of_list_vt (ys)
end // end of [list0_mergesort]

(* ****** ****** *)

implement(a)
fprint_val<list0(a)> = fprint_list0

(* ****** ****** *)

(* end of [list0.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: June, 2013 *)

(* ****** ****** *)

staload
STDLIB = "libc/SATS/stdlib.sats"

(* ****** ****** *)

staload "libats/ML/SATS/basis.sats"

(* ****** ****** *)

staload "libats/ML/SATS/stdlib.sats"

(* ****** ****** *)

implement{}
getenv_exn (name) = let
//
val str = $STDLIB.getenv_gc (name)
//
in
//
if isneqz (str) then
  strptr2string (str)
else let
  prval (
  ) = strptr_free_null (str)
  val () = prerrln! "exit(ATS): [getenv_exn]: variable [" name "] is undefined."
in
  exit (1)
end // end of [if]
//
end // end of [getenv_exn]

(* ****** ****** *)

implement{}
getenv_opt (name) = let
//
val str = $STDLIB.getenv_gc (name)
//
in
//
if isneqz (str) then
  Some0 (strptr2string (str))
else let
  prval () = strptr_free_null (str)
in
  None0 ()
end (* end of [if] *)
//
end // end of [getenv_opt]

(* ****** ****** *)

implement{}
setenv_exn
  (name, value, ow) = let
//
val err = $STDLIB.setenv (name, value, ow)
//
in
//
if err < 0 then let
  val () = prerrln! "exit(ATS): [setenv_exn]: variable: [" name "] cannot be set."
in
  exit (1)
end else () // end of [if]
//
end // end of [setenv_err]

implement{}
setenv_err
  (name, value, ow) = $STDLIB.setenv (name, value, ow)
// end of [setenv_err]

(* ****** ****** *)

(* end of [stdlib.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: July, 2012 *)

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libats/ML/SATS/basis.sats"
staload "libats/ML/SATS/list0.sats"
staload "libats/ML/SATS/array0.sats"

(* ****** ****** *)

extern
fun memcpy
  (d:ptr, s:ptr, n:size_t):<!wrt> ptr = "mac#atslib_ML_array0_memcpy"
// end of [memcpy]


(* ****** ****** *)
//
implement
{}(*tmp*)
array0_of_arrszref{a}(A) = $UN.cast{array0(a)}(A)
//
implement
{}(*tmp*)
arrszref_of_array0{a}(A) = $UN.cast{arrszref(a)}(A)
//
(* ****** ****** *)

implement
{}(*tmp*)
array0_get_ref (A0) = let
  val ASZ =
    arrszref_of_array0 (A0) in arrszref_get_ref (ASZ)
  // end of [val]
end // end of [array0_get_ref]

implement
{}(*tmp*)
array0_get_size (A0) = let
  val ASZ =
    arrszref_of_array0 (A0) in arrszref_get_size (ASZ)
  // end of [val]
end // end of [array0_get_size]

implement
{}(*tmp*)
array0_get_refsize (A0) = let
  var asz: size_t
  val ASZ = arrszref_of_array0 (A0)
  val A = $effmask_wrt (arrszref_get_refsize (ASZ, asz))
in
  @(A, asz)
end // end of [array0_get_refsize]

(* ****** ****** *)

implement
{}(*tmp*)
array0_make_arrpsz (psz) = let
  val ASZ =
    arrszref_make_arrpsz (psz) in array0_of_arrszref (ASZ)
  // end of [val]
end // end of [array0_make_arrpsz]

implement
{}(*tmp*)
array0_make_arrayref (A, n) = let
  val ASZ =
    arrszref_make_arrayref (A, n) in array0_of_arrszref (ASZ)
  // end of [val]
end // end of [array0_make_arrpsz]

(* ****** ****** *)

implement
{a}(*tmp*)
array0_make_elt (asz, x) = let
  val ASZ =
    arrszref_make_elt<a> (asz, x) in array0_of_arrszref (ASZ)
  // end of [val]
end // end of [array0_make_elt]

(* ****** ****** *)

implement
{a}(*tmp*)
array0_make_list
  (xs) = let
  val xs = g1ofg0(xs)
  val ASZ = arrszref_make_list (xs) in array0_of_arrszref (ASZ)
end // end of [array0_make_list]

(* ****** ****** *)

implement
{a}(*tmp*)
array0_make_rlist
  (xs) = let
  val xs = g1ofg0(xs)
  val ASZ = arrszref_make_rlist (xs) in array0_of_arrszref (ASZ)
end // end of [array0_make_rlist]

(* ****** ****** *)

implement
{a}(*tmp*)
array0_make_subarray
  (A0, st, ln) = let
//
val st = g1ofg0(st)
val ln = g1ofg0(ln)
val [n:int] (A, asz) = array0_get_refsize (A0)
//
val [st:int] st =
  (if st <= asz then st else asz): sizeLte (n)
val [ln:int] ln =
  (if st + ln <= asz then ln else asz - st): sizeLte (n-st)
//
val A2 = arrayptr_make_uninitized<a> (ln)
val p2 = memcpy (ptrcast(A2), ptr_add<a> (ptrcast(A), st), ln*sizeof<a>)
val A2 = $UN.castvwtp0{arrayref(a,ln)}(A2)
//
in
  array0_make_arrayref (A2, ln)
end // end of [array0_make_subarray]

(* ****** ****** *)
//
implement
{a}(*tmp*)
print_array0 (A) =
  fprint_array0<a> (stdout_ref, A)
//
implement
{a}(*tmp*)
prerr_array0 (A) =
  fprint_array0<a> (stderr_ref, A)
//
implement
{a}(*tmp*)
fprint_array0 (out, A) =
  fprint_arrszref (out, arrszref_of_array0(A))
//
implement
{a}(*tmp*)
fprint_array0_sep (out, A, sep) =
  fprint_arrszref_sep (out, arrszref_of_array0(A), sep)
//
(* ****** ****** *)

implement
{a}{tk}
array0_get_at_gint
  (A0, i) = let
in
//
if i >= 0 then
  array0_get_at_size (A0, g0i2u(i))
else
  $raise ArraySubscriptExn() // neg index
//
end // end of [array0_get_at_gint]

implement
{a}{tk}
array0_get_at_guint
  (A0, i) = let
in
  array0_get_at_size (A0, g0u2u(i))
end // end of [array0_get_at_guint]

implement
{a}(*tmp*)
array0_get_at_size
  (A0, i) = let
  val ASZ =
    arrszref_of_array0 (A0) in arrszref_get_at_size (ASZ, i)
  // end of [val]
end // end of [array0_get_at_size]

(* ****** ****** *)

implement
{a}{tk}
array0_set_at_gint
  (A0, i, x) = let
in
//
if i >= 0 then
  array0_set_at_size (A0, g0i2u(i), x)
else
  $raise ArraySubscriptExn() // neg index
//
end // end of [array0_set_at_gint]

implement
{a}{tk}
array0_set_at_guint
  (A0, i, x) =
(
  array0_set_at_size (A0, g0u2u(i), x)
) // end of [array0_set_at_guint]

implement
{a}(*tmp*)
array0_set_at_size
  (A0, i, x) = let
  val ASZ =
    arrszref_of_array0 (A0) in arrszref_set_at_size (ASZ, i, x)
  // end of [val]
end // end of [array0_set_at_size]

(* ****** ****** *)

implement
{a}{tk}
array0_exch_at_gint
  (A0, i, x) = let
in
//
if i >= 0 then
  array0_exch_at_size (A0, g0i2u(i), x)
else
  $raise ArraySubscriptExn() // neg index
//
end // end of [array0_exch_at_gint]

implement
{a}{tk}
array0_exch_at_guint
  (A0, i, x) =
(
  array0_exch_at_size (A0, g0u2u(i), x)
) // end of [array0_exch_at_guint]

implement
{a}(*tmp*)
array0_exch_at_size
  (A0, i, x) = let
  val ASZ =
    arrszref_of_array0 (A0) in arrszref_exch_at_size (ASZ, i, x)
  // end of [val]
end // end of [array0_exch_at_size]

(* ****** ****** *)

implement
{a}(*tmp*)
array0_interchange
  (A0, i, j) = let
  val ASZ =
    arrszref_of_array0 (A0) in arrszref_interchange (ASZ, i, j)
  // end of [val]
end // end of [array0_interchange]

(* ****** ****** *)

implement
{a}(*tmp*)
array0_subcirculate
  (A0, i, j) = let
  val ASZ =
    arrszref_of_array0 (A0) in arrszref_subcirculate (ASZ, i, j)
  // end of [val]
end // end of [array0_subcirculate]

(* ****** ****** *)

implement
{a}(*tmp*)
array0_copy
  (A0) = let
//
val ASZ = arrszref_of_array0 (A0)
//
var asz: size_t
val A = arrszref_get_refsize (ASZ, asz)
//
val (
  vbox pf | p
) = arrayref_get_viewptr (A)
val (pfarr, pfgc | q) = array_ptr_alloc<a> (asz)
val () = array_copy<a> (!q, !p, asz)
//
val A2 = arrayptr_encode (pfarr, pfgc | q)
val A2 = arrayptr_refize (A2) // non-linearizing
val ASZ2 = arrszref_make_arrayref (A2, asz)
//
in
  array0_of_arrszref (ASZ2)
end // end of [array0_copy]

(* ****** ****** *)

implement
{a}(*tmp*)
array0_append
  (A01, A02) = let
//
val ASZ1 = arrszref_of_array0 (A01)
and ASZ2 = arrszref_of_array0 (A02)
//
var asz1: size_t and asz2: size_t
val A1 = arrszref_get_refsize (ASZ1, asz1)
and A2 = arrszref_get_refsize (ASZ2, asz2)
//
val (pf1box | p1) = arrayref_get_viewptr (A1)
and (pf2box | p2) = arrayref_get_viewptr (A2)
//
extern
praxi unbox : {v:view} vbox (v) -<prf> (v, v -<lin,prf> void)
//
prval (pf1, fpf1) = unbox (pf1box) and (pf2, fpf2) = unbox (pf2box)
//
val asz = asz1 + asz2
val (pfarr, pfgc | q) = array_ptr_alloc<a> (asz)
prval (pf1arr, pf2arr) = array_v_split_at (pfarr | asz1)
//
val () = array_copy<a> (!q, !p1, asz1)
val q2 = ptr1_add_guint<a> (q, asz1)
val (pf2arr | q2) = viewptr_match (pf2arr | q2)
val () = array_copy<a> (!q2, !p2, asz2)
//
prval () = fpf1 (pf1) and () = fpf2 (pf2)
//
prval pfarr = array_v_unsplit (pf1arr, pf2arr)
//
val A12 = arrayptr_encode (pfarr, pfgc | q)
val A12 = arrayptr_refize (A12)
val ASZ12 = arrszref_make_arrayref (A12, asz)
//
in
  array0_of_arrszref (ASZ12)
end // end of [array0_append]

(* ****** ****** *)

implement
{a}{b}
array0_map
  (A, f) = let
//
val p0 = array0_get_ref (A)
val asz = array0_get_size (A)
//
val f = $UN.cast{cfun1(ptr, b)}(f)
//
in
  array0_tabulate<b> (asz, lam i => f (ptr_add<a> (p0, i)))
end // end of [array0_map]

(* ****** ****** *)

implement
{a}(*tmp*)
array0_tabulate
  (asz, f) = let
//
implement{a2}
array_tabulate$fopr
  (i) = $UN.castvwtp0{a2}(f(i))
//
val ASZ = arrszref_tabulate<a> (asz)
//
in
  array0_of_arrszref (ASZ)  
end // end of [array0_tabulate]

(* ****** ****** *)

implement
{a}(*tmp*)
array0_find_exn (A0, p) = let
//
val
ASZ = arrszref_of_array0 (A0)
//
var
asz : size_t
val A = arrszref_get_refsize (ASZ, asz)
//
implement(tenv)
array_foreach$cont<a><tenv> (x, env) = ~p(x)
implement(tenv)
array_foreach$fwork<a><tenv> (x, env) = ((*nothing*))
//
val idx = arrayref_foreach<a> (A, asz)
//
in
  if idx < asz then idx else $raise NotFoundExn()
end // end of [array0_find_exn]

(*
/*
implement
{a}(*tmp*)
array0_find_opt (A0, p) =
  try Some0 (array0_find_exn<a> (A0, p)) with ~NotFoundExn() => None0 ()
// end of [array0_find_opt]
*/
*)

(* ****** ****** *)

implement
{a}(*tmp*)
array0_foreach
  (A0, f) = let
//
val
ASZ = arrszref_of_array0 (A0)
//
var
asz : size_t
val A = arrszref_get_refsize (ASZ, asz)
//
implement(tenv)
array_foreach$cont<a><tenv> (x, env) = true
implement(tenv)
array_foreach$fwork<a><tenv> (x, env) = f (x)
//
val _(*asz*) = arrayref_foreach<a> (A, asz)
//
in
  // nothing
end // end of [array0_foreach]

(* ****** ****** *)

implement
{a}(*tmp*)
array0_iforeach
  (A0, f) = let
//
val
ASZ = arrszref_of_array0 (A0)
//
var
asz : size_t
val A = arrszref_get_refsize (ASZ, asz)
//
implement(tenv)
array_iforeach$cont<a><tenv> (i, x, env) = true
implement(tenv)
array_iforeach$fwork<a><tenv> (i, x, env) = f (i, x)
//
val _(*asz*) = arrayref_iforeach<a> (A, asz)
//
in
  // nothing
end // end of [array0_iforeach]

(* ****** ****** *)

implement
{a}(*tmp*)
array0_rforeach
  (A0, f) = let
//
val
ASZ = arrszref_of_array0 (A0)
//
var
asz : size_t
val A = arrszref_get_refsize (ASZ, asz)
//
implement(tenv)
array_rforeach$cont<a><tenv> (x, env) = true
implement(tenv)
array_rforeach$fwork<a><tenv> (x, env) = f (x)
//
val _(*asz*) = arrayref_rforeach<a> (A, asz)
//
in
  // nothing
end // end of [array0_rforeach]

(* ****** ****** *)

implement
{res}{a}
array0_foldleft
  (A0, ini, f) = let
//
val
ASZ = arrszref_of_array0 (A0)
//
var
asz : size_t
val A = arrszref_get_refsize (ASZ, asz)
//
implement
array_foreach$cont<a><res> (x, env) = true
implement
array_foreach$fwork<a><res> (x, env) = env := f (env, x)
//
var
result: res = ini
val _(*asz*) = arrayref_foreach_env<a><res> (A, asz, result)
//
in
  result
end // end of [array0_foldleft]

(* ****** ****** *)

implement
{res}{a}
array0_ifoldleft
  (A0, ini, f) = let
//
val
ASZ = arrszref_of_array0 (A0)
//
var
asz : size_t
val A = arrszref_get_refsize (ASZ, asz)
//
implement
array_iforeach$cont<a><res> (i, x, env) = true
implement
array_iforeach$fwork<a><res> (i, x, env) = (env := f (env, i, x))
//
var
result: res = ini
val _(*asz*) = arrayref_iforeach_env<a><res> (A, asz, result)
//
in
  result
end // end of [array0_ifoldleft]

(* ****** ****** *)

implement
{a}{res}
array0_foldright
  (A0, f, snk) = let
//
val
ASZ = arrszref_of_array0 (A0)
//
var
asz : size_t
val A = arrszref_get_refsize (ASZ, asz)
//
implement
array_rforeach$cont<a><res> (x, env) = true
implement
array_rforeach$fwork<a><res> (x, env) = env := f (x, env)
//
var
result: res = snk
val _(*asz*) = arrayref_rforeach_env<a><res> (A, asz, result)
//
in
  result
end // end of [array0_foldright]

(* ****** ****** *)

implement
{a}(*tmp*)
array0_quicksort
  (A0, cmp) = let
//
val
ASZ = arrszref_of_array0 (A0)
//
var
asz : size_t
val A = arrszref_get_refsize (ASZ, asz)
//
implement
{a}(*tmp*)
array_quicksort$cmp
  (x1, x2) = let
//
val
cmp =
$UN.cast{(&a,&a)-<cloref>int}(cmp)
//
in
   cmp(x1, x2)
end // end of [array_quicksort$cmp]
//
in
  arrayref_quicksort<a> (A, asz)
end // end of [array0_quicksort]

(* ****** ****** *)

(* end of [array0.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: July, 2012 *)

(* ****** ****** *)

#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time
#define ATS_EXTERN_PREFIX "atslib_ML_" // prefix for external names

(* ****** ****** *)
//
#include
"share/atspre_staload.hats"
//
(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)
//
macdef
prelude_string_sing = string_sing
//
macdef
prelude_string_is_empty = string_is_empty
macdef
prelude_string_isnot_empty = string_isnot_empty
//
macdef
prelude_string0_copy = string0_copy
//
macdef
prelude_string_make_list = string_make_list
macdef
prelude_string_make_rlist = string_make_rlist
//
macdef
prelude_string_make_substring = string_make_substring
//
macdef
prelude_string0_length = string0_length
macdef
prelude_string1_length = string1_length
//
macdef
prelude_string0_append = string0_append
//
macdef
prelude_stringlst_concat = stringlst_concat
//
macdef
prelude_string_explode = string_explode
//
macdef
prelude_string_tabulate = string_tabulate
//
macdef
prelude_string_forall = string_forall
macdef
prelude_string_iforall = string_iforall
//
macdef
prelude_string_foreach = string_foreach
//
(* ****** ****** *)

staload "libats/ML/SATS/basis.sats"
staload "libats/ML/SATS/list0.sats"
staload "libats/ML/SATS/string.sats"

(* ****** ****** *)

macdef
castvwtp_trans = $UN.castvwtp0 // former name

(* ****** ****** *)

implement{
} itoa (int) =
  $effmask_wrt(strptr2string(g0int2string_int(int)))
// end of [iota]

(* ****** ****** *)
//
implement{
} string_sing (c) =
  strnptr2string ($effmask_wrt(prelude_string_sing (c)))
//
(* ****** ****** *)
//
implement{
} string_is_empty (str) =
  prelude_string_is_empty (g1ofg0(str))
implement{
} string_isnot_empty (str) =
  prelude_string_isnot_empty (g1ofg0(str))
//
(* ****** ****** *)

implement{
} string_copy (str) =
  strptr2string ($effmask_wrt(prelude_string0_copy (str)))
// end of [string_copy]

(* ****** ****** *)
//
implement{
} string_make_list (cs) = let
  val cs = $UN.cast{list0(charNZ)}(cs)
  val str = $effmask_wrt(prelude_string_make_list (g1ofg0_list(cs)))
in
  strnptr2string (str)
end // end of [string_make_list]
//
implement{
} string_make_rlist (cs) = let
  val cs = $UN.cast{list0(charNZ)}(cs)
  val str = $effmask_wrt(prelude_string_make_rlist (g1ofg0_list(cs)))
in
  strnptr2string (str)
end // end of [string_make_rlist]
//
(* ****** ****** *)

implement{
} string_make_substring
  (x, st, ln) = let
//
val x = g1ofg0_string(x)
val st = g1ofg0_uint(st) and ln = g1ofg0_uint(ln)
val lnx = prelude_string1_length (x)
//
val st = min (st, lnx)
//
val substr =
$effmask_wrt(prelude_string_make_substring (x, st, min (ln, lnx-st)))
//
in
  $UN.castvwtp0{string}(substr)
end // end of [string_make_substring]

(* ****** ****** *)

implement{
} string_append
  (str1, str2) = let
  val res = $effmask_wrt (prelude_string0_append (str1, str2))
in
  strptr2string (res)
end // end of [string_append]

(* ****** ****** *)

implement{
} stringlst_concat (xs) = let
  val res = $effmask_wrt (prelude_stringlst_concat (g1ofg0_list(xs)))
in
  strptr2string (res)
end // end of [stringlst_concat]

(* ****** ****** *)

implement{
} string_explode (str) = let
  val str = g1ofg0_string (str)
  val res = $effmask_wrt (prelude_string_explode (str))
in
  list0_of_list_vt (res)
end // end of [string_explode]

(* ****** ****** *)

implement{
} string_implode (cs) = string_make_list (cs)

(* ****** ****** *)

implement
string_tabulate
  (n, f) = let
//
val n = g1ofg0_uint(n)
//
implement
string_tabulate$fopr<> (i) = f (i)
//
in
  strnptr2string(prelude_string_tabulate (n))
end // end of [string_tabulate]

(* ****** ****** *)

implement
string_forall
  (str, f) = let
//
val str = g1ofg0_string(str)
//
implement
string_forall$pred<> (c) = f(c)
//
in
  prelude_string_forall (str)
end // end of [string_forall]

implement
string_iforall
  (str, f) = let
//
val str = g1ofg0_string(str)
//
implement
string_iforall$pred<> (i, c) = f(i, c)
//
in
  prelude_string_iforall (str)
end // end of [string_iforall]

(* ****** ****** *)

implement
string_foreach
  (str, f) = let
//
val str = g1ofg0_string(str)
//
implement(env)
string_foreach$cont<env> (c, env) = true
implement(env)
string_foreach$fwork<env> (c, env) = f(c)
//
val _(*nchar*) = prelude_string_foreach (str)
//
in
  // nothing
end // end of [string_foreach]

(* ****** ****** *)
//
implement{}
string_forall_method(x) = lam(f) => string_forall (x, f)
implement{}
string_iforall_method(x) = lam(f) => string_iforall (x, f)
implement{}
string_foreach_method(x) = lam(f) => string_foreach (x, f)
//
(* ****** ****** *)

(* end of [string.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: February, 2014 *)

(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libats/ML/SATS/basis.sats"
staload "libats/ML/SATS/matrix0.sats"

(* ****** ****** *)
//
implement{}
matrix0_of_mtrxszref{a}(A) = $UN.cast{matrix0(a)}(A)
//
implement{}
mtrxszref_of_matrix0{a}(A) = $UN.cast{mtrxszref(a)}(A)
//
(* ****** ****** *)
//
implement{
} matrix0_get_ref (M) =
  mtrxszref_get_ref (mtrxszref_of_matrix0(M))
//
implement{
} matrix0_get_nrow (M) =
  mtrxszref_get_nrow (mtrxszref_of_matrix0(M))
implement{
} matrix0_get_ncol (M) =
  mtrxszref_get_ncol (mtrxszref_of_matrix0(M))
//
(* ****** ****** *)

implement{
} matrix0_get_refsize (M) = let
  var nrow: size_t and ncol: size_t
  val Mref =
  $effmask_wrt
  (
    mtrxszref_get_refsize(mtrxszref_of_matrix0(M), nrow, ncol)
  ) (* end of [val] *)
in
  (Mref, nrow, ncol)
end // end of [matrix0_get_refsize]

(* ****** ****** *)

implement
{a}(*tmp*)
matrix0_make_elt
  (nrow, ncol, x0) =
  matrix0_of_mtrxszref (mtrxszref_make_elt<a> (nrow, ncol, x0))
// end of [matrix0_make_elt]

(* ****** ****** *)

implement
{a}(*tmp*)
matrix0_get_at_int
  (M0, i, j) = let
  val i = g1ofg0_int(i)
  and j = g1ofg0_int(j)
in
//
if i >= 0
then (
if j >= 0 then
  matrix0_get_at_size<a> (M0, i2sz(i), i2sz(j))
else
  $raise MatrixSubscriptExn((*void*)) // neg index
// end of [if]
) else
  $raise MatrixSubscriptExn((*void*)) // neg index
// end of [if]
//
end // end of [matrix0_get_at_int]

(* ****** ****** *)

implement
{a}(*tmp*)
matrix0_get_at_size
  (M0, i, j) = let
  val MSZ =
    mtrxszref_of_matrix0 (M0) in mtrxszref_get_at_size (MSZ, i, j)
  // end of [val]
end // end of [matrix0_get_at_size]

(* ****** ****** *)

implement
{a}(*tmp*)
matrix0_set_at_int
  (M0, i, j, x) = let
  val i = g1ofg0_int(i)
  and j = g1ofg0_int(j)
in
//
if i >= 0
then (
if j >= 0 then
  matrix0_set_at_size<a> (M0, i2sz(i), i2sz(j), x)
else
  $raise MatrixSubscriptExn((*void*)) (* neg index *)
// end of [if]
) else
  $raise MatrixSubscriptExn((*void*)) (* neg index *)
// end of [if]
//
end // end of [matrix0_set_at_int]

(* ****** ****** *)

implement
{a}(*tmp*)
matrix0_set_at_size
  (M0, i, j, x) = let
  val MSZ =
    mtrxszref_of_matrix0 (M0) in mtrxszref_set_at_size (MSZ, i, j, x)
  // end of [val]
end // end of [matrix0_set_at_size]

(* ****** ****** *)
//
implement
{a}(*tmp*)
print_matrix0 (A) =
  fprint_matrix0<a> (stdout_ref, A)
//
implement
{a}(*tmp*)
prerr_matrix0 (A) =
  fprint_matrix0<a> (stderr_ref, A)
//
implement
{a}(*tmp*)
fprint_matrix0 (out, M) =
  fprint_mtrxszref (out, mtrxszref_of_matrix0(M))
//
implement
{a}(*tmp*)
fprint_matrix0_sep (out, M, sep1, sep2) =
  fprint_mtrxszref_sep (out, mtrxszref_of_matrix0(M), sep1, sep2)
//
(* ****** ****** *)

implement
{a}(*tmp*)
matrix0_copy (M0) = let
//
val M = matrix0_get_ref (M0)
val [m:int] m = g1ofg0 (M0.nrow())
val [n:int] n = g1ofg0 (M0.ncol())
val M =
  matrixref_copy<a> ($UN.cast{matrixref(a,m,n)}(M), m, n)
// end of [val]
in
//
matrix0_of_mtrxszref
  (mtrxszref_make_matrixref (matrixptr_refize{a}(M), m, n))
//
end // end of [matrix0_copy]

(* ****** ****** *)

implement
{a}(*tmp*)
matrix0_tabulate
  (nrow, ncol, f) = let
//
implement{a2}
matrix_tabulate$fopr
  (i, j) = $UN.castvwtp0{a2}(f(i,j))
//
val MSZ = mtrxszref_tabulate<a> (nrow, ncol)
//
in
  matrix0_of_mtrxszref (MSZ)  
end // end of [matrix0_tabulate]

(* ****** ****** *)

implement
{a}(*tmp*)
matrix0_foreach
  (M0, f) = let
//
fun loop
(
  p: ptr, i: size_t
) : void = (
if i > 0 then let
  val (pf, fpf | p) = $UN.ptr0_vtake (p)
  val ((*void*)) = f (!p)
  prval ((*void*)) = fpf (pf)
in
  loop (ptr_succ<a> (p), pred (i))
end else ((*void*)) // end of [if]
) (* end of [loop] *)
//
val (M, m, n) = matrix0_get_refsize (M0)
//
in
  loop (ptrcast(M), m * n)
end // end of [matrix0_foreach]

(* ****** ****** *)

implement
{a}(*tmp*)
matrix0_iforeach
  (M0, f) = let
//
val (M, m, n) =
  matrix0_get_refsize (M0)
//
fun loop
(
  p: ptr
, k: size_t, i: size_t, j: size_t
) : void = (
if k > 0 then let
  val (
    pf, fpf | p
  ) = $UN.ptr0_vtake (p)
  val () = f (i, j, !p)
  prval ((*void*)) = fpf (pf)
  val p = ptr_succ<a> (p)
  val k = pred(k) and j = succ(j)
in
//
if j < n
  then loop (p, k, i, j)
  else loop (p, k, succ(i), i2sz(0))
// end of [if]
//
end else ((*void*)) // end of [if]
) (* end of [loop] *)
//
in
  loop (ptrcast(M), m * n, i2sz(0), i2sz(0))
end // end of [matrix0_iforeach]

(* ****** ****** *)

implement
{res}{a}(*tmp*)
matrix0_foldleft
  (M0, ini, f) = let
//
var ini: res = ini
val p_ini = addr@(ini)
//
var f2 =
lam@ (x: &a): void =>
  $UN.ptr0_set<res> (p_ini, f ($UN.ptr0_get<res> (p_ini), x))
//
val () =
matrix0_foreach<a> (M0, $UN.cast{(&a)-<cloref1>void}(addr@f2))
//
in
  ini
end // end of [matrix0_foldleft]

(* ****** ****** *)

implement
{res}{a}(*tmp*)
matrix0_ifoldleft
  (M0, ini, f) = let
//
var ini: res = ini
val p_ini = addr@(ini)
//
var f2 =
lam@ (i: size_t, j: size_t, x: &a): void =>
  $UN.ptr0_set<res> (p_ini, f ($UN.ptr0_get<res> (p_ini), i, j, x))
//
val () =
matrix0_iforeach<a> (M0, $UN.cast{(size_t,size_t,&a)-<cloref1>void}(addr@f2))
//
in
  ini
end // end of [matrix0_ifoldleft]

(* ****** ****** *)

(* end of [matrix.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: July, 2012 *)

(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libats/ML/SATS/basis.sats"
staload "libats/ML/SATS/option0.sats"

(* ****** ****** *)

implement
{a}(*tmp*)
option0_some (x) = Some0{a}(x)
implement{
} option0_none ((*void*)) = None0((*void*))

(* ****** ****** *)

implement{}
option0_is_some (opt) =
  case+ opt of Some0 _ => true | None0 _ => false
// end of [option0_is_some]

implement{}
option0_is_none (opt) =
  case+ opt of Some0 _ => false | None0 _ => true
// end of [option0_is_none]

(* ****** ****** *)

implement{a}
option0_unsome_exn (opt) =
  case+ opt of
  | Some0 (x) => x | None0 ( ) => $raise NotSomeExn()
// end of [option0_unsome_exn]

(* ****** ****** *)

implement{a}
fprint_option0
  (out, opt) = fprint_option (out, g1ofg0_option(opt))
// end of [fprint_option0]

(* ****** ****** *)

implement
{a}{b}
option0_map (opt, f) =
(
case+ opt of
| Some0 (x) => Some0{b}(f(x)) | None0 () => None0 ()
) (* end of [option0_map] *)

(* ****** ****** *)

(* end of [option0.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: February, 2013 *)

(* ****** ****** *)

#define ATS_DYNLOADFLAG 0 // no need for dynloading at run-time
#define ATS_EXTERN_PREFIX "atslib_ML_" // prefix for external names

(* ****** ****** *)
//
#include
"share/atspre_staload.hats"
//
(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libats/ML/SATS/basis.sats"
staload "libats/ML/SATS/array0.sats"
staload _(*anon*) = "libats/ML/DATS/array0.dats"

(* ****** ****** *)

staload "libats/ML/SATS/strarr.sats"

(* ****** ****** *)

implement
{}(*tmp*)
strarr_get_ref (str) =
  array0_get_ref (strarr2array (str))
// end of [strarr_get_ref]

implement
{}(*tmp*)
strarr_get_size (str) =
  array0_get_size (strarr2array (str))
// end of [strarr_get_size]

implement
{}(*tmp*)
strarr_get_refsize (str) =
  array0_get_refsize (strarr2array (str))
// end of [strarr_get_refsize]

(* ****** ****** *)

implement
strarr_make_string
  (str) = let
//
val [n:int]
  str = g1ofg0_string (str)
val n = string1_length (str)
//
val
(
  pfarr, pfgc | p
) = array_ptr_alloc<char> (n)
//
// [memcpy] declared in [string.h]
//
val _ =
$extfcall
(
  ptr, "atslib_ML_strarr_memcpy", p, string2ptr(str), n
) (* end of [val] *)
//
typedef A = arrayref (char, n)
//
val A = $UN.castvwtp0 {A} @(pfarr, pfgc | p)
//
in
  array2strarr (array0_make_arrayref (A, n))
end // end of [strarr_make_string]

(* ****** ****** *)

implement
strarr_imake_string
  (str) = let
//
val p = strarr_get_ref (str)
val sz = g1ofg0_uint (strarr_get_size (str))
val (pfgc, pfarr | p2) = malloc_gc (succ (sz))
//
// [memcpy] declared in [string.h]
//
val _ =
$extfcall (ptr, "atslib_ML_strarr_memcpy", p2, p, sz)
//
val () = $UN.ptr0_set<char> (ptr_add<char> (p2, sz), '\000')
//
in
  $UN.castvwtp0 {string} @(pfgc, pfarr | p2)
end // end of [strarr_imake_string]

(* ****** ****** *)

implement
{}(*tmp*)
strarr_is_empty (str) = strarr_get_size (str) = 0
implement
{}(*tmp*)
strarr_isnot_empty (str) = strarr_get_size (str) > 0

(* ****** ****** *)

implement
{tk}(*tmp*)
strarr_get_at_gint
  (str, i) = let
  val str = strarr2array (str) in
  $effmask_ref (array0_get_at_gint<char> (str, i))
end // end of [strarr_get_at_gint]

implement
{tk}(*tmp*)
strarr_get_at_guint
  (str, i) = let
  val str = strarr2array (str) in
  $effmask_ref (array0_get_at_guint<char> (str, i))
end // end of [strarr_get_at_guint]

(* ****** ****** *)

implement
strarr_get_range
  (str, i0, i1) = let
//
#define CNUL '\000'
//
val n = strarr_get_size (str)
val i0 = min (i0, n) and i1 = min (i1, n)
//
val pa = strarr_get_ref (str)
val p0 = add_ptr_bsz (pa, i0)
val p1 = add_ptr_bsz (pa, i1)
//
fun loop_inc
(
  p0: ptr, p1: ptr, pb: ptr
) : void =
(
  if p0 < p1 then let
    val c = $UN.ptr0_get<char> (p0)
    val p0 = ptr_succ<char> (p0)
    val () = $UN.ptr0_set<char> (pb, c)
    val pb = ptr_succ<char> (pb)
  in
    loop_inc (p0, p1, pb)
  end else let
    val () = $UN.ptr0_set<char> (pb, CNUL)
  in
    // nothing
  end (* end of [if] *)
)
fun loop_dec
(
  p0: ptr, p1: ptr, pb: ptr
) : void =
(
  if p0 > p1 then let
    val p0 = ptr_pred<char> (p0)
    val c = $UN.ptr0_get<char> (p0)
    val () = $UN.ptr0_set<char> (pb, c)
    val pb = ptr_succ<char> (pb)
  in
    loop_dec (p0, p1, pb)
  end else let
    val () = $UN.ptr0_set<char> (pb, CNUL)
  in
    // nothing
  end (* end of [if] *)
)
//
in
//
if i0 <= i1 then let
  val df = g1ofg0(i1 - i0)
  val (pf, pfgc | pb) = malloc_gc (df)
  val () = loop_inc (p0, p1, pb)
in
  $UN.castvwtp0{string}((pf, pfgc | pb))
end else let
  val df = g1ofg0(i0 - i1)
  val (pf, pfgc | pb) = malloc_gc (df)  
  val () = loop_dec (p0, p1, pb)
in
  $UN.castvwtp0{string}((pf, pfgc | pb))
end // end of [if]
//
end // end of [strarr_get_range]
  
(* ****** ****** *)

implement
lt_strarr_strarr
  (str1, str2) = (strarr_compare (str1, str2) < 0)
implement
lte_strarr_strarr
  (str1, str2) = (strarr_compare (str1, str2) <= 0)

implement
gt_strarr_strarr
  (str1, str2) = (strarr_compare (str1, str2) > 0)
implement
gte_strarr_strarr
  (str1, str2) = (strarr_compare (str1, str2) >= 0)

implement
eq_strarr_strarr
  (str1, str2) = (strarr_compare (str1, str2) = 0)
implement
neq_strarr_strarr
  (str1, str2) = (strarr_compare (str1, str2) != 0)

(* ****** ****** *)

implement
strarr_compare
  (str1, str2) = let
//
val (A1, n1) = strarr_get_refsize (str1)
and (A2, n2) = strarr_get_refsize (str2)
//
extern
fun strncmp
  : (ptr, ptr, size_t) -<fun> int = "strncmp"
//
val n = g0uint_min_size (n1, n2)
//
// [strncmp] declared in [string.h]
//
val sgn =
$extfcall
(
  int, "atslib_ML_strarr_strncmp", $UN.cast2ptr(A1), $UN.cast2ptr(A2), n
) (* end of [val] *)
//
in
//
if sgn = 0 then
  (if n1 < n2 then ~1 else if n1 > n2 then 1 else 0)
else sgn // end of [if]
//
end // end of [strarr_compare]

(* ****** ****** *)

implement
strarr_length (str) = strarr_get_size (str)

(* ****** ****** *)
//
implement
print_strarr (x) = fprint_strarr (stdout_ref, x)
implement
prerr_strarr (x) = fprint_strarr (stderr_ref, x)
//
(* ****** ****** *)

implement
fprint_strarr (out, str) = let
//
extern
fun fwrite
(
  bufp: ptr
, tsz: size_t, asz: size_t, out: FILEref
) : size_t = "mac#atslib_ML_strarr_fwrite"
//
fun loop
(
  out: FILEref, bufp: ptr, n: size_t
) : void = let
in
//
if n > 0 then let
  val n1 = fwrite (bufp, sizeof<char>, n, out)
in
  if n1 > 0 then
    loop (out, add_ptr_bsz (bufp, n1), n - n1)
  else ((*error*))
end // end of of [if]
//
end // end of [loop]
//
in
  loop (out, strarr_get_ref (str), strarr_get_size (str))
end // end of [fprint_strarr]

(* ****** ****** *)

implement
strarr_contains
  (str, c0) = $effmask_all let
//
val (A, asz) = strarr_get_refsize (str)
//
// [memcpy] declared in [string.h]
//
val p =
$extfcall
(
  ptr, "atslib_ML_strarr_memchr", $UN.cast2ptr(A), char2int0(c0), asz
) (* end of [val] *)
//
in
  (p > the_null_ptr)
end // end of [strarr_contains]

(* ****** ****** *)

implement
strarr_copy
  (str) = let
  val str = strarr2array (str)
  val str2 = $effmask_ref (array0_copy<char> (str))
in
  array2strarr (str2)
end // end of [strarr_copy]

(* ****** ****** *)

implement
strarr_append
  (str1, str2) = let
  val str1 = strarr2array (str1)
  val str2 = strarr2array (str2)
  val str12 = $effmask_ref (array0_append<char> (str1, str2))
in
  array2strarr (str12)
end // end of [strarr_append]

(* ****** ****** *)

implement
strarr_tabulate (n, f) = array2strarr (array0_tabulate (n, f))

(* ****** ****** *)

implement
strarr_foreach
  (str, f) = let
//
fun loop
(
  p: ptr, n: size_t, f: cfun (char, void)
) : void = let
in
//
if n > 0 then let
  val () = f ($UN.ptr0_get<char> (p))
in
  loop (ptr0_succ<char> (p), pred (n), f)
end else () // end of [if]
//
end // end of [loop]
//
val p0 = strarr_get_ref (str)
val n0 = strarr_get_size (str)
//
in
  loop (p0, n0, f)
end // end of [strarr_foreach]

(* ****** ****** *)

implement
strarr_iforeach
  (str, f) = let
//
fun loop
(
  p: ptr, n: size_t
, i: size_t, f: cfun (size_t, char, void)
) : void = let
in
//
if n > i then let
  val () = f (i, $UN.ptr0_get<char> (p))
in
  loop (ptr0_succ<char> (p), n, succ (i), f)
end else () // end of [if]
//
end // end of [loop]
//
val p0 = strarr_get_ref (str)
val n0 = strarr_get_size (str)
//
in
  loop (p0, n0, i2sz(0), f)
end // end of [strarr_iforeach]

(* ****** ****** *)

implement
strarr_rforeach
  (str, f) = let
//
fun loop
(
  p: ptr, n: size_t, f: cfun (char, void)
) : void = let
in
//
if n > 0 then let
  val p1 = ptr0_pred<char> (p)
  val () = f ($UN.ptr0_get<char> (p1)) in loop (p1, pred (n), f)
end else () // end of [if]
//
end // end of [loop]
//
val p0 = strarr_get_ref (str)
val n0 = strarr_get_size (str)
//
in
  loop (ptr0_add_guint<char> (p0, n0), n0, f)
end // end of [strarr_rforeach]

(* ****** ****** *)
//
implement
fprint_val<strarr>
  (out, str) = fprint_strarr (out, str)
//
(* ****** ****** *)

(* end of [strarr.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: July, 2013 *)

(* ****** ****** *)

staload "libats/ML/SATS/basis.sats"

(* ****** ****** *)

staload "libats/ML/SATS/monad_maybe.sats"

(* ****** ****** *)

#include "./SHARE/monad.hats"

(* ****** ****** *)

assume monad_type (a:t0p) = Option (a)

(* ****** ****** *)

implement
{a}{b}
monad_bind
  (opt, f) = let
in
//
case+ opt of
| Some (x) => f (x) | None () => None ()
//
end // end of [monad_bind]

(* ****** ****** *)

implement
{a1,a2}{b}
monad_bind2
  (opt1, opt2, f) = let
in
//
case+ opt1 of
| Some (x1) => (
  case+ opt2 of Some (x2) => f (x1, x2) | None () => None ()
  ) (* end of [Some] *)
| None () => None ()
//
end // end of [monad_bind2]

(* ****** ****** *)

implement
{a1,a2,a3}{b}
monad_bind3
  (opt1, opt2, opt3, f) = let
in
//
case+ opt1 of
| Some (x1) => (
  case+ opt2 of
  | Some (x2) =>
    (
      case+ opt3 of
      | Some (x3) => f (x1, x2, x3) | None () => None ()
    )
  | None () => None ()
  ) (* end of [Some] *)
| None () => None ()
//
end // end of [monad_bind3]

(* ****** ****** *)

implement{a} monad_return (x) = Some{a}(x)

(* ****** ****** *)

implement{a}
monad_cons (mx, mxs) = let
in
//
case+ mx of
| Some (x) =>
  (
  case+ mxs of
  | Some (xs) => Some{list0(a)}(list0_cons{a}(x, xs))
  | None ((*void*)) => None ()
  )
| None () => None ()
//
end // end of [monad_cons]

(* ****** ****** *)

implement{a} monad_maybe_none () = None{a}()
implement{a} monad_maybe_some (x) = Some{a}(x)

(* ****** ****** *)

implement{a} monad_maybe_optize (m) = (m)

(* ****** ****** *)
//
implement{a}
fprint_monad (out, m) = fprint_option<a> (out, m)
//
(* ****** ****** *)

(* end of [monad_maybe.hats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: January, 2013 *)

(* ****** ****** *)

#define ATS_DYNLOADFLAG 0 // no dynloading at run-time

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload _(*anon*) = "prelude/DATS/integer.dats"
staload _(*anon*) = "prelude/DATS/filebas.dats"

(* ****** ****** *)

(*
macdef
prelude_fileref_open_opt = fileref_open_opt
*)
macdef
prelude_fileref_get_line_charlst = fileref_get_line_charlst
macdef
prelude_fileref_get_lines_charlstlst = fileref_get_lines_charlstlst
macdef
prelude_fileref_get_line_string = fileref_get_line_string
macdef
prelude_fileref_get_lines_stringlst = fileref_get_lines_stringlst

(* ****** ****** *)

staload "libats/ML/SATS/basis.sats"
staload "libats/ML/SATS/list0.sats"
staload "libats/ML/SATS/option0.sats"

(* ****** ****** *)

staload "libats/ML/SATS/filebas.sats"

(* ****** ****** *)

(*
implement
fileref_open_opt
  (path, mode) = let
  val opt = prelude_fileref_open_opt (path, mode)
in
  option0_of_option_vt (opt)
end // end of [fileref_open_opt]
*)

(* ****** ****** *)

implement
fileref_get_line_charlst (filr) =
  list0_of_list_vt (prelude_fileref_get_line_charlst (filr))
// end of [fileref_get_line_charlst]

implement
fileref_get_lines_charlstlst (filr) =
  $UN.castvwtp0{list0(charlst0)} (prelude_fileref_get_lines_charlstlst (filr))
// end of [fileref_get_lines_charlstlst]

(* ****** ****** *)

local

staload _(*anon*) = "prelude/DATS/strptr.dats"

in (* in of [local] *)

implement
fileref_get_line_string (filr) =
  strptr2string (prelude_fileref_get_line_string (filr))
// end of [fileref_get_line_string]

implement
fileref_get_lines_stringlst (filr) =
  $UN.castvwtp0{list0(string)}(prelude_fileref_get_lines_stringlst (filr))
// end of [fileref_get_lines_stringlst]

end // end of [local]

(* ****** ****** *)

(* end of [filebas.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: August, 2013 *)

(* ****** ****** *)

staload
UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)
//
staload HT =
"libats/SATS/hashtbl_chain.sats"
//
(* ****** ****** *)

staload "libats/ML/SATS/list0.sats"

(* ****** ****** *)

staload "libats/SATS/hashfun.sats"
staload "libats/ML/SATS/hashtblref.sats"

(* ****** ****** *)

(*
implement
{key}(*tmp*)
hash_key = ghash_val<key>
*)

(* ****** ****** *)

implement
{key}(*tmp*)
equal_key_key = gequal_val_val<key>

(* ****** ****** *)
//
implement
hash_key<int> (key) = let
  val key = $UN.cast{uint32}(key)
in
  $UN.cast{ulint}(inthash_jenkins<>(key))
end // end of [hash_key<int>]
//
implement
hash_key<uint> (key) = let
  val key = $UN.cast{uint32}(key)
in
  $UN.cast{ulint}(inthash_jenkins<>(key))
end // end of [hash_key<uint>]
//
(* ****** ****** *)
//
// HX: 31 and 37 are top choices
//
implement
hash_key<string> (key) =
  string_hash_multiplier (31UL, 31415926536UL, key)
//
(* ****** ****** *)
//
implement
{key}(*tmp*)
$HT.hash_key = hash_key<key>
//
implement
{key}(*tmp*)
$HT.equal_key_key = equal_key_key<key>
//
(* ****** ****** *)
//
extern
castfn
hashtbl_encode
  {key,itm:t0p}
  ($HT.hashtbl (key, INV(itm))): hashtbl (key, itm)
extern
castfn
hashtbl_decode
  {key,itm:t0p}
  (hashtbl (key, INV(itm))): $HT.hashtbl (key, itm)
//
(* ****** ****** *)

#define htencode hashtbl_encode
#define htdecode hashtbl_decode

(* ****** ****** *)
//
implement
{key,itm}
hashtbl_make_nil (cap) =
  htencode($HT.hashtbl_make_nil<key,itm> (cap))
//
(* ****** ****** *)

implement{}
hashtbl_get_size
  (tbl) = nitm where
{
//
val tbl = htdecode (tbl)
val nitm = $HT.hashtbl_get_size (tbl)
prval () = $UN.cast2void (tbl)
//
} (* end of [hashtbl_get_size] *)

(* ****** ****** *)

implement{}
hashtbl_get_capacity
  (tbl) = cap where
{
//
val tbl = htdecode (tbl)
val cap = $HT.hashtbl_get_capacity (tbl)
prval () = $UN.cast2void (tbl)
//
} (* end of [hashtbl_get_capacity] *)

(* ****** ****** *)

implement
{key,itm}
hashtbl_search
  (tbl, k) = opt where
{
//
val tbl = htdecode (tbl)
val opt = $HT.hashtbl_search_opt (tbl, k)
prval () = $UN.cast2void (tbl)
//
} (* end of [hashtbl_search] *)

(* ****** ****** *)

implement
{key,itm}
hashtbl_search_ref
  (tbl, k) = cptr where
{
//
val tbl = htdecode (tbl)
val cptr = $HT.hashtbl_search_ref (tbl, k)
prval () = $UN.cast2void (tbl)
//
} (* end of [hashtbl_search_ref] *)

(* ****** ****** *)

implement
{key,itm}
hashtbl_insert
  (tbl, k, x) = opt where
{
//
val tbl = htdecode (tbl)
val opt = $HT.hashtbl_insert_opt<key,itm> (tbl, k, x)
prval () = $UN.cast2void (tbl)
//
} (* hashtbl_insert *)

(* ****** ****** *)

implement
{key,itm}
hashtbl_insert_any
  (tbl, k, x) = () where
{
//
val tbl = htdecode (tbl)
val () = $HT.hashtbl_insert_any<key,itm> (tbl, k, x)
prval () = $UN.cast2void (tbl)
//
} (* hashtbl_insert_any *)

(* ****** ****** *)

implement
{key,itm}
hashtbl_takeout
  (tbl, k) = opt where
{
//
val tbl = htdecode (tbl)
val opt = $HT.hashtbl_takeout_opt (tbl, k)
prval () = $UN.cast2void (tbl)
//
} (* end of [hashtbl_takeout] *)

(* ****** ****** *)

implement
{key,itm}
hashtbl_remove
  (tbl, k) = ans where
{
//
val tbl = htdecode (tbl)
val ans = $HT.hashtbl_remove (tbl, k)
prval () = $UN.cast2void (tbl)
//
} (* end of [hashtbl_remove] *)

(* ****** ****** *)

implement
{key,itm}
hashtbl_takeout_all
  (tbl) = kxs where
{
//
val tbl = htdecode (tbl)
val kxs = $HT.hashtbl_takeout_all (tbl)
prval () = $UN.cast2void (tbl)
val kxs = list0_of_list_vt{(key,itm)}(kxs)
//
} (* end of [hashtbl_takeout_all] *)

(* ****** ****** *)

implement
{key,itm}
fprint_hashtbl
  (out, tbl) = let
//
implement
$HT.fprint_hashtbl$sep<> = fprint_hashtbl$sep<>
implement
$HT.fprint_hashtbl$mapto<> = fprint_hashtbl$mapto<>
//
val tbl = htdecode (tbl)
val () = $HT.fprint_hashtbl (out, tbl)
prval () = $UN.cast2void (tbl)
//
in
  // nothing
end // end of [fprint_hashtbl]

(* ****** ****** *)

implement{}
fprint_hashtbl$sep (out) = fprint (out, "; ")
implement{}
fprint_hashtbl$mapto (out) = fprint (out, "->")

(* ****** ****** *)

implement
{key,itm}
hashtbl_foreach_cloref
  (tbl, fwork) = () where
{
//
var env: void = ((*void*))
//
implement
(env)(*tmp*)
$HT.hashtbl_foreach$fwork<key,itm><env> (k, x, env) = fwork(k, x)
//
val tbl = htdecode (tbl)
val ((*void*)) = $HT.hashtbl_foreach_env<key,itm><void> (tbl, env)
prval ((*void*)) = $UN.cast2void (tbl)
//
} (* end of [hashtbl_foreach_cloref] *)

(* ****** ****** *)

implement
{key,itm}
hashtbl_listize1
  (tbl) = kxs where
{
//
typedef ki = @(key, itm)
//
val tbl = htdecode (tbl)
val kxs = $HT.hashtbl_listize1 (tbl)
prval () = $UN.cast2void (tbl)
val kxs = list0_of_list_vt{(key,itm)}(kxs)
//
} (* end of [hashtbl_listize1] *)

(* ****** ****** *)

(* end of [hashtblref.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: December, 2012 *)

(* ****** ****** *)
//
// HX-2012-12: the set implementation is based on AVL trees
//
(* ****** ****** *)
//
staload
UN = "prelude/SATS/unsafe.sats"
//
(* ****** ****** *)
//
staload
FS =
"libats/SATS/funset_avltree.sats"
//
(* ****** ****** *)

staload "libats/ML/SATS/basis.sats"

(* ****** ****** *)

staload "libats/ML/SATS/list0.sats"

(* ****** ****** *)

staload "libats/ML/SATS/funset.sats"

(* ****** ****** *)

implement{a}
compare_elt_elt = gcompare_val_val<a>
implement{a}
$FS.compare_elt_elt = compare_elt_elt<a>

(* ****** ****** *)

assume set_type (a:t0p) = $FS.set (a)

(* ****** ****** *)

implement{}
funset_nil () = $FS.funset_nil ()
implement{}
funset_make_nil () = $FS.funset_make_nil ()

(* ****** ****** *)

implement{a}
funset_sing (x) = $FS.funset_sing<a> (x)
implement{a}
funset_make_sing (x) = $FS.funset_make_sing<a> (x)

(* ****** ****** *)

implement{a}
funset_make_list
  (xs) = let
//
val xs = g1ofg0_list (xs)
implement
$FS.compare_elt_elt<a> = compare_elt_elt<a>
//
in
  $FS.funset_make_list (xs)
end // end of [funset_make_list]

(* ****** ****** *)

implement{}
fprint_funset$sep
  (out) = fprint_string (out, ", ")
implement{a}
fprint_funset (out, xs) = let
//
implement
$FS.fprint_funset$sep<> (out) = fprint_funset$sep (out)
//
in
  $FS.fprint_funset (out, xs)
end // end of [fprint_funset]

(* ****** ****** *)

implement{}
funset_is_nil (xs) = $FS.funset_is_nil (xs)
implement{}
funset_isnot_nil (xs) = $FS.funset_isnot_nil (xs)

(* ****** ****** *)

implement{a}
funset_size (xs) = $FS.funset_size (xs)

(* ****** ****** *)

implement
{a}(*tmp*)
funset_is_member
  (xs, x0) = let
//
implement
$FS.compare_elt_elt<a> = compare_elt_elt<a>
//
in
  $FS.funset_is_member (xs, x0)
end // end of [funset_is_member]

implement
{a}(*tmp*)
funset_isnot_member (xs, x0) = ~funset_is_member (xs, x0)

(* ****** ****** *)

implement
{a}(*tmp*)
funset_insert
  (xs, x0) = let
//
implement
$FS.compare_elt_elt<a> = compare_elt_elt<a>
//
in
  $FS.funset_insert (xs, x0)
end // end of [funset_insert]

(* ****** ****** *)

implement
{a}(*tmp*)
funset_remove
  (xs, x0) = let
//
implement
$FS.compare_elt_elt<a> = compare_elt_elt<a>
//
in
  $FS.funset_remove (xs, x0)
end // end of [funset_remove]

(* ****** ****** *)

implement
{a}(*tmp*)
funset_getmax_opt = $FS.funset_getmax_opt<a>
implement
{a}(*tmp*)
funset_getmin_opt = $FS.funset_getmin_opt<a>

(* ****** ****** *)

implement
{a}(*tmp*)
funset_takeoutmax_opt = $FS.funset_takeoutmax_opt<a>
implement
{a}(*tmp*)
funset_takeoutmin_opt = $FS.funset_takeoutmin_opt<a>

(* ****** ****** *)

implement
{a}(*tmp*)
funset_union
  (xs1, xs2) = let
//
implement
$FS.compare_elt_elt<a> = compare_elt_elt<a>
//
in
  $FS.funset_union (xs1, xs2)
end // end of [funset_union]

(* ****** ****** *)

implement
{a}(*tmp*)
funset_intersect
  (xs1, xs2) = let
//
implement
$FS.compare_elt_elt<a> = compare_elt_elt<a>
//
in
  $FS.funset_intersect (xs1, xs2)
end // end of [funset_intersect]

(* ****** ****** *)

implement
{a}(*tmp*)
funset_differ
  (xs1, xs2) = let
//
implement
$FS.compare_elt_elt<a> = compare_elt_elt<a>
//
in
  $FS.funset_differ (xs1, xs2)
end // end of [funset_differ]

(* ****** ****** *)

implement
{a}(*tmp*)
funset_symdiff
  (xs1, xs2) = let
//
implement
$FS.compare_elt_elt<a> = compare_elt_elt<a>
//
in
  $FS.funset_symdiff (xs1, xs2)
end // end of [funset_symdiff]

(* ****** ****** *)

implement
{a}(*tmp*)
funset_equal
  (xs1, xs2) = let
//
implement
$FS.compare_elt_elt<a> = compare_elt_elt<a>
//
in
  $FS.funset_equal (xs1, xs2)
end // end of [funset_equal]

(* ****** ****** *)

implement
{a}(*tmp*)
funset_compare
  (xs1, xs2) = let
//
implement
$FS.compare_elt_elt<a> = compare_elt_elt<a>
//
in
  $FS.funset_compare (xs1, xs2)
end // end of [funset_compare]

(* ****** ****** *)

implement
{a}(*tmp*)
funset_is_subset
  (xs1, xs2) = let
//
implement
$FS.compare_elt_elt<a> = compare_elt_elt<a>
//
in
  $FS.funset_is_subset (xs1, xs2)
end // end of [funset_is_subset]

implement
{a}(*tmp*)
funset_is_supset (xs1, xs2) = funset_is_subset (xs2, xs1)

(* ****** ****** *)

implement
{a}(*tmp*)
funset_foreach (xs) = let
//
var env: void = ((*void*))
//
in
  funset_foreach_env<a><void> (xs, env)
end // end of [funset_foreach]

implement
{a}{env}
funset_foreach_env (xs, env) = let
//
implement
$FS.funset_foreach$fwork<a><env>
  (x, env) = funset_foreach$fwork<a><env> (x, env)
//
in
  $FS.funset_foreach_env<a><env> (xs, env)
end // end of [funset_foreach_env]

implement
{a}(*tmp*)
funset_foreach_cloref
  (xs, fwork) = let
//
var env: void = ((*void*))
//
implement
(env)(*tmp*)
$FS.funset_foreach$fwork<a><env> (x, env) = fwork (x)
//
in
  $FS.funset_foreach_env<a><void> (xs, env)
end // end of [funset_foreach_cloref]

(* ****** ****** *)

implement
{a}(*tmp*)
funset_tabulate_cloref
  {n}(n, fopr) = let
//
implement
$FS.funset_tabulate$fopr<a> (i) = fopr($UN.cast{natLt(n)}(i))
//
in
  $FS.funset_tabulate<a> (n)
end // end of [funset_tabulate]

(* ****** ****** *)
//
implement
{a}(*tmp*)
funset_listize (xs) =
  ($effmask_wrt(list0_of_list_vt{a}($FS.funset_listize<a>(xs))))
//
(* ****** ****** *)

(* end of [funset.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: September, 2014 *)

(* ****** ****** *)

staload "libats/ML/SATS/basis.sats"

(* ****** ****** *)

staload "libats/ML/SATS/list0.sats"
staload "libats/ML/SATS/array0.sats"
staload "libats/ML/SATS/intrange.sats"

(* ****** ****** *)
//
implement
{}(*tmp*)
int_repeat_lazy
  (n, f) =
  int_repeat_cloref<> (n, lazy2cloref(f))
//
(* ****** ****** *)

implement
{}(*tmp*)
int_repeat_cloref
  (n, f) = let
//
fun
loop
(
  n: int, f: cfun0(void)
) : void = (
//
if n > 0
  then let val () = f () in loop (n-1, f) end
  else ()
//
) (* end of [loop] *)
//
in
  loop (n, f)
end // end of [int_repeat_cloref]

(* ****** ****** *)
//
implement
{}(*tmp*)
int_foreach_cloref
  (n, f) =
  intrange_foreach_cloref<> (0, n, f)
//
implement
{}(*tmp*)
int_foreach_method
  (n) = lam(f) => int_foreach_cloref (n, f)
//
(* ****** ****** *)
//
implement
{res}(*tmp*)
int_foldleft_cloref
  (n, ini, f) =
  intrange_foldleft_cloref<res> (0, n, ini, f)
//
implement
{res}(*tmp*)
int_foldleft_method
  (n, tres) =
  lam(ini, f) => int_foldleft_cloref (n, ini, f)
//
(* ****** ****** *)

implement
{}(*tmp*)
intrange_foreach_cloref
  (l, r, f) = let
//
fun
loop
(
  l: int, r: int, f: cfun1(int, void)
) : void = (
//
if l < r
  then let val () = f(l) in loop(l+1, r, f) end
  else ()
//
) (* end of [loop] *)
//
in
  loop (l, r, f)
end // end of [intrange_foreach_cloref]

(* ****** ****** *)

implement
{}(*tmp*)
intrange_foreach_method
  ( @(l, r) ) = lam(f) => intrange_foreach_cloref (l, r, f)
//
(* ****** ****** *)

implement
{res}(*tmp*)
intrange_foldleft_cloref
  (l, r, ini, fopr) = let
//
fun
loop
(
  l: int, r: int
, ini: res, f: cfun2(res, int, res)
) : res = (
//
if l < r then loop (l+1, r, f(ini, l), f) else ini
//
) (* end of [loop] *)
//
in
  loop (l, r, ini, fopr)
end // end of [intrange_foldleft_cloref]

(* ****** ****** *)
//
implement
{res}(*tmp*)
intrange_foldleft_method
  ( @(l, r), tres ) =
  lam(ini, f) => intrange_foldleft_cloref<res> (l, r, ini, f)
//
(* ****** ****** *)
//
implement
{a}(*tmp*)
int_list_map_cloref
  (n, f) = list0_tabulate<a> (n, f)
//
implement
{a}(*tmp*)
int_list_map_method
  (n, tres) = lam(f) => int_list_map_cloref<a> (n, f)
//
(* ****** ****** *)
//
implement
{a}(*tmp*)
int_array_map_cloref
  (n, f) = array0_tabulate<a> (i2sz(n), f)
//
implement
{a}(*tmp*)
int_array_map_method
  (n, tres) = lam(f) => int_array_map_cloref<a> (n, f)
//
(* ****** ****** *)
//
implement
{}(*tmp*)
int2_foreach_cloref
  (n1, n2, f) =
  intrange2_foreach_cloref<> (0, n1, 0, n2, f)
//
implement
{}(*tmp*)
intrange2_foreach_cloref
  (l1, r1, l2, r2, f) = let
//
fnx
loop1
(
  m1: int, r1: int
, l2: int, r2: int
, f: cfun2 (int, int, void)
) : void = (
//
if
m1 < r1
then loop2(m1, r1, l2, l2, r2, f)
else ()
//
) (* end of [loop1] *)
//
and
loop2
(
  m1: int, r1: int
, l2: int, m2: int, r2: int
, f: cfun2 (int, int, void)
) : void = (
//
if
m2 < r2
then (
//
f(m1, m2);
loop2(m1, r1, l2, m2+1, r2, f)
//
) (* end of [then] *)
else loop1(m1+1, r1, l2, r2, f)
//
) (* end of [loop2] *)
//
in
  loop1 (l1, r1, l2, r2, f)
end // end of [intrange2_foreach_cloref]
//
(* ****** ****** *)

(* end of [intrange.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmmhwxiATgmailDOTcom *)
(* Start time: July, 2013 *)

(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload "libats/ML/SATS/basis.sats"
staload "libats/ML/SATS/list0.sats"

(* ****** ****** *)

staload "libats/ML/SATS/monad_list.sats"

(* ****** ****** *)

#include "./SHARE/monad.hats"

(* ****** ****** *)

assume monad_type (a:t0p) = list0 (a)

(* ****** ****** *)

implement
{a}{b}
monad_bind (xs, f) = let
//
implement
list_map$fopr<a><list0(b)> (x) = f (x)
val xss = list_map<a><list0(b)> (g1ofg0(xs))
val res = list_concat<b> ($UN.castvwtp1{List(List(b))}(xss))
val ((*void*)) = list_vt_free<list0(b)> (xss)
//
in
  list0_of_list_vt (res)
end // end of [monad_bind]

(* ****** ****** *)

implement
{a1,a2}{b}
monad_bind2 (xs, ys, f) = let
//
implement
list_crosswith$fopr<a1,a2><list0(b)> (x, y) = f (x, y)
val xss =
  list_crosswith<a1,a2><list0(b)> (g1ofg0(xs), g1ofg0(ys))
val res = list_concat<b> ($UN.castvwtp1{List(List(b))}(xss))
val ((*void*)) = list_vt_free<list0(b)> (xss)
//
in
  list0_of_list_vt (res)
end // end of [monad_bind2]

(* ****** ****** *)

implement{a}
monad_return (x) = list0_cons{a}(x, list0_nil)

(* ****** ****** *)

implement{a} monad_list_list (xs) = (xs)

(* ****** ****** *)

implement{a} monad_list_listize (m) = (m)

(* ****** ****** *)
//
implement{a}
fprint_monad (out, m) = fprint_list0<a> (out, m)
//
(* ****** ****** *)

(* end of [monad_list.hats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: August, 2013 *)

(* ****** ****** *)
//
// HX-2012-12:
// the map implementation is based on AVL trees
//
(* ****** ****** *)
//
staload FM =
"libats/SATS/funmap_avltree.sats"
//
(* ****** ****** *)

staload "libats/ML/SATS/list0.sats"

(* ****** ****** *)

staload "libats/ML/SATS/funmap.sats"

(* ****** ****** *)
//
assume
map_type(key, itm) = $FM.map (key, itm)
//
(* ****** ****** *)

implement{a}
compare_key_key = gcompare_val_val<a>
implement{a}
$FM.compare_key_key = compare_key_key<a>

(* ****** ****** *)

implement
{}(*tmp*)
funmap_nil() = $FM.funmap_nil ()
implement
{}(*tmp*)
funmap_make_nil() = $FM.funmap_make_nil ()

(* ****** ****** *)

implement{}
funmap_is_nil(map) = $FM.funmap_is_nil (map)
implement{}
funmap_isnot_nil(map) = $FM.funmap_isnot_nil (map)

(* ****** ****** *)
//
implement
{key,itm}
funmap_size (map) = $FM.funmap_size (map)
//
(* ****** ****** *)
//
implement
{key,itm}
funmap_search
  (map, k) = $FM.funmap_search_opt (map, k)
//
(* ****** ****** *)
//
implement
{key,itm}
funmap_insert
  (map, k, x) = $FM.funmap_insert_opt (map, k, x)
//
(* ****** ****** *)
//
implement
{key,itm}
funmap_takeout
  (map, k) = $FM.funmap_takeout_opt (map, k)
//
(* ****** ****** *)
//
implement
{key,itm}
funmap_remove (map, k) = $FM.funmap_remove (map, k)
//
(* ****** ****** *)

implement
{key,itm}
fprint_funmap
  (out, map) = let
//
implement
$FM.fprint_funmap$sep<> = fprint_funmap$sep<>
implement
$FM.fprint_funmap$mapto<> = fprint_funmap$mapto<>
//
val () = $FM.fprint_funmap (out, map)
//
in
  // nothing
end // end of [fprint_funmap]

(* ****** ****** *)

implement{}
fprint_funmap$sep (out) = fprint (out, "; ")
implement{}
fprint_funmap$mapto (out) = fprint (out, "->")

(* ****** ****** *)

implement
{key,itm}
funmap_foreach_cloref
  (tbl, fwork) = () where
{
//
var env: void = ((*void*))
//
implement
(env)(*tmp*)
$FM.funmap_foreach$fwork<key,itm><env> (k, x, env) = fwork(k, x)
//
val ((*void*)) = $FM.funmap_foreach_env<key,itm><void> (tbl, env)
//
} (* end of [funmap_foreach_cloref] *)

(* ****** ****** *)

implement
{key,itm}
funmap_listize
  (map) = let
  val xs = $effmask_wrt ($FM.funmap_listize (map))
in
  list0_of_list_vt (xs)
end // end of [funmap_listize]

(* ****** ****** *)

(* end of [funmap.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: September, 2013 *)

(* ****** ****** *)

#define ATS_DYNLOADFLAG 0
  
(* ****** ****** *)

staload UN = "prelude/SATS/unsafe.sats"

(* ****** ****** *)

staload _(*INT*) = "prelude/DATS/integer.dats"
staload _(*STRING*) = "prelude/DATS/string.dats"
staload _(*STRING*) = "prelude/DATS/strptr.dats"
staload _(*UNSAFE*) = "prelude/DATS/unsafe.dats"

(* ****** ****** *)
//
staload "libats/ML/SATS/basis.sats"
staload "libats/ML/SATS/list0.sats"
staload "libats/ML/SATS/string.sats"
//
staload "libats/ML/SATS/filebas.sats"
//
(* ****** ****** *)

staload DIR = "libc/SATS/dirent.sats"
staload _(*anon*) = "libc/DATS/dirent.dats"

(* ****** ****** *)

staload QUE = "libats/SATS/qlist.sats"
staload _(*anon*) = "libats/DATS/qlist.dats"

(* ****** ****** *)

stadef dirent = $DIR.dirent
stadef DIRptr1 = $DIR.DIRptr1
stadef qstruct0 = $QUE.qstruct0

(* ****** ****** *)

implement
dirname_get_fnamelst
  (dirname) = let
//
vtypedef res = $QUE.qstruct0 (string)
//
fun loop
(
  dirp: !DIRptr1, res: &res >> _
) : void = let
//
var ent: dirent?
var result: ptr?
//
val err = $DIR.readdir_r (dirp, ent, result)
//
in
//
if result > 0 then let
  prval () = opt_unsome{dirent}(ent)
  val d_name = $DIR.dirent_get_d_name_gc (ent)
  val () = $QUE.qstruct_insert (res, strptr2string(d_name))
in
  loop (dirp, res)
end else let
  prval () = opt_unnone{dirent}(ent)
in
  // nothing
end // end of [if]
//
end // end of [loop]
//
val dirp = $DIR.opendir (dirname)
//
in
//
if $DIR.DIRptr2ptr(dirp) > 0 then let
  var res: $QUE.qstruct
  val () = $QUE.qstruct_initize{string}(res)
  val () = loop (dirp, res)
  val res2 = $QUE.qstruct_takeout_list (res)
  prval () = $QUE.qstruct_uninitize{string}(res)
  val () = $DIR.closedir_exn (dirp)
in
  g0ofg1_list_vt (res2)  
end else let
  prval () = $DIR.DIRptr_free_null (dirp)
in
  list0_nil(*void*)
end // end of [if]
//
end // end of [dirname_get_fnamelst]

(* ****** ****** *)

(* end of [dirent.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmmhwxiATgmailDOTcom *)
(* Start time: July, 2013 *)

(* ****** ****** *)
//
// HX: shared by monad_list
// HX: shared by monad_maybe
//
(* ****** ****** *)

implement{}
monad_unit () = monad_return<unit> (unit)

(* ****** ****** *)

implement{a}
monad_nil ((*void*)) =
  monad_return<list0(a)> (list0_nil{a}())
// end of [monad_nil]

implement{a}
monad_cons (m, ms) =
  monad_liftm2<a,list0(a)><list0(a)> (lam (x, xs) => list0_cons{a}(x, xs), m, ms)
// end of [monad_cons]

(* ****** ****** *)

implement
{a1,a2}
monad_seq (m1, m2) = monad_bind<a1><a2> (m1, lam _ => m2)

(* ****** ****** *)

implement
{a}(*tmp*)
monad_join (mm) = monad_bind<monad(a)><a> (mm, lam m => m)

(* ****** ****** *)

implement
{a}{b}
monad_fmap (f, m) =
  monad_bind<a><b> (m, lam x => monad_return<b> (f(x)))
// end of [monad_fmap]

(* ****** ****** *)

implement
{a}{b}
monad_liftm (f, m) =
  monad_bind<a><b> (m, lam x => monad_return<b> (f(x)))
// end of [monad_liftm]

(* ****** ****** *)

implement
{a1,a2}{b}
monad_liftm2
  (f, m1, m2) =
(
  monad_bind2<a1,a2><b>
    (m1, m2, lam (x1, x2) => monad_return<b> (f(x1, x2)))
) // end of [monad_liftm2]

implement
{a1,a2,a3}{b}
monad_liftm3
  (f, m1, m2, m3) =
(
  monad_bind3<a1,a2,a3><b>
    (m1, m2, m3, lam (x1, x2, x3) => monad_return<b> (f(x1, x2, x3)))
) // end of [monad_liftm3]

(* ****** ****** *)

implement
{a}{b}
monad_mapm (f, ms) = let
in
//
case+ ms of
| list0_cons
    (m, ms) => let
    val m = monad_fmap (f, m)
    val ms = monad_mapm (f, ms)
  in
    monad_cons<b> (m, ms)
  end // list0_cons
| list0_nil () => monad_nil<b> ()
//
end // end of [monad_mapm]

(* ****** ****** *)

implement
{a}{b}
monad_mapm_ (f, xs) = let
in
//
case+ xs of
| list0_cons
    (x, xs) => let
    val m = f (x)
    val mu = monad_mapm_ (f, xs)
  in
    monad_seq (m, mu)
  end // end of [list0_cons]
| list0_nil () => monad_unit ()
//
end // end of [monad_mapm_]

(* ****** ****** *)

implement
{a}(*tmp*)
monad_seqlist (ms) = monad_mapm<a><a> (lam x => x, ms)
implement
{a}(*tmp*)
monad_seqlist_ (ms) = monad_mapm_<monad(a)><a> (lam m => m, ms)

(* ****** ****** *)

(* end of [monad.hats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2015 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: March, 2015 *)

(* ****** ****** *)
//
// HX-2015-03-12:
// For quickly building a hashmap interface
//
(* ****** ****** *)
//
(*
typedef key = int/string
typedef itm = int/string/...
*)
//
(* ****** ****** *)
//
abstype
myhashtbl_type = ptr
//
typedef
myhashtbl = myhashtbl_type
//
(* ****** ****** *)
//
extern
fun
myhashtbl_make_nil
  (cap: intGte(1)): myhashtbl
//
(* ****** ****** *)
//
extern
fun
myhashtbl_get_size(myhashtbl): intGte(0)
//
overload .size with myhashtbl_get_size
overload .get_size with myhashtbl_get_size
//
extern
fun
myhashtbl_get_capacity(myhashtbl): intGte(1)
//
overload .capacity with myhashtbl_get_capacity
overload .get_capacity with myhashtbl_get_capacity
//
(* ****** ****** *)
//
extern
fun
myhashtbl_search
  (myhashtbl, key): Option_vt(itm)
//
overload .search with myhashtbl_search
//
extern
fun
myhashtbl_search_ref
  (tbl: myhashtbl, k: key): cPtr0(itm)
//
overload .search_ref with myhashtbl_search_ref
//
(* ****** ****** *)
//
extern
fun
myhashtbl_insert
  (myhashtbl, key, itm): Option_vt(itm)
//
overload .insert with myhashtbl_insert
//
extern
fun
myhashtbl_insert_any
  (tbl: myhashtbl, k: key, x: itm): void
//
overload .insert_any with myhashtbl_insert_any
//
(* ****** ****** *)
//
extern
fun
myhashtbl_remove
  (myhashtbl, k: key): bool
//
overload .remove with myhashtbl_remove
//
extern
fun
myhashtbl_takeout
  (myhashtbl, k: key): Option_vt(itm)
//
overload .takeout with myhashtbl_takeout
//
(* ****** ****** *)
//
extern
fun
myhashtbl_takeout_all
  (tbl: myhashtbl): List0 @(key, itm)
//
overload .takeout_all with myhashtbl_takeout_all
//
(* ****** ****** *)
//
extern
fun
fprint_myhashtbl
  (out: FILEref, myhashtbl): void
//
overload fprint with fprint_myhashtbl
//
(* ****** ****** *)
//
extern
fun
myhashtbl_foreach_cloref
(
  tbl: myhashtbl
, fwork: (key, &(itm) >> _) -<cloref1> void
) : void // end-of-function
//
extern
fun
myhashtbl_foreach_method
(
  tbl: myhashtbl
) (fwork: (key, &(itm) >> _) -<cloref1> void): void
//
overload .foreach with myhashtbl_foreach_method
//
(* ****** ****** *)
//
extern
fun
myhashtbl_listize1
  (tbl: myhashtbl): List0 @(key, itm)
//
overload .listize1 with myhashtbl_listize1
//
(* ****** ****** *)

local
//
staload "libats/ML/SATS/basis.sats"
staload "libats/ML/SATS/list0.sats"
staload "libats/ML/SATS/hashtblref.sats"
//
staload _(*anon*) = "libats/DATS/qlist.dats"
//
staload _(*anon*) = "libats/DATS/hashfun.dats"
staload _(*anon*) = "libats/DATS/linmap_list.dats"
staload _(*anon*) = "libats/DATS/hashtbl_chain.dats"
staload _(*anon*) = "libats/ML/DATS/hashtblref.dats"
//
assume
myhashtbl_type = hashtbl_type(key, itm)
//
in (* in-of-local *)
//
macdef sz2n(sz) = sz2i(g1ofg0(,(sz)))
//
implement
myhashtbl_make_nil(cap) =
  hashtbl_make_nil<key,itm>(i2sz(cap))
//
(* ****** ****** *)
//
implement
myhashtbl_get_size
  (tbl) = sz2n(hashtbl_get_size<>(tbl))
implement
myhashtbl_get_capacity
  (tbl) = sz2i(hashtbl_get_capacity<>(tbl))
//
(* ****** ****** *)
//
implement
myhashtbl_search
  (tbl, k) = hashtbl_search<key,itm>(tbl, k)
implement
myhashtbl_search_ref
  (tbl, k) = hashtbl_search_ref<key,itm>(tbl, k)
//
(* ****** ****** *)
//
implement
myhashtbl_insert
  (tbl, k, x) = hashtbl_insert<key,itm>(tbl, k, x)
implement
myhashtbl_insert_any
  (tbl, k, x) = hashtbl_insert_any<key,itm>(tbl, k, x)
//
(* ****** ****** *)
//
implement
myhashtbl_remove
  (tbl, k) = hashtbl_remove<key,itm>(tbl, k)
implement
myhashtbl_takeout
  (tbl, k) = hashtbl_takeout<key,itm>(tbl, k)
//
implement
myhashtbl_takeout_all
  (tbl) =
(
  g1ofg0_list(hashtbl_takeout_all<key,itm>(tbl))
) (* myhashtbl_takeout_all *)
//
(* ****** ****** *)
//
implement
fprint_myhashtbl
  (out, tbl) = fprint_hashtbl<key,itm>(out, tbl)
//
(* ****** ****** *)
//
implement
myhashtbl_foreach_cloref
  (tbl, fwork) =
  hashtbl_foreach_cloref<key,itm>(tbl, fwork)
implement
myhashtbl_foreach_method(tbl) =
(
  lam(fwork) => myhashtbl_foreach_cloref(tbl, fwork)  
) (* myhashtbl_foreach_method *)
//
(* ****** ****** *)
//
implement
myhashtbl_listize1
  (tbl) = g1ofg0_list(hashtbl_listize1<key,itm>(tbl))
//
end // end of [local]

(* ****** ****** *)

(* end of [myhashtblref.hats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2015 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: March, 2015 *)

(* ****** ****** *)
//
// HX-2015-03-14:
// For quickly building a funset interface
//
(* ****** ****** *)
//
(*
typedef elt = int/...
*)
//
(* ****** ****** *)
//
abstype
myset_type = ptr
//
typedef
myset = myset_type
//
(* ****** ****** *)

extern
fun
myfunset_nil():<> myset
and
myfunset_make_nil():<> myset

(* ****** ****** *)

extern
fun
myfunset_sing(elt): myset
and
myfunset_make_sing(elt): myset

(* ****** ****** *)

extern
fun
myfunset_make_list(List(elt)): myset

(* ****** ****** *)
//
extern
fun
fprint_myfunset
  (out: FILEref, xs: myset): void
//
overload fprint with fprint_myfunset
//
(* ****** ****** *)
//
extern
fun
myfunset_size(myset): size_t
//
overload .size with myfunset_size
//
(* ****** ****** *)
//
extern
fun
myfunset_is_member(myset, elt): bool
and
myfunset_isnot_member(myset, elt): bool
//
overload is_member with myfunset_is_member
overload isnot_member with myfunset_isnot_member
//
overload .is_member with myfunset_is_member
overload .isnot_member with myfunset_isnot_member
//
(* ****** ****** *)
//
extern
fun
myfunset_insert
  (xs: &myset >> _, x0: elt): bool
//
overload .insert with myfunset_insert
//
(* ****** ****** *)
//
extern
fun
myfunset_remove
  (xs: &myset >> _, x0: elt): bool
//
overload .remove with myfunset_remove
//
(* ****** ****** *)
//
extern
fun
myfunset_union(myset, myset): myset
and
myfunset_union2(&myset >> _, myset): void
//
overload union with myfunset_union
overload .union with myfunset_union2
//
extern
fun
myfunset_intersect(myset, myset): myset
and
myfunset_intersect2(&myset >> _, myset): void
//
overload intersect with myfunset_intersect
overload .intersect with myfunset_intersect2
//
(* ****** ****** *)
//
extern
fun
myfunset_differ
  (xs: myset, ys: myset): myset
and
myfunset_differ2
  (xs: &myset >> _, ys: myset): void
//
overload differ with myfunset_differ
overload .differ with myfunset_differ2
//
extern
fun
myfunset_symdiff
  (xs: myset, ys: myset): myset
and
myfunset_symdiff2
  (xs: &myset >> _, ys: myset): void
//
overload symdiff with myfunset_symdiff
overload .symdiff with myfunset_symdiff2
//
(* ****** ****** *)
//
extern
fun
myfunset_equal(myset, myset): bool
and
myfunset_notequal(myset, myset): bool
//
overload = with myfunset_equal
overload != with myfunset_notequal
//
(* ****** ****** *)
//
extern
fun
myfunset_compare(myset, myset): int
//
overload compare with myfunset_compare
//
(* ****** ****** *)
//
extern
fun
myfunset_is_subset(myset, myset): bool
and
myfunset_is_supset(myset, myset): bool
//
(* ****** ****** *)
//
overload is_subset with myfunset_is_subset
overload is_supset with myfunset_is_supset
//
overload .is_subset with myfunset_is_subset
overload .is_supset with myfunset_is_supset
//
(* ****** ****** *)
//
extern
fun
myfunset_foreach_cloref
  (myset, fwork: (elt) -<cloref1> void): void
//
extern
fun
myfunset_foreach_method
  (myset) (fwork: (elt) -<cloref1> void): void
//
overload .foreach with myfunset_foreach_method
//
(* ****** ****** *)
//
extern
fun
{res:t@ype}
myfunset_foldleft_cloref
(
  xs: myset
, ini: res, fopr: (res, elt) -<cloref1> res
) : res // end of [myfunset_foldleft_cloref]
//
extern
fun
{res:t@ype}
myfunset_foldleft_method
(
  myset, TYPE(res)
) (ini: res, fopr: (res, elt) -<cloref1> res): res
//
overload .foldleft with myfunset_foldleft_method
//
(* ****** ****** *)
//
extern
fun
myfunset_tabulate_cloref
  {n:nat}
(
  n: int(n), fopr: (natLt(n)) -<cloref1> elt
) : myset // end of [myfunset_tabulate_cloref]
//
extern
fun
myfunset_tabulate_method
  {n:nat}
  (n: int(n)) (fopr: (natLt(n)) -<cloref1> elt): myset
//
overload .tabulate with myfunset_tabulate_method
//
(* ****** ****** *)
//
extern
fun
myfunset_listize(myset): List0(elt)
//
overload listize with myfunset_listize
overload .listize with myfunset_listize
//
(* ****** ****** *)

local
//
staload
UN = "prelude/SATS/unsafe.sats"
//
staload "libats/ML/SATS/basis.sats"
staload "libats/ML/SATS/list0.sats"
staload "libats/ML/SATS/funset.sats"
//
staload _ = "libats/DATS/funset_avltree.dats"
//
staload _(*anon*) = "libats/ML/DATS/funset.dats"
//
assume myset_type = set_type(elt)
//
in (* in-of-local *)

(* ****** ****** *)
//
implement
myfunset_nil() = funset_make_nil{elt}()
implement
myfunset_make_nil() = funset_make_nil{elt}()
//
implement
myfunset_sing
  (x) = funset_make_sing<elt>(x)
implement
myfunset_make_sing
  (x) = funset_make_sing<elt>(x)
//
implement
myfunset_make_list
  (xs) = funset_make_list<elt>(g0ofg1(xs))
//
(* ****** ****** *)
//
implement
fprint_myfunset
  (out, xs) = fprint_funset<elt>(out, xs)
//
(* ****** ****** *)
//
implement
myfunset_size(xs) = funset_size<elt>(xs)
//
(* ****** ****** *)
//
implement
myfunset_is_member
  (xs, x0) = funset_is_member<elt>(xs, x0)
implement
myfunset_isnot_member
  (xs, x0) = funset_isnot_member<elt>(xs, x0)
//
(* ****** ****** *)
//
implement
myfunset_insert
  (xs, x0) = funset_insert<elt>(xs, x0)
//
implement
myfunset_remove
  (xs, x0) = funset_remove<elt>(xs, x0)
//
(* ****** ****** *)
//
implement
myfunset_union
  (xs, ys) = funset_union<elt>(xs, ys)
implement
myfunset_union2
  (xs, ys) = (xs := funset_union<elt>(xs, ys))
implement
myfunset_intersect
  (xs, ys) = funset_intersect<elt>(xs, ys)
implement
myfunset_intersect2
  (xs, ys) = (xs := funset_intersect<elt>(xs, ys))
//
(* ****** ****** *)
//
implement
myfunset_differ
  (xs, ys) = funset_differ<elt>(xs, ys)
implement
myfunset_differ2
  (xs, ys) = (xs := funset_differ<elt>(xs, ys))
implement
myfunset_symdiff
  (xs, ys) = funset_symdiff<elt>(xs, ys)
implement
myfunset_symdiff2
  (xs, ys) = (xs := funset_symdiff<elt>(xs, ys))
//
(* ****** ****** *)
//
implement
myfunset_equal
  (xs, ys) = funset_equal<elt>(xs, ys)
implement
myfunset_notequal
  (xs, ys) = ~(funset_equal<elt>(xs, ys))
//
implement
myfunset_compare
  (xs, ys) = funset_compare<elt>(xs, ys)
//
(* ****** ****** *)
//
implement
myfunset_is_subset
  (xs, ys) = funset_is_subset<elt>(xs, ys)
implement
myfunset_is_supset
  (xs, ys) = funset_is_supset<elt>(xs, ys)
//
(* ****** ****** *)
//
implement
myfunset_foreach_cloref
(
  xs, fwork
) = funset_foreach_cloref<elt>(xs, fwork)
//
implement
myfunset_foreach_method
  (xs) =
(
  lam (fwork) => myfunset_foreach_cloref(xs, fwork)
) (* myfunset_foreach_method *)
//
(* ****** ****** *)

implement
{res}(*tmp*)
myfunset_foldleft_cloref
  (xs0, ini, fopr) = r0 where
{
//
var r0
  : res = ini
//
val p_r0 = addr@r0
//
val ((*void*)) =
myfunset_foreach_cloref
(
  xs0
, lam(x) =>
  $UN.ptr0_set<res>
  (p_r0, fopr($UN.ptr0_get<res>(p_r0), x))
  // end of [lam]
) (* end of [myfunset_foreach_cloref] *)
//
} (* end of [myfunset_foldleft_cloref] *)
//
(* ****** ****** *)
//
implement
{res}(*tmp*)
myfunset_foldleft_method
  (xs0, tres) =
  lam (int, fopr) =>
  myfunset_foldleft_cloref<res> (xs0, int, fopr)
//
(* ****** ****** *)
//
implement
myfunset_tabulate_cloref
  (n, fopr) = funset_tabulate_cloref<elt>(n, fopr)
//
implement
myfunset_tabulate_method
  (n) = lam(fopr) => myfunset_tabulate_cloref(n, fopr)
//
(* ****** ****** *)
//
implement
myfunset_listize
  (xs) = g1ofg0_list(funset_listize<elt>(xs))
//
(* ****** ****** *)

end // end of [local]

(* ****** ****** *)

(* end of [myfunset.hats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2015 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: March, 2015 *)

(* ****** ****** *)
//
// HX-2015-03-15:
// For quickly building a funmap interface
//
(* ****** ****** *)
//
(*
typedef key = int/string
typedef itm = int/string/...
*)
//
(* ****** ****** *)
//
abstype
mymap_type = ptr
//
typedef
mymap = mymap_type
//
(* ****** ****** *)
//
extern
fun
myfunmap_nil():<> mymap
and
myfunmap_make_nil():<> mymap
//
(* ****** ****** *)
//
extern
fun
myfunmap_is_nil(mymap):<> bool
and
myfunmap_isnot_nil(mymap):<> bool
//
overload .is_nil with myfunmap_is_nil
overload .isnot_nil with myfunmap_isnot_nil
//
(* ****** ****** *)
//
extern
fun
myfunmap_size(mymap): size_t
//
overload .size with myfunmap_size
//
(* ****** ****** *)
//
extern
fun
myfunmap_search
  (mymap, key): Option_vt(itm)
//
overload .search with myfunmap_search
//
(* ****** ****** *)
//
extern
fun
myfunmap_insert
  (&mymap >> _, key, itm): Option_vt(itm)
//
overload .insert with myfunmap_insert
//
(* ****** ****** *)
//
extern
fun
myfunmap_remove
  (&mymap >> _, k: key): bool
//
overload .remove with myfunmap_remove
//
extern
fun
myfunmap_takeout
  (&mymap >> _, k: key): Option_vt(itm)
//
overload .takeout with myfunmap_takeout
//
(* ****** ****** *)
//
extern
fun
fprint_myfunmap
  (out: FILEref, mymap): void
//
overload fprint with fprint_myfunmap
//
(* ****** ****** *)
//
extern
fun
myfunmap_foreach_cloref
(
  mymap, fwork: (key, itm) -<cloref1> void
) : void // end-of-function
//
extern
fun
myfunmap_foreach_method
  (mymap)
  (fwork: (key, itm) -<cloref1> void): void
//
overload .foreach with myfunmap_foreach_method
//
(* ****** ****** *)
//
extern
fun
myfunmap_listize
  (map: mymap): List0 @(key, itm)
//
overload .listize with myfunmap_listize
//
(* ****** ****** *)

local
//
staload
UN = "prelude/SATS/unsafe.sats"
//
staload "libats/ML/SATS/basis.sats"
staload "libats/ML/SATS/list0.sats"
staload "libats/ML/SATS/funmap.sats"
//
staload _ = "libats/DATS/qlist.dats"
//
staload _ = "libats/DATS/funmap_avltree.dats"
//
staload _(*anon*) = "libats/ML/DATS/funmap.dats"
//
assume mymap_type = map_type(key, itm)
//
in (* in-of-local *)
//
implement
myfunmap_nil() = funmap_nil{key,itm}()
implement
myfunmap_make_nil() = funmap_make_nil{key,itm}()
//
implement
myfunmap_size(map) = funmap_size<key,itm>(map)
//
implement
myfunmap_search
  (map, k) = funmap_search<key,itm>(map, k)
//
implement
myfunmap_insert
  (map, k, x) = funmap_insert<key,itm>(map, k, x)
//
implement
myfunmap_remove
  (map, k) = funmap_remove<key,itm>(map, k)
implement
myfunmap_takeout
  (map, k) = funmap_takeout<key,itm>(map, k)
//
implement
fprint_myfunmap
  (out, map) = fprint_funmap<key,itm>(out, map)
//
implement
myfunmap_foreach_cloref
  (map, fwork) =
  funmap_foreach_cloref<key,itm>(map, fwork)
implement
myfunmap_foreach_method
  (map) =
(
  lam(fwork) => myfunmap_foreach_cloref(map, fwork)
) (* myfunmap_foreach_method *)
//
implement
myfunmap_listize
  (map) = g1ofg0_list(funmap_listize<key,itm>(map))
//
end // end of [local]

(* ****** ****** *)

(* end of [myfunmap.hats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: August, 2013 *)

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.ML"
#define ATS_EXTERN_PREFIX "atslib_ML_" // prefix for external names

(* ****** ****** *)

staload "./basis.sats"

(* ****** ****** *)

#include "./SHARE/monad.hats"

(* ****** ****** *)

fun{a:t0p}
monad_list_list (xs: list0 (INV(a))): monad (a)

(* ****** ****** *)

fun{a:t0p}
monad_list_listize (m: monad (INV(a))): list0 (a)

(* ****** ****** *)
//
fun{a:t0p}
fprint_monad (out: FILEref, m: monad (INV(a))): void
overload fprint with fprint_monad
//
(* ****** ****** *)

(* end of [monad_list.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// For supporting ML-style of functional programming
//
(* ****** ****** *)
//
// Author of the file: Hongwei Xi (gmhwxiATgmailDOTcom)
// Start Time: June, 2012
//
(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats"

(* ****** ****** *)
//
typedef
cfun0(b:vt0p) = ((*void*)) -<cloref1> b
typedef
cfun1(a:vt0p, b:vt0p) = (a) -<cloref1> b
typedef
cfun2(a1:vt0p, a2:vt0p, b:vt0p) = (a1, a2) -<cloref1> b
//
(* ****** ****** *)
//
typedef
cfun3 (
  a1:vt0p, a2:vt0p, a3:vt0p, b:vt0p
) = (a1, a2, a3) -<cloref1> b
typedef
cfun4 (
  a1:vt0p, a2:vt0p, a3:vt0p, a4:vt0p, b:vt0p
) = (a1, a2, a3, a4) -<cloref1> b
typedef
cfun5 (
  a1:vt0p, a2:vt0p, a3:vt0p, a4:vt0p, a5:vt0p, b:vt0p
) = (a1, a2, a3, a4, a5) -<cloref1> b
typedef
cfun6 (
  a1:vt0p, a2:vt0p, a3:vt0p, a4:vt0p, a5:vt0p, a6:vt0p, b:vt0p
) = (a1, a2, a3, a4, a5, a6) -<cloref1> b
typedef
cfun7 (
  a1:vt0p, a2:vt0p, a3:vt0p, a4:vt0p, a5:vt0p, a6:vt0p, a7:vt0p, b:vt0p
) = (a1, a2, a3, a4, a5, a6, a7) -<cloref1> b
typedef
cfun8 (
  a1:vt0p, a2:vt0p, a3:vt0p, a4:vt0p, a5:vt0p, a6:vt0p, a7:vt0p, a8:vt0p, b:vt0p
) = (a1, a2, a3, a4, a5, a6, a7, a8) -<cloref1> b
typedef
cfun9 (
  a1:vt0p, a2:vt0p, a3:vt0p, a4:vt0p, a5:vt0p, a6:vt0p, a7:vt0p, a8:vt0p, a9:vt0p, b:vt0p
) = (a1, a2, a3, a4, a5, a6, a7, a8, a9) -<cloref1> b
//
(* ****** ****** *)

stadef cfun = cfun0
stadef cfun = cfun1
stadef cfun = cfun2
stadef cfun = cfun3
stadef cfun = cfun4
stadef cfun = cfun5
stadef cfun = cfun6
stadef cfun = cfun7
stadef cfun = cfun8
stadef cfun = cfun9

(* ****** ****** *)

datatype // t@ype+: covariant
list0_t0ype_type (a: t@ype+) =
  | list0_nil of () | list0_cons of (a, list0_t0ype_type a)
stadef list0 = list0_t0ype_type

#define nil0 list0_nil
#define cons0 list0_cons

(* ****** ****** *)

datatype // t@ype+: covariant
option0_t0ype_type
  (a: t@ype+) = Some0 of (a) | None0 of ()
stadef option0 = option0_t0ype_type

(* ****** ****** *)
//
abstype
array0_vt0ype_type
  (a: vt@ype(*invariant*)) = ptr
stadef array0 = array0_vt0ype_type
(*
abstype
subarray0_vt0ype_type
  (a: vt@ype(*invariant*)) = ptr
stadef subarray0 = subarray0_vt0ype_type
*)
//
(* ****** ****** *)
//
abstype
matrix0_vt0ype_type
  (a: vt@ype(*invariant*)) = ptr
stadef matrix0 = matrix0_vt0ype_type
//
(* ****** ****** *)
//
abstype strarr_type = ptr
typedef strarr = strarr_type
(*
abstype substrarr_type = ptr
typedef substrarr = substrarr_type
*)
//
(* ****** ****** *)

(* end of [basis.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmmhwxiATgmailDOTcom *)
(* Start time: February, 2013 *)

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.ML"
#define ATS_EXTERN_PREFIX "atslib_ML_" // prefix for external names

(* ****** ****** *)

%{#
#include "libats/ML/CATS/strarr.cats"
%} // end of [%{#]

(* ****** ****** *)

staload "libats/ML/SATS/basis.sats"

(* ****** ****** *)

typedef SHR(a:type) = a // for commenting purpose
typedef NSH(a:type) = a // for commenting purpose

(* ****** ****** *)
//
// HX-2013-02:
// a strarr-value is represented an array of character;
// in principle, this array should be treated as read-only.
//
(* ****** ****** *)

#if(0)
//
// HX: in [basis.sats]
//
abstype strarr_type = ptr
typedef strarr = strarr_type
//
#endif

(* ****** ****** *)

castfn array2strarr (cs: array0 (char)):<> strarr
castfn strarr2array (cs: strarr):<> array0 (char)

(* ****** ****** *)

fun{}
strarr_get_ref (str: strarr):<> Ptr1
fun{}
strarr_get_size (str: strarr):<> size_t

fun{}
strarr_get_refsize
  (A: strarr):<> [n:nat] (arrayref (char, n), size_t (n))
// end of [strarr_get_refsize]

(* ****** ****** *)
//
fun
strarr_make_string (str: string):<!wrt> strarr
//
fun strarr_make_substring
  (string, st: size_t, ln: size_t):<!wrt> strarr
//
symintr strarr_make
overload strarr_make with strarr_make_string
overload strarr_make with strarr_make_substring
//
(* ****** ****** *)
//
// HX-2013:
// naming convention: xxx_imake_yyy -> yyy_make_xxx
//
fun strarr_imake_string (str: strarr):<!wrt> string
//
(* ****** ****** *)

fun{}
strarr_is_empty (strarr):<> bool
overload iseqz with strarr_is_empty

fun{}
strarr_isnot_empty (strarr):<> bool
overload isneqz with strarr_isnot_empty

(* ****** ****** *)
//
fun{tk:tk}
strarr_get_at_gint
  (str: strarr, i: g0int(tk)):<!exn> char
fun{tk:tk}
strarr_get_at_guint
  (str: strarr, i: g0uint(tk)):<!exn> char
//
symintr strarr_get_at
//
overload [] with strarr_get_at_gint of 0
overload strarr_get_at with strarr_get_at_gint of 0
overload [] with strarr_get_at_guint of 0
overload strarr_get_at with strarr_get_at_guint of 0
//
(* ****** ****** *)

fun strarr_get_range
  (strarr, i0: size_t, i1: size_t): string
// end of [strarr_get_range]

(* ****** ****** *)

fun lt_strarr_strarr
  (str1: strarr, str2: strarr):<> bool
overload < with lt_strarr_strarr
fun lte_strarr_strarr
  (str1: strarr, str2: strarr):<> bool
overload <= with lte_strarr_strarr

fun gt_strarr_strarr
  (str1: strarr, str2: strarr):<> bool
overload > with gt_strarr_strarr
fun gte_strarr_strarr
  (str1: strarr, str2: strarr):<> bool
overload >= with gte_strarr_strarr

fun eq_strarr_strarr
  (str1: strarr, str2: strarr):<> bool
overload = with eq_strarr_strarr
fun neq_strarr_strarr
  (str1: strarr, str2: strarr):<> bool
overload != with neq_strarr_strarr
overload <> with neq_strarr_strarr

(* ****** ****** *)

fun
strarr_compare
  (str1: strarr, str2: strarr):<> int
overload compare with strarr_compare

(* ****** ****** *)
//
fun
strarr_length (strarr):<> size_t
//
overload length with strarr_length
//
(* ****** ****** *)
//
fun print_strarr (str: strarr): void
fun prerr_strarr (str: strarr): void
//
overload print with print_strarr
overload prerr with prerr_strarr
//
fun
fprint_strarr (out: FILEref, str: strarr): void
//
overload fprint with fprint_strarr
//
(* ****** ****** *)

fun strarr_contains (str: strarr, c: char):<> bool

(* ****** ****** *)

fun strarr_copy (str: strarr):<!wrt> strarr

(* ****** ****** *)

fun strarr_append
  (str1: strarr, str2: strarr):<!wrt> strarr
overload + with strarr_append

(* ****** ****** *)
//
fun strarr_tabulate
  (n: size_t, f: cfun (size_t, char)): strarr
//
(* ****** ****** *)
//
fun strarr_foreach (str: strarr, f: cfun (char, void)): void
fun strarr_iforeach (str: strarr, f: cfun2 (size_t, char, void)): void
fun strarr_rforeach (str: strarr, f: cfun (char, void)): void
//
(* ****** ****** *)

(* end of [strarr.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: June, 2013 *)

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.ML"
#define ATS_EXTERN_PREFIX "atslib_ML_" // prefix for external names

(* ****** ****** *)

staload "libats/ML/SATS/basis.sats"

(* ****** ****** *)

typedef SHR(a:type) = a // for commenting purpose
typedef NSH(a:type) = a // for commenting purpose

(* ****** ****** *)

fun{} getenv_exn (name: NSH(string)): string
fun{} getenv_opt (name: NSH(string)): option0 (string)

(* ****** ****** *)

fun{} setenv_exn
  (name: NSH(string), value: NSH(string), overwrite: int): void
fun{} setenv_err
  (name: NSH(string), value: NSH(string), overwrite: int): int(*err*)

(* ****** ****** *)

(* end of [stdlib.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2014 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)
(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom*)
(* Start time: September, 2014 *)

(* ****** ****** *)
//
// HX-2013-04:
// intrange (l, r) is for integers i satisfying l <= i < r
//
(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.ML"
#define ATS_EXTERN_PREFIX "atslib_ML_" // prefix for external names

(* ****** ****** *)

staload "libats/ML/SATS/basis.sats"

(* ****** ****** *)
//
fun{}
int_repeat_lazy
  (n: int, f: lazy (void)): void
fun{}
int_repeat_cloref
  (n: int, f: cfun0 (void)): void
//
overload repeat with int_repeat_lazy
overload repeat with int_repeat_cloref
overload .repeat with int_repeat_cloref
//
(* ****** ****** *)
//
fun{}
int_foreach_cloref
  (n: int, f: cfun1 (int, void)): void
fun{}
int_foreach_method
  (n: int) (f: cfun1 (int, void)): void
//
overload .foreach with int_foreach_method
//
(* ****** ****** *)
//
fun{res:vt0p}
int_foldleft_cloref
  (n: int, ini: res, f: cfun2 (res, int, res)): res
//
fun{res:vt0p}
int_foldleft_method
  (int, TYPE(res))(ini: res, f: cfun2 (res, int, res)): res
//
overload .foldleft with int_foldleft_method
//
(* ****** ****** *)
//
fun{}
intrange_foreach_cloref
  (l: int, r: int, f: cfun1 (int, void)): void
fun{}
intrange_foreach_method
  (lr: @(int, int)) (f: cfun1 (int, void)): void
//
overload .foreach with intrange_foreach_method
//
(* ****** ****** *)
//
fun{res:vt0p}
intrange_foldleft_cloref
  (l: int, r: int, ini: res, f: cfun2 (res, int, res)): res
//
fun{res:vt0p}
intrange_foldleft_method
  ((int, int), TYPE(res))(ini: res, f: cfun2 (res, int, res)): res
//
overload .foldleft with intrange_foldleft_method
//
(* ****** ****** *)
//
fun{a:t0p}
int_list_map_cloref
  (n: intGte(0), f: cfun(int, a)): list0(a)
fun{a:t0p}
int_list_map_method
  (n: intGte(0), TYPE(a))(f: cfun(int, a)): list0(a)
//
overload .list_map with int_list_map_method
//
(* ****** ****** *)
//
fun{a:t0p}
int_array_map_cloref
  (n: intGte(0), f: cfun(size_t, a)): array0(a)
fun{a:t0p}
int_array_map_method
  (n: intGte(0), TYPE(a))(f: cfun(size_t, a)): array0(a)
//
overload .array_map with int_array_map_method
//
(* ****** ****** *)
//
fun{}
int2_foreach_cloref
  (n1: int, n2: int, f: cfun2 (int, int, void)): void
//
fun{}
intrange2_foreach_cloref
  (l1: int, r1: int, l2: int, r2: int, f: cfun2 (int, int, void)): void
//
(* ****** ****** *)

(* end of [intrange.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmmhwxiATgmailDOTcom *)
(* Start time: May, 2012 *)

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.ML"
#define ATS_EXTERN_PREFIX "atslib_ML_" // prefix for external names

(* ****** ****** *)

staload "libats/ML/SATS/basis.sats"

(* ****** ****** *)

typedef SHR(a:type) = a // for commenting purpose
typedef NSH(a:type) = a // for commenting purpose

(* ****** ****** *)
//
castfn
option0_of_option
  {a:t@ype} (xs: Option a):<> option0 (a)
castfn
option0_of_option_vt
  {a:t@ype} (xs: Option_vt a):<> option0 (a)
//
(* ****** ****** *)

castfn
g0ofg1_option {a:t@ype} (xs: Option (a)):<> option0 (a)
overload g0ofg1 with g0ofg1_option

castfn
g1ofg0_option {a:t@ype} (xs: option0 (a)):<> Option (a)
overload g1ofg0 with g1ofg0_option

(* ****** ****** *)
//
fun{
} option0_none
  {a:t0p} ((*void*)):<> option0 (a)
//
fun{
a:t0p
} option0_some (x: a):<> option0 (a)
//
(* ****** ****** *)

fun{}
option0_is_none {a:t0p} (x: option0 a):<> bool
overload iseqz with option0_is_none

fun{}
option0_is_some {a:t0p} (x: option0 a):<> bool
overload isneqz with option0_is_some

(* ****** ****** *)

fun{a:t0p}
option0_unsome_exn (opt: option0 (a)):<!exn> a

(* ****** ****** *)

fun{a:t0p}
fprint_option0 (out: FILEref, opt: option0 (a)): void
overload fprint with fprint_option0

(* ****** ****** *)
//
fun{
a:t0p}{b:t0p
} option0_map
  (xs: option0 (INV(a)), f: cfun (a, b)): option0 (b)
//
(* ****** ****** *)

(* end of [option0.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: August, 2013 *)

(* ****** ****** *)

#define
ATS_PACKNAME "ATSLIB.libats.ML"
#define
ATS_EXTERN_PREFIX "atslib_ML_" // prefix for external names

(* ****** ****** *)

staload "libats/ML/SATS/basis.sats"

(* ****** ****** *)
//
// HX: for maps of elements of type (a)
//
abstype
hashtbl_type(key:t@ype, itm:t0ype) = ptr
typedef
hashtbl(key:t0p, itm:t0p) = hashtbl_type(key, itm)
//
(* ****** ****** *)
//
fun{
key:t0p
} hash_key (x: key):<> ulint
//
fun{
key:t0p
} equal_key_key (x1: key, x2: key):<> bool
//
(* ****** ****** *)

fun{
key,itm:t0p
} hashtbl_make_nil (cap: sizeGte(1)): hashtbl(key, itm)

(* ****** ****** *)

fun{}
hashtbl_get_size{key,itm:t0p} (hashtbl(key, itm)): size_t
fun{}
hashtbl_get_capacity{key,itm:t0p} (hashtbl(key, itm)): sizeGte(1)

(* ****** ****** *)

fun{
key,itm:t0p
} hashtbl_search
  (hashtbl(key, itm), key): Option_vt (itm)
// end of [hashtbl_search]

fun{
key,itm:t0p
} hashtbl_search_ref
  (tbl: hashtbl(key, itm), k: key): cPtr0 (itm)
// end of [hashtbl_search_ref]

(* ****** ****** *)

fun{
key,itm:t0p
} hashtbl_insert
  (hashtbl(key, itm), key, itm): Option_vt (itm)
// end of [hashtbl_insert]

fun{
key,itm:t0p
} hashtbl_insert_any(hashtbl(key, itm), key, itm): void

(* ****** ****** *)

fun{
key,itm:t0p
} hashtbl_takeout
  (hashtbl(key, itm), key): Option_vt (itm)
// end of [hashtbl_takeout]

(* ****** ****** *)

fun{
key,itm:t0p
} hashtbl_remove(tbl: hashtbl(key, itm), key): bool

(* ****** ****** *)

fun{
key,itm:t0p
} hashtbl_takeout_all
  (tbl: hashtbl(key, itm)): list0 @(key, itm)
// end of [hashtbl_takeout_all]

(* ****** ****** *)
//
fun{
key,itm:t@ype
} fprint_hashtbl
  (out: FILEref, tbl: hashtbl(key, itm)): void
//
overload fprint with fprint_hashtbl
//
fun{}
fprint_hashtbl$sep (out: FILEref): void // default: fprint("; ")
fun{}
fprint_hashtbl$mapto (out: FILEref): void // default: fprint("->")
//
(* ****** ****** *)
//
fun{
key,itm:t0p
} hashtbl_foreach
  (tbl: hashtbl(key, itm)): void
fun
{key:t0p
;itm:t0p}
{env:vt0p}
hashtbl_foreach_env
  (tbl: hashtbl(key, itm), env: &(env) >> _): void
//
fun
{key:t0p
;itm:t0p}
{env:vt0p}
hashtbl_foreach$fwork
  (key: key, itm: &itm >> _, env: &(env) >> _): void
//
(* ****** ****** *)
//
fun{
key,itm:t0p
} hashtbl_foreach_cloref
  (tbl: hashtbl(key, itm), fwork: (key, &itm >> _) -<cloref1> void): void
//
(* ****** ****** *)
//
fun{
key,itm:t0p
} hashtbl_listize1(hashtbl(key, itm)): list0 @(key, itm)
//
(* ****** ****** *)

(* end of [hashtblref.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmmhwxiATgmailDOTcom *)
(* Start time: July, 2012 *)

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.ML"
#define ATS_EXTERN_PREFIX "atslib_ML_" // prefix for external names

(* ****** ****** *)

staload "libats/ML/SATS/basis.sats"

(* ****** ****** *)

typedef SHR(a:type) = a // for commenting purpose
typedef NSH(a:type) = a // for commenting purpose

(* ****** ****** *)

fun{
} itoa (x: int):<> string

(* ****** ****** *)

fun{
} string_sing (c: charNZ):<> string

(* ****** ****** *)

fun{
} string_is_empty (NSH(string)):<> bool
fun{
} string_isnot_empty (NSH(string)):<> bool
  
(* ****** ****** *)

overload iseqz with string_is_empty
overload isneqz with string_isnot_empty

(* ****** ****** *)

fun{
} string_copy (x: NSH(string)):<> string

(* ****** ****** *)

fun{
} string_make_list (cs: list0 (char)):<> string
fun{
} string_make_rlist (cs: list0 (char)):<> string

(* ****** ****** *)

fun{
} string_make_substring
  (x: NSH(string), st: size_t, ln: size_t):<> string
// end of [string_make_substring]

(* ****** ****** *)

fun{
} string_append
  (x1: NSH(string), x2: NSH(string)):<> string
overload + with string_append of 0

(* ****** ****** *)

fun{
} stringlst_concat (xs: list0 (string)):<> string

(* ****** ****** *)

fun{
} string_explode (x: string):<> list0 (char)
fun{
} string_implode (cs: list0 (char)):<> string

(* ****** ****** *)
//
fun string_tabulate
  (n: size_t, f: (size_t) -<cloref1> charNZ): string
//
(* ****** ****** *)
//
fun
string_forall (x: string, f: cfun (char, bool)): bool
fun
string_iforall (x: string, f: cfun2 (int, char, bool)): bool
//
fun
string_foreach (x: string, f: cfun (char, void)): void
//
fun{}
string_forall_method(string)(cfun (char, bool)): bool
fun{}
string_iforall_method(string)(cfun2 (int, char, bool)): bool
//
fun{}
string_foreach_method(x: string)(f: cfun (char, void)): void
//
overload .forall with string_forall_method
overload .iforall with string_iforall_method
overload .foreach with string_foreach_method
//
(* ****** ****** *)

(* end of [string.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: August, 2013 *)

(* ****** ****** *)

#define
ATS_PACKNAME "ATSLIB.libats.ML"
#define
ATS_EXTERN_PREFIX "atslib_ML_" // prefix for external names

(* ****** ****** *)

staload "libats/ML/SATS/basis.sats"

(* ****** ****** *)
//
// HX: for maps of elements of type (a)
//
abstype
map_type (key:t@ype, itm:t0ype+) = ptr
typedef
map (key:t0p, itm:t0p) = map_type (key, itm)
//
(* ****** ****** *)

fun{key:t0p}
compare_key_key (x1: key, x2: key):<> int

(* ****** ****** *)

fun{} funmap_nil{key,itm:t0p} ():<> map (key, itm)
fun{} funmap_make_nil{key,itm:t0p} ():<> map (key, itm)

(* ****** ****** *)

fun{
} funmap_is_nil
  {key,itm:t0p} (map: map (key, INV(itm))):<> bool
fun{
} funmap_isnot_nil
  {key,itm:t0p} (map: map (key, INV(itm))):<> bool

(* ****** ****** *)

fun{
key,itm:t0p
} funmap_size (map: map (key, INV(itm))):<> size_t

(* ****** ****** *)

fun{
key,itm:t0p
} funmap_search
  (map: map (key, INV(itm)), k: key): Option_vt (itm)
// end of [funmap_search]

(* ****** ****** *)

fun{
key,itm:t0p
} funmap_insert
  (map: &map (key, INV(itm)) >> _, key, itm): Option_vt (itm)
// end of [funmap_insert]

(* ****** ****** *)

fun{
key,itm:t0p
} funmap_takeout
  (map: &map (key, INV(itm)) >> _, k: key): Option_vt (itm)
// end of [funmap_takeout]

(* ****** ****** *)

fun{
key,itm:t0p
} funmap_remove (map: &map (key, INV(itm)) >> _, k: key): bool

(* ****** ****** *)
//
fun{
key,itm:t@ype
} fprint_funmap
  (out: FILEref, map: map(key, itm)): void
//
overload fprint with fprint_funmap
//
fun{}
fprint_funmap$sep (out: FILEref): void // default: fprint("; ")
fun{}
fprint_funmap$mapto (out: FILEref): void // default: fprint("->")
//
(* ****** ****** *)
//
fun{
key,itm:t0p
} funmap_foreach
  (map: map(key, itm)): void
fun
{key:t0p
;itm:t0p}
{env:vt0p}
funmap_foreach_env
  (map: map(key, itm), env: &(env) >> _): void
//
fun
{key:t0p
;itm:t0p}
{env:vt0p}
funmap_foreach$fwork
  (key: key, itm: &itm >> _, env: &(env) >> _): void
//
(* ****** ****** *)
//
fun{
key,itm:t0p
} funmap_foreach_cloref
  (map: map(key, itm), fwork: (key, itm) -<cloref1> void): void
//
(* ****** ****** *)

fun{
key,itm:t0p
} funmap_listize (map: map (key, INV(itm))): list0 @(key, itm)

(* ****** ****** *)

(* end of [funmap.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: August, 2013 *)

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.ML"
#define ATS_EXTERN_PREFIX "atslib_ML_" // prefix for external names

(* ****** ****** *)

staload "libats/ML/SATS/basis.sats"

(* ****** ****** *)
//
// HX-2013-08:
// for sets of elements of type a
//
abstype set_type (a:t@ype+) = ptr
typedef set (a:t0p) = set_type (a)
//
(* ****** ****** *)

fun{a:t0p}
compare_elt_elt (x: a, y: a):<> int

(* ****** ****** *)

fun{} funset_nil{a:t0p} ():<> set(a)
fun{} funset_make_nil{a:t0p} ():<> set(a)

(* ****** ****** *)

fun{a:t0p} funset_sing (x: a): set(a)
fun{a:t0p} funset_make_sing (x: a): set(a)

(* ****** ****** *)

fun{a:t0p}
funset_make_list (xs: list0(INV(a))): set(a)

(* ****** ****** *)
//
fun{
} fprint_funset$sep (out: FILEref): void // ", "
//
fun{a:t0p}
fprint_funset (out: FILEref, set: set(INV(a))): void
//
overload fprint with fprint_funset
//
(* ****** ****** *)

fun{}
funset_is_nil {a:t0p} (xs: set(INV(a))):<> bool
fun{}
funset_isnot_nil {a:t0p} (xs: set(INV(a))):<> bool

(* ****** ****** *)

fun{a:t0p}
funset_size (xs: set(INV(a))):<> size_t

(* ****** ****** *)

fun{a:t0p}
funset_is_member (xs: set(INV(a)), x0: a):<> bool
fun{a:t0p}
funset_isnot_member (xs: set(INV(a)), x0: a):<> bool

(* ****** ****** *)

fun{a:t0p}
funset_insert
  (xs: &set(INV(a)) >> _, x0: a): bool(*[x0] in [xs]*)
// end of [funset_insert]

(* ****** ****** *)

fun{a:t0p}
funset_remove
  (xs: &set(INV(a)) >> _, x0: a): bool(*[x0] is [xs]*)
// end of [funset_remove]

(* ****** ****** *)

fun{a:t0p}
funset_getmax_opt (xs: set(INV(a))): Option_vt (a)
fun{a:t0p}
funset_getmin_opt (xs: set(INV(a))): Option_vt (a)

(* ****** ****** *)

fun{a:t0p}
funset_takeoutmax_opt (xs: &set(INV(a)) >> _): Option_vt (a)
fun{a:t0p}
funset_takeoutmin_opt (xs: &set(INV(a)) >> _): Option_vt (a)

(* ****** ****** *)

fun{a:t0p}
funset_union (xs1: set(INV(a)), xs2: set(a)):<> set(a)
fun{a:t0p}
funset_intersect (xs1: set(INV(a)), xs2: set(a)):<> set(a)
fun{a:t0p}
funset_differ (xs1: set(INV(a)), xs2: set(a)):<> set(a)
fun{a:t0p}
funset_symdiff (xs1: set(INV(a)), xs2: set(a)):<> set(a)

(* ****** ****** *)

fun{a:t0p}
funset_equal (xs1: set(INV(a)), xs2: set(a)):<> bool

(* ****** ****** *)
//
// HX: set ordering induced by the ordering on elements
//
fun{a:t0p}
funset_compare (xs1: set(INV(a)), xs2: set(a)):<> int

(* ****** ****** *)
//
fun{a:t0p}
funset_is_subset (xs1: set(INV(a)), xs2: set(a)):<> bool
fun{a:t0p}
funset_is_supset (xs1: set(INV(a)), xs2: set(a)):<> bool
//
(* ****** ****** *)
//
fun{a:t0p}
funset_foreach (set: set(INV(a))): void
fun{
a:t0p}{env:vt0p
} funset_foreach_env
  (set: set(INV(a)), env: &(env) >> _): void
// end of [funset_foreach_env]
//
fun{
a:t0p}{env:vt0p
} funset_foreach$fwork (x: a, env: &(env) >> _): void
//
(* ****** ****** *)
//
fun{a:t0p}
funset_foreach_cloref
  (set: set(INV(a)), fwork: (a) -<cloref1> void): void
//
(* ****** ****** *)
//
fun{a:t0p}
funset_tabulate_cloref
  {n:nat}(int(n), fopr: (natLt(n)) -<cloref1> a): set(a)
//
(* ****** ****** *)

fun{a:t0p}
funset_listize (xs: set(INV(a))):<> list0 (a)

(* ****** ****** *)

(* end of [funset.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)
//
// HX-2013-09:
// A multi-set (mset) is like a set but elements can occur more than once
//
(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.ML"
#define ATS_EXTERN_PREFIX "atslib_ML_" // prefix for external names

(* ****** ****** *)

staload "libats/ML/SATS/basis.sats"

(* ****** ****** *)
//
abstype
mset_type (a:t@ype+) = ptr
//
typedef mset (a:t0p) = mset_type (a)
//
(* ****** ****** *)

fun{a:t0p}
compare_elt_elt (x: a, y: a):<> int

(* ****** ****** *)

fun{a:t0p}
funmset_size (xs: mset(a), x: a): size_t

(* ****** ****** *)

fun{a:t0p}
funmset_insert (xs: mset(a), x: a): intGte(0)

(* ****** ****** *)

fun{a:t0p}
funmset_remove (xs: mset(a), x: a): intGte(0)

(* ****** ****** *)
//
// HX-2013-09:
// if an element occurs n times in [xs],
// then it occurs n times in the returned list
//
fun{a:t0p}
funmset_listize (xs: mset(a)): list0 (a)
//
(* ****** ****** *)

(* end of [funmset.dats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmmhwxiATgmailDOTcom *)
(* Start time: May, 2012 *)

(* ****** ****** *)
//
// HX-2013-01:
// A rule of thumb for effect-annotation is that
// higher-order functions should not be annotated!
//
(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.ML"
#define ATS_EXTERN_PREFIX "atslib_ML_" // prefix for external names

(* ****** ****** *)

staload "libats/ML/SATS/basis.sats"

(* ****** ****** *)

(*
typedef SHR(a:type) = a // for commenting purpose
typedef NSH(a:type) = a // for commenting purpose
*)

(* ****** ****** *)

#define nil0 list0_nil
#define cons0 list0_cons

(* ****** ****** *)
//
#define
list0_sing(x) list0_cons(x, list0_nil())
//
#define
list0_pair(x1, x2)
list0_cons(x1, list0_cons (x2, list0_nil()))
//
(* ****** ****** *)
//
castfn
list0_cast{x:t0p} (xs: list0(INV(x))):<> list0(x)
//
(* ****** ****** *)
//
castfn
list0_of_list
  {a:t@ype}(List(INV(a))):<> list0(a)
castfn
list0_of_list_vt
  {a:t@ype}(List_vt(INV(a))):<> list0(a)
//
(* ****** ****** *)
//
castfn
g0ofg1_list{a:t@ype}(List(INV(a))):<> list0(a)
castfn
g0ofg1_list_vt{a:t@ype}(List_vt(INV(a))):<> list0(a)
//
overload g0ofg1 with g0ofg1_list
overload g0ofg1 with g0ofg1_list_vt
//
(* ****** ****** *)
//
castfn
g1ofg0_list{a:t@ype}(list0(INV(a))):<> List0(a)
//
overload g1ofg0 with g1ofg0_list
//
(* ****** ****** *)

fun{a:t0p}
list0_make_sing (x: a):<> list0(a)
fun{a:t0p}
list0_make_pair (x1: a, x2: a):<> list0(a)

(* ****** ****** *)

fun{a:t0p}
list0_make_elt (n: int, x: a):<!exn> list0(a)

(* ****** ****** *)
//
symintr list0
//
fun{a:t0p}
list0_make_arrpsz{n:int}
  (psz: arrpsz(INV(a), n)):<!wrt> list0(a)
//
overload list0 with list0_make_arrpsz
//
(* ****** ****** *)
//
fun{}
list0_make_intrange_lr
  (l: int, r: int):<> list0(int)
fun{}
list0_make_intrange_lrd
  (l: int, r: int, d: int):<!exn> list0(int)
//
symintr list0_make_intrange
//
overload list0_make_intrange with list0_make_intrange_lr
overload list0_make_intrange with list0_make_intrange_lrd
//
(* ****** ****** *)

fun{a:t0p}
list0_is_nil (list0(a)):<> bool
fun{a:t0p}
list0_is_cons (list0(a)):<> bool

(* ****** ****** *)
//
fun{a:t0p}
list0_is_empty (list0(a)):<> bool
fun{a:t0p}
list0_isnot_empty (list0(a)):<> bool
//
overload iseqz with list0_is_empty
overload isneqz with list0_isnot_empty
//
(* ****** ****** *)
//
fun{a:t0p}
list0_head_exn
  (xs: list0(INV(a))):<!exn> (a)
fun{a:t0p}
list0_head_opt
  (xs: list0(INV(a))):<> Option_vt(a)
//
(* ****** ****** *)
//
fun{a:t0p}
list0_tail_exn
  (xs: SHR(list0(INV(a)))):<!exn> list0(a)
fun{a:t0p}
list0_tail_opt
  (xs: SHR(list0(INV(a)))):<> Option_vt(list0(a))
//
(* ****** ****** *)
//
overload .head with list0_head_exn
overload .tail with list0_tail_exn
//
(* ****** ****** *)
//
fun{a:t0p}
list0_length(list0(INV(a))):<> int
//
overload length with list0_length of 0
//
(* ****** ****** *)

fun{a:t0p}
list0_last_exn (xs: list0(INV(a))):<!exn> (a)
fun{a:t0p}
list0_last_opt (xs: list0(INV(a))):<> Option_vt(a)

(* ****** ****** *)
//
fun{a:t0p}
list0_nth_exn
  (xs: list0(INV(a)), i: int):<!exn> (a)
fun{a:t0p}
list0_nth_opt
  (xs: list0(INV(a)), i: int):<> Option_vt(a)
//
(* ****** ****** *)
//
fun{a:t0p}
list0_get_at_exn
  (xs: list0(INV(a)), index: int):<!exn> (a)
//
overload [] with list0_get_at_exn
//
(* ****** ****** *)
//
fun{a:t0p}
print_list0 (xs: list0(INV(a))): void
fun{a:t0p}
prerr_list0 (xs: list0(INV(a))): void
//
overload print with print_list0
overload prerr with prerr_list0
//
(* ****** ****** *)
//
fun{a:t0p}
fprint_list0
(
  out: FILEref, xs: list0(INV(a))
) : void // end of [fprint_list0]
fun{a:t0p}
fprint_list0_sep
(
  out: FILEref, xs: list0(INV(a)), sep: NSH(string)
) : void // end of [fprint_list0_sep]
//
overload fprint with fprint_list0
overload fprint with fprint_list0_sep
//
(* ****** ****** *)

fun{a:t0p}
list0_insert_at_exn
(
  SHR(list0(INV(a))), i: int, x: a
) :<!exn> list0(a) // endfun

(* ****** ****** *)

fun{a:t0p}
list0_remove_at_exn
  (SHR(list0(INV(a))), int):<!exn> list0(a)
// end of [list0_remove_at_exn]

fun{a:t0p}
list0_takeout_at_exn
(
  xs: SHR(list0(INV(a))), i: int, x: &a? >> a
) :<!exnwrt> list0(a) // end-of-function

(* ****** ****** *)
//
fun{a:t0p}
list0_append
(
  xs: NSH(list0(INV(a))), ys: SHR(list0(a))
) :<> list0(a)
//
overload + with list0_append
//
(* ****** ****** *)
//
fun{a:t0p}
list0_extend
  (xs: NSH(list0(INV(a))), y: a):<> list0(a)
//
macdef list0_snoc = list0_extend
//
(* ****** ****** *)

fun{a:t0p}
list0_reverse (xs: list0(INV(a))):<> list0(a)

fun{a:t0p}
list0_reverse_append
  (xs: list0(INV(a)), ys: list0(a)):<> list0(a)
// end of [list0_reverse_append]

macdef list0_revapp = list_reverse_append

(* ****** ****** *)
//
fun{a:t0p}
list0_concat
  (xss: NSH(list0(list0(INV(a))))):<> list0(a)
//
(* ****** ****** *)

fun{a:t0p}
list0_take_exn
  (xs: NSH(list0(INV(a))), i: int):<!exn> list0(a)
// end of [list0_take_exn]

fun{a:t0p}
list0_drop_exn
  (xs: SHR(list0(INV(a))), i: int):<!exn> list0(a)
// end of [list0_drop_exn]

(* ****** ****** *)

fun
{a:t0p}
list0_app
(
  xs: list0(INV(a)), fwork: cfun(a, void)
) : void // end of [list0_app]

(* ****** ****** *)

fun{a:t0p}
list0_foreach
(
  xs: list0(INV(a)), fwork: cfun(a, void)
) : void // end of [list0_foreach]

fun{a:t0p}
list0_iforeach
(
 xs: list0(INV(a)), fwork: cfun2(int, a, void)
) : int(*length*) // end of [list0_iforeach]

(* ****** ****** *)

fun
{a1,a2:t0p}
list0_foreach2
(
  xs1: list0(INV(a1))
, xs2: list0(INV(a2))
, fwork: cfun2(a1, a2, void)
) : void // end of [list0_foreach2]

fun{a1,a2:t0p}
list0_foreach2_eq
(
  xs1: list0(INV(a1))
, xs2: list0(INV(a2))
, fwork: cfun2(a1, a2, void), sgn: &int? >> int
) : void // end of [list0_foreach2_eq]

(* ****** ****** *)
//
fun{
a:t0p}{res:t0p
} list0_foldleft
  (xs: list0(INV(a)), ini: res, fopr: cfun2(res, a, res)): res
//
fun{
a:t0p}{res:t0p
} list0_ifoldleft
  (xs: list0(INV(a)), ini: res, fopr: cfun3(res, int, a, res)): res
// end of [list0_ifoldleft]
//
(* ****** ****** *)

fun{
a1,a2:t0p}{res:t0p
} list0_foldleft2 (
  xs1: list0(INV(a1))
, xs2: list0(INV(a2))
, ini: res, fopr: cfun3(res, a1, a2, res)
) : res // end of [list0_foldleft2]

(* ****** ****** *)
//
fun{
a:t0p}{res:t0p
} list0_foldright
  (xs: list0(INV(a)), fopr: cfun2(a, res, res), snk: res): res
//
(*
fun{
a:t0p}{res:t0p
} list0_ifoldright
  (xs: list0(INV(a)), fopr: cfun3(int, a, res, res), snk: res): res
// end of [list0_ifoldright]
*)
//
(* ****** ****** *)

fun
{a:t0p}
list0_exists (xs: list0(INV(a)), p: cfun(a, bool)): bool

fun
{a1,a2:t0p}
list0_exists2
(
  xs1: list0(INV(a1))
, xs2: list0(INV(a2))
, pred: cfun2(a1, a2, bool)
) : bool // end of [list0_exists2]

(* ****** ****** *)

fun
{a:t0p}
list0_forall (xs: list0(INV(a)), p: cfun(a, bool)): bool

fun
{a1,a2:t0p}
list0_forall2 (
  xs1: list0(INV(a1))
, xs2: list0(INV(a2))
, pred: cfun2(a1, a2, bool)
) : bool // end of [list0_forall2]
fun
{a1,a2:t0p}
list0_forall2_eq
(
  xs1: list0(INV(a1))
, xs2: list0(INV(a2))
, p: cfun2(a1, a2, bool), sgn: &int? >> int
) : bool // end of [list0_forall2_eq]

(* ****** ****** *)

fun
{a:t0p}
list0_equal
(
  xs1: list0(INV(a)), xs2: list0(a), eqfn: cfun2(a, a, bool)
) : bool // end of [list0_equal]

(* ****** ****** *)
//
fun
{a:t0p}
list0_find_exn
  (xs: list0(INV(a)), p: cfun(a, bool)): (a)
//
fun
{a:t0p}
list0_find_opt
  (xs: list0(INV(a)), p: cfun(a, bool)): Option_vt (a)
//
(* ****** ****** *)
//
fun{
a,b:t0p
} list0_assoc_exn
  (xys: list0 @(INV(a), b), x0: a, eq: cfun(a, a, bool)): (b)
fun{
a,b:t0p
} list0_assoc_opt
  (xys: list0 @(INV(a), b), x0: a, eq: cfun(a, a, bool)): Option_vt (b)
//
(* ****** ****** *)

fun{a:t0p}
list0_filter
  (xs: list0(INV(a)), pred: cfun(a, bool)): list0(a)
// end of [list0_filter]

(* ****** ****** *)
//
fun{
a:t0p}{b:t0p
} list0_map
  (xs: list0(INV(a)), fopr: cfun(a, b)): list0(b)
//
fun{
a:t0p}{b:t0p
} list0_mapopt
  (xs: list0(INV(a)), fopr: cfun(a, Option_vt(b))): list0(b)
//
(* ****** ****** *)
//
fun{a:t0p}
list0_mapcons
  (x0: a, xss: list0(list0(INV(a)))): list0(list0(a))
//
(* ****** ****** *)

fun{
a:t0p}{b:t0p
} list0_imap
  (xs: list0(INV(a)), fopr: cfun2(int, a, b)): list0(b)

(* ****** ****** *)

fun{
a1,a2:t0p}{b:t0p
} list0_map2 (
  list0(INV(a1)), list0(INV(a2)), fopr: cfun2(a1, a2, b)
) : list0(b) // end of [list0_map2]

(* ****** ****** *)

fun{a:t0p}
list0_tabulate
  (n: int, fopr: cfun(int, a)): list0(a)
fun{a:t0p}
list0_tabulate_opt
  (n: int, fopr: cfun(int, Option_vt (a))): list0(a)

(* ****** ****** *)
//
fun
{x,y:t0p}
list0_zip
  (list0(INV(x)), list0(INV(y))):<> list0 @(x, y)
//
(*
fun{
x,y:t0p}{z:t0p
} list0_zipwith
  (list0(INV(x)), list0(INV(y)), fopr: cfun2(x, y, z)): list0(z)
*)
macdef list0_zipwith = list0_map2
//
(* ****** ****** *)
//
fun
{x,y:t0p}
list0_cross
  (list0(INV(x)), list0(INV(y))):<> list0 @(x, y)
//
fun{
x,y:t0p}{z:t0p
} list0_crosswith
  (list0(INV(x)), list0(INV(y)), fopr: cfun2(x, y, z)): list0(z)
//
(* ****** ****** *)

fun{a:t0p}
list0_quicksort
  (xs: NSH(list0(INV(a))), cmp: (a, a) -<cloref> int):<> list0(a)
// end of [list0_quicksort]

(* ****** ****** *)

fun{a:t0p}
list0_mergesort
  (xs: NSH(list0(INV(a))), cmp: (a, a) -<cloref> int):<> list0(a)
// end of [list0_mergesort]

(* ****** ****** *)

(* end of [list0.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: December, 2012 *)

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.ML"
#define ATS_EXTERN_PREFIX "atslib_ML_" // prefix for external names

(* ****** ****** *)

staload "libats/ML/SATS/basis.sats"

(* ****** ****** *)

typedef SHR(a:type) = a // for commenting purpose
typedef NSH(a:type) = a // for commenting purpose

(* ****** ****** *)

#if(0)
//
// HX: in [basis.sats]
//
abstype
matrix0_vt0ype_type
  (a: vt@ype(*invariant*)) = ptr
stadef matrix0 = matrix0_vt0ype_type
//
#endif

(* ****** ****** *)

(*
typedef matrix0 (a: vt@ype) = mtrxszref (a)
*)

(* ****** ****** *)

sortdef t0p = t@ype and vt0p = viewt@ype

(* ****** ****** *)
//
fun{}
matrix0_of_mtrxszref
  {a:vt0p} (mtrxszref (a)):<> matrix0 (a)
//
fun{}
mtrxszref_of_matrix0
  {a:vt0p} (M: matrix0 (a)):<> mtrxszref (a)
//
(* ****** ****** *)

fun{a:t0p}
matrix0_make_elt
  (nrow: size_t, ncol: size_t, init: a):<!wrt> matrix0 (a)
// end of [matrix0_make_elt]

(* ****** ****** *)
//
fun{}
matrix0_get_ref{a:vt0p} (M: matrix0 a):<> Ptr1
//
fun{}
matrix0_get_nrow{a:vt0p} (M: matrix0 a):<> size_t
fun{}
matrix0_get_ncol{a:vt0p} (M: matrix0 a):<> size_t
//
fun{}
matrix0_get_refsize
  {a:vt0p}
(
  M: matrix0 (a)
) :<> [m,n:nat] (matrixref (a, m, n), size_t(m), size_t(n))
//
(* ****** ****** *)
//
fun{a:t0p}
matrix0_get_at_int
  (M: matrix0(a), i: int, j: int):<!exnref> a
//
fun{a:t0p}
matrix0_get_at_size
  (M: matrix0 (a), i: size_t, j: size_t):<!exnref> a
//
symintr matrix0_get_at
overload matrix0_get_at with matrix0_get_at_int
overload matrix0_get_at with matrix0_get_at_size
//
(* ****** ****** *)
//
fun{a:t0p}
matrix0_set_at_int
  (M: matrix0(a), i: int, j: int, x: a):<!exnrefwrt> void
//
fun{a:t0p}
matrix0_set_at_size
  (M: matrix0 (a), i: size_t, j: size_t, x: a):<!exnrefwrt> void
//
symintr matrix0_set_at
overload matrix0_set_at with matrix0_set_at_int
overload matrix0_set_at with matrix0_set_at_size
//
(* ****** ****** *)
//
fun{a:vt0p}
print_matrix0 (M: matrix0 (a)): void
fun{a:vt0p}
prerr_matrix0 (M: matrix0 (a)): void
//
(*
fprint_matrix$sep1 // col separation
fprint_matrix$sep2 // row separation
*)
fun{a:vt0p}
fprint_matrix0 (out: FILEref, M: matrix0 (a)): void
fun{a:vt0p}
fprint_matrix0_sep
  (out: FILEref, M: matrix0 (a), sep1: string, sep2: string): void
//
(* ****** ****** *)

fun{a:t0p}
matrix0_copy (M: matrix0 (a)): matrix0 (a)

(* ****** ****** *)

fun{a:vt0p}
matrix0_tabulate
(
  nrow: size_t, ncol: size_t, f: cfun (size_t, size_t, a)
) : matrix0 (a) // end-of-fun

(* ****** ****** *)

fun{a:vt0p}
matrix0_foreach
  (M: matrix0 (a), f: (&a >> _) -<cloref1> void): void
// end of [matrix0_foreach]

fun{a:vt0p}
matrix0_iforeach
  (M: matrix0 (a), f: (size_t, size_t, &a >> _) -<cloref1> void): void
// end of [matrix0_iforeach]

(* ****** ****** *)

fun{
res:vt0p}{a:vt0p
} matrix0_foldleft
(
  M: matrix0 (a), ini: res, f: (res, &a) -<cloref1> res
) : res // end of [matrix0_foldleft]

fun{
res:vt0p}{a:vt0p
} matrix0_ifoldleft
(
  M: matrix0 (a), ini: res, f: (res, size_t, size_t, &a) -<cloref1> res
) : res // end of [matrix0_ifoldleft]

(* ****** ****** *)
//
// overloading for certain symbols
//
(* ****** ****** *)

overload .nrow with matrix0_get_nrow
overload .ncol with matrix0_get_ncol

(* ****** ****** *)

overload [] with matrix0_get_at_int of 0
overload [] with matrix0_get_at_size of 0
overload [] with matrix0_set_at_int of 0
overload [] with matrix0_set_at_size of 0

(* ****** ****** *)

overload print with print_matrix0
overload prerr with print_matrix0
overload fprint with fprint_matrix0
overload fprint with fprint_matrix0_sep

(* ****** ****** *)

(* end of [matrix0.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: August, 2013 *)

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.ML"
#define ATS_EXTERN_PREFIX "atslib_ML_" // prefix for external names

(* ****** ****** *)

staload "./basis.sats"

(* ****** ****** *)

#include "./SHARE/monad.hats"

(* ****** ****** *)

fun{a:t0p}
monad_maybe_none (): monad (a)
fun{a:t0p}
monad_maybe_some (x: a): monad (a)

(* ****** ****** *)

fun{a:t0p}
monad_maybe_optize (m: monad (a)): Option (a)

(* ****** ****** *)
//
fun{a:t0p}
fprint_monad (out: FILEref, m: monad (INV(a))): void
overload fprint with fprint_monad
//
(* ****** ****** *)

(* end of [monad_maybe.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2010-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
**
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
**
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: January, 2013 *)

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.ML"
#define ATS_EXTERN_PREFIX "atslib_ML_" // prefix for external names

(* ****** ****** *)

staload "libats/ML/SATS/basis.sats"

(* ****** ****** *)

typedef SHR(a:type) = a // for commenting purpose
typedef NSH(a:type) = a // for commenting purpose

(* ****** ****** *)

typedef charlst0 = list0 (char)
typedef stringlst0 = list0 (string)

(* ****** ****** *)

(*
fun fileref_open_opt
  (path: NSH(string), fm: file_mode): option0 (FILEref)
// end of [fileref_open_opt]
*)

(* ****** ****** *)

fun
fileref_get_line_charlst (filr: FILEref): charlst0

(*
** HX: for handling files of "tiny" size
*)
fun
fileref_get_lines_charlstlst (filr: FILEref): list0 (charlst0)

(* ****** ****** *)

fun fileref_get_line_string (filr: FILEref): string

(*
** HX: for handling files of "tiny" size
*)
fun fileref_get_lines_stringlst (filr: FILEref): stringlst0

(* ****** ****** *)

fun dirname_get_fnamelst (dirname: string): list0 (string)

(* ****** ****** *)

(* end of [filebas.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmmhwxiATgmailDOTcom *)
(* Start time: July, 2012 *)

(* ****** ****** *)

#define ATS_PACKNAME "ATSLIB.libats.ML"
#define ATS_EXTERN_PREFIX "atslib_ML_" // prefix for external names

(* ****** ****** *)

%{#
#include "libats/ML/CATS/array0.cats"
%} // end of [%{#]

(* ****** ****** *)

staload "libats/ML/SATS/basis.sats"

(* ****** ****** *)

typedef SHR(a:type) = a // for commenting purpose
typedef NSH(a:type) = a // for commenting purpose

(* ****** ****** *)

#if(0)
//
// HX: in [basis.sats]
//
abstype
array0_vt0ype_type
  (a: vt@ype(*invariant*)) = ptr
stadef array0 = array0_vt0ype_type
//
#endif

(* ****** ****** *)

(*
typedef array0 (a: vt@ype) = arrszref (a)
*)

(* ****** ****** *)

sortdef t0p = t@ype and vt0p = viewt@ype

(* ****** ****** *)
//
fun{}
array0_of_arrszref
  {a:vt0p} (arrszref (a)):<> array0 (a)
//
fun{}
arrszref_of_array0
  {a:vt0p} (A: array0 (a)):<> arrszref (a)
//
(* ****** ****** *)
//
symintr array0
//
fun{}
array0_make_arrpsz
  {a:vt0p}{n:int}
  (psz: arrpsz (INV(a), n)):<!wrt> array0 (a)
overload array0 with array0_make_arrpsz
//
fun{}
array0_make_arrayref
  {a:vt0p}{n:int}
  (A: arrayref (a, n), n: size_t (n)):<!wrt> array0 (a)
overload array0 with array0_make_arrayref
//
(* ****** ****** *)
//
fun{}
array0_get_ref{a:vt0p} (A: array0 a):<> Ptr1
fun{}
array0_get_size{a:vt0p} (A: array0 a):<> size_t
//
fun{}
array0_get_refsize
  {a:vt0p}
  (array0 (a)):<> [n:nat] (arrayref (a, n), size_t (n))
//
(* ****** ****** *)
//
fun{a:t0p}
array0_make_elt (asz: size_t, x: a):<!wrt> array0 (a)
//
(* ****** ****** *)
//
fun{a:t0p}
array0_make_list (xs: list0 (INV(a))):<!wrt> array0 (a)
fun{a:t0p}
array0_make_rlist (xs: list0 (INV(a))):<!wrt> array0 (a)
//
(* ****** ****** *)

fun{a:t0p}
array0_make_subarray
  (A: array0 (a), st: size_t, ln: size_t):<!wrt> array0 (a)
// end of [array0_make_subarray]

(* ****** ****** *)

fun{a:t0p}
array0_get_at_size
  (A: array0 (a), i: size_t):<!exnref> a
fun{a:t0p}{tk:tk}
array0_get_at_gint
  (A: array0 (a), i: g0int(tk)):<!exnref> a
fun{a:t0p}{tk:tk}
array0_get_at_guint
  (A: array0 (a), i: g0uint(tk)):<!exnref> a
//
symintr array0_get_at
overload array0_get_at with array0_get_at_gint
overload array0_get_at with array0_get_at_guint
//
(* ****** ****** *)

fun{a:t0p}
array0_set_at_size
  (A: array0 (a), i: size_t, x: a):<!exnrefwrt> void
fun{a:t0p}{tk:tk}
array0_set_at_gint
  (A: array0 (a), i: g0int(tk), x: a):<!exnrefwrt> void
fun{a:t0p}{tk:tk}
array0_set_at_guint
  (A: array0 (a), i: g0uint(tk), x: a):<!exnrefwrt> void
//
symintr array0_set_at
overload array0_set_at with array0_set_at_gint
overload array0_set_at with array0_set_at_guint
//
(* ****** ****** *)

fun{a:vt0p}
array0_exch_at_size
  (A: array0 (a), i: size_t, x: &a >> _):<!exnrefwrt> void
fun{a:vt0p}{tk:tk}
array0_exch_at_gint
  (A: array0 (a), i: g0int(tk), x: &a >> _):<!exnrefwrt> void
fun{a:vt0p}{tk:tk}
array0_exch_at_guint
  (A: array0 (a), i: g0uint(tk), x: &a >> _):<!exnrefwrt> void
//
symintr array0_exch_at
overload array0_exch_at with array0_exch_at_gint
overload array0_exch_at with array0_exch_at_guint
//
(* ****** ****** *)

fun{a:vt0p}
array0_interchange
  (A: array0 (a), i: size_t, j: size_t):<!exnrefwrt> void
// end of [array0_interchange]

(* ****** ****** *)

fun{a:vt0p}
array0_subcirculate
  (A: array0 (a), i: size_t, j: size_t):<!exnrefwrt> void
// end of [array0_subcirculate]

(* ****** ****** *)
//
fun{a:vt0p}
print_array0 (A: array0 (a)): void
fun{a:vt0p}
prerr_array0 (A: array0 (a)): void
//
(*
fun{}
fprint_array$sep (out: FILEref): void
*)
fun{a:vt0p}
fprint_array0 (out: FILEref, A: array0 (a)): void
fun{a:vt0p}
fprint_array0_sep
  (out: FILEref, A: array0 (a), sep: string): void
//
(* ****** ****** *)

fun{a:t0p}
array0_copy (A: array0 (a)):<!refwrt> array0 (a)

(* ****** ****** *)

fun{a:t0p}
array0_append
  (A1: array0 (a), A2: array0 (a)):<!refwrt> array0 (a)
// end of [array0_append]

(* ****** ****** *)

fun{
a:vt0p}{b:vt0p
} array0_map
  (A: array0 (a), f: (&a) -<cloref1> b): array0 (b)
// end of [array0_map]

fun{
a:vt0p}{b:vt0p
} array0_mapopt
  (A: array0 (a), f: (&a) -<cloref1> Option_vt (b)): array0 (b)
// end of [array0_mapopt]

(* ****** ****** *)

fun{a:vt0p}
array0_tabulate
  (asz: size_t, f: (size_t) -<cloref1> a): array0 (a)
// end of [array0_tabulate]

(* ****** ****** *)

fun{a:vt0p}
array0_foreach
  (A: array0 (a), f: (&a >> _) -<cloref1> void): void
// end of [array0_foreach]

fun{a:vt0p}
array0_iforeach
  (A: array0 (a), f: (size_t, &a >> _) -<cloref1> void): void
// end of [array0_iforeach]

(* ****** ****** *)

fun{a:vt0p}
array0_rforeach
  (A: array0 (a), f: (&a >> _) -<cloref1> void): void
// end of [array0_rforeach]

(* ****** ****** *)

(*
** HX: raising NotFoundExn if no satisfying element is found
*)
fun{a:vt0p}
array0_find_exn
  (A: array0 (a), p: (&a) -<cloref1> bool): size_t
// end of [array0_find_exn]

fun{a:vt0p}
array0_find_opt
  (A: array0 (a), p: (&a) -<cloref1> bool): option0 (size_t)
// end of [array0_find_opt]

(* ****** ****** *)

fun{
res:vt0p}{a:vt0p
} array0_foldleft
(
  A: array0 (a), ini: res, f: (res, &a) -<cloref1> res
) : res // end of [array0_foldleft]

fun{
res:vt0p}{a:vt0p
} array0_ifoldleft
(
  A: array0 (a), ini: res, f: (res, size_t, &a) -<cloref1> res
) : res // end of [array0_ifoldleft]

(* ****** ****** *)

fun{
a:vt0p}{res:vt0p
} array0_foldright
(
  A: array0 (a), f: (&a, res) -<cloref1> res, snk: res
) : res // end of [array0_foldright]

(* ****** ****** *)
//
fun
{a:vt0p}
array0_quicksort(array0(a), cmp: (&a, &a) -<cloref1> int): void
//
(* ****** ****** *)
//
// Overloading certain symbols
//
(* ****** ****** *)

overload .size with array0_get_size

(* ****** ****** *)

overload [] with array0_get_at_gint
overload [] with array0_get_at_guint
overload [] with array0_set_at_gint
overload [] with array0_set_at_guint

(* ****** ****** *)

overload print with print_array0
overload prerr with print_array0
overload fprint with fprint_array0
overload fprint with fprint_array0_sep

(* ****** ****** *)

(* end of [array0.sats] *)
(***********************************************************************)
(*                                                                     *)
(*                         Applied Type System                         *)
(*                                                                     *)
(***********************************************************************)

(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)

(* ****** ****** *)

(* Author: Hongwei Xi *)
(* Authoremail: gmmhwxiATgmailDOTcom *)
(* Start time: July, 2013 *)

(* ****** ****** *)
//
// HX: shared by monad_list
// HX: shared by monad_maybe
//
(* ****** ****** *)

abstype monad_type (a:t@ype+) = ptr
typedef monad (a:t@ype) = monad_type (a)

(* ****** ****** *)

fun
{a:t0p}
{b:t0p}
monad_bind
(
  monad (a), cfun (a, monad (b))
) : monad (b) // end-of-function

fun
{a1,a2:t0p}
{b:t0p}
monad_bind2
(
  monad (a1), monad(a2), cfun (a1, a2, monad (b))
) : monad (b) // end-of-function

fun
{a1,a2,a3:t0p}
{b:t0p}
monad_bind3
(
  monad (a1), monad(a2), monad (a3), cfun (a1, a2, a3, monad (b))
) : monad (b) // end-of-function

(* ****** ****** *)

fun{a:t0p} monad_return (x: a): monad (a)

(* ****** ****** *)

fun{
} monad_unit (): monad (unit)

(* ****** ****** *)
//
fun{a:t0p}
monad_nil (): monad (list0 (a))
fun{a:t0p}
monad_cons
(
  monad (INV(a)), monad (list0 (a))
) : monad (list0 (a)) // end-of-fun
//
(* ****** ****** *)

fun
{a1,a2:t0p}
monad_seq
(
  m1: monad (INV(a1)), m2: monad (INV(a2))
): monad (a2) // end of [monad_seq]

(* ****** ****** *)

fun{a:t0p}
monad_join (monad (monad (INV(a)))): monad (a)

(* ****** ****** *)

fun
{a:t0p}
{b:t0p}
monad_fmap (cfun (a, b), monad (a)): monad (b)

(* ****** ****** *)

fun
{a:t0p}
{b:t0p}
monad_liftm (cfun (a, b), monad (a)): monad (b)
fun
{a1,a2:t0p}
{b:t0p}
monad_liftm2
  (cfun (a1, a2, b), monad (a1), monad (a2)): monad (b)
// end of [monad_liftm2]
fun
{a1,a2,a3:t0p}
{b:t0p}
monad_liftm3
  (cfun (a1, a2, a3, b), monad (a1), monad (a2), monad (a3)): monad (b)
// end of [monad_liftm3]

(* ****** ****** *)
//
fun
{a:t0p}
{b:t0p}
monad_mapm
  (cfun (a, b), list0 (monad (a))): monad (list0 (b))
//
fun
{a:t0p}
{b:t0p}
monad_mapm_(cfun (a, monad (b)), list0 (a)): monad (unit)
//
(* ****** ****** *)
//
fun{a:t0p}
monad_seqlist
  (list0 (monad (INV(a)))): monad (list0 (a))
//
fun{a:t0p}
monad_seqlist_(list0 (monad (INV(a)))): monad (unit)
//
(* ****** ****** *)

(* end of [monad.hats] *)
/* ******************************************************************* */
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/* ******************************************************************* */

/*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: December, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBATS_ML_ARRAY0_CATS
#define ATSLIB_LIBATS_ML_ARRAY0_CATS

/* ****** ****** */

#define atslib_ML_array0_memcpy memcpy

/* ****** ****** */

#endif // ifndef ATSLIB_LIBATS_ML_ARRAY0_CATS

/* ****** ****** */

/* end of [array0.cats] */
/* ******************************************************************* */
/*                                                                     */
/*                         Applied Type System                         */
/*                                                                     */
/* ******************************************************************* */

/*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*/

/* ****** ****** */

/*
(* Author: Hongwei Xi *)
(* Authoremail: gmhwxiATgmailDOTcom *)
(* Start time: April, 2013 *)
*/

/* ****** ****** */

#ifndef ATSLIB_LIBATS_ML_STRARR_CATS
#define ATSLIB_LIBATS_ML_STRARR_CATS

/* ****** ****** */

#ifndef strncmp
extern
int strncmp (const char *s1, const char *s2, size_t n) ;
#endif // ifndef(strncmp)

/* ****** ****** */

#ifndef memchr
extern void *memchr(const void *s, int c, size_t n) ;
#endif // ifndef(memchr)

#ifndef memcpy
extern void *memcpy(void *dst, const void *src, size_t n) ;
#endif // ifndef(memcpy)

/* ****** ****** */

extern
size_t
fwrite
(
  const void *ptr, size_t size, size_t nmemb, FILE *stream
) ; // end of [fwrite] // in [stdio.h]

/* ****** ****** */

#define atslib_ML_strarr_memchr memchr
#define atslib_ML_strarr_memcpy memcpy
#define atslib_ML_strarr_strncmp strncmp
#define atslib_ML_strarr_fwrite fwrite

/* ****** ****** */

#endif // ifndef ATSLIB_LIBATS_ML_STRARR_CATS

/* ****** ****** */

/* end of [strarr.cats] */
