<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <title></title>
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
  <style type="text/css">
    .patsyntax {color:#808080;background-color:#E0E0E0;}
    .patsyntax span.keyword {color:#000000;font-weight:bold;}
    .patsyntax span.comment {color:#787878;font-style:italic;}
    .patsyntax span.extcode {color:#A52A2A;}
    .patsyntax span.neuexp  {color:#800080;}
    .patsyntax span.staexp  {color:#0000F0;}
    .patsyntax span.prfexp  {color:#603030;}
    .patsyntax span.dynexp  {color:#F00000;}
    .patsyntax span.stalab  {color:#0000F0;font-style:italic}
    .patsyntax span.dynlab  {color:#F00000;font-style:italic}
    .patsyntax span.dynstr  {color:#008000;font-style:normal}
    .patsyntax span.stacstdec  {text-decoration:none;}
    .patsyntax span.stacstuse  {color:#0000CF;text-decoration:underline;}
    .patsyntax span.dyncstdec  {text-decoration:none;}
    .patsyntax span.dyncstuse  {color:#B80000;text-decoration:underline;}
    .patsyntax span.dyncst_implement  {color:#B80000;text-decoration:underline;}
  </style>
</head>
<body class="patsyntax">

<pre class="patsyntax">
<span class="comment">(***********************************************************************)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(*                         Applied Type System                         *)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(***********************************************************************)</span>

<span class="comment">(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">(*
**
** A list-based queue implementation
**
*)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">(*
**
** Author: Hongwei Xi
** Authoremail: hwxiATcsDOTbuDOTedu
** Time: July, 2010
** It is based on an earlier version done in October, 2008
**
*)</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="comment">// HX-2012-12: ported to ATS/Postitats from ATS/Anairiats</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="extcode"><span class="extcode">%{#
#include "libats/CATS/qlist.cats"
%}</span></span> <span class="comment">// end of [%{#]</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">#define</span>
ATS_PACKNAME "ATSLIB.libats.qlist"</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="staexp"><span class="keyword">absvtype</span>
qlist_vtype<span class="keyword">(</span>a<span class="keyword">:</span><span class="keyword">vt@ype+</span><span class="keyword">,</span> n<span class="keyword">:</span>int<span class="keyword">)</span> <span class="keyword">=</span> ptr</span>
<span class="comment">//</span>
<span class="keyword">vtypedef</span>
<span class="staexp">qlist<span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>vt0p</span><span class="keyword">,</span> <span class="staexp">n<span class="keyword">:</span>int</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp">qlist_vtype</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">vtypedef</span>
<span class="staexp">qlist<span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>vt0p</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>n<span class="keyword">:</span>int<span class="keyword">]</span></span> <span class="staexp">qlist_vtype</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">vtypedef</span>
<span class="staexp">qlist0<span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>vt0p</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n &gt;= 0<span class="keyword">]</span></span> <span class="staexp">qlist</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="prfexp"><span class="keyword">praxi</span>
lemma_qlist_param
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>q0<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">qlist</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>n &gt;= 0<span class="keyword">]</span></span> <span class="staexp">void</span></span>
<span class="comment">// end of [lemma_qlist_param]</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
qlist_make_nil<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">qlist</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
qlist_free_nil<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="keyword">(</span><span class="staexp">qlist</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
qlist_length
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="keyword">(</span>q0<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">qlist</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">int</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
qlist_is_nil
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="keyword">(</span>q0<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">qlist</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">bool</span><span class="keyword">(</span><span class="staexp">n</span> <span class="staexp">==</span> <span class="staexp">0</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
qlist_isnot_nil
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="keyword">(</span>q0<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">qlist</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">bool</span><span class="keyword">(</span><span class="staexp">n</span> <span class="staexp"><span class="keyword">&gt;</span></span> <span class="staexp">0</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
fprint_qlist$sep
  <span class="keyword">(</span>out<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
fprint_qlist
<span class="keyword">(</span>
  out<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">,</span> que<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">qlist</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span></span> <span class="comment">// end of [fprint_qlist]</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
fprint_qlist_sep
<span class="keyword">(</span>
  out<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">,</span> que<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">qlist</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> sep<span class="keyword">:</span> <span class="staexp">string</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span></span> <span class="comment">// end of [fprint_qlist_sep]</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
qlist_insert<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  que<span class="keyword">:</span>
  <span class="staexp"><span class="keyword">!</span></span><span class="staexp">qlist</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">qlist</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span>
<span class="keyword">,</span> elt<span class="keyword">:</span> <span class="staexp">a</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span> <span class="comment">// end of [qlist_insert]</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
qlist_takeout<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>pos<span class="keyword">}</span></span>
<span class="keyword">(</span>
  q0<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">qlist</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">qlist</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">-</span><span class="staexp">1</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span> <span class="comment">// end-of-function</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
qlist_takeout_opt
  <span class="keyword">(</span>q0<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">qlist</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">Option_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="comment">(*
** HX: this operation is O(1)
*)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
qlist_takeout_list<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>q0<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">qlist</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">qlist</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span>
<span class="comment">// end of [qlist_takeout_list]</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
qlist_foreach<span class="keyword">(</span>q0<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">qlist</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
<span class="staexp"><span class="keyword">{</span>env<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
qlist_foreach_env
  <span class="keyword">(</span>q0<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">qlist</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="staexp">env</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
<span class="staexp"><span class="keyword">{</span>env<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
qlist_foreach$cont<span class="keyword">(</span>x0<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">a</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">env</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span></span>
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
<span class="staexp"><span class="keyword">{</span>env<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
qlist_foreach$fwork<span class="keyword">(</span>x0<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">a</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="staexp">env</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="staexp"><span class="keyword">abst@ype</span>
qstruct_tsize <span class="keyword">=</span>
<span class="keyword">$extype</span>"atslib_qlist_struct"</span>
<span class="staexp"><span class="keyword">absvt@ype</span>
qstruct_vt0ype
  <span class="keyword">(</span>a<span class="keyword">:</span><span class="keyword">vt@ype+</span><span class="keyword">,</span> n<span class="keyword">:</span>int<span class="keyword">)</span> <span class="keyword">=</span> qstruct_tsize</span>
<span class="comment">//</span>
<span class="keyword">stadef</span>
<span class="staexp">qstruct <span class="keyword">=</span> <span class="staexp">qstruct_vt0ype</span></span>
<span class="comment">//</span>
<span class="keyword">stadef</span>
<span class="staexp">qstruct <span class="keyword">=</span> <span class="staexp">qstruct_tsize</span></span> <span class="comment">// HX: order significant</span>
<span class="comment">//</span>
<span class="keyword">viewtypedef</span>
<span class="staexp">qstruct<span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>vt0p</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>n<span class="keyword">:</span>int<span class="keyword">]</span></span> <span class="staexp">qstruct</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span>
<span class="keyword">viewtypedef</span>
<span class="staexp">qstruct0<span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>vt0p</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>n<span class="keyword">:</span>nat<span class="keyword">]</span></span> <span class="staexp">qstruct</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
qstruct_initize
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
  <span class="keyword">(</span>q0<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">qstruct</span><span class="staexp">?</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">qstruct</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span>
<span class="comment">// end of [qstruct_initize]</span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">praxi</span>
qstruct_uninitize
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
  <span class="keyword">(</span> q0<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">qstruct</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">qstruct</span><span class="staexp">?</span> <span class="keyword">)</span><span class="keyword">:&lt;</span><span class="staexp">prf</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span>
<span class="comment">// end of [qstruct_uninitize]</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="prfexp"><span class="keyword">praxi</span>
qstruct_objfize
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp">pf<span class="keyword">:</span>
  <span class="staexp">qstruct</span>
  <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span></span> <span class="keyword">|</span> p0<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">ptrlin</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">qlist</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="staexp">prf</span><span class="keyword">&gt;</span> <span class="staexp">mfree_ngc_v</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span></span> <span class="comment">// end of [qstruct_objfize]</span>

<span class="prfexp"><span class="keyword">praxi</span>
qstruct_unobjfize
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp">pf<span class="keyword">:</span> <span class="staexp">mfree_ngc_v</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span></span> <span class="keyword">|</span> p0<span class="keyword">:</span> <span class="staexp">ptr</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span><span class="keyword">,</span> q0<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">qlist</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">ptrlin</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="staexp">prf</span><span class="keyword">&gt;</span> <span class="staexp">qstruct</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span></span> <span class="comment">// end of [qstruct_unobjfize]</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
qstruct_insert<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  q0<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">qstruct</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">qstruct</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span><span class="keyword">,</span> x0<span class="keyword">:</span> <span class="staexp">a</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span> <span class="comment">// end of [qstruct_insert]</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
qstruct_takeout<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>pos<span class="keyword">}</span></span>
  <span class="keyword">(</span>q0<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">qstruct</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">qstruct</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">-</span><span class="staexp">1</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="comment">(*
** HX: this operation is O(1)
*)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
qstruct_takeout_list<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>q0<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">qstruct</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">qstruct</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span>
<span class="comment">// end of [qstruct_takeout_list]</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="comment">// HX: ngc-functions do not make use of malloc/free</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="staexp"><span class="keyword">absvtype</span>
qlist_node_vtype<span class="keyword">(</span>a<span class="keyword">:</span><span class="keyword">vt@ype+</span><span class="keyword">,</span> l<span class="keyword">:</span>addr<span class="keyword">)</span> <span class="keyword">=</span> ptr</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="keyword">stadef</span>
<span class="staexp">mynode <span class="keyword">=</span> <span class="staexp">qlist_node_vtype</span></span>
<span class="comment">//</span>
<span class="keyword">vtypedef</span>
<span class="staexp">mynode<span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>l<span class="keyword">:</span>addr<span class="keyword">]</span></span> <span class="staexp">mynode</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">)</span></span>
<span class="keyword">vtypedef</span>
<span class="staexp">mynode0<span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>l<span class="keyword">:</span>addr <span class="keyword">|</span> l &gt;= null<span class="keyword">]</span></span> <span class="staexp">mynode</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">)</span></span>
<span class="keyword">vtypedef</span>
<span class="staexp">mynode1<span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>l<span class="keyword">:</span>addr <span class="keyword">|</span> l <span class="keyword">&gt;</span>  null<span class="keyword">]</span></span> <span class="staexp">mynode</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">castfn</span>
mynode2ptr
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span>
  <span class="keyword">(</span>nx<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">mynode</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">l</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">ptr</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span></span>
<span class="comment">// end of [mynode2ptr]</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
mynode_null<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">mynode</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">null</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">praxi</span>
mynode_free_null<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="keyword">(</span>nx<span class="keyword">:</span> <span class="staexp">mynode</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">null</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
mynode_make_elt<span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">mynode1</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
mynode_getref_elt<span class="keyword">(</span>nx<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">mynode1</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">cPtr1</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
mynode_free_elt
  <span class="keyword">(</span>nx<span class="keyword">:</span> <span class="staexp">mynode1</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> res<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="staexp">a</span><span class="staexp">?</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span>
<span class="comment">// end of [mynode_free_elt]</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
mynode_getfree_elt<span class="keyword">(</span>node<span class="keyword">:</span> <span class="staexp">mynode1</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
qlist_insert_ngc <span class="comment">(*last*)</span>
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  q0<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">qlist</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">qlist</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span><span class="keyword">,</span> nx<span class="keyword">:</span> <span class="staexp">mynode1</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span> <span class="comment">// end of [qlist_insert_ngc]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
qlist_takeout_ngc <span class="comment">(*first*)</span>
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n <span class="keyword">&gt;</span> 0<span class="keyword">}</span></span>
  <span class="keyword">(</span>q0<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">qlist</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">qlist</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">-</span><span class="staexp">1</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">mynode1</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="comment">// end of [qlist_takeout_ngc]</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="comment">// overloading for certain symbols</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">overload</span> iseqz <span class="keyword">with</span> qlist_is_nil</span>
<span class="dynexp"><span class="keyword">overload</span> isneqz <span class="keyword">with</span> qlist_isnot_nil</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">overload</span> length <span class="keyword">with</span> qlist_length</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">overload</span> fprint <span class="keyword">with</span> fprint_qlist</span>
<span class="dynexp"><span class="keyword">overload</span> fprint <span class="keyword">with</span> fprint_qlist_sep</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">(* end of [qlist.sats] *)</span>
</pre>
<pre class="patsyntax">
<span class="comment">(***********************************************************************)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(*                         Applied Type System                         *)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(***********************************************************************)</span>

<span class="comment">(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">(* Author: Hongwei Xi *)</span>
<span class="comment">(* Authoremail: hwxi AT cs DOT bu DOT edu *)</span>
<span class="comment">(* Start time: March, 2013 *)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="neuexp"><span class="keyword">#define</span> ATS_PACKNAME "ATSLIB.libats.sllist"</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">typedef</span> <span class="staexp">SHR<span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>type</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp">a</span></span> <span class="comment">// for commenting purpose</span>
<span class="keyword">typedef</span> <span class="staexp">NSH<span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>type</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp">a</span></span> <span class="comment">// for commenting purpose</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">(*
**
** HX-2013-03:
** sllist (a, n) means that there are n elements in the list.
**
*)</span>
<span class="staexp"><span class="keyword">absvtype</span>
sllist_vtype <span class="keyword">(</span>a<span class="keyword">:</span><span class="keyword">viewt@ype+</span><span class="keyword">,</span> n<span class="keyword">:</span>int<span class="keyword">)</span> <span class="keyword">=</span> ptr</span>
<span class="keyword">stadef</span> <span class="staexp">sllist <span class="keyword">=</span> <span class="staexp">sllist_vtype</span></span> <span class="comment">// HX: shorthand</span>
<span class="comment">//</span>
<span class="keyword">vtypedef</span> <span class="staexp">Sllist <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>vt0p</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>n<span class="keyword">:</span>int<span class="keyword">]</span></span> <span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span>
<span class="keyword">vtypedef</span> <span class="staexp">Sllist0 <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>vt0p</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n &gt;= 0<span class="keyword">]</span></span> <span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span>
<span class="keyword">vtypedef</span> <span class="staexp">Sllist1 <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>vt0p</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n &gt;= 1<span class="keyword">]</span></span> <span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">castfn</span>
sllist2ptr <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">Sllist</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">Ptr0</span></span>
<span class="dynexp"><span class="keyword">castfn</span>
sllist2ptr1 <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">Sllist1</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">Ptr1</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="prfexp"><span class="keyword">praxi</span>
lemma_sllist_param <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>n &gt;= 0<span class="keyword">]</span></span> <span class="staexp">void</span></span>
<span class="comment">// end of [lemma_sllist_param]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
sllist_nil <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span> <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="prfexp"><span class="keyword">praxi</span>
sllist_free_nil
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
sllist_sing <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">1</span><span class="keyword">)</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
sllist_cons<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">,</span> xs<span class="keyword">:</span> <span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span></span>
<span class="comment">// end of [sllist_cons]</span>

<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
sllist_uncons<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n <span class="keyword">&gt;</span> 0<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">-</span><span class="staexp">1</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="comment">// end of [sllist_uncons]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
sllist_snoc<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span></span>
<span class="comment">// end of [sllist_snoc]</span>

<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
sllist_unsnoc<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n <span class="keyword">&gt;</span> 0<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">-</span><span class="staexp">1</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="comment">// end of [sllist_unsnoc]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
sllist_make_list
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span>
<span class="comment">// end of [sllist_make_list]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
sllist_make_list_vt
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list_vt</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span>
<span class="comment">// end of [sllist_make_list_vt]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
<span class="keyword">}</span></span> sllist_is_nil
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">bool</span> <span class="keyword">(</span><span class="staexp">n</span><span class="staexp">==</span><span class="staexp">0</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
<span class="keyword">}</span></span> sllist_is_cons
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">bool</span> <span class="keyword">(</span><span class="staexp">n</span> <span class="staexp"><span class="keyword">&gt;</span></span> <span class="staexp">0</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">overload</span> iseqz <span class="keyword">with</span> sllist_is_nil</span>
<span class="dynexp"><span class="keyword">overload</span> isneqz <span class="keyword">with</span> sllist_is_cons</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
sllist_length
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">int</span> <span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">overload</span> length <span class="keyword">with</span> sllist_length</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
sllist_get_elt <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">Sllist1</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
sllist_set_elt <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">Sllist1</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> x0<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
sllist_getref_elt <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">Sllist1</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">cPtr1</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
sllist_getref_next <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">Sllist1</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">Ptr1</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
sllist_getref_elt_at <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">natLt</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">cPtr1</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="comment">// end of [sllist_getref_elt_at]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
sllist_get_elt_at <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">natLt</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">overload</span> <span class="keyword">[</span><span class="keyword">]</span> <span class="keyword">with</span> sllist_get_elt_at</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
sllist_set_elt_at <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">natLt</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> x0<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span>
<span class="dynexp"><span class="keyword">overload</span> <span class="keyword">[</span><span class="keyword">]</span> <span class="keyword">with</span> sllist_set_elt_at</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
sllist_getref_at<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">natLte</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">Ptr1</span></span>
<span class="comment">// end of [sllist_getref_at]</span>

<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
sllist_insert_at <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">natLte</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> x0<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span></span>
<span class="comment">// end of [sllist_insert_at]</span>

<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
sllist_takeout_at <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">-</span><span class="staexp">1</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">natLt</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="comment">// end of [sllist_takeout_at]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
sllist_append
  <span class="staexp"><span class="keyword">{</span>n1<span class="keyword">,</span>n2<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>
  xs1<span class="keyword">:</span> <span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="keyword">)</span><span class="keyword">,</span> xs2<span class="keyword">:</span> <span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n2</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="staexp">+</span><span class="staexp">n2</span><span class="keyword">)</span></span> <span class="comment">// end of [sllist_append]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
sllist_reverse
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span>
<span class="comment">// end of [sllist_reverse]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
sllist_reverse_append
  <span class="staexp"><span class="keyword">{</span>n1<span class="keyword">,</span>n2<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>
  xs1<span class="keyword">:</span> <span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="keyword">)</span><span class="keyword">,</span> xs2<span class="keyword">:</span> <span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n2</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n1</span><span class="staexp">+</span><span class="staexp">n2</span><span class="keyword">)</span></span> <span class="comment">// end of [sllist_reverse_append]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span>
sllist_free <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">Sllist</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span>

<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
sllist_freelin$clear <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">a</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">a</span><span class="staexp">?</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
sllist_freelin <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">Sllist</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>b<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> sllist_map$fopr <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">b</span></span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>b<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> sllist_map <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">b</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>env<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> sllist_foreach$cont <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">a</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">env</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span></span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>env<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> sllist_foreach$fwork <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">a</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">env</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
sllist_foreach <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">Sllist</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>env<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> sllist_foreach_env
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">Sllist</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">env</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="comment">// end of [sllist_foreach_env]</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
fprint_sllist$sep <span class="keyword">(</span>out<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
fprint_sllist
  <span class="keyword">(</span>out<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">,</span> xs<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">Sllist</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="comment">// end of [fprint_sllist]</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">overload</span> fprint <span class="keyword">with</span> fprint_sllist</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="comment">// HX-2013-05: functions of ngc-version</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">staload</span> "libats/SATS/gnode.sats"

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">stadef</span> <span class="staexp">mytkind <span class="keyword">=</span> <span class="staexp"><span class="keyword">$extkind</span>"libats_sllist"</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">typedef</span> <span class="staexp">g2node0 <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>vt0p</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp">gnode0</span> <span class="keyword">(</span><span class="staexp">mytkind</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">)</span></span>
<span class="keyword">typedef</span> <span class="staexp">g2node1 <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>vt0p</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp">gnode1</span> <span class="keyword">(</span><span class="staexp">mytkind</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">)</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">(*
** HX: this is O(1)-time
*)</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
sllist_cons_ngc<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>nx<span class="keyword">:</span> <span class="staexp">g2node1</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> xs<span class="keyword">:</span> <span class="staexp">sllist</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span></span>
<span class="comment">// end of [sllist_cons_ngc]</span>

<span class="comment">(*
** HX: this is O(1)-time
*)</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
sllist_uncons_ngc<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>pos<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">-</span><span class="staexp">1</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">g2node1</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="comment">// end of [sllist_uncons_ngc]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">(*
** HX: this is O(n)-time
*)</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
sllist_snoc_ngc<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">sllist</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> nx<span class="keyword">:</span> <span class="staexp">g2node1</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span></span>
<span class="comment">// end of [sllist_snoc_ngc]</span>

<span class="comment">(*
** HX: this is O(n)-time
*)</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
sllist_unsnoc_ngc<span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>pos<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">-</span><span class="staexp">1</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">g2node1</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="comment">// end of [sllist_unsnoc_ngc]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">(* end of [sllist.sats] *)</span>
</pre>
<pre class="patsyntax">
<span class="comment">(***********************************************************************)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(*                         Applied Type System                         *)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(***********************************************************************)</span>

<span class="comment">(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">(*
**
** An list-based stack implementation
**
*)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">(*
**
** Author: Hongwei Xi
** Start time: March, 2017
** Authoremail: gmhwxiATgmailDOTcom
**
*)</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">#define</span>
ATS_PACKNAME
"ATSLIB.libats.stklist"</span>
<span class="comment">//</span>
<span class="comment">// HX-2017-03-28:</span>
<span class="neuexp"><span class="keyword">#define</span> <span class="comment">// prefix for external</span>
ATS_EXTERN_PREFIX "atslib_"</span> <span class="comment">// names</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="staexp"><span class="keyword">absvtype</span>
stklist_vtype
  <span class="keyword">(</span>a<span class="keyword">:</span> <span class="keyword">vt@ype+</span><span class="keyword">,</span> n<span class="keyword">:</span> int<span class="keyword">)</span> <span class="keyword">=</span> ptr</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="keyword">stadef</span>
<span class="staexp">stklist <span class="keyword">=</span> <span class="staexp">stklist_vtype</span></span>
<span class="comment">//</span>
<span class="keyword">vtypedef</span>
<span class="staexp">stklist
<span class="keyword">(</span>
  <span class="staexp">a<span class="keyword">:</span>vt0p</span>
<span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>n<span class="keyword">:</span>int<span class="keyword">]</span></span> <span class="staexp">stklist_vtype</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">praxi</span>
lemma_stklist_param
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>stk<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">stklist</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>n &gt;= 0<span class="keyword">]</span></span> <span class="staexp">void</span></span>
<span class="comment">// end of [lemma_stklist_param]</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
stklist_make_nil
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">stklist</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
stklist_getfree
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>stk<span class="keyword">:</span> <span class="staexp">stklist</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
stklist_is_nil
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>stk<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">stklist</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">bool</span><span class="keyword">(</span><span class="staexp">n</span><span class="staexp">==</span><span class="staexp">0</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
stklist_isnot_nil
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>stk<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">stklist</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">bool</span><span class="keyword">(</span><span class="staexp">n</span> <span class="staexp"><span class="keyword">&gt;</span></span> <span class="staexp">0</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
stklist_insert
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  stk<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">stklist</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">stklist</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span><span class="keyword">,</span> x0<span class="keyword">:</span> <span class="staexp">a</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span> <span class="comment">// endfun</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
stklist_takeout
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n <span class="keyword">&gt;</span> 0<span class="keyword">}</span></span>
<span class="keyword">(</span>
  stk<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">stklist</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">stklist</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">-</span><span class="staexp">1</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span> <span class="comment">// endfun</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
stklist_takeout_opt
  <span class="keyword">(</span>stk<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">stklist</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">Option_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="comment">// end of [stklist_takeout_opt]</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">(* end of [stklist.sats] *)</span>
</pre>
<pre class="patsyntax">
<span class="comment">(***********************************************************************)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(*                         Applied Type System                         *)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(***********************************************************************)</span>

<span class="comment">(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">(*
**
** An array-based stack implementation
**
*)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">(*
**
** Author: Hongwei Xi
** Start time: September, 2013
** Authoremail: gmhwxiATgmailDOTcom
**
*)</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">#define</span>
ATS_PACKNAME
"ATSLIB.libats.stkarray"</span>
<span class="comment">//</span>
<span class="comment">// HX-2017-03-28:</span>
<span class="neuexp"><span class="keyword">#define</span> <span class="comment">// prefix for external</span>
ATS_EXTERN_PREFIX "atslib_"</span> <span class="comment">// names</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="extcode"><span class="extcode">%{#
//
#include "libats/CATS/stkarray.cats"
//
%}</span></span> <span class="comment">// end of [%{#]</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="staexp"><span class="keyword">absvtype</span>
stkarray_vtype
  <span class="keyword">(</span>a<span class="keyword">:</span> <span class="keyword">vt@ype+</span><span class="keyword">,</span> m<span class="keyword">:</span> int<span class="keyword">,</span> n<span class="keyword">:</span> int<span class="keyword">)</span> <span class="keyword">=</span> ptr</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="keyword">stadef</span>
<span class="staexp">stkarray <span class="keyword">=</span> <span class="staexp">stkarray_vtype</span></span>
<span class="comment">//</span>
<span class="keyword">vtypedef</span>
<span class="staexp">stkarray
<span class="keyword">(</span>
  <span class="staexp">a<span class="keyword">:</span>vt0p</span>
<span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp"><span class="keyword">[</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">]</span></span> <span class="staexp">stkarray_vtype</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="staexp"><span class="keyword">abst@ype</span>
stkarray_tsize <span class="keyword">=</span> <span class="keyword">$extype</span>"atslib_stkarray_struct"</span>

<span class="comment">(* ****** ****** *)</span>

<span class="prfexp"><span class="keyword">praxi</span>
lemma_stkarray_param
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="staexp"><span class="keyword">!</span></span><span class="staexp">stkarray</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp"><span class="keyword">[</span>m &gt;= n<span class="keyword">;</span> n &gt;= 0<span class="keyword">]</span></span> <span class="staexp">void</span></span>
<span class="comment">// end of [lemma_stkarray_param]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
stkarray_make_cap
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>cap<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">stkarray</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span></span>
<span class="comment">// end of [stkarray_make_cap]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span>
stkarray_make_ngc_tsz
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>l<span class="keyword">:</span>addr<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  <span class="prfexp"><span class="staexp">stkarray_tsize</span><span class="staexp">?</span> <span class="staexp"><span class="keyword">@</span></span> <span class="staexp">l</span></span>
<span class="keyword">|</span> <span class="staexp">ptr</span><span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">arrayptr</span><span class="keyword">(</span><span class="staexp">a</span><span class="staexp">?</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">sizeof_t</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="staexp">mfree_ngc_v</span> <span class="keyword">(</span><span class="staexp">l</span><span class="keyword">)</span> <span class="keyword">|</span> <span class="staexp">stkarray</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
stkarray_free_nil
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>m<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>stk<span class="keyword">:</span> <span class="staexp">stkarray</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">// end of [stkarray_free_nil]</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
stkarray_getfree_arrayptr
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span><span class="staexp">stkarray</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">arrayptr</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">// end of [stkarray_getfree_arrayptr]</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
stkarray_get_size
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>stk<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">stkarray</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
stkarray_get_capacity
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>stk<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">stkarray</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span>
stkarray_get_ptrbeg<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>stk<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">stkarray</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">Ptr1</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">// end of [stkarray_get_ptrbeg]</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
stkarray_is_nil
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>stk<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">stkarray</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">bool</span><span class="keyword">(</span><span class="staexp">n</span><span class="staexp">==</span><span class="staexp">0</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span>
stkarray_isnot_nil
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>stk<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">stkarray</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">bool</span><span class="keyword">(</span><span class="staexp">n</span> <span class="staexp"><span class="keyword">&gt;</span></span> <span class="staexp">0</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
stkarray_is_full
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>stk<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">stkarray</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">bool</span><span class="keyword">(</span><span class="staexp">m</span><span class="staexp">==</span><span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>
<span class="dynexp"><span class="keyword">fun</span>
stkarray_isnot_full
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>stk<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">stkarray</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">bool</span><span class="keyword">(</span><span class="staexp">m</span> <span class="staexp"><span class="keyword">&gt;</span></span> <span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span><span class="keyword">}</span></span>
fprint_stkarray$sep<span class="keyword">(</span>out<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
fprint_stkarray
  <span class="keyword">(</span>out<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">,</span> stk<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">stkarray</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
fprint_stkarray_sep
  <span class="keyword">(</span>out<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">,</span> stk<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">stkarray</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> sep<span class="keyword">:</span> <span class="staexp">string</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="dynexp"><span class="keyword">overload</span> fprint <span class="keyword">with</span> fprint_stkarray</span>
<span class="dynexp"><span class="keyword">overload</span> fprint <span class="keyword">with</span> fprint_stkarray_sep</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
stkarray_insert
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int <span class="keyword">|</span> m <span class="keyword">&gt;</span> n<span class="keyword">}</span></span>
<span class="keyword">(</span>
  stk<span class="keyword">:</span>
  <span class="staexp"><span class="keyword">!</span></span><span class="staexp">stkarray</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">stkarray</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span>
<span class="keyword">,</span> elt<span class="keyword">:</span> <span class="staexp">a</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span> <span class="comment">// stkarray_insert</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
stkarray_insert_opt
  <span class="keyword">(</span>stk<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">stkarray</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">,</span> x0<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">Option_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="comment">// end of [stkarray_insert_opt]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
stkarray_takeout
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n <span class="keyword">&gt;</span> 0<span class="keyword">}</span></span>
<span class="keyword">(</span>
  stk<span class="keyword">:</span>
  <span class="staexp"><span class="keyword">!</span></span><span class="staexp">stkarray</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">stkarray</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">-</span><span class="staexp">1</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span> <span class="comment">// endfun</span>

<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
stkarray_takeout_opt
  <span class="keyword">(</span>stk<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">stkarray</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">Option_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="comment">// end of [stkarray_takeout_opt]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
stkarray_getref_top
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n <span class="keyword">&gt;</span> 0<span class="keyword">}</span></span>
  <span class="keyword">(</span>stk<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">stkarray</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">cPtr1</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="comment">// end of [stkarray_getref_top]</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">symintr</span> stkarray_getref_at</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
stkarray_getref_at_int
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i <span class="keyword">&lt;</span> n<span class="keyword">}</span></span>
  <span class="keyword">(</span>stk<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">stkarray</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">(</span><span class="staexp">i</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">cPtr1</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
stkarray_getref_at_size
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>i<span class="keyword">:</span>nat <span class="keyword">|</span> i <span class="keyword">&lt;</span> n<span class="keyword">}</span></span>
  <span class="keyword">(</span>stk<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">stkarray</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">i</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">cPtr1</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">overload</span> stkarray_getref_at <span class="keyword">with</span> stkarray_getref_at_int</span>
<span class="dynexp"><span class="keyword">overload</span> stkarray_getref_at <span class="keyword">with</span> stkarray_getref_at_size</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>env<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> stkarray_foreach$cont<span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">a</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">env</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">bool</span></span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>env<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> stkarray_foreach$fwork<span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">a</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="staexp">env</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> stkarray_foreach<span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>stk<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">stkarray</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">sizeLte</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>
a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>env<span class="keyword">:</span>vt0p
<span class="keyword">}</span></span> stkarray_foreach_env<span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>stk<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">stkarray</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="staexp">env</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">_</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">sizeLte</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="comment">(* end of [stkarray.sats] *)</span>
</pre>
<pre class="patsyntax">
<span class="comment">(***********************************************************************)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(*                         Applied Type System                         *)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(***********************************************************************)</span>

<span class="comment">(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">(* Author: Hongwei Xi *)</span>
<span class="comment">(* Authoremail: hwxi AT cs DOT bu DOT edu *)</span>
<span class="comment">(* Start time: December, 2012 *)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">staload</span>
UN <span class="keyword">=</span> "prelude/SATS/unsafe.sats"

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">staload</span> "libats/SATS/qlist.sats"

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp"><span class="keyword">}</span></span><span class="comment">(*tmp*)</span>
qlist_make_nil
  <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> pq <span class="keyword">where</span> <span class="keyword">{</span>
<span class="comment">//</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span>
    <span class="prfexp">pf</span><span class="keyword">,</span> <span class="prfexp">pfgc</span> <span class="keyword">|</span> p
  <span class="keyword">)</span> <span class="keyword">=</span> ptr_alloc&lt;<span class="staexp">qstruct</span><span class="keyword">&gt;</span> <span class="keyword">(</span><span class="keyword">)</span></span>
<span class="comment">//</span>
  <span class="dynexp"><span class="keyword">val</span> pq <span class="keyword">=</span> ptr2ptrlin <span class="keyword">(</span>p<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> qstruct_initize <span class="keyword">(</span><span class="keyword">!</span>p<span class="keyword">)</span></span>
<span class="comment">//</span>
  <span class="prfexp"><span class="keyword">prval</span> pfngc <span class="keyword">=</span> qstruct_objfize <span class="keyword">(</span><span class="prfexp">pf</span> <span class="keyword">|</span> pq<span class="keyword">)</span></span>
  <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="comment">(*freed*)</span><span class="keyword">)</span> <span class="keyword">=</span> mfree_gcngc_v_nullify <span class="keyword">(</span>pfgc<span class="keyword">,</span> pfngc<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">}</span></span> <span class="comment">(* end of [qlist_make] *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp"><span class="keyword">}</span></span><span class="comment">(*tmp*)</span>
qlist_free_nil
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="keyword">(</span>pq<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">where</span>
<span class="keyword">{</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> __mfree<span class="keyword">(</span>pq<span class="keyword">)</span> <span class="keyword">where</span>
<span class="keyword">{</span>
  <span class="keyword">extern</span> <span class="dynexp"><span class="keyword">fun</span> __mfree
    <span class="keyword">:</span> <span class="staexp">qlist</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">0</span><span class="keyword">,</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> "mac#atspre_mfree_gc"</span>
<span class="keyword">}</span></span> <span class="comment">// end of [where] // end of [val]</span>
<span class="comment">//</span>
<span class="keyword">}</span></span> <span class="comment">(* end of [qlist_free_nil] *)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
qlist_insert
  <span class="keyword">(</span>pq<span class="keyword">,</span> x<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> nx <span class="keyword">=</span>
mynode_make_elt&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>x<span class="keyword">)</span></span> <span class="keyword">in</span> qlist_insert_ngc&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>pq<span class="keyword">,</span> nx<span class="keyword">)</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [qlist_insert]</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
qstruct_insert
  <span class="keyword">(</span>que<span class="keyword">,</span> x<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> pq <span class="keyword">=</span> <span class="dynexp"><span class="keyword">addr@</span></span><span class="keyword">(</span>que<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> pq2 <span class="keyword">=</span> ptr2ptrlin<span class="keyword">(</span>pq<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span>
pfngc <span class="keyword">=</span>
qstruct_objfize<span class="keyword">(</span><span class="prfexp"><span class="dynexp"><span class="keyword">view@</span></span><span class="keyword">(</span>que<span class="keyword">)</span></span><span class="keyword">|</span>pq2<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> qlist_insert&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>pq2<span class="keyword">,</span> x<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span> pfat <span class="keyword">=</span> qstruct_unobjfize<span class="keyword">(</span><span class="prfexp">pfngc</span> <span class="keyword">|</span> pq<span class="keyword">,</span> pq2<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">(</span><span class="dynexp"><span class="keyword">view@</span></span><span class="keyword">(</span>que<span class="keyword">)</span> := pfat<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> ptrlin_free<span class="keyword">(</span>pq2<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">in</span>
  <span class="comment">// nothing</span>
<span class="keyword">end</span></span></span> <span class="comment">// end of [qstruct_insert]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
qlist_takeout<span class="keyword">(</span>pq<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> nx0 <span class="keyword">=</span>
qlist_takeout_ngc<span class="keyword">(</span>pq<span class="keyword">)</span></span> <span class="keyword">in</span> mynode_getfree_elt&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>nx0<span class="keyword">)</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [qlist_takeout]</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
qlist_takeout_opt<span class="keyword">(</span>pq<span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">(</span>
<span class="keyword">if</span> qlist_isnot_nil<span class="keyword">(</span>pq<span class="keyword">)</span>
  <span class="keyword">then</span> Some_vt<span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="keyword">(</span>qlist_takeout<span class="keyword">(</span>pq<span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">else</span> None_vt<span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="keyword">(</span><span class="keyword">)</span>
<span class="comment">// end of [if]</span>
<span class="keyword">)</span></span> <span class="comment">// end of [qlist_takeout_opt]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
qstruct_takeout
  <span class="keyword">(</span>que<span class="keyword">)</span> <span class="keyword">=</span> res <span class="keyword">where</span>
<span class="keyword">{</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> pq <span class="keyword">=</span> <span class="dynexp"><span class="keyword">addr@</span></span><span class="keyword">(</span>que<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> pq2 <span class="keyword">=</span> ptr2ptrlin<span class="keyword">(</span>pq<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span>
pfngc <span class="keyword">=</span>
qstruct_objfize<span class="keyword">(</span><span class="prfexp"><span class="dynexp"><span class="keyword">view@</span></span><span class="keyword">(</span>que<span class="keyword">)</span></span><span class="keyword">|</span>pq2<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> res <span class="keyword">=</span> qlist_takeout&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>pq2<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span> pfat <span class="keyword">=</span> qstruct_unobjfize<span class="keyword">(</span><span class="prfexp">pfngc</span> <span class="keyword">|</span> pq<span class="keyword">,</span> pq2<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">(</span><span class="dynexp"><span class="keyword">view@</span></span><span class="keyword">(</span>que<span class="keyword">)</span> := pfat<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> ptrlin_free<span class="keyword">(</span>pq2<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">}</span></span> <span class="comment">// end of [qstruct_takeout]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">stadef</span> <span class="staexp">mykind <span class="keyword">=</span> <span class="staexp"><span class="keyword">$extkind</span>"atslib_qlist"</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">datavtype</span>
<span class="staexp">qlist_data<span class="keyword">(</span>a<span class="keyword">:</span><span class="keyword">vt@ype+</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp">QLIST <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">ptr</span><span class="keyword">,</span> <span class="staexp">ptr</span><span class="keyword">)</span></span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="staexp"><span class="keyword">assume</span>
qlist_vtype<span class="keyword">(</span>a<span class="keyword">:</span> vt0p<span class="keyword">,</span> n<span class="keyword">:</span> int<span class="keyword">)</span> <span class="keyword">=</span> qlist_data<span class="keyword">(</span>a<span class="keyword">)</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
qlist_is_nil
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span> <span class="keyword">(</span>pq<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val+</span><span class="keyword">@</span>QLIST <span class="keyword">(</span>nxf<span class="keyword">,</span> p_nxr<span class="keyword">)</span> <span class="keyword">=</span> pq</span>
<span class="dynexp"><span class="keyword">val</span> isnil <span class="keyword">=</span> <span class="keyword">(</span><span class="dynexp"><span class="keyword">addr@</span></span><span class="keyword">(</span>nxf<span class="keyword">)</span> <span class="keyword">=</span> p_nxr<span class="keyword">)</span></span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>pq<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  $UN<span class="keyword">.</span>cast<span class="staexp"><span class="keyword">{</span>bool<span class="keyword">(</span>n==0<span class="keyword">)</span><span class="keyword">}</span></span><span class="keyword">(</span>isnil<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [qlist_is_nil]</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
qlist_isnot_nil
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span> <span class="keyword">(</span>pq<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val+</span><span class="keyword">@</span>QLIST <span class="keyword">(</span>nxf<span class="keyword">,</span> p_nxr<span class="keyword">)</span> <span class="keyword">=</span> pq</span>
<span class="dynexp"><span class="keyword">val</span> isnot <span class="keyword">=</span> <span class="keyword">(</span><span class="dynexp"><span class="keyword">addr@</span></span><span class="keyword">(</span>nxf<span class="keyword">)</span> != p_nxr<span class="keyword">)</span></span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="comment">(*prf*)</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>pq<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  $UN<span class="keyword">.</span>cast<span class="staexp"><span class="keyword">{</span>bool<span class="keyword">(</span>n <span class="keyword">&gt;</span> 0<span class="keyword">)</span><span class="keyword">}</span></span><span class="keyword">(</span>isnot<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [qlist_isnot_nil]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
qlist_length
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span> <span class="keyword">(</span>pq<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="keyword">{</span> <span class="staexp">env</span> <span class="keyword">}</span>
qlist_foreach$cont<span class="keyword">(</span>x<span class="keyword">,</span> env<span class="keyword">)</span> <span class="keyword">=</span> true</span>
<span class="dynexp"><span class="keyword">implement</span>
qlist_foreach$fwork&lt;<span class="staexp">a</span><span class="keyword">&gt;&lt;</span><span class="staexp">int</span><span class="keyword">&gt;</span><span class="keyword">(</span>x<span class="keyword">,</span> env<span class="keyword">)</span> <span class="keyword">=</span> env := env+<span class="dynexp">1</span></span>
<span class="comment">//</span>
<span class="keyword">var</span> env<span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="dynexp">0</span><span class="keyword">)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">$effmask_all</span><span class="keyword">(</span>qlist_foreach_env&lt;<span class="staexp">a</span><span class="keyword">&gt;&lt;</span><span class="staexp">int</span><span class="keyword">&gt;</span><span class="keyword">(</span>pq<span class="keyword">,</span> env<span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  $UN<span class="keyword">.</span>cast<span class="staexp"><span class="keyword">{</span>int<span class="keyword">(</span>n<span class="keyword">)</span><span class="keyword">}</span></span><span class="keyword">(</span>env<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [qlist_length]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp"><span class="keyword">}</span></span><span class="comment">(*tmp*)</span>
fprint_qlist$sep
  <span class="keyword">(</span>out<span class="keyword">)</span> <span class="keyword">=</span> fprint_string <span class="keyword">(</span>out<span class="keyword">,</span> <span class="dynstr">"-&gt;"</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
fprint_qlist
  <span class="keyword">(</span>out<span class="keyword">,</span> pq<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="keyword">{</span> <span class="staexp">env</span> <span class="keyword">}</span>
qlist_foreach$cont
  <span class="keyword">(</span>x<span class="keyword">,</span> env<span class="keyword">)</span> <span class="keyword">=</span> true</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
qlist_foreach$fwork&lt;<span class="staexp">a</span><span class="keyword">&gt;&lt;</span><span class="staexp">int</span><span class="keyword">&gt;</span>
  <span class="keyword">(</span>x0<span class="keyword">,</span> env<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">if</span> env <span class="keyword">&gt;</span> <span class="dynexp">0</span>
    <span class="keyword">then</span> fprint_qlist$sep&lt;<span class="keyword">&gt;</span><span class="keyword">(</span>out<span class="keyword">)</span></span>
  <span class="comment">// end of [if]</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>env := env + <span class="dynexp">1</span><span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_ref&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>out<span class="keyword">,</span> x0<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">in</span>
  <span class="comment">// nothing</span>
<span class="keyword">end</span></span></span> <span class="comment">// end of [qlist_foreach$fwork]</span>
<span class="comment">//</span>
<span class="keyword">var</span> env<span class="keyword">:</span> <span class="staexp">int</span> <span class="keyword">=</span> <span class="dynexp">0</span>
<span class="comment">//</span>
<span class="keyword">in</span>
  qlist_foreach_env&lt;<span class="staexp">a</span><span class="keyword">&gt;&lt;</span><span class="staexp">int</span><span class="keyword">&gt;</span><span class="keyword">(</span>pq<span class="keyword">,</span> env<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [fprint_qlist]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
fprint_qlist_sep
  <span class="keyword">(</span>out<span class="keyword">,</span> pq<span class="keyword">,</span> sep<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp"><span class="keyword">}</span></span><span class="comment">(* tmp *)</span>
fprint_qlist$sep <span class="keyword">(</span>out<span class="keyword">)</span> <span class="keyword">=</span> fprint_string <span class="keyword">(</span>out<span class="keyword">,</span> sep<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  fprint_qlist&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>out<span class="keyword">,</span> pq<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [fprint_qlist_sep]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="keyword">{</span> <span class="staexp">env</span> <span class="keyword">}</span>
qlist_foreach$cont<span class="keyword">(</span>_x_<span class="keyword">,</span> env<span class="keyword">)</span> <span class="keyword">=</span> true</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
qlist_foreach<span class="keyword">(</span>pq<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="keyword">var</span>
env<span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">in</span> qlist_foreach_env&lt;<span class="staexp">a</span><span class="keyword">&gt;&lt;</span><span class="staexp">void</span><span class="keyword">&gt;</span><span class="keyword">(</span>pq<span class="keyword">,</span> env<span class="keyword">)</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [qlist_foreach]</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="keyword">{</span> <span class="staexp">env</span> <span class="keyword">}</span>
qlist_foreach_env
  <span class="keyword">(</span>pq<span class="keyword">,</span> env<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> loop
<span class="keyword">(</span>
  p_nxf<span class="keyword">:</span> <span class="staexp">ptr</span><span class="keyword">,</span> p_nxr<span class="keyword">:</span> <span class="staexp">ptr</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">env</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">if</span> p_nxf != p_nxr <span class="keyword">then</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> xs <span class="keyword">=</span>
  $UN<span class="keyword">.</span>ptr0_get&lt;<span class="staexp">List1_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">&gt;</span><span class="keyword">(</span>p_nxf<span class="keyword">)</span></span>
<span class="comment">// end of [val]</span>
<span class="dynexp"><span class="keyword">val+</span><span class="keyword">@</span>list_vt_cons<span class="keyword">(</span>x1<span class="keyword">,</span> xs2<span class="keyword">)</span> <span class="keyword">=</span> xs</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> test <span class="keyword">=</span>
  qlist_foreach$cont&lt;<span class="staexp">a</span><span class="keyword">&gt;&lt;</span><span class="staexp">env</span><span class="keyword">&gt;</span><span class="keyword">(</span>x1<span class="keyword">,</span> env<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">(</span>
<span class="comment">//</span>
<span class="keyword">if</span>
test
<span class="keyword">then</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
qlist_foreach$fwork&lt;<span class="staexp">a</span><span class="keyword">&gt;&lt;</span><span class="staexp">env</span><span class="keyword">&gt;</span><span class="keyword">(</span>x1<span class="keyword">,</span> env<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  loop<span class="keyword">(</span><span class="dynexp"><span class="keyword">addr@</span></span><span class="keyword">(</span>xs2<span class="keyword">)</span><span class="keyword">,</span> p_nxr<span class="keyword">,</span> env<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [then] // end of [if]</span>
<span class="comment">//</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span></span> <span class="comment">// end of [val]</span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="comment">(*proof*)</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>xs<span class="keyword">)</span></span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="comment">(*proof*)</span><span class="keyword">)</span> <span class="keyword">=</span> $UN<span class="keyword">.</span>cast2void<span class="keyword">(</span>xs<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">in</span>
  <span class="comment">// nothing</span>
<span class="keyword">end</span></span> <span class="keyword">else</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="comment">// end of [if]</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [loop]</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val+</span><span class="keyword">@</span>QLIST<span class="keyword">(</span>nxf<span class="keyword">,</span> p_nxr<span class="keyword">)</span> <span class="keyword">=</span> pq</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> loop<span class="keyword">(</span><span class="dynexp"><span class="keyword">addr@</span></span><span class="keyword">(</span>nxf<span class="keyword">)</span><span class="keyword">,</span> p_nxr<span class="keyword">,</span> env<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="comment">(*folded*)</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span><span class="keyword">(</span>pq<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">in</span>
  <span class="comment">// nothing</span>
<span class="keyword">end</span></span></span> <span class="comment">// end of [qlist_foreach_env]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp"><span class="keyword">}</span></span><span class="comment">(* tmp *)</span>
qstruct_initize
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="keyword">(</span>que<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> pq <span class="keyword">=</span>
$UN<span class="keyword">.</span>castvwtp0
  <span class="staexp"><span class="keyword">{</span>qlist<span class="keyword">(</span>a<span class="keyword">,</span>0<span class="keyword">)</span><span class="keyword">}</span></span><span class="keyword">(</span><span class="dynexp"><span class="keyword">addr@</span></span><span class="keyword">(</span>que<span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">// end of [val]</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val+</span><span class="keyword">@</span>QLIST<span class="keyword">(</span>nxf<span class="keyword">,</span> p_nxr<span class="keyword">)</span> <span class="keyword">=</span> pq</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>p_nxr := <span class="dynexp"><span class="keyword">addr@</span></span> <span class="keyword">(</span>nxf<span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span><span class="keyword">(</span>pq<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
__assert<span class="keyword">(</span>que<span class="keyword">,</span> pq<span class="keyword">)</span> <span class="keyword">where</span>
<span class="keyword">{</span>
  <span class="keyword">extern</span> <span class="prfexp"><span class="keyword">praxi</span>
    __assert <span class="keyword">(</span>que<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">qstruct</span><span class="staexp">?</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">qstruct</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span><span class="keyword">,</span> pq<span class="keyword">:</span> <span class="staexp">qlist</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">0</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
  <span class="comment">// end of [extern]</span>
<span class="keyword">}</span></span> <span class="comment">// end of [where] // end of [prval]</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">in</span>
  <span class="comment">(* DoNothing *)</span>
<span class="keyword">end</span></span></span> <span class="comment">// end of [qstruct_initize]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">castfn</span>
mynode1_encode
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">List1_vt</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">mynode1</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="comment">// end of [mynode1_encode]</span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">castfn</span>
mynode1_decode
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
  <span class="keyword">(</span>nx<span class="keyword">:</span> <span class="staexp">mynode1</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">List1_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="comment">// end of [mynode1_decode]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp"><span class="keyword">}</span></span><span class="comment">(*tmp*)</span>
mynode_null<span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
  $UN<span class="keyword">.</span>castvwtp0<span class="staexp"><span class="keyword">{</span>mynode<span class="keyword">(</span>a<span class="keyword">,</span>null<span class="keyword">)</span><span class="keyword">}</span></span><span class="keyword">(</span>list_vt_nil<span class="keyword">)</span></span>
<span class="comment">// end of [mynode_null]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
mynode_make_elt <span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">=</span>
  $UN<span class="keyword">.</span>castvwtp0<span class="staexp"><span class="keyword">{</span>mynode1<span class="keyword">(</span>a<span class="keyword">)</span><span class="keyword">}</span></span><span class="keyword">(</span>list_vt_cons<span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>0<span class="keyword">}</span></span><span class="keyword">(</span>x<span class="keyword">,</span> _<span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">// end of [mynode_make_elt]</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
mynode_free_elt
  <span class="keyword">(</span>nx<span class="keyword">,</span> res<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">where</span>
<span class="keyword">{</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> xs <span class="keyword">=</span>
  mynode1_decode<span class="keyword">(</span>nx<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val+</span><span class="keyword">~</span>list_vt_cons<span class="keyword">(</span>x1<span class="keyword">,</span> xs2<span class="keyword">)</span> <span class="keyword">=</span> xs</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>res := x1<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
__assert <span class="keyword">(</span>xs2<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="keyword">extern</span> <span class="prfexp"><span class="keyword">praxi</span> __assert <span class="keyword">:</span> <span class="staexp"><span class="keyword">{</span>vt<span class="keyword">:</span>vtype<span class="keyword">}</span></span> <span class="keyword">(</span><span class="staexp">vt</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">prf</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span>
<span class="keyword">}</span></span> <span class="comment">// end of [where] // end of [prval]</span>
<span class="comment">//</span>
<span class="keyword">}</span></span> <span class="comment">(* end of [mynode_free_elt] *)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
mynode_getfree_elt
  <span class="keyword">(</span>nx<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>x1<span class="keyword">)</span> <span class="keyword">where</span>
<span class="keyword">{</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> xs <span class="keyword">=</span>
  mynode1_decode<span class="keyword">(</span>nx<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val+</span><span class="keyword">~</span>list_vt_cons<span class="keyword">(</span>x1<span class="keyword">,</span> xs2<span class="keyword">)</span> <span class="keyword">=</span> xs</span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
__assert<span class="keyword">(</span>xs2<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
  <span class="keyword">extern</span> <span class="prfexp"><span class="keyword">praxi</span> __assert <span class="keyword">:</span> <span class="staexp"><span class="keyword">{</span>vt<span class="keyword">:</span>vtype<span class="keyword">}</span></span> <span class="keyword">(</span><span class="staexp">vt</span><span class="keyword">)</span> <span class="keyword">-&lt;</span><span class="staexp">prf</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span>
<span class="keyword">}</span></span> <span class="comment">// end of [where] // end of [prval]</span>
<span class="comment">//</span>
<span class="keyword">}</span></span> <span class="comment">(* end of [mynode_getfree_elt] *)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
qlist_insert_ngc
  <span class="keyword">(</span>pq<span class="keyword">,</span> nx0<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val+</span><span class="keyword">@</span>QLIST<span class="keyword">(</span>nxf<span class="keyword">,</span> p_nxr<span class="keyword">)</span> <span class="keyword">=</span> pq</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> xs <span class="keyword">=</span> mynode1_decode<span class="keyword">(</span>nx0<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val+</span><span class="keyword">@</span>list_vt_cons<span class="keyword">(</span>_<span class="keyword">,</span> xs2<span class="keyword">)</span> <span class="keyword">=</span> xs</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> p2_nxr <span class="keyword">=</span> <span class="dynexp"><span class="keyword">addr@</span></span><span class="keyword">(</span>xs2<span class="keyword">)</span></span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="comment">(*folded*)</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span><span class="keyword">(</span>xs<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> nx0 <span class="keyword">=</span> mynode1_encode<span class="keyword">(</span>xs<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> $UN<span class="keyword">.</span>ptr0_set&lt;<span class="staexp">mynode1</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">&gt;</span><span class="keyword">(</span>p_nxr<span class="keyword">,</span> nx0<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>p_nxr := p2_nxr<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="comment">(*folded*)</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>pq<span class="keyword">)</span></span>
<span class="comment">//  </span>
<span class="dynexp"><span class="keyword">in</span>
  <span class="comment">// nothing</span>
<span class="keyword">end</span></span></span> <span class="comment">// end of [qlist_insert_ngc]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
qlist_takeout_ngc
  <span class="keyword">(</span>q0<span class="keyword">)</span> <span class="keyword">=</span> nx0 <span class="keyword">where</span>
<span class="keyword">{</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val+</span><span class="keyword">@</span>QLIST<span class="keyword">(</span>nxf<span class="keyword">,</span> p_nxr<span class="keyword">)</span> <span class="keyword">=</span> q0</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> nx0 <span class="keyword">=</span>
$UN<span class="keyword">.</span>castvwtp0<span class="staexp"><span class="keyword">{</span>mynode1<span class="keyword">(</span>a<span class="keyword">)</span><span class="keyword">}</span></span><span class="keyword">(</span>nxf<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> xs <span class="keyword">=</span> mynode1_decode<span class="keyword">(</span>nx0<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val+</span><span class="keyword">@</span>list_vt_cons <span class="keyword">(</span>_<span class="keyword">,</span> xs2<span class="keyword">)</span> <span class="keyword">=</span> xs</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> p2_nxr <span class="keyword">=</span> <span class="dynexp"><span class="keyword">addr@</span></span><span class="keyword">(</span>xs2<span class="keyword">)</span></span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="comment">(*folded*)</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span><span class="keyword">(</span>xs<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> nx0 <span class="keyword">=</span> mynode1_encode<span class="keyword">(</span>xs<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">(</span>
<span class="comment">//</span>
<span class="keyword">if</span>
<span class="keyword">(</span>p_nxr != p2_nxr<span class="keyword">)</span>
<span class="keyword">then</span>
<span class="keyword">(</span>
nxf := $UN<span class="keyword">.</span>ptr0_get&lt;<span class="staexp">ptr</span><span class="keyword">&gt;</span><span class="keyword">(</span>p2_nxr<span class="keyword">)</span>
<span class="keyword">)</span> <span class="comment">(* end of [then] *)</span>
<span class="keyword">else</span> p_nxr := <span class="dynexp"><span class="keyword">addr@</span></span><span class="keyword">(</span>nxf<span class="keyword">)</span>
<span class="comment">//</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span></span> <span class="comment">// end of [val]</span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="comment">(*folded*)</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>q0<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">}</span></span> <span class="comment">// end of [qlist_takeout_ngc]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp"><span class="keyword">}</span></span><span class="comment">(* tmp *)</span>
qlist_takeout_list
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span><span class="keyword">(</span>pq<span class="keyword">)</span> <span class="keyword">=</span> xs <span class="keyword">where</span>
<span class="keyword">{</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val+</span><span class="keyword">@</span>QLIST<span class="keyword">(</span>nxf<span class="keyword">,</span> p_nxr<span class="keyword">)</span> <span class="keyword">=</span> pq</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
$UN<span class="keyword">.</span>ptr0_set&lt;<span class="staexp">ptr</span><span class="keyword">&gt;</span><span class="keyword">(</span>p_nxr<span class="keyword">,</span> the_null_ptr<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> xs <span class="keyword">=</span> $UN<span class="keyword">.</span>castvwtp0<span class="staexp"><span class="keyword">{</span>list_vt<span class="keyword">(</span>a<span class="keyword">,</span>n<span class="keyword">)</span><span class="keyword">}</span></span><span class="keyword">(</span>nxf<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> p_nxr := <span class="dynexp"><span class="keyword">addr@</span></span><span class="keyword">(</span>nxf<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="comment">(*folded*)</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span><span class="keyword">(</span>pq<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">}</span></span> <span class="comment">// end of [qlist_takeout_list]</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp"><span class="keyword">}</span></span><span class="comment">(* tmp *)</span>
qstruct_takeout_list
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span><span class="keyword">(</span>que<span class="keyword">)</span> <span class="keyword">=</span> xs <span class="keyword">where</span>
<span class="keyword">{</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> pq <span class="keyword">=</span> <span class="dynexp"><span class="keyword">addr@</span></span><span class="keyword">(</span>que<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> pq2 <span class="keyword">=</span> ptr2ptrlin <span class="keyword">(</span>pq<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span>
pfngc <span class="keyword">=</span>
qstruct_objfize<span class="keyword">(</span><span class="prfexp"><span class="dynexp"><span class="keyword">view@</span></span><span class="keyword">(</span>que<span class="keyword">)</span></span><span class="keyword">|</span>pq2<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> xs <span class="keyword">=</span> qlist_takeout_list<span class="keyword">(</span>pq2<span class="keyword">)</span></span>
<span class="prfexp"><span class="keyword">prval</span> pfat <span class="keyword">=</span> qstruct_unobjfize<span class="keyword">(</span><span class="prfexp">pfngc</span> <span class="keyword">|</span> pq<span class="keyword">,</span> pq2<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">(</span><span class="dynexp"><span class="keyword">view@</span></span><span class="keyword">(</span>que<span class="keyword">)</span> := pfat<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> ptrlin_free <span class="keyword">(</span>pq2<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">}</span></span> <span class="comment">(* end of [qstruct_takeout_list] *)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">(* end of [qlist.dats] *)</span>
</pre>
<pre class="patsyntax">
<span class="comment">(***********************************************************************)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(*                         Applied Type System                         *)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(***********************************************************************)</span>

<span class="comment">(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">(* Author: Hongwei Xi *)</span>
<span class="comment">(* Authoremail: hwxi AT cs DOT bu DOT edu *)</span>
<span class="comment">(* Start time: March, 2013 *)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">staload</span>
UN <span class="keyword">=</span> "prelude/SATS/unsafe.sats"

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">staload</span> "libats/SATS/gnode.sats"

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">staload</span> "libats/SATS/sllist.sats"

<span class="comment">(* ****** ****** *)</span>

<span class="neuexp"><span class="keyword">#define</span> nullp the_null_ptr</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
g2node_make_elt
  <span class="keyword">(</span>x<span class="keyword">:</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">g2node1</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>t0p<span class="keyword">}</span></span> <span class="comment">// [a] is nonlinear</span>
g2node_free
  <span class="keyword">(</span>nx<span class="keyword">:</span> <span class="staexp">g2node1</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span>
<span class="comment">//</span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span> <span class="comment">// [a] may be linear</span>
g2node_freelin
  <span class="keyword">(</span>nx<span class="keyword">:</span> <span class="staexp">g2node1</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
g2node_free_elt
<span class="keyword">(</span>
nx<span class="keyword">:</span> <span class="staexp">g2node1</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> res<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="keyword">(</span><span class="staexp">a</span><span class="staexp">?</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">a</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span></span> <span class="comment">// end-of-function</span>
<span class="comment">//</span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
g2node_getfree_elt<span class="keyword">(</span>nx<span class="keyword">:</span> <span class="staexp">g2node1</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">castfn</span>
sllist0_encode
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>nx<span class="keyword">:</span> <span class="staexp">g2node0</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">sllist</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">castfn</span>
sllist0_decode
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">sllist</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">g2node0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">castfn</span>
sllist1_encode
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n <span class="keyword">&gt;</span> 0<span class="keyword">}</span></span>
  <span class="keyword">(</span>nx<span class="keyword">:</span> <span class="staexp">g2node1</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">sllist</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span></span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">castfn</span>
sllist1_decode
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">:</span>int <span class="keyword">|</span> n <span class="keyword">&gt;</span> 0<span class="keyword">}</span></span>
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">sllist</span><span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">g2node1</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp"><span class="keyword">}</span></span><span class="comment">(*tmp*)</span>
sllist_nil<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> sllist0_encode<span class="keyword">(</span>gnode_null<span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
sllist_sing<span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">=</span> sllist_cons&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>x<span class="keyword">,</span> sllist_nil<span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
sllist_cons
  <span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> nx <span class="keyword">=</span>
g2node_make_elt&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>x<span class="keyword">)</span></span> <span class="keyword">in</span> sllist_cons_ngc&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>nx<span class="keyword">,</span> xs<span class="keyword">)</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [sllist_cons]</span>

<span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span>
sllist_uncons
  <span class="keyword">(</span>xs<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> nx0 <span class="keyword">=</span>
sllist_uncons_ngc&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>xs<span class="keyword">)</span></span> <span class="keyword">in</span> g2node_getfree_elt&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>nx0<span class="keyword">)</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [sllist_uncons]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
sllist_snoc
  <span class="keyword">(</span>xs<span class="keyword">,</span> x<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> nx <span class="keyword">=</span> g2node_make_elt&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">)</span></span> <span class="keyword">in</span> sllist_snoc_ngc <span class="keyword">(</span>xs<span class="keyword">,</span> nx<span class="keyword">)</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [sllist_snoc]</span>

<span class="dynexp"><span class="keyword">implement</span><span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span>
sllist_unsnoc
  <span class="keyword">(</span>xs<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> nx0 <span class="keyword">=</span> sllist_unsnoc_ngc <span class="keyword">(</span>xs<span class="keyword">)</span></span> <span class="keyword">in</span> g2node_getfree_elt&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>nx0<span class="keyword">)</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [sllist_unsnoc]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
sllist_make_list
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span><span class="keyword">(</span>xs<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> loop <span class="keyword">(</span>
  nx0<span class="keyword">:</span> <span class="staexp">g2node1</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> xs<span class="keyword">:</span> <span class="staexp">List</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">case+</span> xs <span class="keyword">of</span>
<span class="keyword">|</span> list_cons
    <span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> nx1 <span class="keyword">=</span> g2node_make_elt&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">)</span></span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> gnode_link11 <span class="keyword">(</span>nx0<span class="keyword">,</span> nx1<span class="keyword">)</span></span>
  <span class="keyword">in</span>
    loop <span class="keyword">(</span>nx1<span class="keyword">,</span> xs<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [loop]</span>
<span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> gnode_set_next_null <span class="keyword">(</span>nx0<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">in</span>
    <span class="comment">// nothing</span>
  <span class="keyword">end</span></span> <span class="comment">// end of [list_nil]</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [loop]</span>
<span class="comment">//</span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">case+</span> xs <span class="keyword">of</span>
<span class="keyword">|</span> list_cons
    <span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> nx0 <span class="keyword">=</span> g2node_make_elt&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x<span class="keyword">)</span></span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">$effmask_all</span> <span class="keyword">(</span>loop <span class="keyword">(</span>nx0<span class="keyword">,</span> xs<span class="keyword">)</span><span class="keyword">)</span></span>
  <span class="keyword">in</span>
    sllist0_encode <span class="keyword">(</span>nx0<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [list_cons]</span>
<span class="keyword">|</span> list_nil <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> sllist_nil <span class="keyword">(</span><span class="keyword">)</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [sllist_make_list]</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
sllist_make_list_vt
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span><span class="keyword">(</span>xs<span class="keyword">)</span> <span class="keyword">=</span> $UN<span class="keyword">.</span>castvwtp0<span class="staexp"><span class="keyword">{</span>sllist<span class="keyword">(</span>a<span class="keyword">,</span>n<span class="keyword">)</span><span class="keyword">}</span></span><span class="keyword">(</span>xs<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp"><span class="keyword">}</span></span><span class="comment">(*tmp*)</span>
sllist_is_nil
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> nxs <span class="keyword">=</span> $UN<span class="keyword">.</span>castvwtp1<span class="staexp"><span class="keyword">{</span>g2node0<span class="keyword">(</span>a<span class="keyword">)</span><span class="keyword">}</span></span><span class="keyword">(</span>xs<span class="keyword">)</span></span>
<span class="keyword">in</span>
  $UN<span class="keyword">.</span>cast<span class="staexp"><span class="keyword">{</span>bool<span class="keyword">(</span>n==0<span class="keyword">)</span><span class="keyword">}</span></span><span class="keyword">(</span>gnodelst_is_nil <span class="keyword">(</span>nxs<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [sllist_is_nil]</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp"><span class="keyword">}</span></span><span class="comment">(*tmp*)</span>
sllist_is_cons
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> nxs <span class="keyword">=</span> $UN<span class="keyword">.</span>castvwtp1<span class="staexp"><span class="keyword">{</span>g2node0<span class="keyword">(</span>a<span class="keyword">)</span><span class="keyword">}</span></span><span class="keyword">(</span>xs<span class="keyword">)</span></span>
<span class="keyword">in</span>
  $UN<span class="keyword">.</span>cast<span class="staexp"><span class="keyword">{</span>bool<span class="keyword">(</span>n <span class="keyword">&gt;</span> 0<span class="keyword">)</span><span class="keyword">}</span></span><span class="keyword">(</span>gnodelst_is_cons <span class="keyword">(</span>nxs<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [sllist_is_cons]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">(*
fun{a:vt0p}
sllist_length
  {n:int} (xs: !sllist (INV(a), n)):&lt;&gt; int (n)
*)</span>
<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
sllist_length
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> nxs <span class="keyword">=</span> $UN<span class="keyword">.</span>castvwtp1<span class="staexp"><span class="keyword">{</span>g2node0<span class="keyword">(</span>a<span class="keyword">)</span><span class="keyword">}</span></span><span class="keyword">(</span>xs<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  $UN<span class="keyword">.</span>cast<span class="staexp"><span class="keyword">{</span>int<span class="keyword">(</span>n<span class="keyword">)</span><span class="keyword">}</span></span><span class="keyword">(</span>gnodelst_length <span class="keyword">(</span>nxs<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [sllist_length]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
sllist_get_elt
  <span class="keyword">(</span>xs<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> p_elt <span class="keyword">=</span>
    sllist_getref_elt <span class="keyword">(</span>xs<span class="keyword">)</span></span> <span class="keyword">in</span> $UN<span class="keyword">.</span>cptr_get&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>p_elt<span class="keyword">)</span>
  <span class="comment">// end of [val]</span>
<span class="keyword">end</span></span> <span class="comment">// end of [sllist_get_elt]</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
sllist_set_elt
  <span class="keyword">(</span>xs<span class="keyword">,</span> x0<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> p_elt <span class="keyword">=</span> 
    sllist_getref_elt <span class="keyword">(</span>xs<span class="keyword">)</span></span> <span class="keyword">in</span> $UN<span class="keyword">.</span>cptr_set&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>p_elt<span class="keyword">,</span> x0<span class="keyword">)</span>
  <span class="comment">// end of [val]</span>
<span class="keyword">end</span></span> <span class="comment">// end of [sllist_set_elt]</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
sllist_getref_elt <span class="keyword">(</span>xs<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> nxs <span class="keyword">=</span>
    $UN<span class="keyword">.</span>castvwtp1<span class="staexp"><span class="keyword">{</span>g2node1<span class="keyword">(</span>a<span class="keyword">)</span><span class="keyword">}</span></span><span class="keyword">(</span>xs<span class="keyword">)</span></span> <span class="keyword">in</span> gnode_getref_elt <span class="keyword">(</span>nxs<span class="keyword">)</span>
  <span class="comment">// end of [val]</span>
<span class="keyword">end</span></span> <span class="comment">// end of [sllist_getref_elt]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
sllist_getref_next <span class="keyword">(</span>xs<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> nxs <span class="keyword">=</span>
    $UN<span class="keyword">.</span>castvwtp1<span class="staexp"><span class="keyword">{</span>g2node1<span class="keyword">(</span>a<span class="keyword">)</span><span class="keyword">}</span></span><span class="keyword">(</span>xs<span class="keyword">)</span></span> <span class="keyword">in</span> cptr2ptr <span class="keyword">(</span>gnode_getref_next <span class="keyword">(</span>nxs<span class="keyword">)</span><span class="keyword">)</span>
  <span class="comment">// end of [val]  </span>
<span class="keyword">end</span></span> <span class="comment">// end of [sllist_getref_next]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
sllist_get_elt_at
  <span class="keyword">(</span>xs<span class="keyword">,</span> i<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> p_elt <span class="keyword">=</span>
    sllist_getref_elt_at <span class="keyword">(</span>xs<span class="keyword">,</span> i<span class="keyword">)</span></span> <span class="keyword">in</span> $UN<span class="keyword">.</span>cptr_get&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>p_elt<span class="keyword">)</span>
  <span class="comment">// end of [val]</span>
<span class="keyword">end</span></span> <span class="comment">// end of [sllist_get_elt_at]</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
sllist_set_elt_at
  <span class="keyword">(</span>xs<span class="keyword">,</span> i<span class="keyword">,</span> x0<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> p_elt <span class="keyword">=</span> 
    sllist_getref_elt_at <span class="keyword">(</span>xs<span class="keyword">,</span> i<span class="keyword">)</span></span> <span class="keyword">in</span> $UN<span class="keyword">.</span>cptr_set&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>p_elt<span class="keyword">,</span> x0<span class="keyword">)</span>
  <span class="comment">// end of [val]</span>
<span class="keyword">end</span></span> <span class="comment">// end of [sllist_set_elt_at]</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
sllist_getref_elt_at
  <span class="keyword">(</span>xs<span class="keyword">,</span> i<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> loop
<span class="keyword">(</span>
  nxs<span class="keyword">:</span> <span class="staexp">g2node1</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">g2node1</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">=</span>
  <span class="keyword">if</span> i <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> nxs <span class="keyword">=</span> gnode_get_next <span class="keyword">(</span>nxs<span class="keyword">)</span></span>
  <span class="keyword">in</span>
    loop <span class="keyword">(</span>$UN<span class="keyword">.</span>cast<span class="staexp"><span class="keyword">{</span>g2node1<span class="keyword">(</span>a<span class="keyword">)</span><span class="keyword">}</span></span><span class="keyword">(</span>nxs<span class="keyword">)</span><span class="keyword">,</span> i-<span class="dynexp">1</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="keyword">else</span> nxs</span> <span class="comment">// end of [if]</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> nxs0 <span class="keyword">=</span> $UN<span class="keyword">.</span>castvwtp1<span class="staexp"><span class="keyword">{</span>g2node1<span class="keyword">(</span>a<span class="keyword">)</span><span class="keyword">}</span></span><span class="keyword">(</span>xs<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> nxs_i <span class="keyword">=</span> <span class="keyword">$effmask_all</span> <span class="keyword">(</span>loop <span class="keyword">(</span>nxs0<span class="keyword">,</span> i<span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  gnode_getref_elt <span class="keyword">(</span>nxs_i<span class="keyword">)</span> 
<span class="keyword">end</span></span> <span class="comment">// end of [sllist_getref_elt_at]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
sllist_getref_at <span class="keyword">(</span>xs<span class="keyword">,</span> i<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> loop <span class="keyword">(</span>
  p<span class="keyword">:</span> <span class="staexp">Ptr1</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">Ptr1</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="keyword">in</span>
  <span class="keyword">if</span> i <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> nx <span class="keyword">=</span>
      $UN<span class="keyword">.</span>ptr1_get&lt;<span class="staexp">g2node1</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">&gt;</span> <span class="keyword">(</span>p<span class="keyword">)</span></span>
    <span class="comment">// end of [val]</span>
    <span class="dynexp"><span class="keyword">val</span> p2 <span class="keyword">=</span> gnode_getref_next <span class="keyword">(</span>nx<span class="keyword">)</span></span>
  <span class="keyword">in</span>
    loop <span class="keyword">(</span>cptr2ptr <span class="keyword">(</span>p2<span class="keyword">)</span><span class="keyword">,</span> i-<span class="dynexp">1</span><span class="keyword">)</span>
  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">(</span>p<span class="keyword">)</span> <span class="comment">// end of [if]</span>
<span class="keyword">end</span></span> <span class="comment">// end of [loop]</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> p0 <span class="keyword">=</span> $UN<span class="keyword">.</span>cast<span class="staexp"><span class="keyword">{</span>Ptr1<span class="keyword">}</span></span><span class="keyword">(</span><span class="dynexp"><span class="keyword">addr@</span></span><span class="keyword">(</span>xs<span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  <span class="keyword">$effmask_all</span> <span class="keyword">(</span>loop <span class="keyword">(</span>p0<span class="keyword">,</span> i<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [sllist_getref_at]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
sllist_insert_at
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">,</span> i<span class="keyword">,</span> x0<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">var</span> xs <span class="keyword">=</span> xs
  <span class="dynexp"><span class="keyword">val</span> p_i <span class="keyword">=</span> sllist_getref_at <span class="keyword">(</span>xs<span class="keyword">,</span> i<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> nx0 <span class="keyword">=</span> g2node_make_elt&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>x0<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> nxs <span class="keyword">=</span> $UN<span class="keyword">.</span>ptr1_get&lt;<span class="staexp">g2node0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">&gt;</span> <span class="keyword">(</span>p_i<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> gnode_link10 <span class="keyword">(</span>nx0<span class="keyword">,</span> nxs<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> $UN<span class="keyword">.</span>ptr1_set&lt;<span class="staexp">g2node1</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">&gt;</span> <span class="keyword">(</span>p_i<span class="keyword">,</span> nx0<span class="keyword">)</span></span>
<span class="keyword">in</span>
  $UN<span class="keyword">.</span>castvwtp0<span class="staexp"><span class="keyword">{</span>sllist<span class="keyword">(</span>a<span class="keyword">,</span> n+1<span class="keyword">)</span><span class="keyword">}</span></span><span class="keyword">(</span>xs<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [sllist_insert_at]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
sllist_takeout_at
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">,</span> i<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> p_i <span class="keyword">=</span> sllist_getref_at <span class="keyword">(</span>xs<span class="keyword">,</span> i<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> nxs <span class="keyword">=</span> $UN<span class="keyword">.</span>ptr1_get&lt;<span class="staexp">g2node1</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">&gt;</span> <span class="keyword">(</span>p_i<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> nx0 <span class="keyword">=</span> nxs</span>
  <span class="dynexp"><span class="keyword">val</span> nxs <span class="keyword">=</span> gnode_get_next <span class="keyword">(</span>nx0<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> $UN<span class="keyword">.</span>ptr1_set&lt;<span class="staexp">g2node0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">&gt;</span> <span class="keyword">(</span>p_i<span class="keyword">,</span> nxs<span class="keyword">)</span></span>
  <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span>
  <span class="keyword">)</span> <span class="keyword">=</span> __assert <span class="keyword">(</span>xs<span class="keyword">)</span> <span class="keyword">where</span> <span class="keyword">{</span>
    <span class="keyword">extern</span> <span class="prfexp"><span class="keyword">praxi</span> __assert <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">sllist</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">-</span><span class="staexp">1</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
  <span class="keyword">}</span></span> <span class="comment">// end of [where] // end of [prval]</span>
<span class="keyword">in</span>
  g2node_getfree_elt <span class="keyword">(</span>nx0<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [sllist_takeout_at]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
sllist_append
  <span class="staexp"><span class="keyword">{</span>n1<span class="keyword">,</span>n2<span class="keyword">}</span></span> <span class="keyword">(</span>xs1<span class="keyword">,</span> xs2<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span><span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> lemma_sllist_param<span class="keyword">(</span>xs1<span class="keyword">)</span></span>
<span class="prfexp"><span class="keyword">prval</span><span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> lemma_sllist_param<span class="keyword">(</span>xs2<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> iscons1 <span class="keyword">=</span> sllist_is_cons<span class="keyword">(</span>xs1<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">if</span>
iscons1
<span class="keyword">then</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> iscons2 <span class="keyword">=</span> sllist_is_cons<span class="keyword">(</span>xs2<span class="keyword">)</span></span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">if</span> iscons2 <span class="keyword">then</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> nxs1 <span class="keyword">=</span> sllist1_decode <span class="keyword">(</span>xs1<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> nxs2 <span class="keyword">=</span> sllist0_decode <span class="keyword">(</span>xs2<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> nxs1_end <span class="keyword">=</span> gnodelst_next_all <span class="keyword">(</span>nxs1<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> _void_ <span class="keyword">=</span> gnode_link10 <span class="keyword">(</span>nxs1_end<span class="keyword">,</span> nxs2<span class="keyword">)</span></span>
<span class="keyword">in</span>
  sllist0_encode <span class="keyword">(</span>nxs1<span class="keyword">)</span>
<span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
  <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> sllist_free_nil <span class="keyword">(</span>xs2<span class="keyword">)</span></span> <span class="keyword">in</span> xs1
<span class="keyword">end</span> <span class="comment">// end of [if]</span>
<span class="comment">//</span>
<span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
  <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> sllist_free_nil <span class="keyword">(</span>xs1<span class="keyword">)</span></span> <span class="keyword">in</span> xs2
<span class="keyword">end</span> <span class="comment">// end of [if]</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [sllist_append]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
sllist_reverse <span class="keyword">(</span>xs<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="keyword">in</span>
  sllist_reverse_append <span class="keyword">(</span>xs<span class="keyword">,</span> sllist_nil <span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [sllist_reverse]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
sllist_reverse_append
  <span class="keyword">(</span>xs1<span class="keyword">,</span> xs2<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> loop
<span class="keyword">(</span>
  nxs<span class="keyword">:</span> <span class="staexp">g2node0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> res<span class="keyword">:</span> <span class="staexp">g2node1</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">g2node1</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> iscons <span class="keyword">=</span> gnodelst_is_cons <span class="keyword">(</span>nxs<span class="keyword">)</span></span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">if</span>
iscons
<span class="keyword">then</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> nx0 <span class="keyword">=</span> nxs</span>
  <span class="dynexp"><span class="keyword">val</span> nxs <span class="keyword">=</span> gnode_get_next <span class="keyword">(</span>nx0<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> gnode_link11 <span class="keyword">(</span>nx0<span class="keyword">,</span> res<span class="keyword">)</span></span>
<span class="keyword">in</span>
  loop <span class="keyword">(</span>nxs<span class="keyword">,</span> nx0<span class="keyword">)</span>
<span class="keyword">end</span> <span class="keyword">else</span> res <span class="comment">// end of [if]</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [loop]</span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span>
<span class="keyword">)</span> <span class="keyword">=</span> lemma_sllist_param <span class="keyword">(</span>xs1<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> iscons <span class="keyword">=</span> sllist_is_cons <span class="keyword">(</span>xs1<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">if</span>
iscons
<span class="keyword">then</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> nxs1 <span class="keyword">=</span> sllist1_decode <span class="keyword">(</span>xs1<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> nx0 <span class="keyword">=</span> nxs1</span>
  <span class="dynexp"><span class="keyword">val</span> nxs1 <span class="keyword">=</span> gnode_get_next <span class="keyword">(</span>nx0<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> gnode_link10 <span class="keyword">(</span>nx0<span class="keyword">,</span> sllist0_decode <span class="keyword">(</span>xs2<span class="keyword">)</span><span class="keyword">)</span></span>
<span class="keyword">in</span>
  sllist0_encode <span class="keyword">(</span><span class="keyword">$effmask_all</span> <span class="keyword">(</span>loop <span class="keyword">(</span>nxs1<span class="keyword">,</span> nx0<span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
  <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> sllist_free_nil <span class="keyword">(</span>xs1<span class="keyword">)</span></span>
<span class="keyword">in</span>
  xs2
<span class="keyword">end</span> <span class="comment">// end of [if]</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [sllist_reverse_append]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
sllist_free
  <span class="keyword">(</span>xs<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
loop
<span class="keyword">(</span>
  nxs<span class="keyword">:</span> <span class="staexp">g2node0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span>
iscons <span class="keyword">=</span>
gnodelst_is_cons<span class="keyword">(</span>nxs<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">if</span>
iscons
<span class="keyword">then</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> nxs2 <span class="keyword">=</span>
    gnode_get_next<span class="keyword">(</span>nxs<span class="keyword">)</span></span>
  <span class="comment">// end of [val]</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> g2node_free&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>nxs<span class="keyword">)</span></span>
<span class="keyword">in</span>
  loop<span class="keyword">(</span>nxs2<span class="keyword">)</span>
<span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="comment">// end of [if]</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [loop]</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> nxs <span class="keyword">=</span> sllist0_decode<span class="keyword">(</span>xs<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  <span class="keyword">$effmask_all</span> <span class="keyword">(</span>loop<span class="keyword">(</span>nxs<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [sllist_free]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
sllist_freelin
  <span class="keyword">(</span>xs<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">(</span><span class="staexp">a2</span><span class="keyword">)</span><span class="comment">(*tmp*)</span>
gclear_ref&lt;<span class="staexp">a2</span><span class="keyword">&gt;</span><span class="keyword">(</span>x0<span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">{</span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> $UN<span class="keyword">.</span>castview2void_at<span class="keyword">(</span><span class="dynexp"><span class="keyword">view@</span></span>x0<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> sllist_freelin$clear&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>x0<span class="keyword">)</span></span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> $UN<span class="keyword">.</span>castview2void_at<span class="keyword">(</span><span class="dynexp"><span class="keyword">view@</span></span>x0<span class="keyword">)</span></span>
<span class="keyword">}</span></span> <span class="comment">(* gclear_ref *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
loop
<span class="keyword">(</span>
  nxs<span class="keyword">:</span> <span class="staexp">g2node0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span>
iscons <span class="keyword">=</span>
gnodelst_is_cons<span class="keyword">(</span>nxs<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">if</span>
iscons
<span class="keyword">then</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> nxs2 <span class="keyword">=</span>
    gnode_get_next<span class="keyword">(</span>nxs<span class="keyword">)</span></span>
  <span class="comment">// end of [val]</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> g2node_freelin&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>nxs<span class="keyword">)</span></span>
<span class="keyword">in</span>
  loop<span class="keyword">(</span>nxs2<span class="keyword">)</span>
<span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="comment">// end of [if]</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [loop]</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> nxs <span class="keyword">=</span> sllist0_decode<span class="keyword">(</span>xs<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  <span class="keyword">$effmask_all</span><span class="keyword">(</span>loop<span class="keyword">(</span>nxs<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [sllist_freelin]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="keyword">{</span><span class="staexp">b</span><span class="keyword">}</span>
sllist_map<span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span><span class="keyword">(</span>xs<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
loop
<span class="keyword">(</span>
  nxs<span class="keyword">:</span> <span class="staexp">g2node0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> p_res<span class="keyword">:</span> <span class="staexp">ptr</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span>
iscons <span class="keyword">=</span> gnodelst_is_cons<span class="keyword">(</span>nxs<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">if</span>
iscons
<span class="keyword">then</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> nx <span class="keyword">=</span> nxs</span>
  <span class="dynexp"><span class="keyword">val</span> nxs <span class="keyword">=</span> gnode_get_next<span class="keyword">(</span>nx<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> p_x <span class="keyword">=</span> gnode_getref_elt<span class="keyword">(</span>nx<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf</span><span class="keyword">,</span> <span class="prfexp">fpf</span> <span class="keyword">|</span> p_x<span class="keyword">)</span> <span class="keyword">=</span> $UN<span class="keyword">.</span>cptr_vtake<span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="keyword">(</span>p_x<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> y <span class="keyword">=</span> sllist_map$fopr&lt;<span class="staexp">a</span><span class="keyword">&gt;&lt;</span><span class="staexp">b</span><span class="keyword">&gt;</span><span class="keyword">(</span><span class="keyword">!</span>p_x<span class="keyword">)</span></span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="comment">(*returned*)</span><span class="keyword">)</span> <span class="keyword">=</span> fpf<span class="keyword">(</span>pf<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> ny <span class="keyword">=</span> g2node_make_elt&lt;<span class="staexp">b</span><span class="keyword">&gt;</span><span class="keyword">(</span>y<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> $UN<span class="keyword">.</span>ptr0_set&lt;<span class="staexp">g2node1</span><span class="keyword">(</span><span class="staexp">b</span><span class="keyword">)</span><span class="keyword">&gt;</span><span class="keyword">(</span>p_res<span class="keyword">,</span> ny<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> p_res <span class="keyword">=</span> gnode_getref_next<span class="keyword">(</span>ny<span class="keyword">)</span></span>
<span class="keyword">in</span>
  loop <span class="keyword">(</span>nxs<span class="keyword">,</span> cptr2ptr<span class="keyword">(</span>p_res<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="comment">// end of [if]</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">(* end of [loop] *)</span>
<span class="comment">//</span>
<span class="keyword">var</span> res<span class="keyword">:</span> <span class="staexp">ptr</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> loop <span class="keyword">(</span>$UN<span class="keyword">.</span>castvwtp1<span class="staexp"><span class="keyword">{</span>g2node0<span class="keyword">(</span>a<span class="keyword">)</span><span class="keyword">}</span></span><span class="keyword">(</span>xs<span class="keyword">)</span><span class="keyword">,</span> <span class="dynexp"><span class="keyword">addr@</span></span><span class="keyword">(</span>res<span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  $UN<span class="keyword">.</span>castvwtp0<span class="staexp"><span class="keyword">{</span>sllist<span class="keyword">(</span>b<span class="keyword">,</span>n<span class="keyword">)</span><span class="keyword">}</span></span><span class="keyword">(</span>res<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">(* end of [sllist_map] *)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">(*
fun{
a:vt0p}{env:vt0p
} sllist_foreach_env
  (xs: !Sllist (INV(a)), env: &amp;env &gt;&gt; _): void
*)</span>
<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="keyword">{</span><span class="staexp">env</span><span class="keyword">}</span>
sllist_foreach_env
  <span class="keyword">(</span>xs<span class="keyword">,</span> env<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> loop <span class="keyword">(</span>
  nxs<span class="keyword">:</span> <span class="staexp">g2node0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> env<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">env</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> iscons <span class="keyword">=</span> gnodelst_is_cons <span class="keyword">(</span>nxs<span class="keyword">)</span></span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">if</span> iscons <span class="keyword">then</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> nx0 <span class="keyword">=</span> nxs</span>
  <span class="dynexp"><span class="keyword">val</span> nxs <span class="keyword">=</span> gnode_get_next <span class="keyword">(</span>nxs<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> p_elt <span class="keyword">=</span> gnode_getref_elt <span class="keyword">(</span>nx0<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf</span><span class="keyword">,</span> <span class="prfexp">fpf</span> <span class="keyword">|</span> p_elt<span class="keyword">)</span> <span class="keyword">=</span> $UN<span class="keyword">.</span>cptr_vtake <span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span> <span class="keyword">(</span>p_elt<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> test <span class="keyword">=</span> sllist_foreach$cont <span class="keyword">(</span><span class="keyword">!</span>p_elt<span class="keyword">,</span> env<span class="keyword">)</span></span>
<span class="keyword">in</span>
  <span class="keyword">if</span> test <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> sllist_foreach$fwork <span class="keyword">(</span><span class="keyword">!</span>p_elt<span class="keyword">,</span> env<span class="keyword">)</span></span>
    <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fpf <span class="keyword">(</span>pf<span class="keyword">)</span></span>
  <span class="keyword">in</span>
    loop <span class="keyword">(</span>nxs<span class="keyword">,</span> env<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">let</span>
    <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fpf <span class="keyword">(</span>pf<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">in</span>
    <span class="comment">// nothing</span>
  <span class="keyword">end</span></span> <span class="comment">// end of [if]</span>
<span class="keyword">end</span> <span class="keyword">else</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="comment">// end of [if]</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [loop]</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> nxs <span class="keyword">=</span> $UN<span class="keyword">.</span>castvwtp1<span class="staexp"><span class="keyword">{</span>g2node0<span class="keyword">(</span>a<span class="keyword">)</span><span class="keyword">}</span></span><span class="keyword">(</span>xs<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  loop <span class="keyword">(</span>nxs<span class="keyword">,</span> env<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [sllist_foreach_env]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp"><span class="keyword">}</span></span><span class="comment">(*tmp*)</span>
fprint_sllist$sep
  <span class="keyword">(</span>out<span class="keyword">)</span> <span class="keyword">=</span> fprint_string <span class="keyword">(</span>out<span class="keyword">,</span> <span class="dynstr">"-&gt;"</span><span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
fprint_sllist <span class="keyword">(</span>out<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> loop <span class="keyword">(</span>
  out<span class="keyword">:</span> <span class="staexp">FILEref</span><span class="keyword">,</span> nxs<span class="keyword">:</span> <span class="staexp">g2node0</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> i<span class="keyword">:</span> <span class="staexp">int</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> iscons <span class="keyword">=</span> gnodelst_is_cons <span class="keyword">(</span>nxs<span class="keyword">)</span></span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">if</span> iscons <span class="keyword">then</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> nx0 <span class="keyword">=</span> nxs</span>
  <span class="dynexp"><span class="keyword">val</span> nxs <span class="keyword">=</span> gnode_get_next <span class="keyword">(</span>nx0<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span>
    <span class="keyword">if</span> i <span class="keyword">&gt;</span> <span class="dynexp">0</span> <span class="keyword">then</span> fprint_sllist$sep <span class="keyword">(</span>out<span class="keyword">)</span></span>
  <span class="comment">// end of [val]</span>
  <span class="dynexp"><span class="keyword">val</span> p_elt <span class="keyword">=</span> gnode_getref_elt <span class="keyword">(</span>nx0<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf</span><span class="keyword">,</span> <span class="prfexp">fpf</span> <span class="keyword">|</span> p_elt<span class="keyword">)</span> <span class="keyword">=</span> $UN<span class="keyword">.</span>cptr_vtake <span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span> <span class="keyword">(</span>p_elt<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_ref <span class="keyword">(</span>out<span class="keyword">,</span> <span class="keyword">!</span>p_elt<span class="keyword">)</span></span>
  <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fpf <span class="keyword">(</span>pf<span class="keyword">)</span></span>
<span class="keyword">in</span>
  loop <span class="keyword">(</span>out<span class="keyword">,</span> nxs<span class="keyword">,</span> i+<span class="dynexp">1</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [if]</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [loop]</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> nxs <span class="keyword">=</span> $UN<span class="keyword">.</span>castvwtp1<span class="staexp"><span class="keyword">{</span>g2node0<span class="keyword">(</span>a<span class="keyword">)</span><span class="keyword">}</span></span><span class="keyword">(</span>xs<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  loop <span class="keyword">(</span>out<span class="keyword">,</span> nxs<span class="keyword">,</span> <span class="dynexp">0</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [fprint_sllist]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">datavtype</span>
<span class="staexp">slnode_vtype
  <span class="keyword">(</span>a<span class="keyword">:</span><span class="keyword">vt@ype+</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp">SLNODE <span class="keyword">of</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">ptr</span><span class="comment">(*next*)</span><span class="keyword">)</span></span></span>
<span class="comment">// end of [slnode_vtype]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">vtypedef</span> <span class="staexp">slnode <span class="keyword">(</span><span class="staexp">a<span class="keyword">:</span>vt0p</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="staexp">slnode_vtype</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">extern</span>
<span class="prfexp"><span class="keyword">praxi</span> slnode_vfree <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span> <span class="keyword">(</span>nx<span class="keyword">:</span> <span class="staexp">slnode</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">castfn</span>
g2node_decode <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span> <span class="keyword">(</span>nx<span class="keyword">:</span> <span class="staexp">g2node1</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">slnode</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">castfn</span>
g2node_encode <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span> <span class="keyword">(</span>nx<span class="keyword">:</span> <span class="staexp">slnode</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">g2node1</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
g2node_make_elt
  <span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="keyword">in</span>
  $UN<span class="keyword">.</span>castvwtp0<span class="staexp"><span class="keyword">{</span>g2node1<span class="keyword">(</span>a<span class="keyword">)</span><span class="keyword">}</span></span><span class="keyword">(</span>SLNODE<span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="keyword">(</span>x<span class="keyword">,</span> _<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [g2node_make_elt]</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
g2node_free<span class="keyword">(</span>nx<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> nx <span class="keyword">=</span>
    g2node_decode <span class="keyword">(</span>nx<span class="keyword">)</span></span>
  <span class="comment">// end of [val]</span>
  <span class="dynexp"><span class="keyword">val+</span><span class="keyword">~</span>SLNODE <span class="keyword">(</span>_<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>nx<span class="keyword">)</span></span> <span class="dynexp"><span class="keyword">in</span> <span class="comment">(*nothing*)</span>
<span class="keyword">end</span></span></span> <span class="comment">// end of [g2node_free]</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
g2node_freelin<span class="keyword">(</span>nx<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> nx <span class="keyword">=</span>
    g2node_decode <span class="keyword">(</span>nx<span class="keyword">)</span></span>
  <span class="comment">// end of [val]</span>
  <span class="dynexp"><span class="keyword">val+</span><span class="keyword">@</span>SLNODE<span class="keyword">(</span>x0<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>nx<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*freed*)</span><span class="keyword">)</span> <span class="keyword">=</span> gclear_ref&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>x0<span class="keyword">)</span></span> <span class="keyword">in</span> <span class="keyword">free@</span><span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="keyword">(</span>nx<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [g2node_free]</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
g2node_free_elt
  <span class="keyword">(</span>nx<span class="keyword">,</span> res<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> nx <span class="keyword">=</span> g2node_decode <span class="keyword">(</span>nx<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span><span class="keyword">~</span>SLNODE <span class="keyword">(</span>x<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>nx<span class="keyword">)</span></span><span class="keyword">;</span> <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> res := x</span> <span class="dynexp"><span class="keyword">in</span> <span class="comment">(*nothing*)</span>
<span class="keyword">end</span></span></span> <span class="comment">// end of [g2node_free_elt]</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
g2node_getfree_elt
  <span class="keyword">(</span>nx<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> nx <span class="keyword">=</span> g2node_decode <span class="keyword">(</span>nx<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span><span class="keyword">~</span>SLNODE <span class="keyword">(</span>x<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>nx<span class="keyword">)</span></span> <span class="keyword">in</span> x
<span class="keyword">end</span></span> <span class="comment">// end of [g2node_getfree_elt]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
gnode_getref_elt&lt;<span class="staexp">mytkind</span><span class="keyword">&gt;&lt;</span><span class="staexp">a</span><span class="keyword">&gt;</span>
  <span class="keyword">(</span>nx<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> nx <span class="keyword">=</span> g2node_decode <span class="keyword">(</span>nx<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val+</span><span class="keyword">@</span>SLNODE <span class="keyword">(</span>elt<span class="keyword">,</span> _<span class="keyword">)</span> <span class="keyword">=</span> nx</span>
<span class="dynexp"><span class="keyword">val</span> p_elt <span class="keyword">=</span> <span class="dynexp"><span class="keyword">addr@</span></span> <span class="keyword">(</span>elt<span class="keyword">)</span></span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>nx<span class="keyword">)</span></span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> slnode_vfree <span class="keyword">(</span>nx<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  $UN<span class="keyword">.</span>cast<span class="staexp"><span class="keyword">{</span>cPtr1<span class="keyword">(</span>a<span class="keyword">)</span><span class="keyword">}</span></span><span class="keyword">(</span>p_elt<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [gnode_getref_elt]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
gnode_getref_next&lt;<span class="staexp">mytkind</span><span class="keyword">&gt;&lt;</span><span class="staexp">a</span><span class="keyword">&gt;</span>
  <span class="keyword">(</span>nx<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> nx <span class="keyword">=</span> g2node_decode <span class="keyword">(</span>nx<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val+</span><span class="keyword">@</span>SLNODE <span class="keyword">(</span>_<span class="keyword">,</span> next<span class="keyword">)</span> <span class="keyword">=</span> nx</span>
<span class="dynexp"><span class="keyword">val</span> p_next <span class="keyword">=</span> <span class="dynexp"><span class="keyword">addr@</span></span> <span class="keyword">(</span>next<span class="keyword">)</span></span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">fold@</span> <span class="keyword">(</span>nx<span class="keyword">)</span></span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> slnode_vfree <span class="keyword">(</span>nx<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  $UN<span class="keyword">.</span>cast<span class="staexp"><span class="keyword">{</span>cPtr1<span class="keyword">(</span>g2node0<span class="keyword">(</span>a<span class="keyword">)</span><span class="keyword">)</span><span class="keyword">}</span></span><span class="keyword">(</span>p_next<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [gnode_getref_next]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
gnode_link10&lt;<span class="staexp">mytkind</span><span class="keyword">&gt;&lt;</span><span class="staexp">a</span><span class="keyword">&gt;</span>
  <span class="keyword">(</span>nx1<span class="keyword">,</span> nx2<span class="keyword">)</span> <span class="keyword">=</span> gnode_set_next <span class="keyword">(</span>nx1<span class="keyword">,</span> nx2<span class="keyword">)</span></span>
<span class="comment">// end of [gnode_link10]</span>

<span class="dynexp"><span class="keyword">implement</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
gnode_link11&lt;<span class="staexp">mytkind</span><span class="keyword">&gt;&lt;</span><span class="staexp">a</span><span class="keyword">&gt;</span>
  <span class="keyword">(</span>nx1<span class="keyword">,</span> nx2<span class="keyword">)</span> <span class="keyword">=</span> gnode_set_next <span class="keyword">(</span>nx1<span class="keyword">,</span> nx2<span class="keyword">)</span></span>
<span class="comment">// end of [gnode_link11]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
sllist_cons_ngc
  <span class="keyword">(</span>nx0<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> nxs <span class="keyword">=</span> sllist0_decode <span class="keyword">(</span>xs<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> _void_ <span class="keyword">=</span> gnode_link10 <span class="keyword">(</span>nx0<span class="keyword">,</span> nxs<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  sllist0_encode <span class="keyword">(</span>nx0<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [sllist_cons_ngc]</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
sllist_uncons_ngc
  <span class="keyword">(</span>xs<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> nxs <span class="keyword">=</span> sllist1_decode <span class="keyword">(</span>xs<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> nxs2 <span class="keyword">=</span> gnode_get_next <span class="keyword">(</span>nxs<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> _void_ <span class="keyword">=</span> xs := sllist0_encode <span class="keyword">(</span>nxs2<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  nxs
<span class="keyword">end</span></span> <span class="comment">// end of [sllist_uncons_ngc]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
sllist_snoc_ngc
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">,</span> nx0<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="keyword">vtypedef</span> <span class="staexp">res <span class="keyword">=</span> <span class="staexp">sllist</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span><span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> gnode_set_next_null <span class="keyword">(</span>nx0<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> nxs <span class="keyword">=</span> sllist0_decode <span class="keyword">(</span>xs<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> iscons <span class="keyword">=</span> gnodelst_is_cons <span class="keyword">(</span>nxs<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">if</span> iscons <span class="keyword">then</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> nx_end <span class="keyword">=</span> gnodelst_next_all <span class="keyword">(</span>nxs<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> _void_ <span class="keyword">=</span> gnode_link11 <span class="keyword">(</span>nx_end<span class="keyword">,</span> nx0<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  $UN<span class="keyword">.</span>castvwtp0<span class="staexp"><span class="keyword">{</span>res<span class="keyword">}</span></span><span class="keyword">(</span>nxs<span class="keyword">)</span>
<span class="keyword">end</span> <span class="keyword">else</span>
  $UN<span class="keyword">.</span>castvwtp0<span class="staexp"><span class="keyword">{</span>res<span class="keyword">}</span></span><span class="keyword">(</span>nx0<span class="keyword">)</span>
<span class="comment">// end of [if]</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [sllist_snoc_ngc]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
sllist_unsnoc_ngc
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span> <span class="keyword">(</span>xs<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span> loop
<span class="keyword">(</span>
  xs<span class="keyword">:</span> <span class="staexp">&amp;</span><span class="staexp">Sllist1</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">Sllist0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">g2node1</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> p <span class="keyword">=</span> sllist_getref_next <span class="keyword">(</span>xs<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf</span><span class="keyword">,</span> <span class="prfexp">fpf</span> <span class="keyword">|</span> p<span class="keyword">)</span> <span class="keyword">=</span> $UN<span class="keyword">.</span>ptr_vtake<span class="staexp"><span class="keyword">{</span>Sllist0<span class="keyword">(</span>a<span class="keyword">)</span><span class="keyword">}</span></span><span class="keyword">(</span>p<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> iscons <span class="keyword">=</span> sllist_is_cons <span class="keyword">(</span><span class="keyword">!</span>p<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">if</span> iscons
  <span class="keyword">then</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> res <span class="keyword">=</span> loop <span class="keyword">(</span><span class="keyword">!</span>p<span class="keyword">)</span></span>
    <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fpf <span class="keyword">(</span>pf<span class="keyword">)</span></span> <span class="keyword">in</span> res
  <span class="keyword">end</span> <span class="comment">// end of [then]</span>
  <span class="keyword">else</span> <span class="keyword">let</span>
    <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fpf <span class="keyword">(</span>pf<span class="keyword">)</span></span>
    <span class="dynexp"><span class="keyword">val</span> nx <span class="keyword">=</span> $UN<span class="keyword">.</span>castvwtp0<span class="staexp"><span class="keyword">{</span>g2node1<span class="keyword">(</span>a<span class="keyword">)</span><span class="keyword">}</span></span><span class="keyword">(</span>xs<span class="keyword">)</span></span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> xs := sllist_nil<span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span></span> <span class="keyword">in</span> nx
  <span class="keyword">end</span> <span class="comment">// end of [else]</span>
<span class="comment">// end of [if]</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">(* end of [loop] *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> res <span class="keyword">=</span> <span class="keyword">$effmask_all</span> <span class="keyword">(</span>loop <span class="keyword">(</span>xs<span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">[</span><span class="staexp">l<span class="keyword">:</span>addr</span><span class="keyword">]</span> EQADDR <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> eqaddr_make_ptr <span class="keyword">(</span><span class="dynexp"><span class="keyword">addr@</span></span>xs<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="dynexp"><span class="keyword">view@</span></span>xs := $UN<span class="keyword">.</span>castview0<span class="staexp"><span class="keyword">{</span>sllist<span class="keyword">(</span>a<span class="keyword">,</span>n-1<span class="keyword">)</span><span class="keyword">@</span>l<span class="keyword">}</span></span><span class="keyword">(</span><span class="dynexp"><span class="keyword">view@</span></span>xs<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  res
<span class="keyword">end</span></span> <span class="comment">// end of [sllist_unsnoc_ngc]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">(* end of [sllist.dats] *)</span>
</pre>
<pre class="patsyntax">
<span class="comment">(***********************************************************************)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(*                         Applied Type System                         *)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(***********************************************************************)</span>

<span class="comment">(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">(* Author: Hongwei Xi *)</span>
<span class="comment">(* Start time: September, 2013 *)</span>
<span class="comment">(* Authoremail: hwxi AT cs DOT bu DOT edu *)</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">#define</span>
ATS_PACKNAME
"ATSLIB.libats.stklist"</span>
<span class="comment">//</span>
<span class="comment">// HX-2017-03-28:</span>
<span class="neuexp"><span class="keyword">#define</span> <span class="comment">// no dynloading</span>
ATS_DYNLOADFLAG 0</span> <span class="comment">// at run-time</span>
<span class="comment">//</span>
<span class="comment">// HX-2017-03-28:</span>
<span class="neuexp"><span class="keyword">#define</span> <span class="comment">// prefix for external</span>
ATS_EXTERN_PREFIX "atslib_"</span> <span class="comment">// names</span>
<span class="comment">//  </span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">staload</span>
UN <span class="keyword">=</span> "prelude/SATS/unsafe.sats"

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">staload</span> "libats/SATS/stklist.sats"

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="staexp"><span class="keyword">assume</span>
stklist_vtype
  <span class="keyword">(</span>a<span class="keyword">:</span>vt0p<span class="keyword">,</span> n<span class="keyword">:</span>int<span class="keyword">)</span> <span class="keyword">=</span> aPtr1<span class="keyword">(</span>list_vt<span class="keyword">(</span>a<span class="keyword">,</span> n<span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp"><span class="keyword">}</span></span><span class="comment">(*tmp*)</span>
stklist_make_nil
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">(</span>
aptr_make_elt&lt;
  <span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span><span class="staexp">0</span><span class="keyword">)</span><span class="keyword">&gt;</span><span class="keyword">(</span>list_vt_nil<span class="comment">(*void*)</span><span class="keyword">)</span>
<span class="keyword">)</span></span> <span class="comment">(* stklist_make_nil *)</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp"><span class="keyword">}</span></span><span class="comment">(*tmp*)</span>
stklist_getfree
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span><span class="keyword">(</span>stk<span class="keyword">)</span> <span class="keyword">=</span>
  aptr_getfree_elt&lt;<span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">&gt;</span><span class="keyword">(</span>stk<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp"><span class="keyword">}</span></span><span class="comment">(*tmp*)</span>
stklist_is_nil
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span><span class="keyword">(</span>stk<span class="keyword">)</span> <span class="keyword">=</span> isnil <span class="keyword">where</span>
<span class="keyword">{</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> p0 <span class="keyword">=</span> $UN<span class="keyword">.</span>castvwtp1<span class="staexp"><span class="keyword">{</span>ptr<span class="keyword">}</span></span><span class="keyword">(</span>stk<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> xs <span class="keyword">=</span> $UN<span class="keyword">.</span>ptr0_get&lt;<span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">&gt;</span><span class="keyword">(</span>p0<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> isnil <span class="keyword">=</span> list_vt_is_nil<span class="keyword">(</span>xs<span class="keyword">)</span></span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> $UN<span class="keyword">.</span>cast2void<span class="keyword">(</span>xs<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">}</span></span> <span class="comment">(* end of [stklist_is_nil] *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp"><span class="keyword">}</span></span><span class="comment">(*tmp*)</span>
stklist_isnot_nil
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span><span class="keyword">(</span>stk<span class="keyword">)</span> <span class="keyword">=</span> iscons <span class="keyword">where</span>
<span class="keyword">{</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> p0 <span class="keyword">=</span> $UN<span class="keyword">.</span>castvwtp1<span class="staexp"><span class="keyword">{</span>ptr<span class="keyword">}</span></span><span class="keyword">(</span>stk<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> xs <span class="keyword">=</span> $UN<span class="keyword">.</span>ptr0_get&lt;<span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">&gt;</span><span class="keyword">(</span>p0<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> iscons <span class="keyword">=</span> list_vt_is_cons<span class="keyword">(</span>xs<span class="keyword">)</span></span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> $UN<span class="keyword">.</span>cast2void<span class="keyword">(</span>xs<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">}</span></span> <span class="comment">(* end of [stklist_isnot_nil] *)</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
stklist_insert
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span><span class="keyword">(</span>stk<span class="keyword">,</span> x0<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span>
<span class="keyword">(</span><span class="comment">(*n&gt;=0*)</span><span class="keyword">)</span> <span class="keyword">=</span>
lemma_stklist_param<span class="keyword">(</span>stk<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> xs <span class="keyword">=</span>
aptr_get_elt&lt;<span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">&gt;</span><span class="keyword">(</span>stk<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> xs <span class="keyword">=</span> list_vt_cons<span class="keyword">(</span>x0<span class="keyword">,</span> xs<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  aptr_set_elt&lt;<span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span><span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span><span class="keyword">&gt;</span><span class="keyword">(</span>stk<span class="keyword">,</span> xs<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [stklist_insert]</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
stklist_takeout
  <span class="staexp"><span class="keyword">{</span>n<span class="keyword">}</span></span><span class="keyword">(</span>stk<span class="keyword">)</span> <span class="keyword">=</span> x0 <span class="keyword">where</span>
<span class="keyword">{</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> xs <span class="keyword">=</span>
aptr_get_elt&lt;<span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span><span class="staexp">n</span><span class="keyword">)</span><span class="keyword">&gt;</span><span class="keyword">(</span>stk<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val+</span><span class="keyword">~</span>list_vt_cons<span class="keyword">(</span>x0<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=</span> xs</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> aptr_set_elt&lt;<span class="staexp">list_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span><span class="staexp">n</span><span class="staexp">-</span><span class="staexp">1</span><span class="keyword">)</span><span class="keyword">&gt;</span><span class="keyword">(</span>stk<span class="keyword">,</span> xs<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">}</span></span> <span class="comment">(* end of [stklist_takeout] *)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
stklist_takeout_opt
  <span class="keyword">(</span>stk<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span>
<span class="keyword">(</span><span class="comment">(*n&gt;=0*)</span><span class="keyword">)</span> <span class="keyword">=</span>
lemma_stklist_param<span class="keyword">(</span>stk<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> xs <span class="keyword">=</span>
aptr_get_elt&lt;<span class="staexp">List0_vt</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">&gt;</span><span class="keyword">(</span>stk<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">case+</span> xs <span class="keyword">of</span>
<span class="keyword">|</span> list_vt_nil
  <span class="keyword">(</span>
  <span class="keyword">)</span> <span class="keyword">=&gt;</span> None_vt<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">where</span>
  <span class="keyword">{</span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> aptr_set_elt<span class="keyword">(</span>stk<span class="keyword">,</span> xs<span class="keyword">)</span></span>
  <span class="keyword">}</span> <span class="comment">(* end of [list_vt_nil] *)</span>
<span class="keyword">|</span> <span class="keyword">~</span>list_vt_cons
  <span class="keyword">(</span>
    x0<span class="keyword">,</span> xs
  <span class="keyword">)</span> <span class="keyword">=&gt;</span> Some_vt<span class="keyword">(</span>x0<span class="keyword">)</span> <span class="keyword">where</span>
  <span class="keyword">{</span>
    <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> aptr_set_elt<span class="keyword">(</span>stk<span class="keyword">,</span> xs<span class="keyword">)</span></span>
  <span class="keyword">}</span> <span class="comment">(* end of [list_vt_nil] *)</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [stklist_takeout_opt]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">(* end of [stklist.dats] *)</span>
</pre>
<pre class="patsyntax">
<span class="comment">(***********************************************************************)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(*                         Applied Type System                         *)</span>
<span class="comment">(*                                                                     *)</span>
<span class="comment">(***********************************************************************)</span>

<span class="comment">(*
** ATS/Postiats - Unleashing the Potential of Types!
** Copyright (C) 2011-2013 Hongwei Xi, ATS Trustful Software, Inc.
** All rights reserved
**
** ATS is free software;  you can  redistribute it and/or modify it under
** the terms of  the GNU GENERAL PUBLIC LICENSE (GPL) as published by the
** Free Software Foundation; either version 3, or (at  your  option)  any
** later version.
** 
** ATS is distributed in the hope that it will be useful, but WITHOUT ANY
** WARRANTY; without  even  the  implied  warranty  of MERCHANTABILITY or
** FITNESS FOR A PARTICULAR PURPOSE.  See the  GNU General Public License
** for more details.
** 
** You  should  have  received  a  copy of the GNU General Public License
** along  with  ATS;  see the  file COPYING.  If not, please write to the
** Free Software Foundation,  51 Franklin Street, Fifth Floor, Boston, MA
** 02110-1301, USA.
*)</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">(* Author: Hongwei Xi *)</span>
<span class="comment">(* Start time: September, 2013 *)</span>
<span class="comment">(* Authoremail: hwxi AT cs DOT bu DOT edu *)</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">#define</span>
ATS_PACKNAME
"ATSLIB.libats.stkarray"</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">#define</span> <span class="comment">// HX: no dynloading</span>
ATS_DYNLOADFLAG 0</span> <span class="comment">// at run-time</span>
<span class="comment">//</span>
<span class="neuexp"><span class="keyword">#define</span> <span class="comment">// HX: prefix for external</span>
ATS_EXTERN_PREFIX "atslib_"</span> <span class="comment">// names</span>
<span class="comment">//  </span>
<span class="comment">(* ****** ****** *)</span>

<span class="keyword">staload</span>
UN <span class="keyword">=</span> "prelude/SATS/unsafe.sats"

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">staload</span> "libats/SATS/stkarray.sats"

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
stkarray_make_cap
  <span class="keyword">(</span>cap<span class="keyword">)</span> <span class="keyword">=</span> stk <span class="keyword">where</span>
<span class="keyword">{</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> A <span class="keyword">=</span> arrayptr_make_uninitized&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>cap<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span>
<span class="keyword">(</span><span class="prfexp">pfat</span><span class="keyword">,</span> <span class="prfexp">pfgc</span> <span class="keyword">|</span> p<span class="keyword">)</span> <span class="keyword">=</span> ptr_alloc&lt;<span class="staexp">stkarray_tsize</span><span class="keyword">&gt;</span><span class="keyword">(</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pfngc</span> <span class="keyword">|</span> stk<span class="keyword">)</span> <span class="keyword">=</span>
  stkarray_make_ngc_tsz<span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="keyword">(</span><span class="prfexp">pfat</span> <span class="keyword">|</span> p<span class="keyword">,</span> A<span class="keyword">,</span> cap<span class="keyword">,</span> sizeof&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span> mfree_gcngc_v_nullify<span class="keyword">(</span>pfgc<span class="keyword">,</span> pfngc<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">}</span></span> <span class="comment">// end of [stkarray_make_cap]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">local</span>

<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span>
stkarray_get_size_tsz
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  stk<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">stkarray</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">sizeof_t</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">n</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span> <span class="comment">// end-of-fun</span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span>
stkarray_get_capacity_tsz
  <span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span><span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span>
<span class="keyword">(</span>
  stk<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">stkarray</span> <span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">sizeof_t</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">size_t</span><span class="keyword">(</span><span class="staexp">m</span><span class="keyword">)</span> <span class="keyword">=</span> "mac#%"</span> <span class="comment">// end-of-fun</span>

<span class="keyword">in</span> <span class="comment">(* in of [local] *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
stkarray_get_size
  <span class="keyword">(</span>stk<span class="keyword">)</span> <span class="keyword">=</span>
  stkarray_get_size_tsz<span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="keyword">(</span>stk<span class="keyword">,</span> sizeof&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
stkarray_get_capacity
  <span class="keyword">(</span>stk<span class="keyword">)</span> <span class="keyword">=</span>
  stkarray_get_capacity_tsz<span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="keyword">(</span>stk<span class="keyword">,</span> sizeof&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">end</span> <span class="comment">// end of [local]</span>

<span class="comment">(* ****** ****** *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp"><span class="keyword">}</span></span><span class="comment">(*tmp*)</span>
fprint_stkarray$sep
  <span class="keyword">(</span>out<span class="keyword">)</span> <span class="keyword">=</span> fprint <span class="keyword">(</span>out<span class="keyword">,</span> <span class="dynstr">"&lt;-"</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
fprint_stkarray
  <span class="keyword">(</span>out<span class="keyword">,</span> stk<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> n <span class="keyword">=</span>
stkarray_get_size&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>stk<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span>
<span class="keyword">[</span><span class="staexp">n<span class="keyword">:</span>int</span><span class="keyword">]</span>
EQINT<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> eqint_make_guint<span class="keyword">(</span>n<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
fprint_array$sep&lt;<span class="keyword">&gt;</span>
  <span class="keyword">(</span>out<span class="keyword">)</span> <span class="keyword">=</span> fprint_stkarray$sep&lt;<span class="keyword">&gt;</span><span class="keyword">(</span>out<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span>
p_beg <span class="keyword">=</span>
stkarray_get_ptrbeg<span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="keyword">(</span>stk<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span>
<span class="keyword">(</span><span class="prfexp">pf</span><span class="keyword">,</span><span class="prfexp">fpf</span><span class="keyword">|</span>p_beg<span class="keyword">)</span> <span class="keyword">=</span>
$UN<span class="keyword">.</span>ptr_vtake<span class="staexp"><span class="keyword">{</span>array<span class="keyword">(</span>a<span class="keyword">,</span>n<span class="keyword">)</span><span class="keyword">}</span></span><span class="keyword">(</span>p_beg<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fprint_array&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>out<span class="keyword">,</span> <span class="keyword">!</span>p_beg<span class="keyword">,</span> n<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fpf<span class="keyword">(</span>pf<span class="keyword">)</span></span> <span class="comment">// end of [prval]</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">in</span>
  <span class="comment">// nothing</span>
<span class="keyword">end</span></span></span> <span class="comment">// end of [fprint_stkarray]</span>
<span class="comment">//</span>
<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
fprint_stkarray_sep
  <span class="keyword">(</span>out<span class="keyword">,</span> stk<span class="keyword">,</span> sep<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp"><span class="keyword">}</span></span><span class="comment">(*tmp*)</span>
fprint_stkarray$sep
  <span class="keyword">(</span>out<span class="keyword">)</span> <span class="keyword">=</span> fprint_string<span class="keyword">(</span>out<span class="keyword">,</span> sep<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  fprint_stkarray&lt;<span class="staexp">a</span><span class="keyword">&gt;</span> <span class="keyword">(</span>out<span class="keyword">,</span> stk<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [fprint_stkarray_sep]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="keyword">extern</span> <span class="dynexp"><span class="keyword">fun</span>
stkarray_get_ptrcur<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>stk<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">stkarray</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">&gt;</span> <span class="staexp">ptr</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">// end of [stkarray_get_ptrcur]</span>
<span class="keyword">extern</span> <span class="dynexp"><span class="keyword">fun</span>
stkarray_set_ptrcur<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span>vt0p<span class="keyword">}</span></span>
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">:</span>int<span class="keyword">}</span></span> <span class="keyword">(</span>stk<span class="keyword">:</span> <span class="staexp"><span class="keyword">!</span></span><span class="staexp">stkarray</span> <span class="keyword">(</span><span class="staexp">INV</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">ptr</span><span class="keyword">)</span><span class="keyword">:&lt;</span><span class="keyword">!</span><span class="staexp">wrt</span><span class="keyword">&gt;</span> <span class="staexp">void</span> <span class="keyword">=</span> "mac#%"</span>
<span class="comment">// end of [stkarray_set_ptrcur]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
stkarray_insert
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">}</span></span><span class="keyword">(</span>stk<span class="keyword">,</span> x0<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> p_cur <span class="keyword">=</span>
  stkarray_get_ptrcur<span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="keyword">(</span>stk<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span>
  $UN<span class="keyword">.</span>ptr0_set&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>p_cur<span class="keyword">,</span> x0<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span> <span class="keyword">=</span>
  stkarray_set_ptrcur<span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="keyword">(</span>stk<span class="keyword">,</span> ptr_succ&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>p_cur<span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> __assert <span class="keyword">(</span>stk<span class="keyword">)</span> <span class="keyword">where</span>
<span class="keyword">{</span>
<span class="comment">//</span>
<span class="keyword">extern</span>
<span class="prfexp"><span class="keyword">praxi</span>
__assert
  <span class="keyword">(</span><span class="staexp"><span class="keyword">!</span></span><span class="staexp">stkarray</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">stkarray</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">+</span><span class="staexp">1</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="comment">//</span>
<span class="keyword">}</span></span> <span class="comment">(* end of [prval] *)</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">in</span>
  <span class="comment">// nothing</span>
<span class="keyword">end</span></span></span> <span class="comment">// end of [stkarray_insert]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
stkarray_insert_opt
  <span class="keyword">(</span>stk<span class="keyword">,</span> x0<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span>
isnot <span class="keyword">=</span> stkarray_isnot_full<span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="keyword">(</span>stk<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">if</span>
isnot
<span class="keyword">then</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> stkarray_insert&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>stk<span class="keyword">,</span> x0<span class="keyword">)</span></span> <span class="keyword">in</span> None_vt<span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">end</span> <span class="keyword">else</span> Some_vt<span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="keyword">(</span>x0<span class="keyword">)</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [stkarray_insert_opt]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
stkarray_takeout
  <span class="staexp"><span class="keyword">{</span>m<span class="keyword">,</span>n<span class="keyword">}</span></span> <span class="keyword">(</span>stk<span class="keyword">)</span> <span class="keyword">=</span> x0 <span class="keyword">where</span>
<span class="keyword">{</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> p_cur <span class="keyword">=</span>
  stkarray_get_ptrcur<span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="keyword">(</span>stk<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> p1_cur <span class="keyword">=</span> ptr_pred&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>p_cur<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> x0 <span class="keyword">=</span> $UN<span class="keyword">.</span>ptr0_get&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>p1_cur<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> stkarray_set_ptrcur<span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="keyword">(</span>stk<span class="keyword">,</span> p1_cur<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> __assert <span class="keyword">(</span>stk<span class="keyword">)</span> <span class="keyword">where</span>
<span class="keyword">{</span>
<span class="comment">//</span>
<span class="keyword">extern</span>
<span class="prfexp"><span class="keyword">praxi</span>
__assert
  <span class="keyword">(</span><span class="staexp"><span class="keyword">!</span></span><span class="staexp">stkarray</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="keyword">)</span> <span class="staexp">&gt;&gt;</span> <span class="staexp">stkarray</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">m</span><span class="keyword">,</span> <span class="staexp">n</span><span class="staexp">-</span><span class="staexp">1</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">void</span></span>
<span class="comment">//</span>
<span class="keyword">}</span></span> <span class="comment">(* end of [prval] *)</span>
<span class="comment">//</span>
<span class="keyword">}</span></span> <span class="comment">// end of [stkarray_takeout]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
stkarray_takeout_opt
  <span class="keyword">(</span>stk<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span>
isnot <span class="keyword">=</span> stkarray_isnot_nil<span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="keyword">(</span>stk<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">if</span>
isnot
<span class="keyword">then</span> <span class="keyword">let</span>
<span class="comment">//</span>
  <span class="dynexp"><span class="keyword">val</span> x0 <span class="keyword">=</span>
  stkarray_takeout&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>stk<span class="keyword">)</span></span> <span class="keyword">in</span> Some_vt<span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="keyword">(</span>x0<span class="keyword">)</span>
<span class="comment">//</span>
<span class="keyword">end</span> <span class="keyword">else</span> None_vt<span class="keyword">(</span><span class="comment">(*void*)</span><span class="keyword">)</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [stkarray_takeout_opt]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="keyword">{</span><span class="staexp">env</span><span class="keyword">}</span>
stkarray_foreach$cont<span class="keyword">(</span>x<span class="keyword">,</span> env<span class="keyword">)</span> <span class="keyword">=</span> true</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
stkarray_foreach
  <span class="keyword">(</span>stk<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
  <span class="keyword">var</span> env<span class="keyword">:</span> <span class="staexp">void</span> <span class="keyword">=</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">in</span>
  stkarray_foreach_env&lt;<span class="staexp">a</span><span class="keyword">&gt;&lt;</span><span class="staexp">void</span><span class="keyword">&gt;</span><span class="keyword">(</span>stk<span class="keyword">,</span> env<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [stkarray_foreach]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="keyword">{</span><span class="staexp">env</span><span class="keyword">}</span>
stkarray_foreach_env
  <span class="keyword">(</span>stk<span class="keyword">,</span> env<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
array_rforeach$cont&lt;<span class="staexp">a</span><span class="keyword">&gt;&lt;</span><span class="staexp">env</span><span class="keyword">&gt;</span>
  <span class="keyword">(</span>x<span class="keyword">,</span> env<span class="keyword">)</span> <span class="keyword">=</span>
  stkarray_foreach$cont&lt;<span class="staexp">a</span><span class="keyword">&gt;&lt;</span><span class="staexp">env</span><span class="keyword">&gt;</span><span class="keyword">(</span>x<span class="keyword">,</span> env<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">implement</span>
array_rforeach$fwork&lt;<span class="staexp">a</span><span class="keyword">&gt;&lt;</span><span class="staexp">env</span><span class="keyword">&gt;</span>
  <span class="keyword">(</span>x<span class="keyword">,</span> env<span class="keyword">)</span> <span class="keyword">=</span>
  stkarray_foreach$fwork&lt;<span class="staexp">a</span><span class="keyword">&gt;&lt;</span><span class="staexp">env</span><span class="keyword">&gt;</span><span class="keyword">(</span>x<span class="keyword">,</span> env<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> n <span class="keyword">=</span>
stkarray_get_size&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>stk<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="prfexp"><span class="keyword">prval</span>
<span class="keyword">[</span>
<span class="staexp">n<span class="keyword">:</span>int</span>
<span class="keyword">]</span> EQINT<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> eqint_make_guint<span class="keyword">(</span>n<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> p0 <span class="keyword">=</span> stkarray_get_ptrbeg<span class="staexp"><span class="keyword">{</span>a<span class="keyword">}</span></span><span class="keyword">(</span>stk<span class="keyword">)</span></span>
<span class="dynexp"><span class="keyword">val</span> <span class="keyword">(</span><span class="prfexp">pf</span><span class="keyword">,</span><span class="prfexp">fpf</span><span class="keyword">|</span>p0<span class="keyword">)</span> <span class="keyword">=</span> $UN<span class="keyword">.</span>ptr0_vtake<span class="staexp"><span class="keyword">{</span>array<span class="keyword">(</span>a<span class="keyword">,</span>n<span class="keyword">)</span><span class="keyword">}</span></span><span class="keyword">(</span>p0<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">val</span> res <span class="keyword">=</span> array_rforeach_env&lt;<span class="staexp">a</span><span class="keyword">&gt;&lt;</span><span class="staexp">env</span><span class="keyword">&gt;</span><span class="keyword">(</span><span class="keyword">!</span>p0<span class="keyword">,</span> n<span class="keyword">,</span> env<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
  <span class="keyword">let</span> <span class="prfexp"><span class="keyword">prval</span> <span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=</span> fpf<span class="keyword">(</span>pf<span class="keyword">)</span></span> <span class="keyword">in</span> res <span class="keyword">end</span>
<span class="keyword">end</span></span> <span class="comment">// end of [stkarray_foreach_env]</span>

<span class="comment">(* ****** ****** *)</span>

<span class="comment">(* end of [stkarray.dats] *)</span>
</pre>
<!--php-->

</body>
</html>
