<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<HTML
><HEAD
><TITLE
>Functional List-Processing (3)</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.79"><LINK
REL="HOME"
TITLE="A Crash into FP through ATS"
HREF="book1.html"><LINK
REL="PREVIOUS"
TITLE="Through ATS to Javascript"
HREF="c763.html"><LINK
REL="NEXT"
TITLE="Example: Game of Twenty-four"
HREF="c917.html"><LINK
REL="STYLESHEET"
TYPE="text/css"
HREF="./assets/ATS2FPCRASH-BOOK.css"></HEAD
><BODY
CLASS="chapter"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="NAVHEADER"
><TABLE
SUMMARY="Header navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>A Crash into FP through ATS: </TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="c763.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
></TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="c917.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="chapter"
><H1
><A
NAME="lecture07"
></A
>Chapter 11. Functional List-Processing (3)</H1
><P
>&#13;In this chapter, I intend to present a few more list-processing
functions. More importantly, I would like to argue for the practice of
actively identifying the need for generic list-processing functions
during problem-solving.

</P
><P
>&#13;There are many useful list-processing functions for handling two lists
simultaneously. For instance, the following function <FONT
COLOR="RED"
>list0_zip</FONT
>
takes a pair of lists and returns a list of pairs:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN839"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span> <span class="staexp"><span class="keyword">{</span>
a<span class="keyword">,</span>b<span class="keyword">:</span><span class="keyword">t@ype</span>
<span class="keyword">}</span></span> list0_zip
  <span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">b</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="keyword">$tup</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">b</span><span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a<span class="keyword">,</span>b</span><span class="keyword">}</span>
list0_zip<span class="keyword">(</span>xs<span class="keyword">,</span> ys<span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">(</span>
<span class="keyword">case</span> xs <span class="keyword">of</span>
<span class="keyword">|</span> list0_nil<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span>
  list0_nil<span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">|</span> list0_cons<span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span>
  <span class="keyword">(</span>
    <span class="keyword">case+</span> ys <span class="keyword">of</span>
    <span class="keyword">|</span> list0_nil<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span>
      list0_nil<span class="keyword">(</span><span class="keyword">)</span>
    <span class="keyword">|</span> list0_cons<span class="keyword">(</span>y<span class="keyword">,</span> ys<span class="keyword">)</span> <span class="keyword">=&gt;</span>
      list0_cons<span class="keyword">(</span><span class="keyword">$tup</span><span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span><span class="keyword">,</span> list0_zip&lt;<span class="staexp">a</span><span class="keyword">,</span><span class="staexp">b</span><span class="keyword">&gt;</span><span class="keyword">(</span>xs<span class="keyword">,</span> ys<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">)</span>
<span class="keyword">)</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


For instance, given two lists
<FONT
COLOR="RED"
>(1, 3, 5)</FONT
> and <FONT
COLOR="RED"
>(2, 4)</FONT
>, <FONT
COLOR="RED"
>list0_zip</FONT
>
returns the list consisting of <FONT
COLOR="RED"
>$tup(1, 2)</FONT
> and
<FONT
COLOR="RED"
>$tup(3,4)</FONT
>.  Note that <FONT
COLOR="RED"
>$tup</FONT
> is a keyword in ATS
(for constructing tuples). For a list-processing function handling one
list, there is often a meaningful variant that essentially acts like
passing to the list-processing function a list of pairs obtained from
applying <FONT
COLOR="RED"
>list0_zip</FONT
> to two given lists. For instance,
the following function <FONT
COLOR="RED"
>list0_map2</FONT
> is such a variant
of <FONT
COLOR="RED"
>list0_map</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN850"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a
<span class="keyword">,</span>b<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
<span class="staexp"><span class="keyword">{</span>c<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
list0_map2
<span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">b</span><span class="keyword">)</span><span class="keyword">,</span> fopr<span class="keyword">:</span> <span class="staexp">cfun</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">b</span><span class="keyword">,</span> <span class="staexp">c</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">c</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a<span class="keyword">,</span>b</span><span class="keyword">}</span><span class="keyword">{</span><span class="staexp">c</span><span class="keyword">}</span>
list0_map2
<span class="keyword">(</span>xs<span class="keyword">,</span> ys<span class="keyword">,</span> fopr<span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">(</span>
<span class="keyword">case</span> xs <span class="keyword">of</span>
<span class="keyword">|</span> list0_nil<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span>
  list0_nil<span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">|</span> list0_cons<span class="keyword">(</span>x<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span>
  <span class="keyword">(</span>
    <span class="keyword">case+</span> ys <span class="keyword">of</span>
    <span class="keyword">|</span> list0_nil<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span>
      list0_nil<span class="keyword">(</span><span class="keyword">)</span>
    <span class="keyword">|</span> list0_cons<span class="keyword">(</span>y<span class="keyword">,</span> ys<span class="keyword">)</span> <span class="keyword">=&gt;</span>
      list0_cons<span class="keyword">(</span>fopr<span class="keyword">(</span>x<span class="keyword">,</span> y<span class="keyword">)</span><span class="keyword">,</span> list0_map2&lt;<span class="staexp">a</span><span class="keyword">,</span><span class="staexp">b</span><span class="keyword">&gt;&lt;</span><span class="staexp">c</span><span class="keyword">&gt;</span><span class="keyword">(</span>xs<span class="keyword">,</span> ys<span class="keyword">,</span> fopr<span class="keyword">)</span><span class="keyword">)</span>
  <span class="keyword">)</span> <span class="comment">(* end of [list0_cons] *)</span>
<span class="keyword">)</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


For instance, given two lists
<FONT
COLOR="RED"
>(1, 3, 5)</FONT
> and <FONT
COLOR="RED"
>(2, 4, 6)</FONT
>
and the multiplication function, <FONT
COLOR="RED"
>list0_map2</FONT
> returns the
list <FONT
COLOR="RED"
>(2, 12, 30)</FONT
>. Sometimes, <FONT
COLOR="RED"
>list0_map2</FONT
> is
referred to as <FONT
COLOR="RED"
>list0_zipwith</FONT
>.

</P
><P
>&#13;There are various list-processing functions operating on ordered
lists. For instance, the following function <FONT
COLOR="RED"
>list0_merge</FONT
> is
for merging two ordered lists into one:
  
<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN860"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
list0_merge
<span class="keyword">(</span> xs<span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">,</span> ys<span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cfun</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
list0_merge
<span class="keyword">(</span>xs0<span class="keyword">,</span> ys0<span class="keyword">,</span> cmp<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
auxlst
<span class="keyword">(</span> xs0<span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">,</span> ys0<span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">(</span>
<span class="comment">//</span>
<span class="keyword">case+</span> xs0 <span class="keyword">of</span>
<span class="keyword">|</span> list0_nil<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> ys0
<span class="keyword">|</span> list0_cons
    <span class="keyword">(</span>x1<span class="keyword">,</span> xs1<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">(</span>
    <span class="keyword">case+</span> ys0 <span class="keyword">of</span>
    <span class="keyword">|</span> list0_nil<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> xs0
    <span class="keyword">|</span> list0_cons
        <span class="keyword">(</span>y1<span class="keyword">,</span> ys1<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
        <span class="dynexp"><span class="keyword">val</span> sgn <span class="keyword">=</span> cmp<span class="keyword">(</span>x1<span class="keyword">,</span> y1<span class="keyword">)</span></span>
      <span class="keyword">in</span>
        <span class="keyword">if</span> <span class="keyword">(</span>sgn &lt;= <span class="dynexp">0</span><span class="keyword">)</span>
          <span class="keyword">then</span> list0_cons<span class="keyword">(</span>x1<span class="keyword">,</span> auxlst<span class="keyword">(</span>xs1<span class="keyword">,</span> ys0<span class="keyword">)</span><span class="keyword">)</span>
          <span class="keyword">else</span> list0_cons<span class="keyword">(</span>y1<span class="keyword">,</span> auxlst<span class="keyword">(</span>xs0<span class="keyword">,</span> ys1<span class="keyword">)</span><span class="keyword">)</span>
        <span class="comment">// end of [if]</span>
      <span class="keyword">end</span> <span class="comment">// end of [list0_cons]</span>
  <span class="keyword">)</span> <span class="comment">(* end of [list0_cons] *)</span>
<span class="comment">//</span>
<span class="keyword">)</span></span> <span class="comment">(* end of [auxlst] *)</span>
<span class="comment">//</span>
<span class="keyword">in</span>
  auxlst<span class="keyword">(</span>xs0<span class="keyword">,</span> ys0<span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [list0_merge]</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


With <FONT
COLOR="RED"
>list0_merge</FONT
>, we can readily implement
as follows the well-known mergesort algorithm to sort a given
list0-value:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN863"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
list0_mergesort
<span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> cmp<span class="keyword">:</span> <span class="staexp">cfun</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
list0_mergesort
  <span class="keyword">(</span>xs<span class="keyword">,</span> cmp<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="comment">// [msort]:</span>
<span class="comment">// It is assumed</span>
<span class="comment">// that length(xs) = n</span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
msort
<span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">if</span>
<span class="keyword">(</span>n &gt;= <span class="dynexp">2</span><span class="keyword">)</span>
<span class="keyword">then</span> <span class="keyword">let</span>
  <span class="dynexp"><span class="keyword">val</span> n1 <span class="keyword">=</span> n / <span class="dynexp">2</span></span>
  <span class="dynexp"><span class="keyword">val</span> xs1 <span class="keyword">=</span> list0_take_exn<span class="keyword">(</span>xs<span class="keyword">,</span> n1<span class="keyword">)</span></span>
  <span class="dynexp"><span class="keyword">val</span> xs2 <span class="keyword">=</span> list0_drop_exn<span class="keyword">(</span>xs<span class="keyword">,</span> n1<span class="keyword">)</span></span>
<span class="keyword">in</span>
  list0_merge&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>msort<span class="keyword">(</span>xs1<span class="keyword">,</span> n1<span class="keyword">)</span><span class="keyword">,</span> msort<span class="keyword">(</span>xs2<span class="keyword">,</span> n-n1<span class="keyword">)</span><span class="keyword">,</span> cmp<span class="keyword">)</span>
<span class="keyword">end</span> <span class="comment">// end of [then]</span>
<span class="keyword">else</span> <span class="keyword">(</span>xs<span class="keyword">)</span></span> <span class="comment">// end of [else]</span>
<span class="comment">//</span>
<span class="keyword">in</span>
  msort<span class="keyword">(</span>xs<span class="keyword">,</span> list0_length&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>xs<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">end</span></span> <span class="comment">// end of [list0_mergesort]</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


Note that <FONT
COLOR="RED"
>list0_take_exn(xs, n)</FONT
> returns the prefix of
<FONT
COLOR="RED"
>xs</FONT
> that is of length <FONT
COLOR="RED"
>n</FONT
> and
<FONT
COLOR="RED"
>list0_drop_exn(xs, n)</FONT
> returns the suffix of <FONT
COLOR="RED"
>xs</FONT
>
that excludes the first <FONT
COLOR="RED"
>n</FONT
> elements of <FONT
COLOR="RED"
>xs</FONT
>.  It
is guaranteed that <FONT
COLOR="RED"
>list0_mergesort</FONT
> is log-linear (that is,
it is of O(n(log(n)))-time for n being the length of its
argument). Also, <FONT
COLOR="RED"
>list0_mergesort</FONT
> is stable in the sense
that the order of the elements considered equal in the input is not
changed in the output.  Clearly, <FONT
COLOR="RED"
>list0_merge</FONT
> is not
tail-recursive, potentially running the risk of stack overflow when
<FONT
COLOR="RED"
>list0_mergesort</FONT
> is applied to a long list (e.g., one
containing 1 million elements). This is a very serious issue with
non-tail-recursion in practice, and some approaches to addressing it are
to be presented later.

</P
><P
>&#13;During problem-solving, it often pays if one actively looks for
opptunities to generalize a specific function into one that can be
given a meaningful description in a broader context. As an example, if
one encounters a need to process all of the pairs formed with elements
chosen from a given list, then one may want to implement the following
function <FONT
COLOR="RED"
>list0_choose2</FONT
>:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN878"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
list0_choose2
<span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="keyword">$tup</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
list0_choose2
<span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="keyword">$tup</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
list0_choose2
  <span class="keyword">(</span>xs<span class="keyword">)</span> <span class="keyword">=</span> <span class="keyword">let</span>
<span class="comment">//</span>
<span class="keyword">typedef</span> <span class="staexp">aa <span class="keyword">=</span> <span class="keyword">$tup</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">,</span> <span class="staexp">a</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">in</span>
<span class="comment">//</span>
<span class="keyword">case+</span> xs <span class="keyword">of</span>
<span class="keyword">|</span> list0_nil<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span>
  list0_nil<span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">|</span> list0_cons<span class="keyword">(</span>x0<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span>
  list0_append&lt;<span class="staexp">aa</span><span class="keyword">&gt;</span>
  <span class="keyword">(</span>list0_map&lt;<span class="staexp">a</span><span class="keyword">&gt;&lt;</span><span class="staexp">aa</span><span class="keyword">&gt;</span><span class="keyword">(</span>xs<span class="keyword">,</span> <span class="keyword">lam</span><span class="keyword">(</span>x<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">$tup</span><span class="keyword">(</span>x0<span class="keyword">,</span> x<span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> list0_choose2<span class="keyword">(</span>xs<span class="keyword">)</span><span class="keyword">)</span>
<span class="comment">//</span>
<span class="keyword">end</span></span> <span class="comment">// end of [list0_choose2]</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


For instance, given the list <FONT
COLOR="RED"
>(1, 2, 3)</FONT
>,
<FONT
COLOR="RED"
>list0_choose2</FONT
> returns the list of 3 pairs: <FONT
COLOR="RED"
>(1,
2)</FONT
>, <FONT
COLOR="RED"
>(1, 3)</FONT
>, and <FONT
COLOR="RED"
>(2, 3)</FONT
>. And
<FONT
COLOR="RED"
>list0_choose2</FONT
> can be further generalized into the
following function <FONT
COLOR="RED"
>list0_nchoose</FONT
> for listing all of the
tuples of a given length that are formed with elements chosen from a
given list:

</P
><P
>&#13;<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN888"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
list0_nchoose
<span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
list0_nchoose
  <span class="keyword">(</span>xs<span class="keyword">,</span> n<span class="keyword">)</span> <span class="keyword">=</span>
  auxlst<span class="keyword">(</span>xs<span class="keyword">,</span> n<span class="keyword">)</span> <span class="keyword">where</span>
<span class="keyword">{</span>
<span class="comment">//</span>
<span class="keyword">typedef</span> <span class="staexp">xs <span class="keyword">=</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
auxlst
<span class="keyword">(</span>
xs<span class="keyword">:</span> <span class="staexp">xs</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">xs</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">(</span>
<span class="keyword">if</span>
<span class="keyword">(</span>n &lt;= <span class="dynexp">0</span><span class="keyword">)</span>
<span class="keyword">then</span>
list0_sing<span class="keyword">(</span>list0_nil<span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">else</span>
<span class="keyword">(</span>
<span class="keyword">case+</span> xs <span class="keyword">of</span>
<span class="keyword">|</span> list0_nil<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span>
  list0_nil<span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">|</span> list0_cons<span class="keyword">(</span>x0<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span>
  list0_append&lt;<span class="staexp">xs</span><span class="keyword">&gt;</span><span class="keyword">(</span>list0_mapcons<span class="keyword">(</span>x0<span class="keyword">,</span> auxlst<span class="keyword">(</span>xs<span class="keyword">,</span> n-<span class="dynexp">1</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">,</span> auxlst<span class="keyword">(</span>xs<span class="keyword">,</span> n<span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="comment">(* end of [else] *)</span>
<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">}</span></span> <span class="comment">(* end of [list0_nchoose] *)</span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


Sometimes, we may need to process tuples consisting of elements
chosen from a given list as well as the complements of these tuples.
The following function <FONT
COLOR="RED"
>list0_nchoose_rest</FONT
> generalizes
<FONT
COLOR="RED"
>list0_nchoose</FONT
> in this regard:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN892"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="keyword">extern</span>
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
list0_nchoose_rest
<span class="keyword">(</span>xs<span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int</span><span class="keyword">)</span><span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="keyword">$tup</span><span class="keyword">(</span><span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">,</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">implement</span>
<span class="keyword">{</span><span class="staexp">a</span><span class="keyword">}</span><span class="comment">(*tmp*)</span>
list0_nchoose_rest
  <span class="keyword">(</span>xs<span class="keyword">,</span> n<span class="keyword">)</span> <span class="keyword">=</span>
  auxlst<span class="keyword">(</span>xs<span class="keyword">,</span> n<span class="keyword">)</span> <span class="keyword">where</span>
<span class="keyword">{</span>
<span class="comment">//</span>
<span class="keyword">typedef</span> <span class="staexp">xs <span class="keyword">=</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
<span class="keyword">typedef</span> <span class="staexp">xsxs <span class="keyword">=</span> <span class="keyword">$tup</span><span class="keyword">(</span><span class="staexp">xs</span><span class="keyword">,</span> <span class="staexp">xs</span><span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
auxlst
<span class="keyword">(</span>
xs<span class="keyword">:</span> <span class="staexp">xs</span><span class="keyword">,</span> n<span class="keyword">:</span> <span class="staexp">int</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">xsxs</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">(</span>
<span class="keyword">if</span>
<span class="keyword">(</span>n &lt;= <span class="dynexp">0</span><span class="keyword">)</span>
<span class="keyword">then</span>
list0_cons
<span class="keyword">(</span><span class="keyword">$tup</span><span class="keyword">(</span>list0_nil<span class="keyword">(</span><span class="keyword">)</span><span class="keyword">,</span> xs<span class="keyword">)</span><span class="keyword">,</span> list0_nil<span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">else</span>
<span class="keyword">(</span>
<span class="keyword">case+</span> xs <span class="keyword">of</span>
<span class="keyword">|</span> list0_nil<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span>
  list0_nil<span class="keyword">(</span><span class="keyword">)</span>
<span class="keyword">|</span> list0_cons<span class="keyword">(</span>x0<span class="keyword">,</span> xs<span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">let</span>
    <span class="dynexp"><span class="keyword">val</span> res1 <span class="keyword">=</span>
    list0_map&lt;<span class="staexp">xsxs</span><span class="keyword">&gt;&lt;</span><span class="staexp">xsxs</span><span class="keyword">&gt;</span>
    <span class="keyword">(</span> auxlst<span class="keyword">(</span>xs<span class="keyword">,</span> n-<span class="dynexp">1</span><span class="keyword">)</span>
    <span class="keyword">,</span> <span class="keyword">lam</span><span class="keyword">(</span><span class="keyword">$tup</span><span class="keyword">(</span>xs1<span class="keyword">,</span> xs2<span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">$tup</span><span class="keyword">(</span>list0_cons<span class="keyword">(</span>x0<span class="keyword">,</span> xs1<span class="keyword">)</span><span class="keyword">,</span> xs2<span class="keyword">)</span>
    <span class="keyword">)</span></span>
    <span class="dynexp"><span class="keyword">val</span> res2 <span class="keyword">=</span>
    list0_map&lt;<span class="staexp">xsxs</span><span class="keyword">&gt;&lt;</span><span class="staexp">xsxs</span><span class="keyword">&gt;</span>
    <span class="keyword">(</span> auxlst<span class="keyword">(</span>xs<span class="keyword">,</span> n-<span class="dynexp">0</span><span class="keyword">)</span>
    <span class="keyword">,</span> <span class="keyword">lam</span><span class="keyword">(</span><span class="keyword">$tup</span><span class="keyword">(</span>xs1<span class="keyword">,</span> xs2<span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> <span class="keyword">$tup</span><span class="keyword">(</span>xs1<span class="keyword">,</span> list0_cons<span class="keyword">(</span>x0<span class="keyword">,</span> xs2<span class="keyword">)</span><span class="keyword">)</span>
    <span class="keyword">)</span></span>
  <span class="keyword">in</span>
    list0_append&lt;<span class="staexp">xsxs</span><span class="keyword">&gt;</span><span class="keyword">(</span>res1<span class="keyword">,</span> res2<span class="keyword">)</span>
  <span class="keyword">end</span> <span class="comment">// end of [list0_cons]</span>
<span class="keyword">)</span> <span class="comment">(* end of [else] *)</span>
<span class="keyword">)</span></span>
<span class="comment">//</span>
<span class="keyword">}</span></span> <span class="comment">(* end of [list0_nchoose_rest] *)</span>
</p></PRE
><P
></P
></DIV
>


For instance, given the list <FONT
COLOR="RED"
>(1, 2, 3)</FONT
> and integer
<FONT
COLOR="RED"
>2</FONT
>, <FONT
COLOR="RED"
>list0_choose_rest</FONT
> returns the list of 3
pairs: <FONT
COLOR="RED"
>$tup((1, 2), (3))</FONT
>, <FONT
COLOR="RED"
>$tup((1, 3), (2))</FONT
>,
and <FONT
COLOR="RED"
>$tup((2, 3), (1))</FONT
>.

</P
><P
>&#13;The problem of enumerating all of the permutations of a given
list is often used to test one's ability in constructing
recursively defined functions. Let us see a solution to this
problem given as follows:

<DIV
CLASS="informalexample"
><P
></P
><A
NAME="AEN901"
></A
><PRE
CLASS="programlisting"
><p class="patsyntax"><span class="comment">//</span>
<span class="dynexp"><span class="keyword">fun</span>
<span class="staexp"><span class="keyword">{</span>a<span class="keyword">:</span><span class="keyword">t@ype</span><span class="keyword">}</span></span>
list0_permute
<span class="keyword">(</span>
xs<span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span>
<span class="keyword">)</span> <span class="keyword">:</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=</span>
<span class="keyword">(</span>
<span class="keyword">case+</span> xs <span class="keyword">of</span>
<span class="keyword">|</span> list0_nil<span class="keyword">(</span><span class="keyword">)</span> <span class="keyword">=&gt;</span>
  list0_cons<span class="keyword">(</span>nil0<span class="keyword">(</span><span class="keyword">)</span><span class="keyword">,</span> nil0<span class="keyword">(</span><span class="keyword">)</span><span class="keyword">)</span>
<span class="keyword">|</span> list0_cons _ <span class="keyword">=&gt;</span> <span class="keyword">let</span>
    <span class="keyword">typedef</span> <span class="staexp">xs <span class="keyword">=</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">a</span><span class="keyword">)</span></span>
    <span class="keyword">typedef</span> <span class="staexp">out <span class="keyword">=</span> <span class="staexp">list0</span><span class="keyword">(</span><span class="staexp">xs</span><span class="keyword">)</span></span>
    <span class="keyword">typedef</span> <span class="staexp">inp <span class="keyword">=</span> <span class="keyword">$tup</span><span class="keyword">(</span><span class="staexp">xs</span><span class="keyword">,</span> <span class="staexp">xs</span><span class="keyword">)</span></span>
  <span class="keyword">in</span>
    list0_concat&lt;<span class="staexp">xs</span><span class="keyword">&gt;</span>
    <span class="keyword">(</span>
     list0_map&lt;<span class="staexp">inp</span><span class="keyword">&gt;&lt;</span><span class="staexp">out</span><span class="keyword">&gt;</span>
     <span class="keyword">(</span> list0_nchoose_rest&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>xs<span class="keyword">,</span> <span class="dynexp">1</span><span class="keyword">)</span>
     <span class="keyword">,</span> <span class="keyword">lam</span><span class="keyword">(</span><span class="keyword">$tup</span><span class="keyword">(</span>ys<span class="keyword">,</span> zs<span class="keyword">)</span><span class="keyword">)</span> <span class="keyword">=&gt;</span> list0_mapcons&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span><span class="dynexp">ys[0<span class="keyword">]</span></span><span class="keyword">,</span> list0_permute&lt;<span class="staexp">a</span><span class="keyword">&gt;</span><span class="keyword">(</span>zs<span class="keyword">)</span><span class="keyword">)</span>
     <span class="keyword">)</span>
    <span class="keyword">)</span> <span class="comment">(* list0_concat *)</span>
  <span class="keyword">end</span> <span class="comment">(* end of [list0_cons] *)</span>
<span class="keyword">)</span></span>
<span class="comment">//</span>
</p></PRE
><P
></P
></DIV
>


For instance, given the list <FONT
COLOR="RED"
>(1, 2, 3)</FONT
>,
<FONT
COLOR="RED"
>list0_permute</FONT
> returns a list of length 6 in which each
element is a permutation of <FONT
COLOR="RED"
>(1, 2, 3)</FONT
>.  Note that
<FONT
COLOR="RED"
>ys[0]</FONT
> refers to the first element in <FONT
COLOR="RED"
>ys</FONT
> and
<FONT
COLOR="RED"
>list0_mapcons</FONT
> prepends its first argument to each element
in its second argument (which is a list of lists). A demo
of <FONT
COLOR="RED"
>list0_permute</FONT
> can be seen by following this <A
HREF="https://ats-lang.github.io/DOCUMENT/ATS2FUNCRASH/LECTURE/07/CODE/Permute.html"
TARGET="_top"
>link</A
>.

</P
><P
>&#13;Please find <A
HREF="https://github.com/ats-lang/ats-lang.github.io/blob/master/DOCUMENT/ATS2FUNCRASH/LECTURE/07/CODE"
TARGET="_top"
>on-line</A
> the entirety of
the code used in this chapter. The mentioned URL link(s) can be found as follows:

<P
></P
><UL
><LI
><P
><A
HREF="https://ats-lang.github.io/DOCUMENT/ATS2FUNCRASH/LECTURE/07/CODE/Permute.html"
TARGET="_top"
>https://ats-lang.github.io/DOCUMENT/ATS2FUNCRASH/LECTURE/07/CODE/Permute.html</A
>
</P
></LI
></UL
>

</P
></DIV
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
SUMMARY="Footer navigation table"
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="c763.html"
ACCESSKEY="P"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="book1.html"
ACCESSKEY="H"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="c917.html"
ACCESSKEY="N"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>Through ATS to Javascript</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
>&nbsp;</TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Example: Game of Twenty-four</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>